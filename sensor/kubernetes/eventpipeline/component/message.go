package component

import (
	"github.com/stackrox/rox/generated/internalapi/central"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/sensor/common/store/resolver"
)

// CompatibilityDetectionMessage should be used by old handlers
// it's here for compatibility reasons.
type CompatibilityDetectionMessage struct {
	// Object references the object that needs to be processed by the detector
	Object *storage.Deployment
	// Action of an event (CREATE_RESOURCE, REMOVE_RESOURCE, UPDATE_RESOURCE, and SYNC_RESOURCE)
	Action central.ResourceAction
}

type DeploymentReference struct {
	// Reference returns an implementation of a struct that can return a list of deployment ids
	// that require processing
	Reference resolver.DeploymentReference

	// ParentResourceAction is the resource action that will be sent to central on the deployment event.
	// If the ResourceEvent originated on a deployment event, this should be set to whatever action triggered
	// the event. For related resources updates, like RBACs and services, this should always be set to
	// UPDATE.
	ParentResourceAction central.ResourceAction

	// ForceDetection is a flag that will force a detection even if the deployment has no changes.
	// This is needed to trigger detection of deployments associated with a NetworkPolicy, since they are not part of the deployment spec
	// and therefore will not be triggered since the deduper won't recognize that a deployment was changed.
	ForceDetection bool
}

// ResourceEvent message used by the event pipeline's components
type ResourceEvent struct {
	// ForwardMessages messages generated by the handlers that need to be forwarded to central
	ForwardMessages []*central.SensorEvent
	// CompatibilityDetectionDeployment should be used by old handlers
	// and it's here for compatibility reasons.
	// This property should be removed in the future and only the
	// deployment references should be sent
	CompatibilityDetectionDeployment []CompatibilityDetectionMessage
	// CompatibilityReprocessDeployments is also used for compatibility reasons with Network Policy handlers
	// in the future this will not be needed as the dependencies are taken care by the resolvers
	CompatibilityReprocessDeployments []string

	// DeploymentTiming has the timing object that needs to be added to any deployments resolved by this event.
	DeploymentTiming *central.Timing

	// DeploymentReferences returns a list of deployment references generated from a Kubernetes Event
	DeploymentReferences []DeploymentReference
}

func NewEvent(msg ...*central.SensorEvent) *ResourceEvent {
	return &ResourceEvent{ForwardMessages: msg}
}

func (e *ResourceEvent) AppendMessage(event ...*central.SensorEvent) *ResourceEvent {
	e.ForwardMessages = append(e.ForwardMessages, event...)
	return e
}

func (e *ResourceEvent) AddDetectionDeployment(messages ...CompatibilityDetectionMessage) *ResourceEvent {
	e.CompatibilityDetectionDeployment = append(e.CompatibilityDetectionDeployment, messages...)
	return e
}

func (e *ResourceEvent) AddReprocessDeployments(ids ...string) *ResourceEvent {
	e.CompatibilityReprocessDeployments = append(e.CompatibilityReprocessDeployments, ids...)
	return e
}

func (e *ResourceEvent) DeploymentReferenceUpdate(reference resolver.DeploymentReference, action central.ResourceAction, force bool) {
	e.DeploymentReferences = append(e.DeploymentReferences, DeploymentReference{
		Reference:            reference,
		ParentResourceAction: action,
		ForceDetection:       force,
	})
}

func (e *ResourceEvent) MergeResourceEvent(ev *ResourceEvent) {
	if ev == nil {
		return
	}
	e.CompatibilityReprocessDeployments = append(e.CompatibilityReprocessDeployments, ev.CompatibilityReprocessDeployments...)
	e.ForwardMessages = append(e.ForwardMessages, ev.ForwardMessages...)
	e.CompatibilityDetectionDeployment = append(e.CompatibilityDetectionDeployment, ev.CompatibilityDetectionDeployment...)
	e.DeploymentReferences = append(e.DeploymentReferences, ev.DeploymentReferences...)
}
