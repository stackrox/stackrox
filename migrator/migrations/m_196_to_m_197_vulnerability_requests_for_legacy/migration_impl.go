package m196tom197

import (
	"context"
	"fmt"
	"strings"

	timestamp "github.com/gogo/protobuf/types"
	"github.com/pkg/errors"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/migrator/migrations/m_196_to_m_197_vulnerability_requests_for_legacy/schema"
	"github.com/stackrox/rox/migrator/types"
	"github.com/stackrox/rox/pkg/logging"
	"github.com/stackrox/rox/pkg/postgres/pgutils"
	"github.com/stackrox/rox/pkg/sac"
	"github.com/stackrox/rox/pkg/uuid"
	"gorm.io/gorm/clause"
)

var (
	batchSize = 2000
	log       = logging.LoggerForModule()

	sysUser = &storage.SlimUser{
		Id:   uuid.NewV4().String(),
		Name: "system",
	}
)

func migrate(database *types.Databases) error {
	ctx := sac.WithAllAccess(context.Background())
	pgutils.CreateTableFromModel(ctx, database.GormDB, schema.CreateTableImagesStmt)
	pgutils.CreateTableFromModel(ctx, database.GormDB, schema.CreateTableImageCvesStmt)
	pgutils.CreateTableFromModel(ctx, database.GormDB, schema.CreateTableImageCveEdgesStmt)
	pgutils.CreateTableFromModel(ctx, database.GormDB, schema.CreateTableVulnerabilityRequestsStmt)

	now := timestamp.TimestampNow()
	snoozedCVEMap, err := collectSnoozedImageCVEs(ctx, database)
	if err != nil || len(snoozedCVEMap) == 0 {
		return err
	}
	if err = createVulnRequests(ctx, database, now, snoozedCVEMap); err != nil {
		return err
	}
	// Note that the fields of `storage.ImageCVE` used by 1st generation exception workflow must not be reset
	// for backward compatibility purpose.
	return updateImageCVEEdges(ctx, database, snoozedCVEMap)
}

func collectSnoozedImageCVEs(ctx context.Context, database *types.Databases) (map[string]*timestamp.Timestamp, error) {
	query := database.GormDB.WithContext(ctx).Table(schema.ImageCvesTableName).
		Select("serialized").Where("snoozed = ?", "true")
	rows, err := query.Rows()
	if err != nil {
		return nil, errors.Wrapf(err, "failed to query table %s", schema.ImageCvesTableName)
	}
	defer func() { _ = rows.Close() }()

	// Map of CVE to expiry.
	cveMap := make(map[string]*timestamp.Timestamp)
	var count int
	for rows.Next() {
		var obj schema.ImageCves
		if err = query.ScanRows(rows, &obj); err != nil {
			return nil, errors.Wrap(err, "failed to scan image_cves table rows")
		}
		proto, err := schema.ConvertImageCVEToProto(&obj)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to convert %+v to proto", proto)
		}

		cveMap[proto.GetCveBaseInfo().GetCve()] = proto.GetSnoozeExpiry()
		count++
	}
	if rows.Err() != nil {
		return nil, errors.Wrapf(rows.Err(), "failed to get rows for %s", schema.ImageCvesTableName)
	}

	log.Infof("Found %d globally snoozed vulnerabilities that need to be migrated", count)
	return cveMap, nil
}

func createVulnRequests(ctx context.Context, database *types.Databases, now *timestamp.Timestamp, cveMap map[string]*timestamp.Timestamp) error {
	db := database.GormDB.WithContext(ctx).Table(schema.VulnerabilityRequestsTableName)

	var vulnReqs []*schema.VulnerabilityRequests
	var count int
	for cve, expiry := range cveMap {
		if now.Compare(expiry) >= 0 {
			continue
		}

		proto := createVulnerabilityRequest(cve, now, expiry)
		converted, err := schema.ConvertVulnerabilityRequestFromProto(proto)
		if err != nil {
			return errors.Wrapf(err, "failed to convert from proto %+v", proto)
		}
		vulnReqs = append(vulnReqs, converted)
		count++

		if len(vulnReqs) == batchSize {
			if err = db.
				Clauses(clause.OnConflict{UpdateAll: true}).
				Model(schema.CreateTableVulnerabilityRequestsStmt.GormModel).
				Create(&vulnReqs).Error; err != nil {
				return errors.Wrapf(err, "failed to upsert converted %d objects after %d upserted", len(vulnReqs), count-len(vulnReqs))
			}
			vulnReqs = vulnReqs[:0]
		}
	}

	if len(vulnReqs) > 0 {
		if err := db.
			Clauses(clause.OnConflict{UpdateAll: true}).
			Model(schema.CreateTableVulnerabilityRequestsStmt.GormModel).
			Create(&vulnReqs).Error; err != nil {
			return errors.Wrapf(err, "failed to upsert last %d objects", len(vulnReqs))
		}
	}
	log.Infof("Populated %d vulnerability exceptions for globally snoozed vulnerabilities", count)
	return nil
}

func updateImageCVEEdges(ctx context.Context, database *types.Databases, cveMap map[string]*timestamp.Timestamp) error {
	cves := make([]string, 0, len(cveMap))
	for cve := range cveMap {
		cves = append(cves, cve)
	}

	db := database.GormDB.WithContext(ctx).Table(schema.ImageCveEdgesTableName)
	query := database.GormDB.WithContext(ctx).Table(schema.ImageCveEdgesTableName).
		Exec(fmt.Sprintf("SELECT %[1]s.serialized FROM %[1]s WHERE EXISTS (SELECT 1 FROM %[2]s WHERE %[1]s.imagecveid = %[2]s.id AND %[2]s.cvebaseinfo_cve = ANY($1::text[]))", schema.ImageCveEdgesTableName, schema.ImageCvesTableName), cves)
	rows, err := query.Rows()
	if err != nil {
		return errors.Wrapf(err, "failed to query table %s", schema.ImageCvesTableName)
	}
	defer func() { _ = rows.Close() }()

	var convertedEdges []*schema.ImageCveEdges
	var count int
	for rows.Next() {
		var obj schema.ImageCveEdges
		if err = query.ScanRows(rows, &obj); err != nil {
			return errors.Wrap(err, "failed to scan image_cves table rows")
		}
		proto, err := schema.ConvertImageCVEEdgeToProto(&obj)
		if err != nil {
			return errors.Wrapf(err, "failed to convert %+v to proto", proto)
		}

		proto.State = storage.VulnerabilityState_DEFERRED

		converted, err := schema.ConvertImageCVEEdgeFromProto(proto)
		if err != nil {
			return errors.Wrapf(err, "failed to convert from proto %+v", proto)
		}
		convertedEdges = append(convertedEdges, converted)
		count++

		if len(cves) == batchSize {
			if err = db.
				Clauses(clause.OnConflict{UpdateAll: true}).
				Model(schema.CreateTableImageCveEdgesStmt.GormModel).
				Create(&convertedEdges).Error; err != nil {
				return errors.Wrapf(err, "failed to upsert converted %d objects after %d upserted", len(cves), count-len(cves))
			}
			cves = cves[:0]
		}
	}
	if rows.Err() != nil {
		return errors.Wrapf(rows.Err(), "failed to get rows for %s", schema.ImageCvesTableName)
	}

	if len(convertedEdges) > 0 {
		if err = db.
			Clauses(clause.OnConflict{UpdateAll: true}).
			Model(schema.CreateTableImageCveEdgesStmt.GormModel).
			Create(&convertedEdges).Error; err != nil {
			return errors.Wrapf(err, "failed to upsert last %d objects", len(cves))
		}
	}
	log.Infof("Updated %d 'imagecveedges' rows", count)
	return nil
}

func createVulnerabilityRequest(cve string, now, expiry *timestamp.Timestamp) *storage.VulnerabilityRequest {
	return &storage.VulnerabilityRequest{
		Id:          uuid.NewV4().String(),
		Name:        requestName(cve),
		TargetState: storage.VulnerabilityState_DEFERRED,
		Status:      storage.RequestStatus_APPROVED,
		Expired:     false,
		Requestor:   sysUser,
		Approvers:   []*storage.SlimUser{sysUser},
		CreatedAt:   now,
		LastUpdated: now,
		Comments: []*storage.RequestComment{
			{
				Id:        uuid.NewV4().String(),
				Message:   "This is a system-generated exception for legacy global vulnerability deferral found during system upgrade",
				User:      sysUser,
				CreatedAt: now,
			},
		},
		Scope: &storage.VulnerabilityRequest_Scope{
			Info: &storage.VulnerabilityRequest_Scope_ImageScope{
				ImageScope: &storage.VulnerabilityRequest_Scope_Image{
					Registry: ".*",
					Remote:   ".*",
					Tag:      ".*",
				},
			},
		},
		Req: &storage.VulnerabilityRequest_DeferralReq{
			DeferralReq: &storage.DeferralRequest{
				Expiry: &storage.RequestExpiry{
					ExpiryType: storage.RequestExpiry_TIME,
					Expiry: &storage.RequestExpiry_ExpiresOn{
						ExpiresOn: expiry,
					},
				},
			},
		},
		Entities: &storage.VulnerabilityRequest_Cves{
			Cves: &storage.VulnerabilityRequest_CVEs{
				Cves: []string{cve},
			},
		},
	}
}

// This guarantees unique exception name because CVE is unique. This approach avoids extra database lookup
// required to avoid sequence number conflict in ABC-YYMMDD-SEQNUM pattern.
func requestName(cve string) string {
	return strings.ReplaceAll(strings.ToUpper(cve), "CVE", "SYS")
}
