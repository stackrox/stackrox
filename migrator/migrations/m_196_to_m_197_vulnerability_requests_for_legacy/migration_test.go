//go:build sql_integration

package m196tom197

import (
	"context"
	"testing"
	"time"

	timestamp "github.com/gogo/protobuf/types"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/migrator/migrations/m_196_to_m_197_vulnerability_requests_for_legacy/schema"
	imageCVEEdgeStore "github.com/stackrox/rox/migrator/migrations/m_196_to_m_197_vulnerability_requests_for_legacy/store/imagecveedges"
	imageCVEStore "github.com/stackrox/rox/migrator/migrations/m_196_to_m_197_vulnerability_requests_for_legacy/store/imagecves"
	imageStore "github.com/stackrox/rox/migrator/migrations/m_196_to_m_197_vulnerability_requests_for_legacy/store/images"
	vulnReqStore "github.com/stackrox/rox/migrator/migrations/m_196_to_m_197_vulnerability_requests_for_legacy/store/vulnerabilityrequests"
	pghelper "github.com/stackrox/rox/migrator/migrations/postgreshelper"
	"github.com/stackrox/rox/migrator/types"
	"github.com/stackrox/rox/pkg/postgres/pgutils"
	"github.com/stackrox/rox/pkg/protoconv"
	"github.com/stackrox/rox/pkg/sac"
	"github.com/stackrox/rox/pkg/search"
	"github.com/stackrox/rox/pkg/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
)

type migrationTestSuite struct {
	suite.Suite

	db  *pghelper.TestPostgres
	ctx context.Context
}

func TestMigration(t *testing.T) {
	suite.Run(t, new(migrationTestSuite))
}

func (s *migrationTestSuite) SetupSuite() {
	s.ctx = sac.WithAllAccess(context.Background())
	s.db = pghelper.ForT(s.T(), false)

	pgutils.CreateTableFromModel(s.ctx, s.db.GetGormDB(), schema.CreateTableImagesStmt)
	pgutils.CreateTableFromModel(s.ctx, s.db.GetGormDB(), schema.CreateTableImageCvesStmt)
	pgutils.CreateTableFromModel(s.ctx, s.db.GetGormDB(), schema.CreateTableImageCveEdgesStmt)
	pgutils.CreateTableFromModel(s.ctx, s.db.GetGormDB(), schema.CreateTableVulnerabilityRequestsStmt)
}

func (s *migrationTestSuite) TearDownSuite() {
	s.db.Teardown(s.T())
}

func (s *migrationTestSuite) TestMigration() {
	images := []*storage.Image{
		getTestImage("image1"),
		getTestImage("image2"),
	}
	cves := []*storage.ImageCVE{
		getTestImageCVE("cve-2023-123", true, false),
		getTestImageCVE("cve-2023-124", true, false),
		getTestImageCVE("cve-2023-125", true, false),
		getTestImageCVE("cve-2023-126", true, true),
		getTestImageCVE("cve-2023-127", true, true),
		getTestImageCVE("cve-2023-128", true, true),
		getTestImageCVE("cve-2023-129", false, false),
		getTestImageCVE("cve-2023-131", false, false),
		getTestImageCVE("cve-2023-132", false, false),
	}
	unExpiredSnoozedCVEMap := map[string]*storage.ImageCVE{
		"cve-2023-123": cves[0],
		"cve-2023-124": cves[1],
		"cve-2023-125": cves[2],
	}
	imageCVEEdges := []*storage.ImageCVEEdge{
		getTestImageCVEEdge("image1", "cve-2023-123"),
		getTestImageCVEEdge("image1", "cve-2023-124"),
		getTestImageCVEEdge("image1", "cve-2023-125"),
	}

	require.NoError(s.T(), imageStore.New(s.db).UpsertMany(s.ctx, images))
	require.NoError(s.T(), imageCVEStore.New(s.db).UpsertMany(s.ctx, cves))
	require.NoError(s.T(), imageCVEEdgeStore.New(s.db).UpsertMany(s.ctx, imageCVEEdges))

	dbs := &types.Databases{
		GormDB:     s.db.GetGormDB(),
		PostgresDB: s.db.DB,
		DBCtx:      s.ctx,
	}

	s.Require().NoError(migration.Run(dbs))

	// Verify all execption request is created for all unexpired snoozed vulnerabilities.
	newStore := vulnReqStore.New(s.db)
	objs, err := newStore.GetByQuery(s.ctx, search.EmptyQuery())
	assert.NoError(s.T(), err)
	assertVulnReq(s.T(), unExpiredSnoozedCVEMap, objs)

	// Verify search works.
	objs, err = newStore.GetByQuery(s.ctx,
		search.NewQueryBuilder().AddExactMatches(search.CVE, "cve-2023-123").ProtoQuery())
	assert.NoError(s.T(), err)
	assertVulnReq(s.T(), unExpiredSnoozedCVEMap, objs)

	// Verify search works.
	objs, err = newStore.GetByQuery(s.ctx,
		search.NewQueryBuilder().
			AddExactMatches(search.RequestedVulnerabilityState, storage.VulnerabilityState_DEFERRED.String()).ProtoQuery())
	assert.NoError(s.T(), err)
	assertVulnReq(s.T(), unExpiredSnoozedCVEMap, objs)

	// Verify expired snoozed CVEs do not have exception request.
	objs, err = newStore.GetByQuery(s.ctx,
		search.NewQueryBuilder().AddExactMatches(search.CVE, "cve-2023-127").ProtoQuery())
	assert.NoError(s.T(), err)
	assert.Nil(s.T(), objs)

	// Verify observed CVEs do not have exception request.
	objs, err = newStore.GetByQuery(s.ctx,
		search.NewQueryBuilder().AddExactMatches(search.CVE, "cve-2023-132").ProtoQuery())
	assert.NoError(s.T(), err)
	assert.Nil(s.T(), objs)

	// Verify storage.ImageCVEEdge is updated.
	edgeObjs, err := imageCVEEdgeStore.New(s.db).GetByQuery(s.ctx,
		search.NewQueryBuilder().AddExactMatches(search.VulnerabilityState, storage.VulnerabilityState_DEFERRED.String()).ProtoQuery())
	assert.NoError(s.T(), err)
	assert.Len(s.T(), edgeObjs, 3)
	for _, obj := range edgeObjs {
		assert.NotNil(s.T(), unExpiredSnoozedCVEMap[obj.GetImageCveId()])
	}

	// Verify storage.ImageCVE is updated.
	cveObjs, err := imageCVEStore.New(s.db).GetByQuery(s.ctx, search.EmptyQuery())
	assert.NoError(s.T(), err)
	assert.Len(s.T(), cveObjs, len(cves))
	for _, obj := range cveObjs {
		assert.False(s.T(), obj.GetSnoozed())
	}
}

func assertVulnReq(t *testing.T, vulnCVEMap map[string]*storage.ImageCVE, exceptions []*storage.VulnerabilityRequest) {
	for _, obj := range exceptions {
		cve := vulnCVEMap[obj.GetCves().GetCves()[0]]
		assert.NotNil(t, cve)
		assert.False(t, obj.GetExpired())
		assert.Equal(t, cve.GetSnoozeExpiry(), obj.GetDeferralReq().GetExpiry().GetExpiresOn())
		assert.Equal(t, ".*", obj.GetScope().GetImageScope().GetRegistry())
		assert.Equal(t, ".*", obj.GetScope().GetImageScope().GetRemote())
		assert.Equal(t, ".*", obj.GetScope().GetImageScope().GetTag())
	}
}

func getTestImageCVE(cve string, snoozed, expired bool) *storage.ImageCVE {
	return &storage.ImageCVE{
		Id: cve,
		CveBaseInfo: &storage.CVEInfo{
			Cve: cve,
		},
		Snoozed: snoozed,
		SnoozeExpiry: func() *timestamp.Timestamp {
			now := time.Now()
			if expired {
				now = now.Add(-(7 * 24 * time.Hour))
			} else {
				now = now.Add(7 * 24 * time.Hour)
			}
			return protoconv.ConvertTimeToTimestamp(now)
		}(),
	}
}

func getTestImage(image string) *storage.Image {
	return &storage.Image{
		Id: image,
	}
}

func getTestImageCVEEdge(image, cve string) *storage.ImageCVEEdge {
	return &storage.ImageCVEEdge{
		Id:         uuid.NewV4().String(),
		ImageCveId: cve,
		ImageId:    image,
	}
}
