// Code originally generated by pg-bindings generator.

//go:build sql_integration
// +build sql_integration

package n35ton36

import (
	"context"
	"testing"

	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/migrator/migrations/n_35_to_n_36_postgres_nodes/legacy"
	pgStore "github.com/stackrox/rox/migrator/migrations/n_35_to_n_36_postgres_nodes/postgres"
	pghelper "github.com/stackrox/rox/migrator/migrations/postgreshelper"
	"github.com/stackrox/rox/pkg/dackbox"
	"github.com/stackrox/rox/pkg/dackbox/concurrency"
	"github.com/stackrox/rox/pkg/env"
	nodeConverter "github.com/stackrox/rox/pkg/nodes/converter"
	"github.com/stackrox/rox/pkg/rocksdb"
	"github.com/stackrox/rox/pkg/sac"
	"github.com/stackrox/rox/pkg/testutils/envisolator"
	"github.com/stackrox/rox/pkg/testutils/rocksdbtest"
	"github.com/stretchr/testify/suite"
)

func TestMigration(t *testing.T) {
	suite.Run(t, new(postgresMigrationSuite))
}

type postgresMigrationSuite struct {
	suite.Suite
	envIsolator *envisolator.EnvIsolator
	ctx         context.Context

	legacyDB   *rocksdb.RocksDB
	postgresDB *pghelper.TestPostgres
}

var _ suite.TearDownTestSuite = (*postgresMigrationSuite)(nil)

func (s *postgresMigrationSuite) SetupTest() {
	s.envIsolator = envisolator.NewEnvIsolator(s.T())
	s.envIsolator.Setenv(env.PostgresDatastoreEnabled.EnvVar(), "true")
	if !env.PostgresDatastoreEnabled.BooleanSetting() {
		s.T().Skip("Skip postgres store tests")
		s.T().SkipNow()
	}

	var err error
	s.legacyDB, err = rocksdb.NewTemp(s.T().Name())
	s.NoError(err)

	s.ctx = sac.WithAllAccess(context.Background())
	s.postgresDB = pghelper.ForT(s.T(), true)
}

func (s *postgresMigrationSuite) TearDownTest() {
	rocksdbtest.TearDownRocksDB(s.legacyDB)
	s.postgresDB.Teardown(s.T())
}

func (s *postgresMigrationSuite) TestMigration() {
	newStore := pgStore.New(s.postgresDB.Pool, true)
	dacky, err := dackbox.NewRocksDBDackBox(s.legacyDB, nil, []byte("graph"), []byte("dirty"), []byte("valid"))
	s.NoError(err)
	legacyStore := legacy.New(dacky, concurrency.NewKeyFence(), false)

	// Prepare data and write to legacy DB
	nodes := []*storage.Node{
		{
			Id:   "id1",
			Name: "node1",
			Scan: &storage.NodeScan{
				Components: []*storage.EmbeddedNodeScanComponent{
					{
						Name:    "kube-proxy",
						Version: "1.16.9",
						Vulns: []*storage.EmbeddedVulnerability{
							{
								Cve:      "CVE-2020-8558",
								Cvss:     5.4,
								Severity: storage.VulnerabilitySeverity_MODERATE_VULNERABILITY_SEVERITY,
							},
						},
					},
					{
						Name:    "kubelet",
						Version: "1.16.9",
						Vulns: []*storage.EmbeddedVulnerability{
							{
								Cve:      "CVE-2020-8558",
								Cvss:     5.4,
								Severity: storage.VulnerabilitySeverity_MODERATE_VULNERABILITY_SEVERITY,
							},
						},
					},
				},
			},
		},
		{
			Id:   "id2",
			Name: "node2",
			Scan: &storage.NodeScan{
				Components: []*storage.EmbeddedNodeScanComponent{
					{
						Name:    "kubelet",
						Version: "1.14.3",
						Vulns: []*storage.EmbeddedVulnerability{
							{
								Cve:      "CVE-2019-11248",
								Cvss:     6.5,
								Severity: storage.VulnerabilitySeverity_CRITICAL_VULNERABILITY_SEVERITY,
							},
						},
					},
				},
			},
		},
	}

	for _, node := range nodes {
		s.NoError(legacyStore.Upsert(s.ctx, node))
	}

	// Move
	s.NoError(move(s.postgresDB.GetGormDB(), s.postgresDB.Pool, legacyStore))

	// Verify
	count, err := newStore.Count(s.ctx)
	s.NoError(err)
	s.Equal(len(nodes), count)
	for _, node := range nodes {
		fetched, ok, err := newStore.Get(s.ctx, node.GetId())
		s.NoError(err)
		s.True(ok)
		s.verifyNode(node, fetched)
	}
}

func (s *postgresMigrationSuite) verifyNode(node *storage.Node, fetched *storage.Node) {
	scan := node.GetScan()
	fetchedScan := fetched.GetScan()
	node.Scan = nil
	fetched.Scan = nil
	s.Equal(node, fetched)

	s.Len(fetchedScan.GetComponents(), len(scan.GetComponents()))
	for i, component := range scan.GetComponents() {
		component.Vulnerabilities = nil
		fetchedComponent := fetchedScan.GetComponents()[i]
		s.Len(fetchedComponent.GetVulnerabilities(), len(component.GetVulns()))
		for vi, vuln := range component.GetVulns() {
			fetchedVuln := fetchedComponent.GetVulnerabilities()[vi]
			converted := nodeConverter.EmbeddedVulnerabilityToNodeVulnerability(vuln)
			fetchedVuln.CveBaseInfo.CreatedAt = nil
			s.Equal(converted, fetchedVuln)
		}
		component.Vulns = nil
		fetchedComponent.Vulnerabilities = nil
		s.Equal(component, fetchedComponent)
	}
}
