// Code originally generated by pg-bindings generator.

//go:build sql_integration
// +build sql_integration

package n5ton6

import (
	"context"
	"strings"
	"testing"

	"github.com/stackrox/rox/generated/storage"
	legacy "github.com/stackrox/rox/migrator/migrations/n_05_to_n_06_postgres_active_components/legacy"
	pgStore "github.com/stackrox/rox/migrator/migrations/n_05_to_n_06_postgres_active_components/postgres"
	pghelper "github.com/stackrox/rox/migrator/migrations/postgreshelper"
	"github.com/stackrox/rox/pkg/dackbox"
	"github.com/stackrox/rox/pkg/dackbox/concurrency"
	"github.com/stackrox/rox/pkg/dackbox/edges"
	"github.com/stackrox/rox/pkg/env"
	pkgSchema "github.com/stackrox/rox/pkg/postgres/schema"
	"github.com/stackrox/rox/pkg/rocksdb"
	"github.com/stackrox/rox/pkg/sac"
	"github.com/stackrox/rox/pkg/search/postgres"
	"github.com/stackrox/rox/pkg/testutils/envisolator"
	"github.com/stackrox/rox/pkg/testutils/rocksdbtest"
	"github.com/stretchr/testify/suite"
)

func TestMigration(t *testing.T) {
	suite.Run(t, new(postgresMigrationSuite))
}

type postgresMigrationSuite struct {
	suite.Suite
	envIsolator *envisolator.EnvIsolator
	ctx         context.Context

	legacyDB   *rocksdb.RocksDB
	postgresDB *pghelper.TestPostgres
}

var _ suite.TearDownTestSuite = (*postgresMigrationSuite)(nil)

func (s *postgresMigrationSuite) SetupTest() {
	s.envIsolator = envisolator.NewEnvIsolator(s.T())
	s.envIsolator.Setenv(env.PostgresDatastoreEnabled.EnvVar(), "true")
	if !env.PostgresDatastoreEnabled.BooleanSetting() {
		s.T().Skip("Skip postgres store tests")
		s.T().SkipNow()
	}

	var err error
	s.legacyDB, err = rocksdb.NewTemp(s.T().Name())
	s.NoError(err)

	s.Require().NoError(err)

	s.ctx = sac.WithAllAccess(context.Background())
	s.postgresDB = pghelper.ForT(s.T(), true)
}

func (s *postgresMigrationSuite) TearDownTest() {
	rocksdbtest.TearDownRocksDB(s.legacyDB)
	s.postgresDB.Teardown(s.T())
}

var (
	deploymentID  = "depA"
	componentName = "bash"
	os            = []string{"rhel:8", "debian:10"}
	versions      = []string{"v1", "v2"}
)

func (s *postgresMigrationSuite) TestActiveComponentMigration() {
	newStore := pgStore.New(s.postgresDB.Pool)
	dacky, err := dackbox.NewRocksDBDackBox(s.legacyDB, nil, []byte("graph"), []byte("dirty"), []byte("valid"))
	s.NoError(err)
	legacyStore := legacy.New(dacky, concurrency.NewKeyFence())

	// Prepare data and write to legacy DB
	images := []*pkgSchema.Images{
		{
			Id:                  "image1",
			ScanOperatingSystem: os[0],
		},
		{
			Id:                  "image2",
			ScanOperatingSystem: os[1],
		},
		{
			Id:                  "image3",
			ScanOperatingSystem: os[0],
		},
		{
			Id:                  "image4",
			ScanOperatingSystem: os[1],
		},
	}
	s.populateImages(images)

	components := []*storage.ImageComponent{
		{
			Name:            componentName,
			Version:         versions[0],
			OperatingSystem: os[0],
		},
		{
			Name:            componentName,
			Version:         versions[1],
			OperatingSystem: os[0],
		},
		{
			Name:            componentName,
			Version:         versions[0],
			OperatingSystem: os[1],
		},
		{
			Name:            componentName,
			Version:         versions[1],
			OperatingSystem: os[1],
		},
	}
	for _, c := range components {
		c.Id = edges.EdgeID{ParentID: c.Name, ChildID: c.Version}.ToString()
	}

	activeComponents := []*storage.ActiveComponent{
		{
			DeploymentId: deploymentID,
			ComponentId:  components[0].Id,
			ActiveContextsSlice: []*storage.ActiveComponent_ActiveContext{
				{
					ContainerName: "c1",
					ImageId:       images[0].Id,
				},
				{
					ContainerName: "c2",
					ImageId:       images[1].Id,
				},
				{
					ContainerName: "c3",
					ImageId:       images[2].Id,
				},
				{
					ContainerName: "c4",
					ImageId:       images[3].Id,
				},
			},
		},
		{
			DeploymentId: deploymentID,
			ComponentId:  components[1].Id,
			ActiveContextsSlice: []*storage.ActiveComponent_ActiveContext{
				{
					ContainerName: "d1",
					ImageId:       images[0].Id,
				},
				{
					ContainerName: "d2",
					ImageId:       images[1].Id,
				},
				{
					ContainerName: "d3",
					ImageId:       images[2].Id,
				},
				{
					ContainerName: "d4",
					ImageId:       images[3].Id,
				},
			},
		},
	}
	for _, ac := range activeComponents {
		ac.Id = edges.EdgeID{ParentID: ac.GetDeploymentId(), ChildID: ac.GetComponentId()}.ToString()
	}

	s.NoError(legacyStore.UpsertMany(s.ctx, activeComponents))

	// Move
	s.NoError(move(s.postgresDB.GetGormDB(), s.postgresDB.Pool, legacyStore))

	// Verify
	s.verify(newStore, images)
}

func (s *postgresMigrationSuite) verify(newStore pgStore.Store, images []*pkgSchema.Images) {
	count, err := newStore.Count(s.ctx)
	s.NoError(err)
	s.Equal(4, count)
	ids, err := newStore.GetIDs(s.ctx)
	s.NoError(err)
	imageToOs := make(map[string]string, 4)
	for _, image := range images {
		imageToOs[image.Id] = image.ScanOperatingSystem
	}
	for _, id := range ids {
		s.True(strings.HasPrefix(id, deploymentID+":"+componentName+"#"))
		fetched, ok, err := newStore.Get(s.ctx, id)
		s.NoError(err)
		s.True(ok)
		s.Equal(deploymentID, fetched.GetDeploymentId())
		// Verify componentId
		s.True(strings.HasSuffix(id, fetched.GetComponentId()))
		parts := postgres.IDToParts(fetched.GetComponentId())
		s.Equal(componentName, parts[0])
		s.Len(fetched.ActiveContextsSlice, 2)
		s.Equal(imageToOs[fetched.ActiveContextsSlice[0].ImageId], parts[2])
	}
}

func (s *postgresMigrationSuite) populateImages(images []*pkgSchema.Images) {
	pkgSchema.ApplySchemaForTable(s.ctx, s.postgresDB.GetGormDB(), pkgSchema.ImagesSchema.Table)
	imageTable := s.postgresDB.GetGormDB().Table(pkgSchema.ImagesSchema.Table).Model(pkgSchema.CreateTableImagesStmt.GormModel)
	s.NoError(imageTable.Create(images).Error)
}
