// Code generated by pg-bindings generator. DO NOT EDIT.


package n5ton6

import (
	"context"
	"strings"
	"testing"

	"github.com/stackrox/rox/generated/storage"
	legacy "github.com/stackrox/rox/migrator/migrations/n_05_to_n_06_postgres_active_components/legacy"
	pgStore "github.com/stackrox/rox/migrator/migrations/n_05_to_n_06_postgres_active_components/postgres"
	pghelper "github.com/stackrox/rox/migrator/migrations/postgreshelper"
	"github.com/stackrox/rox/pkg/dackbox/edges"
	pkgSchema "github.com/stackrox/rox/pkg/postgres/schema"
	"github.com/stackrox/rox/pkg/search/postgres"
	"gorm.io/gorm"

	"github.com/stackrox/rox/pkg/concurrency"
	"github.com/stackrox/rox/pkg/dackbox"
	"github.com/stackrox/rox/pkg/features"
	"github.com/stackrox/rox/pkg/rocksdb"
	"github.com/stackrox/rox/pkg/sac"
	"github.com/stackrox/rox/pkg/testutils"
	"github.com/stackrox/rox/pkg/testutils/envisolator"
	"github.com/stackrox/rox/pkg/testutils/rocksdbtest"
	"github.com/stretchr/testify/suite"
)

func TestMigration(t *testing.T) {
	suite.Run(t, new(postgresMigrationSuite))
}

type postgresMigrationSuite struct {
	suite.Suite
	envIsolator *envisolator.EnvIsolator
	ctx         context.Context

	legacyDB   *rocksdb.RocksDB
	postgresDB *pghelper.TestPostgres
}

var _ suite.TearDownTestSuite = (*postgresMigrationSuite)(nil)

func (s *postgresMigrationSuite) SetupTest() {
	s.envIsolator = envisolator.NewEnvIsolator(s.T())
	s.envIsolator.Setenv(features.PostgresDatastore.EnvVar(), "true")
	if !features.PostgresDatastore.Enabled() {
		s.T().Skip("Skip postgres store tests")
		s.T().SkipNow()
	}

	var err error
	s.legacyDB, err = rocksdb.NewTemp(s.T().Name())
	s.NoError(err)

	s.Require().NoError(err)

	s.ctx = sac.WithAllAccess(context.Background())
	s.postgresDB = pghelper.ForT(s.T(), true)
}

func (s *postgresMigrationSuite) TearDownTest() {
	rocksdbtest.TearDownRocksDB(s.legacyDB)
	s.postgresDB.Teardown(s.T())
}

func (s *postgresMigrationSuite) TestActiveComponentMigration() {
	deploymentID := "depA"
	componentName := "bash"
	os := []string{"rhel:8", "debian:10"}
	versions := []string{"v1", "v2"}
	images := []*pkgSchema.Images{
		{
			Id: "image1",
			ScanOperatingSystem: os[0],
		},
		{
			Id: "image2",
			ScanOperatingSystem: os[1],
		},
		{
			Id: "image3",
			ScanOperatingSystem: os[0],
		},
		{
			Id: "image4",
			ScanOperatingSystem: os[1],
		},
	}
	components := []*storage.ImageComponent{
		{
			Name: componentName,
			Version: versions[0],
			OperatingSystem: os[0],
		},
		{
			Name: componentName,
			Version: versions[1],
			OperatingSystem: os[0],
		},
		{
			Name: componentName,
			Version: versions[0],
			OperatingSystem: os[1],
		},
		{
			Name:            componentName,
			Version:         versions[1],
			OperatingSystem: os[1],
		},
	}

	s.populateImages(images)
	for _, c := range components {
		c.Id = edges.EdgeID{ParentID: c.Name, ChildID: c.Version}.ToString()
	}
	newStore := pgStore.New(s.postgresDB.Pool)
	dacky, err := dackbox.NewRocksDBDackBox(s.legacyDB, nil, []byte("graph"), []byte("dirty"), []byte("valid"))
	s.NoError(err)
	legacyStore := legacy.New(dacky, concurrency.NewKeyFence())

	// Prepare data and write to legacy DB
	activeComponents := []*storage.ActiveComponent{
		{
			DeploymentId: deploymentID,
			ComponentId: components[0].Id,
			ActiveContextsSlice: []*storage.ActiveComponent_ActiveContext{
				{
					ContainerName: "c1",
					ImageId:       images[0].Id,
				},
				{
					ContainerName: "c2",
					ImageId:       images[1].Id,
				},
				{
					ContainerName: "c3",
					ImageId:       images[2].Id,
				},
				{
					ContainerName: "c4",
					ImageId:       images[3].Id,
				},
			},
		},
		{
			DeploymentId: deploymentID,
			ComponentId: components[1].Id,
			ActiveContextsSlice: []*storage.ActiveComponent_ActiveContext{
				{
					ContainerName: "d1",
					ImageId:       images[0].Id,
				},
				{
					ContainerName: "d2",
					ImageId:       images[1].Id,
				},
				{
					ContainerName: "d3",
					ImageId:       images[2].Id,
				},
				{
					ContainerName: "d4",
					ImageId:       images[3].Id,
				},
			},
		},
	}
	for _, ac := range activeComponents {
		ac.Id = edges.EdgeID{ParentID: ac.GetDeploymentId(), ChildID: ac.GetComponentId()}.ToString()
	}


	s.NoError(legacyStore.UpsertMany(s.ctx, activeComponents))

	// Move
	s.NoError(move(s.postgresDB.GetGormDB(), s.postgresDB.Pool, legacyStore))

	// Verify
	count, err := newStore.Count(s.ctx)
	s.NoError(err)
	s.Equal(4, count)
	ids, err := newStore.GetIDs(s.ctx)
	s.NoError(err)
	imageToOs := make(map[string]string, 4)
	for _, image := range images {
		imageToOs[image.Id] = image.ScanOperatingSystem
	}
	for _, id := range ids {
		s.True(strings.HasPrefix(id, deploymentID+":"+componentName+"#"))
		fetched, ok, err := newStore.Get(s.ctx, id)
		s.NoError(err)
		s.True(ok)
		s.Equal(deploymentID, fetched.GetDeploymentId())
		// Verify componentId
		s.True(strings.HasSuffix(id, fetched.GetComponentId()))
		parts := postgres.IDToParts(fetched.GetComponentId())
		s.Equal(componentName, parts[0])
		s.Len(fetched.ActiveContextsSlice, 2)
		s.Equal(imageToOs[fetched.ActiveContextsSlice[0].ImageId], parts[2])
	}
}

func (s *postgresMigrationSuite) populateImages(images []*pkgSchema.Images) {
	pkgSchema.ApplySchemaForTable(s.ctx, s.postgresDB.GetGormDB(), pkgSchema.ImagesSchema.Table)
	imageTable := s.postgresDB.GetGormDB().Table(pkgSchema.ImagesSchema.Table).Model(pkgSchema.CreateTableImagesStmt.GormModel)
	s.NoError(imageTable.Create(images).Error)
}

func (s *postgresMigrationSuite) TestKnentMigration() {
	pkgSchema.ApplySchemaForTable(s.ctx, s.postgresDB.GetGormDB(), pkgSchema.ImagesSchema.Table)
	imageTable := s.postgresDB.GetGormDB().Table(pkgSchema.ImagesSchema.Table).Model(pkgSchema.CreateTableImagesStmt.GormModel)
	images := make([]*pkgSchema.Images, 0, 10)
	for i := 0; i < 10; i++ {
		image := &pkgSchema.Images{}
		s.NoError(testutils.FullInit(image, testutils.UniqueInitializer(), testutils.JSONFieldsFilter))
		images = append(images, image)
	}
	result := imageTable.Create(images)
	s.NoError(result.Error)
	s.Equal(int64(10), result.RowsAffected)
	a := make([]ImageIDAndOs, 2)
	m := make(map[string]string, 13)
	result = imageTable.FindInBatches(&a, 2, func(_ *gorm.DB, batch int) error {
		for _, sub := range a {
			m[sub.Id] = sub.ScanOperatingSystem
		}
		return nil
	})
	s.Equal(int64(10), result.RowsAffected)
	s.NoError(result.Error)
	s.NotEmpty(a[0].Id)
}
