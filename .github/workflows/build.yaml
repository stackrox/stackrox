name: Build
on:
  workflow_dispatch:
    inputs:
      commit:
        description: 'Commit SHA to build'
        required: true
        type: string
  workflow_call:
  push:
    tags:
    - '*-nightly-*'
    branches:
    - master
  pull_request:
    types:
    - opened
    - reopened
    - synchronize

defaults:
  run:
    # This enables `-o pipefail` for all jobs as compared to when shell isn't set.
    # See https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#defaultsrunshell
    shell: bash

jobs:
  all-in-one:
    runs-on: ubuntu-22.04
    env:
      GOOS: linux
      GOARCH: amd64
      CGO_ENABLED: 0
      # Use RHACS_BRANDING to match main build path and share Docker cache
      ROX_PRODUCT_BRANDING: RHACS_BRANDING
    steps:
      - name: Collect Workflow Telemetry
        uses: catchpoint/workflow-telemetry-action@v2
        with:
          theme: dark
          comment_on_pr: false
          job_summary: true
          metric_frequency: 5
          proc_trace_sys_enable: false
          proc_trace_chart_max_count: 100

      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: ${{ github.event.pull_request.commits }}
          fetch-tags: false
          show-progress: false
          ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

      - name: Fetch tags in background
        run: |
          # Fetch tags in background while other setup steps proceed
          # Tags are needed for make tag/version generation
          nohup git fetch --quiet --depth=5000 origin +refs/tags/*:refs/tags/* &

      - uses: ./.github/actions/job-preamble
        with:
          gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

      - uses: ./.github/actions/handle-tagged-build

      # Keep UI cache - changes less frequently than Go code
      - name: restore cached ui
        uses: actions/cache@v4
        id: restore-ui-build
        with:
          key: built-ui-${{ env.ROX_PRODUCT_BRANDING }}-${{ hashFiles('ui/**') }}
          path: ui/build

      - uses: ./.github/actions/cache-ui-dependencies
        if: steps.restore-ui-build.outputs.cache-hit != 'true'

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: true
          cache-dependency-path: '**/go.sum'

      - name: Download Go modules
        run: go mod download

      - name: Login to docker.io to mitigate rate limiting on downloading images
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_CI_ACCOUNT_USERNAME }}
          password: ${{ secrets.DOCKERHUB_CI_ACCOUNT_PASSWORD }}

      - name: Login to ghcr.io for docker layer caching
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Checkout submodules
        run: git submodule update --init

      - name: Setup build env for debugging support
        run: |
          if [[ "${GITHUB_HEAD_REF:-}" =~ -debug ]]; then
            echo "DEBUG_BUILD=yes" >> "${GITHUB_ENV}"
          fi

      - name: Build Go binaries
        env:
          CI: "true"  # Prevents duplicate roxctl build in main-build-nodeps
        run: |
          # cache-go-dependencies already ran make deps, just need build-prep
          make build-prep
          # Build all Go binaries in one invocation for better cache utilization
          # Go's internal parallelism handles concurrent package compilation
          time ./scripts/go-build.sh \
            central \
            compliance/cmd/compliance \
            config-controller \
            migrator \
            sensor/admission-control \
            sensor/kubernetes \
            sensor/upgrader \
            roxctl \
            compliance/virtualmachines/roxagent

      - name: Build UI
        run: |
          export SKIP_UI_BUILD=true  # skip if already built (from cache)
          make ui-build

      # Cache swagger docs - regenerating from proto is slow
      - name: Restore cached docs
        uses: actions/cache@v4
        id: restore-docs-build
        with:
          key: built-docs-${{ env.GOOS }}-${{ env.GOARCH }}-${{ hashFiles('proto/**', 'generated/**') }}
          path: image/rhel/docs

      - name: Build swagger docs
        if: steps.restore-docs-build.outputs.cache-hit != 'true'
        run: make swagger-docs

      - name: Build Docker images
        run: |
          cache_registry='ghcr.io'
          cache_image="${GITHUB_REPOSITORY,,}"
          # Use same cache tag format as build-and-push-main to share cache
          cache_tag="main-${GOARCH}-master-${ROX_PRODUCT_BRANDING,,}"

          # Build cache args: always read from master cache
          cache_args="--cache-from type=registry,ref=${cache_registry}/${cache_image}:${cache_tag}"
          # Only write cache on master branch pushes
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" ]]; then
            cache_args="${cache_args} --cache-to type=registry,ref=${cache_registry}/${cache_image}:${cache_tag},mode=max,ignore-error=true"
          fi

          # Copy binaries to image context (unset CI to use simpler copy path)
          unset CI
          make copy-binaries-to-image-dir

          # Build all Docker images in parallel with layer caching
          export DOCKER_BUILD_CACHE_ARGS="${cache_args}"
          make docker-build-roxctl-image &
          make central-db-image &
          make build-main-image &
          wait

      - name: Verify build artifacts
        if: always()
        run: |
          echo "=== Docker images ==="
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"
          echo ""
          echo "=== Built binaries ==="
          ls -lh bin/linux_amd64/

  define-job-matrix:
    outputs:
      matrix: ${{ steps.define-job-matrix.outputs.matrix }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

      - name: Define the matrix for build jobs
        id: define-job-matrix
        run: |
          source './scripts/ci/lib.sh'

          matrix='{
            "pre_build_ui": { "branding":[] },
            "pre_build_cli": { "include":[] },
            "pre_build_go_binaries": { "include":[] },
            "pre_build_go_binaries_merge": { "include":[] },
            "build_and_push_main": { "name":[], "arch":[] },
            "push_main_multiarch_manifests": { "name":[] },
            "build_and_push_operator": { "name":[], "arch":[] },
            "push_operator_multiarch_manifests": { "name":[] },
            "scan_images_with_roxctl": { "name":[], "image":[], "exclude":[] }
          }'

          # Go binaries: split into 3 component groups for parallelization
          # - central: largest component
          # - sensor: admission-control, kubernetes, upgrader
          # - support: compliance, config-controller, migrator
          add_go_binary_jobs() {
            local arch="$1"
            local name="$2"
            # Add build jobs for each component
            matrix="$(jq --arg arch "$arch" --arg name "$name" \
              '.pre_build_go_binaries.include += [
                {"arch": $arch, "name": $name, "component": "central", "packages": "central"},
                {"arch": $arch, "name": $name, "component": "sensor", "packages": "sensor/admission-control sensor/kubernetes sensor/upgrader"},
                {"arch": $arch, "name": $name, "component": "support", "packages": "compliance/cmd/compliance config-controller migrator"}
              ]' <<< "$matrix")"
            # Add merge job for this (arch, name) combination
            matrix="$(jq --arg arch "$arch" --arg name "$name" \
              '.pre_build_go_binaries_merge.include += [{"arch": $arch, "name": $name}]' <<< "$matrix")"
          }

          # The base matrix - amd64 only for PRs
          add_go_binary_jobs "amd64" "default"

          # CLI: For PRs, only linux-amd64; add darwin/windows for non-PRs or with label
          matrix="$(jq '.pre_build_cli.include += [{"os": "linux-amd64", "targets": "roxctl_linux-amd64 roxagent_linux-amd64"}]' <<< "$matrix")"
          if ! is_in_PR_context || pr_has_label ci-build-all-cli; then
            matrix="$(jq '.pre_build_cli.include += [{"os": "darwin", "targets": "roxctl_darwin-amd64 roxctl_darwin-arm64"}]' <<< "$matrix")"
            matrix="$(jq '.pre_build_cli.include += [{"os": "windows", "targets": "roxctl_windows-amd64"}]' <<< "$matrix")"
          fi

          # Check if operator-related files changed (for PRs only)
          # If no operator files changed, skip the operator build to save ~10 minutes
          operator_files_changed() {
            if ! is_in_PR_context; then
              return 0  # Always build operator for non-PRs (master, tags)
            fi
            # Get the base ref for comparison
            local base_ref="${{ github.event.pull_request.base.sha }}"
            if [[ -z "$base_ref" ]]; then
              return 0  # Can't determine base, assume changed
            fi
            # Check for changes in operator-related paths
            git diff --name-only "$base_ref" HEAD | grep -qE '^(operator/|pkg/|go\.(mod|sum)$|scripts/go-build|generated/|image/rhel/)'
          }

          # For PRs: only RHACS_BRANDING (used by e2e tests), add STACKROX with label
          matrix="$(jq '.pre_build_ui.branding += ["RHACS_BRANDING"]' <<< "$matrix")"
          matrix="$(jq '.build_and_push_main.name += ["RHACS_BRANDING"]' <<< "$matrix")"
          matrix="$(jq '.build_and_push_main.arch += ["amd64"]' <<< "$matrix")"

          matrix="$(jq '.push_main_multiarch_manifests.name += ["RHACS_BRANDING"]' <<< "$matrix")"

          # Only build operator if operator-related files changed (or non-PR builds)
          if operator_files_changed || pr_has_label ci-build-operator; then
            matrix="$(jq '.build_and_push_operator.name += ["RHACS_BRANDING"]' <<< "$matrix")"
            matrix="$(jq '.build_and_push_operator.arch += ["amd64"]' <<< "$matrix")"
          else
            echo "Skipping operator build - no operator-related files changed"
            echo "Add label 'ci-build-operator' to force operator build"
          fi

          matrix="$(jq '.scan_images_with_roxctl.name += ["RHACS_BRANDING"]' <<< "$matrix")"
          matrix="$(jq '.scan_images_with_roxctl.image += ["central-db", "collector", "main", "roxctl", "scanner", "scanner-db", "scanner-db-slim", "scanner-slim", "stackrox-operator"]' <<< "$matrix")"

          # Add STACKROX_BRANDING for non-PRs or PRs with ci-build-stackrox-branding label
          if ! is_in_PR_context || pr_has_label ci-build-stackrox-branding; then
            matrix="$(jq '.pre_build_ui.branding += ["STACKROX_BRANDING"]' <<< "$matrix")"
            matrix="$(jq '.build_and_push_main.name += ["STACKROX_BRANDING"]' <<< "$matrix")"
            matrix="$(jq '.push_main_multiarch_manifests.name += ["STACKROX_BRANDING"]' <<< "$matrix")"
            matrix="$(jq '.scan_images_with_roxctl.name += ["STACKROX_BRANDING"]' <<< "$matrix")"
            # TODO(ROX-27191): remove the exclusion once there's a community operator.
            matrix="$(jq '.scan_images_with_roxctl.exclude += [{ "name": "STACKROX_BRANDING", "image": "stackrox-operator" }]' <<< "$matrix")"
          fi

          # Add arm64 for non-PRs or PRs with ci-build-arm64 label
          if ! is_in_PR_context || pr_has_label ci-build-arm64 || pr_has_label ci-build-all-arch; then
            matrix="$(jq '.pre_build_cli.include += [{"os": "linux-arm64", "targets": "roxctl_linux-arm64 roxagent_linux-arm64"}]' <<< "$matrix")"
            add_go_binary_jobs "arm64" "default"
            matrix="$(jq '.build_and_push_main.arch += ["arm64"]' <<< "$matrix")"
            # Only add arm64 operator if operator files changed
            if operator_files_changed || pr_has_label ci-build-operator; then
              matrix="$(jq '.build_and_push_operator.arch += ["arm64"]' <<< "$matrix")"
            fi
          fi

          # Compute multiarch manifests based on final arch list
          matrix="$(jq '.push_main_multiarch_manifests.archs = [.build_and_push_main.arch | join(",")]' <<< "$matrix")"
          # Only add operator manifest push if operator builds are happening
          if [[ "$(jq -r '.build_and_push_operator.arch | length' <<< "$matrix")" -gt 0 ]]; then
            matrix="$(jq '.push_operator_multiarch_manifests.name += ["RHACS_BRANDING"]' <<< "$matrix")"
            matrix="$(jq '.push_operator_multiarch_manifests.archs = [.build_and_push_operator.arch | join(",")]' <<< "$matrix")"
          fi

          # Add ppc64le/s390x for non-PRs or PRs with ci-build-all-arch label
          if ! is_in_PR_context || pr_has_label ci-build-all-arch; then
            matrix="$(jq '.pre_build_cli.include += [{"os": "linux-ppc64le", "targets": "roxctl_linux-ppc64le roxagent_linux-ppc64le"}]' <<< "$matrix")"
            matrix="$(jq '.pre_build_cli.include += [{"os": "linux-s390x", "targets": "roxctl_linux-s390x roxagent_linux-s390x"}]' <<< "$matrix")"
            add_go_binary_jobs "ppc64le" "default"
            add_go_binary_jobs "s390x" "default"
            matrix="$(jq '.build_and_push_main.arch += ["ppc64le", "s390x"]' <<< "$matrix")"
          fi

          # Conditionally add a prerelease build (binaries built with GOTAGS=release)
          if ! is_tagged; then
            if ! is_in_PR_context || pr_has_label ci-build-prerelease; then
              add_go_binary_jobs "amd64" "prerelease"
              matrix="$(jq '.build_and_push_main.name += ["prerelease"]' <<< "$matrix")"
              matrix="$(jq '.push_main_multiarch_manifests.name += ["prerelease"]' <<< "$matrix")"
            fi
          fi

          # Conditionally add a -race debug build (binaries built with -race, amd64 only)
          if ! is_in_PR_context || pr_has_label ci-build-race-condition-debug; then
            add_go_binary_jobs "amd64" "race-condition-debug"
            matrix="$(jq '.build_and_push_main.name += ["race-condition-debug"]' <<< "$matrix")"
            matrix="$(jq '.push_main_multiarch_manifests.name += ["race-condition-debug"]' <<< "$matrix")"
            # Exclude non-amd64 for race-condition-debug in build_and_push_main
            matrix="$(jq '.build_and_push_main.exclude = [{ "name": "race-condition-debug", "arch": "arm64" }]' <<< "$matrix")"
            matrix="$(jq '.build_and_push_main.exclude += [{ "name": "race-condition-debug", "arch": "ppc64le" }]' <<< "$matrix")"
            matrix="$(jq '.build_and_push_main.exclude += [{ "name": "race-condition-debug", "arch": "s390x" }]' <<< "$matrix")"
          fi

          echo "Job matrix after conditionals:"
          jq <<< "$matrix"

          condensed="$(jq -c <<< "$matrix")"
          echo "matrix=$condensed" >> "$GITHUB_OUTPUT"

  pre-build-ui:
    needs: define-job-matrix
    strategy:
      fail-fast: false
      matrix:
        branding: ${{ fromJson(needs.define-job-matrix.outputs.matrix).pre_build_ui.branding }}
    env:
      ROX_PRODUCT_BRANDING: ${{ matrix.branding }}
      # For consistency with `image/rhel/konflux.Dockerfile`, see comment there.
      UI_PKG_INSTALL_EXTRA_ARGS: --ignore-scripts
    runs-on: ubuntu-22.04
    steps:
      - name: Collect Workflow Telemetry
        uses: catchpoint/workflow-telemetry-action@v2
        with:
          theme: dark
          comment_on_pr: false
          job_summary: true
          metric_frequency: 5
          proc_trace_sys_enable: false
          proc_trace_chart_max_count: 100

      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

      - uses: ./.github/actions/job-preamble
        with:
          gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: 'ui/apps/platform/package-lock.json'

      - uses: actions/cache@v4
        id: restore-ui-build
        with:
          key: built-ui-${{ matrix.branding }}-${{ hashFiles('ui/**') }}
          path: ui/build

      - uses: ./.github/actions/cache-ui-dependencies
        if: steps.restore-ui-build.outputs.cache-hit != 'true'

      - uses: ./.github/actions/handle-tagged-build

      - name: Build UI
        #if: steps.restore-ui-build.outputs.cache-hit != 'true'
        run: |
          set +e
          git describe --tags --abbrev=10 --dirty --long --exclude '*-nightly-*' \
            || git fetch --quiet --depth=5000 origin +refs/tags/*:refs/tags/*
          #git describe --tags --abbrev=10 --dirty --long --exclude '*-nightly-*' \
          #  || echo 'ERROR: cannot find the last release version tag for this branch'
          export SKIP_UI_BUILD=true  # if true, build only if ui/build does not exist
          make ui-build

      - uses: ./.github/actions/upload-artifact-with-retry
        with:
          name: ui-${{env.ROX_PRODUCT_BRANDING}}-build
          path: |
            ui/build
            ui/apps/platform/package-lock.json

  # Generate OSS notice in parallel - needs UI deps but runs independently
  pre-build-oss-notice:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

      - uses: ./.github/actions/job-preamble
        with:
          gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: 'ui/apps/platform/package-lock.json'

      - name: Fetch UI deps
        run: make -C ui deps

      - name: Generate OSS notice
        env:
          GITHUB_OAUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FETCH_VERSION=0.4.6
          FETCH_SHA256=a67ed3141d6deb7e7841f40505cba11eb7a37abbab78374712a42373e7854209
          wget --no-verbose -O fetch https://github.com/gruntwork-io/fetch/releases/download/v${FETCH_VERSION}/fetch_linux_amd64
          echo "${FETCH_SHA256} fetch" | sha256sum -c -
          install fetch /usr/bin \
            || install fetch /usr/local/bin

          OSSLS_VERSION=0.11.1
          OSSLS_SHA256=f1bf3012961c1d90ba307a46263f29025028d35c209b9a65e5c7d502c470c95f
          fetch --repo="https://github.com/stackrox/ossls" --tag="${OSSLS_VERSION}" --release-asset="ossls_linux_amd64" .
          echo "${OSSLS_SHA256} *ossls_linux_amd64" | sha256sum -c -
          install ossls_linux_amd64 /usr/bin/ossls \
            || install ossls_linux_amd64 /usr/local/bin/ossls
          rm ossls_linux_amd64
          ossls version
          make ossls-notice

      - uses: ./.github/actions/upload-artifact-with-retry
        with:
          name: oss-notice
          path: image/rhel/THIRD_PARTY_NOTICES

  # Build CLI binaries in parallel per OS/arch
  # PRs: linux-amd64, darwin, windows (3 jobs)
  # Non-PRs: adds linux-arm64, linux-ppc64le, linux-s390x (6 jobs)
  pre-build-cli:
    needs: define-job-matrix
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.define-job-matrix.outputs.matrix).pre_build_cli }}
    steps:
      - name: Collect Workflow Telemetry
        uses: catchpoint/workflow-telemetry-action@v2
        with:
          theme: dark
          comment_on_pr: false
          job_summary: true
          metric_frequency: 5
          proc_trace_sys_enable: false
          proc_trace_chart_max_count: 100

      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

      - uses: ./.github/actions/job-preamble
        with:
          gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

      - uses: ./.github/actions/handle-tagged-build

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: false

      - name: Cache Go dependencies
        uses: ./.github/actions/cache-go-dependencies

      - name: Build CLI for ${{ matrix.os }}
        run: make ${{ matrix.targets }}

      - name: Bundle build to preserve permissions
        run: tar -cvzf cli-build-${{ matrix.os }}.tgz bin

      - uses: ./.github/actions/upload-artifact-with-retry
        with:
          name: cli-build-${{ matrix.os }}
          path: cli-build-${{ matrix.os }}.tgz

  # Merge CLI artifacts from parallel builds into single artifact
  pre-build-cli-merge:
    runs-on: ubuntu-22.04
    needs: pre-build-cli
    steps:
      - uses: actions/download-artifact@v4
        with:
          pattern: cli-build-*
          merge-multiple: false

      - name: Merge CLI builds
        run: |
          mkdir -p bin
          for archive in cli-build-*/cli-build-*.tgz; do
            echo "Extracting $archive"
            tar -xzf "$archive"
          done
          ls -la bin/

      - name: Bundle merged build
        run: tar -cvzf cli-build.tgz bin

      - uses: actions/upload-artifact@v4
        with:
          name: cli-build
          path: cli-build.tgz

  pre-build-go-binaries:
    strategy:
      # Supports three go binary builds:
      # default - built with environment defaults (see handle-tagged-build & env.mk)
      # prerelease - built with GOTAGS=release
      # race-condition-debug - built with -race
      matrix: ${{ fromJson(needs.define-job-matrix.outputs.matrix).pre_build_go_binaries }}
    env:
      GOOS: linux
      GOARCH: ${{ matrix.arch }}
    needs: define-job-matrix
    runs-on: ubuntu-22.04
    steps:
      - name: Collect Workflow Telemetry
        uses: catchpoint/workflow-telemetry-action@v2
        with:
          theme: dark
          comment_on_pr: false
          job_summary: true
          metric_frequency: 5
          proc_trace_sys_enable: false
          proc_trace_chart_max_count: 100

      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

      - uses: ./.github/actions/job-preamble
        with:
          gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: false

      - name: Cache Go dependencies
        uses: ./.github/actions/cache-go-dependencies

      - uses: ./.github/actions/handle-tagged-build

      - name: PR labels
        uses: joerick/pr-labels-action@v1.0.9

      - name: Setup build env for debugging support
        run: |
          if [[ "${GITHUB_HEAD_REF:-}" =~ -debug ]]; then
            echo "DEBUG_BUILD=yes" >> "${GITHUB_ENV}"
          fi

      - name: Setup Go build environment for release
        if: |
          contains(github.event.pull_request.labels.*.name, 'ci-release-build')
            ||
          matrix.name == 'prerelease'
        run: echo "GOTAGS=release" >> "$GITHUB_ENV"

      - name: Setup Go build environment for -race
        if: |
          matrix.arch == 'amd64'
            &&
          (
            contains(github.event.pull_request.labels.*.name, 'ci-race-tests')
              ||
            matrix.name == 'race-condition-debug'
          )
        run: echo "RACE=true" >> "$GITHUB_ENV"

      - name: Build Go Binaries (${{ matrix.component }})
        run: |
          # Build only the packages for this component: ${{ matrix.packages }}
          make build-prep

          # Determine CGO setting:
          # - CGO_ENABLED=1 for amd64 release builds (FIPS compliance)
          # - CGO_ENABLED=0 for PRs and non-amd64 (faster, better caching)
          cgo_enabled=0
          if [[ "${{ matrix.arch }}" == "amd64" ]]; then
            if [[ "${{ github.event_name }}" == "push" ]]; then
              # Master/release builds need CGO for FIPS
              cgo_enabled=1
              echo "Building amd64 binary with CGO (FIPS build)"
            else
              # PR builds can skip CGO for faster builds
              echo "Building amd64 binary without CGO (PR build, faster)"
            fi
          else
            echo "Building non-amd64 binary (CGO_ENABLED=0)"
          fi

          GOOS=linux GOARCH=${{ matrix.arch }} CGO_ENABLED=$cgo_enabled ./scripts/go-build.sh ${{ matrix.packages }}

      - name: Bundle the build to preserve permissions
        run: tar -cvzf go-binaries-build.tgz bin/linux_${{ matrix.arch }}

      - uses: ./.github/actions/upload-artifact-with-retry
        with:
          name: go-binaries-build-${{ matrix.arch }}-${{ matrix.name }}-${{ matrix.component }}
          path: go-binaries-build.tgz

  # Merge Go binary artifacts from parallel component builds into single artifact per arch/name
  pre-build-go-binaries-merge:
    runs-on: ubuntu-22.04
    needs:
      - define-job-matrix
      - pre-build-go-binaries
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.define-job-matrix.outputs.matrix).pre_build_go_binaries_merge }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          pattern: go-binaries-build-${{ matrix.arch }}-${{ matrix.name }}-*
          merge-multiple: false

      - name: Merge Go binary builds
        run: |
          mkdir -p bin/linux_${{ matrix.arch }}
          for archive in go-binaries-build-*/go-binaries-build.tgz; do
            echo "Extracting $archive"
            tar -xzf "$archive"
          done
          ls -la bin/linux_${{ matrix.arch }}/

      - name: Bundle merged build
        run: tar -cvzf go-binaries-build.tgz bin/linux_${{ matrix.arch }}

      - uses: actions/upload-artifact@v4
        with:
          name: go-binaries-build-${{ matrix.arch }}-${{ matrix.name }}
          path: go-binaries-build.tgz

  pre-build-docs:
    runs-on: ubuntu-22.04
    steps:
      - name: Collect Workflow Telemetry
        uses: catchpoint/workflow-telemetry-action@v2
        with:
          theme: dark
          comment_on_pr: false
          job_summary: true
          metric_frequency: 5
          proc_trace_sys_enable: false
          proc_trace_chart_max_count: 100

      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

      - uses: ./.github/actions/job-preamble
        with:
          gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

      # TODO: update make/protogen to not always rebuild (rebuilds even when files are not updated)
      - name: restore cached docs build
        uses: actions/cache@v4
        id: restore-docs-build
        with:
          key: built-docs-${{ env.GOOS }}-${{ env.GOARCH }}-${{ hashFiles('proto/**', 'generated/**') }}
          path: image/rhel/docs

      - name: Setup Go
        if: steps.restore-docs-build.outputs.cache-hit != 'true'
        uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: false

      - name: Cache Go dependencies
        if: steps.restore-docs-build.outputs.cache-hit != 'true'
        uses: ./.github/actions/cache-go-dependencies

      - uses: ./.github/actions/handle-tagged-build

      - name: Resolve mods for protos
        run: go mod tidy

      - name: Generate the swagger docs
        run: |
          if [[ "${{ steps.restore-docs-build.outputs.cache-hit }}" != 'true' ]]; then
            make swagger-docs
          fi
          # Workaround to handle https://github.com/actions/cache/issues/753
          rm -rf .proto

      - uses: ./.github/actions/upload-artifact-with-retry
        with:
          name: docs-build
          path: |
            image/rhel/docs

  pre-build-operator-bundle:
    runs-on: ubuntu-22.04
    needs: define-job-matrix
    # Only run if operator build is needed (matrix has operator entries)
    if: ${{ fromJson(needs.define-job-matrix.outputs.matrix).build_and_push_operator.arch[0] != null }}
    env:
      QUAY_RHACS_ENG_RW_USERNAME: ${{ secrets.QUAY_RHACS_ENG_RW_USERNAME }}
      QUAY_RHACS_ENG_RW_PASSWORD: ${{ secrets.QUAY_RHACS_ENG_RW_PASSWORD }}
    steps:
      - name: Collect Workflow Telemetry
        uses: catchpoint/workflow-telemetry-action@v2
        with:
          theme: dark
          comment_on_pr: false
          job_summary: true
          metric_frequency: 5
          proc_trace_sys_enable: false
          proc_trace_chart_max_count: 100

      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

      - uses: ./.github/actions/job-preamble
        with:
          gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: false

      - name: Cache Go dependencies
        uses: ./.github/actions/cache-go-dependencies

      - uses: ./.github/actions/handle-tagged-build

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: pip install -r operator/bundle_helpers/requirements.txt

      - name: Cache operator tools
        id: cache-operator-tools
        uses: actions/cache@v4
        with:
          path: operator/.gotools
          key: operator-tools-${{ runner.os }}-amd64-${{ hashFiles('operator/tools/*/go.sum') }}
          restore-keys: |
            operator-tools-${{ runner.os }}-amd64-

      - name: Capture operator tag
        run: |
          OPERATOR_TAG="$(make --quiet --no-print-directory -C operator tag)"
          echo "OPERATOR_TAG=${OPERATOR_TAG}" >> "$GITHUB_ENV"
          echo "Captured operator tag: ${OPERATOR_TAG}"

      - name: Generate operator manifests
        run: |
          make -C operator/ VERSION="${{ env.OPERATOR_TAG }}" manifests generate

      - name: Build operator bundle
        run: |
          # Build bundle with CI-optimized targets (skip network check, assume unreleased)
          make -C operator/ VERSION="${{ env.OPERATOR_TAG }}" bundle-ci bundle-build-ci

      - name: Docker login
        if: |
          github.event_name == 'push' || !github.event.pull_request.head.repo.fork
        run: |
          echo "${{ secrets.QUAY_RHACS_ENG_RW_PASSWORD }}" | \
            docker login quay.io -u "${{ secrets.QUAY_RHACS_ENG_RW_USERNAME }}" --password-stdin

      - name: Push bundle image
        if: |
          github.event_name == 'push' || !github.event.pull_request.head.repo.fork
        run: |
          make -C operator/ VERSION="${{ env.OPERATOR_TAG }}" docker-push-bundle | cat

      - name: Save bundle artifacts
        run: |
          # Save bundle directory for operator job (in case push failed or for verification)
          tar -czf operator-bundle.tgz -C operator build/bundle bundle.Dockerfile

      - uses: ./.github/actions/upload-artifact-with-retry
        with:
          name: operator-bundle
          path: operator-bundle.tgz

  build-and-push-main:
    runs-on: ubuntu-22.04
    needs:
      - define-job-matrix
      - pre-build-ui
      - pre-build-cli-merge
      - pre-build-go-binaries-merge
      - pre-build-docs
      - pre-build-oss-notice
    # This step will run even if required pre-* steps failed. By following this
    # approach as much of the build matrix as possible is completed despite
    # transient issues e.g. docker pull timeouts. In this way some e2e jobs that
    # require some part of the build matrix can still proceed.
    if: ${{ !cancelled() }}
    strategy:
      # Supports four image builds (see Setup build env):
      # STACKROX_BRANDING
      # RHACS_BRANDING
      # prerelease
      # race-condition-debug
      fail-fast: false
      matrix: ${{ fromJson(needs.define-job-matrix.outputs.matrix).build_and_push_main }}
    env:
      GO_BINARIES_BUILD_ARTIFACT: ""
      ROX_PRODUCT_BRANDING: ""
      QUAY_RHACS_ENG_RO_USERNAME: ${{ secrets.QUAY_RHACS_ENG_RO_USERNAME }}
      QUAY_RHACS_ENG_RO_PASSWORD: ${{ secrets.QUAY_RHACS_ENG_RO_PASSWORD }}
      QUAY_RHACS_ENG_RW_USERNAME: ${{ secrets.QUAY_RHACS_ENG_RW_USERNAME }}
      QUAY_RHACS_ENG_RW_PASSWORD: ${{ secrets.QUAY_RHACS_ENG_RW_PASSWORD }}
      QUAY_STACKROX_IO_RW_USERNAME: ${{ secrets.QUAY_STACKROX_IO_RW_USERNAME }}
      QUAY_STACKROX_IO_RW_PASSWORD: ${{ secrets.QUAY_STACKROX_IO_RW_PASSWORD }}
    steps:
      - name: Collect Workflow Telemetry
        uses: catchpoint/workflow-telemetry-action@v2
        with:
          theme: dark
          comment_on_pr: false
          job_summary: true
          metric_frequency: 5
          proc_trace_sys_enable: false
          proc_trace_chart_max_count: 100

      - name: Setup build env
        run: |
          case "${{ matrix.name }}" in
            STACKROX_BRANDING)
              go_binaries="default"
              brand="STACKROX_BRANDING"
              ;;
            RHACS_BRANDING)
              go_binaries="default"
              brand="RHACS_BRANDING"
              ;;
            race-condition-debug)
              go_binaries="race-condition-debug"
              brand="RHACS_BRANDING"
              ;;
            prerelease)
              go_binaries="prerelease"
              brand="RHACS_BRANDING"
              ;;
            *)
              echo "Unsupported build: ${{ matrix.name }}"
              exit 1
          esac

          {
            echo "GO_BINARIES_BUILD_ARTIFACT=go-binaries-build-${{ matrix.arch }}-${go_binaries}"
            echo "ROX_PRODUCT_BRANDING=${brand}"
          } >> "$GITHUB_ENV"
          if [[ "${GITHUB_HEAD_REF:-}" =~ -debug ]]; then
            echo "DEBUG_BUILD=yes" >> "${GITHUB_ENV}"
          fi

      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

      - uses: ./.github/actions/job-preamble
        with:
          gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

      - name: Login to docker.io to mitigate rate limiting on downloading images
        uses: docker/login-action@v3
        # Skip for external contributions.
        if: |
          github.event_name == 'push' || !github.event.pull_request.head.repo.fork
        with:
          username: ${{ secrets.DOCKERHUB_CI_ACCOUNT_USERNAME }}
          password: ${{ secrets.DOCKERHUB_CI_ACCOUNT_PASSWORD }}

      - name: Set up QEMU
        if: matrix.arch != 'amd64'
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to ghcr.io for Docker layer caching
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Setup Docker cache args
        run: |
          cache_registry='ghcr.io'
          cache_image="${GITHUB_REPOSITORY,,}"
          cache_tag="main-${{ matrix.arch }}-master-${ROX_PRODUCT_BRANDING,,}"

          # Build cache-from args: always pull from master cache
          cache_args="--cache-from type=registry,ref=${cache_registry}/${cache_image}:${cache_tag}"

          # Only write cache on master branch pushes to avoid PR cache pollution
          # and reduce build time (cache-to adds upload overhead)
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" ]]; then
            cache_args="${cache_args} --cache-to type=registry,ref=${cache_registry}/${cache_image}:${cache_tag},mode=max,ignore-error=true"
            echo "Docker cache: read/write (master push)"
          else
            echo "Docker cache: read-only (PR or non-master)"
          fi

          echo "DOCKER_BUILD_CACHE_ARGS=${cache_args}" >> "$GITHUB_ENV"

      - name: Checkout submodules
        run: |
            git submodule update --init

      - uses: ./.github/actions/handle-tagged-build

      - uses: ./.github/actions/download-artifact-with-retry
        with:
          name: ui-${{ env.ROX_PRODUCT_BRANDING }}-build
          path: ui

      - uses: ./.github/actions/download-artifact-with-retry
        with:
          name: cli-build

      - name: Unpack cli build
        run: |
          tar xvzf cli-build.tgz

      - uses: ./.github/actions/download-artifact-with-retry
        with:
          name: ${{ env.GO_BINARIES_BUILD_ARTIFACT }}

      - name: Unpack Go binaries build
        run: |
          tar xvzf go-binaries-build.tgz

      - uses: ./.github/actions/download-artifact-with-retry
        with:
          name: docs-build
          path: image/rhel/docs

      - uses: ./.github/actions/download-artifact-with-retry
        with:
          name: oss-notice
          path: image/rhel/THIRD_PARTY_NOTICES

      - name: Set build tag for prerelease images
        if: matrix.name == 'prerelease'
        run: echo "BUILD_TAG=$(make --quiet --no-print-directory tag)-prerelease" >> "$GITHUB_ENV"

      - name: Set build tag for race condition images
        if: matrix.name == 'race-condition-debug'
        run: echo "BUILD_TAG=$(make --quiet --no-print-directory tag)-rcd" >> "$GITHUB_ENV"

      - name: Build main images
        run: |
          GOOS=linux GOARCH=${{ matrix.arch }} scripts/lib.sh retry 6 true make docker-build-main-image

      - name: Check debugger presence in the main image
        run: make check-debugger

      - name: Build roxctl image
        run: |
          GOOS=linux GOARCH=${{ matrix.arch }} scripts/lib.sh retry 6 true make docker-build-roxctl-image

      # needed for docs ensure_image.sh initial pull with RHACS_BRANDING
      - name: Docker login
        # Skip for external contributions.
        if: |
          github.event_name == 'push' || !github.event.pull_request.head.repo.fork
        run: |
          ./scripts/ci/lib.sh registry_ro_login "quay.io/rhacs-eng"

      - name: Push images
        # Skip for external contributions.
        if: |
          github.event_name == 'push' || !github.event.pull_request.head.repo.fork
        run: |
            source ./scripts/ci/lib.sh
            echo "Will determine context from: ${{ github.event_name }} & ${{ github.ref_name }}"
            push_context=""
            if [[ "${{ github.event_name }}" == "push" && "${{ github.ref_name }}" == "master" ]]; then
              push_context="merge-to-master"
            fi
            push_main_image_set "$push_context" "${{ env.ROX_PRODUCT_BRANDING }}" "${{ matrix.arch }}"

      - name: Push matching collector and scanner images
        # Skip for external contributions.
        if: |
          github.event_name == 'push' || !github.event.pull_request.head.repo.fork
        run: |
            # Need to free up some space before push_matching_collector_scanner_images() does its pull.
            docker system prune --all --force
            source ./scripts/ci/lib.sh
            push_matching_collector_scanner_images "${{ env.ROX_PRODUCT_BRANDING }}" "${{ matrix.arch }}"

  push-main-manifests:
    runs-on: ubuntu-latest
    needs:
    - define-job-matrix
    - build-and-push-main
    # This step will run even if some of the build-and-push-matrix steps failed.
    # By following this approach as much of the build matrix as possible is
    # completed despite transient issues e.g. docker pull timeouts. In this way
    # some e2e jobs that require some part of the build matrix can still
    # proceed.
    if: ${{ !cancelled() }}
    strategy:
      # Supports four image builds (see Setup build env):
      # STACKROX_BRANDING
      # RHACS_BRANDING
      # prerelease
      # race-condition-debug
      fail-fast: false
      matrix: ${{ fromJson(needs.define-job-matrix.outputs.matrix).push_main_multiarch_manifests }}
    env:
      ROX_PRODUCT_BRANDING: ""
      QUAY_RHACS_ENG_RO_USERNAME: ${{ secrets.QUAY_RHACS_ENG_RO_USERNAME }}
      QUAY_RHACS_ENG_RO_PASSWORD: ${{ secrets.QUAY_RHACS_ENG_RO_PASSWORD }}
      QUAY_RHACS_ENG_RW_USERNAME: ${{ secrets.QUAY_RHACS_ENG_RW_USERNAME }}
      QUAY_RHACS_ENG_RW_PASSWORD: ${{ secrets.QUAY_RHACS_ENG_RW_PASSWORD }}
      QUAY_STACKROX_IO_RW_USERNAME: ${{ secrets.QUAY_STACKROX_IO_RW_USERNAME }}
      QUAY_STACKROX_IO_RW_PASSWORD: ${{ secrets.QUAY_STACKROX_IO_RW_PASSWORD }}
    steps:
    - name: Setup build env
      run: |
        case "${{ matrix.name }}" in
          STACKROX_BRANDING)
            brand="STACKROX_BRANDING"
            ;;
          RHACS_BRANDING)
            brand="RHACS_BRANDING"
            ;;
          race-condition-debug)
            brand="RHACS_BRANDING"
            ;;
          prerelease)
            brand="RHACS_BRANDING"
            ;;
          *)
            echo "Unsupported build: ${{ matrix.name }}"
            exit 1
        esac

        {
          echo "ROX_PRODUCT_BRANDING=${brand}"
        } >> "$GITHUB_ENV"

    - name: Checkout
      uses: actions/checkout@v6
      with:
        fetch-depth: 0
        ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

    - uses: ./.github/actions/job-preamble
      with:
        gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

    - name: Checkout submodules
      run: |
        git submodule update --init

    - uses: ./.github/actions/handle-tagged-build

    - name: Set build tag for prerelease images
      if: matrix.name == 'prerelease'
      run: echo "BUILD_TAG=$(make --quiet --no-print-directory tag)-prerelease" >> "$GITHUB_ENV"

    - name: Set build tag for race condition images
      if: matrix.name == 'race-condition-debug'
      run: echo "BUILD_TAG=$(make --quiet --no-print-directory tag)-rcd" >> "$GITHUB_ENV"

    - name: Build and push manifest lists
      # Skip for external contributions.
      if: |
        github.event_name == 'push' || !github.event.pull_request.head.repo.fork
      run: |
        source ./scripts/ci/lib.sh
        echo "Will determine context from: ${{ github.event_name }} & ${{ github.ref_name }}"
        push_context=""
        if [[ "${{ github.event_name }}" == "push" && "${{ github.ref_name }}" == "master" ]]; then
          push_context="merge-to-master"
        fi
        # Use architectures from matrix (computed in define-job-matrix based on PR labels)
        architectures="${{ matrix.archs }}"
        # race-condition-debug is always amd64 only
        if [[ "${{ matrix.name }}" == "race-condition-debug" ]]; then
          architectures="amd64"
        fi
        echo "Creating manifest for architectures: $architectures"
        push_image_manifest_lists "$push_context" "${{ env.ROX_PRODUCT_BRANDING }}" "$architectures"

    - name: Comment on the PR
      # Skip for external contributions.
      if: |
        github.event_name == 'push' || !github.event.pull_request.head.repo.fork
      env:
        GITHUB_TOKEN: "${{ secrets.RHACS_BOT_GITHUB_TOKEN }}"
      run: |
        set -x
        sha="${{ github.event.pull_request.head.sha }}"
        tag=$(make tag)
        gh pr comment "${{ github.event.number }}" --body - <<EOT
        Images are ready for the commit at ${sha}.

        To use with deploy scripts, first \`export MAIN_IMAGE_TAG=${tag}\`.
        EOT

  build-and-push-operator:
    runs-on: ubuntu-22.04
    needs:
      - define-job-matrix
      - pre-build-operator-bundle
    # Run even if pre-build-operator-bundle was skipped (e.g., fork PRs)
    if: ${{ !cancelled() }}
    env:
      QUAY_RHACS_ENG_RW_USERNAME: ${{ secrets.QUAY_RHACS_ENG_RW_USERNAME }}
      QUAY_RHACS_ENG_RW_PASSWORD: ${{ secrets.QUAY_RHACS_ENG_RW_PASSWORD }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.define-job-matrix.outputs.matrix).build_and_push_operator }}
    steps:
      - name: Collect Workflow Telemetry
        uses: catchpoint/workflow-telemetry-action@v2
        with:
          theme: dark
          comment_on_pr: false
          job_summary: true
          metric_frequency: 5
          proc_trace_sys_enable: false
          proc_trace_chart_max_count: 100

      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

      - uses: ./.github/actions/job-preamble
        with:
          gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: false

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Go dependencies
        env:
          GOARCH: ${{ matrix.arch }}
        uses: ./.github/actions/cache-go-dependencies

      - uses: ./.github/actions/handle-tagged-build

      - name: PR labels
        uses: joerick/pr-labels-action@v1.0.9

      - name: Setup Go build environment
        if: contains(github.event.pull_request.labels.*.name, 'ci-release-build')
        run: echo "GOTAGS=release" >> "$GITHUB_ENV"

      - name: Setup build env
        run: |
          case "${{ matrix.name }}" in
            RHACS_BRANDING)
              brand="RHACS_BRANDING"
              registry="quay.io/rhacs-eng"
              ;;
            STACKROX_BRANDING)
              brand="STACKROX_BRANDING"
              registry="quay.io/stackrox-io"
              ;;
            *)
              echo "Unsupported build: ${{ matrix.name }}"
              exit 1
          esac

          {
            echo "ROX_PRODUCT_BRANDING=${brand}"
            echo "OPERATOR_REGISTRY=${registry}"
          } >> "$GITHUB_ENV"

      - name: Docker login
        # Skip for external contributions.
        if: |
          github.event_name == 'push' || !github.event.pull_request.head.repo.fork
        run: |
          ./scripts/ci/lib.sh registry_rw_login "${{ env.OPERATOR_REGISTRY }}"

      - name: Capture operator tag
        # Capture the tag before any build steps that might modify files,
        # causing git describe --dirty to return a different tag.
        # Pass this VERSION to all make commands to ensure consistency.
        run: |
          OPERATOR_TAG="$(make --quiet --no-print-directory -C operator tag)"
          echo "OPERATOR_TAG=${OPERATOR_TAG}" >> "$GITHUB_ENV"
          echo "Captured operator tag: ${OPERATOR_TAG}"

      - name: Cache operator tools
        id: cache-operator-tools
        uses: actions/cache@v4
        with:
          path: operator/.gotools
          key: operator-tools-${{ runner.os }}-${{ matrix.arch }}-${{ hashFiles('operator/tools/*/go.sum') }}
          restore-keys: |
            operator-tools-${{ runner.os }}-${{ matrix.arch }}-

      - name: Generate operator manifests
        run: |
          # Generate CRDs and code (needed for Docker build)
          make -C operator/ VERSION="${{ env.OPERATOR_TAG }}" manifests generate

      - name: Login to ghcr.io for Docker layer caching
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Setup operator Docker cache args
        run: |
          cache_registry='ghcr.io'
          cache_image="${GITHUB_REPOSITORY,,}"
          cache_tag="operator-${{ matrix.arch }}-master-${ROX_PRODUCT_BRANDING,,}"

          # Build cache-from args: always pull from master cache
          cache_args="--cache-from type=registry,ref=${cache_registry}/${cache_image}:${cache_tag}"

          # Only write cache on master branch pushes to avoid PR cache pollution
          # and reduce build time (cache-to adds upload overhead)
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" ]]; then
            cache_args="${cache_args} --cache-to type=registry,ref=${cache_registry}/${cache_image}:${cache_tag},mode=max,ignore-error=true"
            echo "Docker cache: read/write (master push)"
          else
            echo "Docker cache: read-only (PR or non-master)"
          fi

          echo "OPERATOR_DOCKER_CACHE_ARGS=${cache_args}" >> "$GITHUB_ENV"

      - name: Build Operator Docker image
        run: |
          # Generate Dockerfile and status.sh
          make -C operator/ VERSION="${{ env.OPERATOR_TAG }}" build/Dockerfile.gen smuggled-status-sh

          # Build with buildx and registry caching
          docker buildx build \
            --load \
            -t "${{ env.OPERATOR_REGISTRY }}/stackrox-operator:${{ env.OPERATOR_TAG }}" \
            --build-arg TARGET_ARCH=${{ matrix.arch }} \
            ${{ env.OPERATOR_DOCKER_CACHE_ARGS }} \
            -f operator/build/Dockerfile.gen \
            .

      - name: Set up QEMU
        if: matrix.arch != 'amd64'
        uses: docker/setup-qemu-action@v3

      - name: Check that Operator image is runnable
        run: docker run --rm --platform linux/${{ matrix.arch }} "${{ env.OPERATOR_REGISTRY }}/stackrox-operator:${{ env.OPERATOR_TAG }}" --help

      - name: Push image
        # Skip for external contributions.
        if: |
          github.event_name == 'push' || !github.event.pull_request.head.repo.fork
        env:
          VERSION: ${{ env.OPERATOR_TAG }}
        run: |
            source ./scripts/ci/lib.sh
            echo "Will determine context from: ${{ github.event_name }} & ${{ github.ref_name }}"
            push_context=""
            if [[ "${{ github.event_name }}" == "push" && "${{ github.ref_name }}" == "master" ]]; then
              push_context="merge-to-master"
            fi
            echo "Starting operator image push for context: \"$push_context\", branding: \"${{ env.ROX_PRODUCT_BRANDING }}\", arch: \"${{ matrix.arch }}\", version: \"${VERSION}\""
            if ! push_operator_image "$push_context" "${{ env.ROX_PRODUCT_BRANDING }}" "${{ matrix.arch }}"; then
              echo "ERROR: push_operator_image failed" >&2
              exit 1
            fi
            echo "Operator image push completed successfully"

      # Bundle for RHACS_BRANDING is pushed by pre-build-operator-bundle job
      # For STACKROX_BRANDING, build and push bundle here (rare case, only non-PRs or with label)
      - name: Build and push bundle (STACKROX_BRANDING only)
        if: |
          matrix.name == 'STACKROX_BRANDING' && matrix.arch == 'amd64' && (github.event_name == 'push' || !github.event.pull_request.head.repo.fork)
        run: |
          make -C operator/ VERSION="${{ env.OPERATOR_TAG }}" bundle-ci bundle-build-ci
          make -C operator/ VERSION="${{ env.OPERATOR_TAG }}" docker-push-bundle | cat

      # Index image only needs to be built once per branding (bundle is arch-independent)
      - name: Build and push index
        # Skip for external contributions and only run on amd64 (bundle is arch-independent)
        if: |
          matrix.arch == 'amd64' && (github.event_name == 'push' || !github.event.pull_request.head.repo.fork)
        run: |
          make -C operator/ VERSION="${{ env.OPERATOR_TAG }}" index-build
          make -C operator/ VERSION="${{ env.OPERATOR_TAG }}" docker-push-index | cat

  push-operator-manifests:
    runs-on: ubuntu-latest
    needs:
    - define-job-matrix
    - build-and-push-operator
    # This step will run even if some of the build-and-push-matrix steps failed.
    # By following this approach as much of the build matrix as possible is
    # completed despite transient issues e.g. docker pull timeouts. In this way
    # some e2e jobs that require some part of the build matrix can still
    # proceed.
    if: ${{ !cancelled() }}
    strategy:
      # Supports image builds (see Setup build env):
      # RHACS_BRANDING
      fail-fast: false
      matrix: ${{ fromJson(needs.define-job-matrix.outputs.matrix).push_operator_multiarch_manifests }}
    env:
      ROX_PRODUCT_BRANDING: ""
    container:
      image: quay.io/stackrox-io/apollo-ci:stackrox-test-0.5.1
      env:
        QUAY_RHACS_ENG_RO_USERNAME: ${{ secrets.QUAY_RHACS_ENG_RO_USERNAME }}
        QUAY_RHACS_ENG_RO_PASSWORD: ${{ secrets.QUAY_RHACS_ENG_RO_PASSWORD }}
        QUAY_RHACS_ENG_RW_USERNAME: ${{ secrets.QUAY_RHACS_ENG_RW_USERNAME }}
        QUAY_RHACS_ENG_RW_PASSWORD: ${{ secrets.QUAY_RHACS_ENG_RW_PASSWORD }}
    steps:
    - name: Setup build env
      run: |
        case "${{ matrix.name }}" in
          RHACS_BRANDING)
            brand="RHACS_BRANDING"
            ;;
          *)
            echo "Unsupported build: ${{ matrix.name }}"
            exit 1
        esac

        {
          echo "ROX_PRODUCT_BRANDING=${brand}"
        } >> "$GITHUB_ENV"

    - name: Checkout
      uses: actions/checkout@v6
      with:
        fetch-depth: 0
        ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

    - uses: ./.github/actions/job-preamble
      with:
        gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

    - uses: ./.github/actions/handle-tagged-build

    - name: Push operator manifest lists
      # Skip for external contributions.
      if: |
        github.event_name == 'push' || !github.event.pull_request.head.repo.fork
      run: |
        source ./scripts/ci/lib.sh
        echo "Will determine context from: ${{ github.event_name }} & ${{ github.ref_name }}"
        push_context=""
        if [[ "${{ github.event_name }}" == "push" && "${{ github.ref_name }}" == "master" ]]; then
          push_context="merge-to-master"
        fi
        push_operator_manifest_lists "$push_context" "${{ env.ROX_PRODUCT_BRANDING }}" ${{ matrix.archs }}

  scan-go-binaries:
    if: |
      contains(github.event.pull_request.labels.*.name, 'scan-go-binaries')
    env:
      ARTIFACT_DIR: junit-reports/
    runs-on: ubuntu-latest
    needs:
    - pre-build-cli-merge
    - pre-build-go-binaries-merge
    steps:
    - name: Checkout
      uses: actions/checkout@v6
      with:
        fetch-depth: 1
        ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

    - uses: ./.github/actions/job-preamble
      with:
        gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

    - uses: ./.github/actions/download-artifact-with-retry
      with:
        name: cli-build

    - name: Unpack cli build
      run: |
        tar xvzf cli-build.tgz

    - uses: ./.github/actions/download-artifact-with-retry
      with:
        name: go-binaries-build-amd64-default

    - name: Unpack Go binaries build
      run: |
        tar xvzf go-binaries-build.tgz

    - name: Scan
      run: |
        ./scripts/ci/govulncheck.sh

    - name: Publish Test Report
      uses: test-summary/action@v2
      if: always()
      with:
        paths: 'junit-reports/**/*.xml'

    - name: Report junit failures in jira
      uses: ./.github/actions/junit2jira
      if: always()
      with:
        jira-token: ${{ secrets.JIRA_TOKEN }}
        gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}
        directory: 'junit-reports'

  scan-images-with-roxctl:
    if: github.event_name == 'push' ||
      contains(github.event.pull_request.labels.*.name, 'scan-images-with-roxctl')
    needs:
      - define-job-matrix
      - build-and-push-main
      - build-and-push-operator
      - push-main-manifests
    name: Check images for vulnerabilities
    runs-on: ubuntu-latest
    permissions:
      # Needed for stackrox/central-login to create the JWT token.
      id-token: write
      security-events: write
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.define-job-matrix.outputs.matrix).scan_images_with_roxctl }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ inputs.commit || github.event.pull_request.head.sha }}

      - uses: ./.github/actions/job-preamble
        with:
          gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

      - uses: ./.github/actions/handle-tagged-build

      - name: Central login
        uses: stackrox/central-login@v1
        with:
          endpoint: ${{ vars.ACS_DOGFOODING_CENTRAL_URL }}

      - name: Install roxctl
        uses: stackrox/roxctl-installer-action@v1
        with:
          central-endpoint: ${{ vars.ACS_DOGFOODING_CENTRAL_URL }}
          central-token: ${{ env.ROX_API_TOKEN }}

      - name: Scan images for vulnerabilities
        run: |
          release_tag="$(make --quiet --no-print-directory tag)"
          if [[ "${{ matrix.image }}" =~ "operator" ]]; then
            release_tag="$(make -C operator --quiet --no-print-directory tag)"
          fi

          registry="$(./scripts/ci/lib.sh registry_from_branding "${{ matrix.name }}")"

          roxctl image scan --retries=10 --retry-delay=15 --force --severity=CRITICAL,IMPORTANT --output=sarif \
            --image="${registry}/${{ matrix.image }}:${release_tag}" \
            | tee results.sarif

      # TODO: re-enable roxctl scan results upload once quota issue has been resolved
      # - name: Upload roxctl scan results to GitHub Security tab
      #   uses: github/codeql-action/upload-sarif@v3
      #   with:
      #     category: ${{ matrix.image }}
      #     sarif_file: results.sarif

  slack-on-build-failure:
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      SLACK_CI_INTEGRATION_TESTING_WEBHOOK: ${{ secrets.SLACK_CI_INTEGRATION_TESTING_WEBHOOK }}
      TEST_FAILURES_NOTIFY_WEBHOOK: ${{ secrets.TEST_FAILURES_NOTIFY_WEBHOOK }}
    if: |
      failure() && (
          github.event_name == 'push' ||
          contains(github.event.pull_request.labels.*.name, 'ci-test-github-action-slack-messages')
      )
    name: Post failure message to Slack
    runs-on: ubuntu-latest
    needs:
      - pre-build-ui
      - pre-build-cli-merge
      - pre-build-go-binaries-merge
      - pre-build-docs
      - build-and-push-main
      - build-and-push-operator
      - scan-images-with-roxctl
      - scan-go-binaries
    permissions:
      actions: read
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Slack message
        env:
          GITHUB_CONTEXT: ${{ toJSON(github) }}
        run: |
          source scripts/ci/lib.sh
          slack_workflow_failure

  # =============================================================================
  # EXPERIMENTAL JOBS - Testing different build strategies
  # These run in parallel with the main build to compare performance
  # =============================================================================

  # Option A: Build Go inside Docker (multi-stage build with layer caching)
  experimental-go-in-docker:
    runs-on: ubuntu-22.04
    needs: define-job-matrix
    # Only run on PRs with the experimental label
    if: contains(github.event.pull_request.labels.*.name, 'ci-experiment-go-in-docker')
    steps:
      - name: Collect Workflow Telemetry
        uses: catchpoint/workflow-telemetry-action@v2
        with:
          theme: dark
          comment_on_pr: false
          job_summary: true
          metric_frequency: 5
          proc_trace_sys_enable: false
          proc_trace_chart_max_count: 100

      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - uses: ./.github/actions/job-preamble
        with:
          gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - uses: ./.github/actions/handle-tagged-build

      - name: Login to ghcr.io for Docker layer caching
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Build with Go-in-Docker (Option A)
        run: |
          echo "=== EXPERIMENTAL: Building Go inside Docker ==="
          echo "This approach uses Docker multi-stage builds with layer caching"
          echo "for Go compilation, eliminating the need for pre-build jobs."
          echo ""

          start_time=$(date +%s)

          # Build using the experimental Dockerfile
          docker buildx build \
            --load \
            --progress=plain \
            -t experimental-go-in-docker:test \
            --build-arg TARGET_ARCH=amd64 \
            --build-arg ROX_PRODUCT_BRANDING=RHACS_BRANDING \
            --build-arg ROX_IMAGE_FLAVOR=rhacs \
            --cache-from type=registry,ref=ghcr.io/${{ github.repository }}:experimental-go-in-docker-cache \
            --cache-to type=registry,ref=ghcr.io/${{ github.repository }}:experimental-go-in-docker-cache,mode=max,ignore-error=true \
            -f image/rhel/Dockerfile.go-in-docker \
            .

          end_time=$(date +%s)
          echo ""
          echo "=== TIMING RESULTS ==="
          echo "Total build time: $((end_time - start_time)) seconds"

      - name: Verify image
        run: |
          docker run --rm experimental-go-in-docker:test version || true

  # Option B: Build Go in same job (no pre-build, no artifacts)
  experimental-go-same-job:
    runs-on: ubuntu-22.04
    needs:
      - define-job-matrix
      - pre-build-ui  # Still need UI
      - pre-build-docs  # Still need docs
    # Only run on PRs with the experimental label
    if: contains(github.event.pull_request.labels.*.name, 'ci-experiment-go-same-job')
    steps:
      - name: Collect Workflow Telemetry
        uses: catchpoint/workflow-telemetry-action@v2
        with:
          theme: dark
          comment_on_pr: false
          job_summary: true
          metric_frequency: 5
          proc_trace_sys_enable: false
          proc_trace_chart_max_count: 100

      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - uses: ./.github/actions/job-preamble
        with:
          gcp-account: ${{ secrets.GCP_SERVICE_ACCOUNT_STACKROX_CI }}

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: false

      - name: Cache Go dependencies
        uses: ./.github/actions/cache-go-dependencies

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - uses: ./.github/actions/handle-tagged-build

      - name: Download UI artifact
        uses: actions/download-artifact@v4
        with:
          name: ui-build-RHACS_BRANDING

      - name: Download docs artifact
        uses: actions/download-artifact@v4
        with:
          name: docs-build

      - name: Extract UI
        run: |
          mkdir -p image/rhel/ui
          tar xzf ui-build.tgz -C image/rhel/ui

      - name: Login to ghcr.io for Docker layer caching
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Build Go and Docker (Option B)
        run: |
          echo "=== EXPERIMENTAL: Building Go in same job ==="
          echo "This approach builds Go binaries directly in this job,"
          echo "eliminating artifact upload/download overhead."
          echo ""

          go_start=$(date +%s)

          # Build Go binaries with timing
          echo "--- Building Go binaries ---"
          make main-build

          go_end=$(date +%s)
          echo "Go build time: $((go_end - go_start)) seconds"
          echo ""

          docker_start=$(date +%s)

          # Prepare image context
          make -C image/rhel copy-binaries

          # Build Docker image
          echo "--- Building Docker image ---"
          docker buildx build \
            --load \
            --progress=plain \
            -t experimental-go-same-job:test \
            --build-arg TARGET_ARCH=amd64 \
            --build-arg ROX_PRODUCT_BRANDING=RHACS_BRANDING \
            --build-arg ROX_IMAGE_FLAVOR=rhacs \
            --cache-from type=registry,ref=ghcr.io/${{ github.repository }}:main-amd64-master-rhacs_branding \
            -f image/rhel/Dockerfile \
            image/rhel

          docker_end=$(date +%s)
          echo ""
          echo "=== TIMING RESULTS ==="
          echo "Go build time: $((go_end - go_start)) seconds"
          echo "Docker build time: $((docker_end - docker_start)) seconds"
          echo "Total time: $((docker_end - go_start)) seconds"

      - name: Verify image
        run: |
          docker run --rm experimental-go-same-job:test version || true
