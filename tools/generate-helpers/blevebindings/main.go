package main

import (
	"fmt"
	"os"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
	"github.com/spf13/cobra"
	v1 "github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/pkg/utils"
	"github.com/stackrox/rox/tools/generate-helpers/blevebindings/operations"
	"github.com/stackrox/rox/tools/generate-helpers/blevebindings/packagenames"
)

const (
	headerComment = "Code generated by blevebindings generator. DO NOT EDIT."
)

func newFile() *jen.File {
	f := jen.NewFile("index")
	f.HeaderComment(headerComment)
	return f
}

func makeTag(object string) string {
	var split []string
	i := 0
	for s := object; s != ""; s = s[i:] {
		i = strings.IndexFunc(s[1:], unicode.IsUpper) + 1
		if i <= 0 {
			i = len(s)
		}
		split = append(split, strings.ToLower(s[:i]))
	}
	return strings.Join(split, "_")
}

func generateOptionsFile(props operations.GeneratorProperties) error {
	if !props.WriteOptions {
		return nil
	}
	tagString := makeTag(props.Object)
	f := jen.NewFile("mappings")
	f.HeaderComment(headerComment)
	f.Line()
	f.Var().Id("OptionsMap").Op("=").Qual(packagenames.RoxBleve, "Walk").Call(
		jen.Qual(packagenames.V1, props.SearchCategory),
		jen.Lit(tagString),
		jen.Parens(jen.Op("*").Qual(props.Pkg, props.Object)).Parens(jen.Nil()),
	)
	return f.Save("mappings/options.go")
}

func generateIndexImplementationFile(props operations.GeneratorProperties, implementations []jen.Code) error {
	wrapperClass := operations.MakeWrapperType(props.Object)
	tagString := makeTag(props.Object)
	if props.Tag != "" {
		tagString = props.Tag
	}
	f := newFile()
	f.ImportAlias(packagenames.Ops, "ops")
	f.Line()
	f.Const().Id("batchSize").Op("=").Lit(5000)
	f.Line()
	f.Type().Id("indexerImpl").Struct(jen.Id("index").Qual(packagenames.Bleve, "Index"))
	f.Line()
	f.Type().Id(wrapperClass).Struct(
		jen.Op("*").Qual(props.Pkg, props.Object).Tag(map[string]string{"json": tagString}),
		jen.Id("Type").String().Tag(map[string]string{"json": "type"}),
	)
	f.Line()

	for _, implementation := range implementations {
		f.Add(implementation)
		f.Line()
	}

	return f.Save("indexer_impl.go")
}

func generateIndexInterfaceFile(interfaceMethods []jen.Code) error {
	f := newFile()
	f.Type().Id("Indexer").Interface(interfaceMethods...)

	f.Func().Id("New").Params(jen.Id("index").Qual(packagenames.Bleve, "Index")).Id("Indexer").Block(
		jen.Return(jen.Op("&").Id("indexerImpl").Values(jen.Dict{
			jen.Id("index"): jen.Id("index"),
		})),
	)
	return f.Save("indexer.go")
}

func generate(props operations.GeneratorProperties) error {
	interfaceMethods, implementations := operations.GenerateInterfaceAndImplementation(props)

	if err := generateIndexInterfaceFile(interfaceMethods); err != nil {
		return err
	}
	if err := generateIndexImplementationFile(props, implementations); err != nil {
		return err
	}
	if err := generateOptionsFile(props); err != nil {
		return err
	}

	return nil
}

func renderSearchCategories() string {
	allCategories := make([]string, 0, len(v1.SearchCategory_value))

	for category := range v1.SearchCategory_value {
		allCategories = append(allCategories, category)
	}
	return strings.Join(allCategories, ",")
}

func checkSupported(searchCategory string) error {
	if _, ok := v1.SearchCategory_value[searchCategory]; !ok {
		return fmt.Errorf("search category %s is unsupported", searchCategory)
	}
	return nil
}

func main() {
	c := &cobra.Command{
		Use: "generate store implementations",
	}

	props := operations.GeneratorProperties{}
	c.Flags().StringVar(&props.Pkg, "package", "github.com/stackrox/rox/generated/storage", "the package of the object being indexed")

	c.Flags().StringVar(&props.Object, "object", "", "the (Go) name of the object being indexed")
	utils.Must(c.MarkFlagRequired("object"))

	c.Flags().StringVar(&props.Singular, "singular", "", "the singular name of the object")
	utils.Must(c.MarkFlagRequired("singular"))

	c.Flags().StringVar(&props.Plural, "plural", "", "the plural name of the object (optional; appends 's' to singular by default")

	c.Flags().StringVar(&props.IDFunc, "id-func", "GetId", "the method to invoke on the proto object to get an id out")

	c.Flags().StringVar(&props.SearchCategory, "search-category", "", fmt.Sprintf("the search category to index under (supported - %s)", renderSearchCategories()))
	utils.Must(c.MarkFlagRequired("search-category"))

	c.Flags().BoolVar(&props.WriteOptions, "write-options", true, "enable writing out the options map")
	c.Flags().StringVar(&props.OptionsPath, "options-path", packagenames.RoxMappingSubPath, "path to write out the options to")
	c.Flags().StringVar(&props.ObjectPathName, "object-path-name", "", "overwrite the object path underneath Central")
	c.Flags().StringVar(&props.Tag, "tag", "", "use the specified json tag")

	c.RunE = func(*cobra.Command, []string) error {
		if props.Plural == "" {
			props.Plural = fmt.Sprintf("%ss", props.Singular)
		}
		if err := checkSupported(props.SearchCategory); err != nil {
			return err
		}
		props.SearchCategory = fmt.Sprintf("SearchCategory_%s", props.SearchCategory)
		return generate(props)
	}

	if err := c.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
