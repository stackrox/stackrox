package main

import (
	_ "embed"
	"fmt"
	"log"
	"reflect"
	"strings"
	"text/template"
	"unicode"

	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/protoreflect"
	"github.com/stackrox/rox/pkg/set"
	"github.com/stackrox/rox/pkg/utils"
	"github.com/stackrox/rox/tools/generate-helpers/common"
)

// externalize this string because Github thinks that this file is autogenerated
const autogenerated = "// Code generated by config-as-code-helper generator. DO NOT EDIT.\n"

//go:embed policy.go.tpl
var templateFile string

type RenderRequestData struct {
	TypesToConvert []ConvertType
	TypeName       string
}

type ConvertType struct {
	Fields   []Field
	TypeName string
}

// Field represents a field in a struct with its corresponding Go and YAML tags
type Field struct {
	Name           string
	Type           string
	TrimmedType    string
	BaseType       string
	YamlTag        string
	IsStringer     bool
	IsTimestamp    bool
	IsSlice        bool
	NeedConversion bool
}

var customResourceTemplate = newTemplate(templateFile)

func main() {
	// DO NOT SUBMIT: fix callers to work with a pointer (go/goprotoapi-findings#message-value)
	typ := reflect.TypeOf(&storage.Policy{})
	renderData := RenderRequestData{
		TypeName:       "Policy",
		TypesToConvert: generateTemplateData(typ, set.NewStringSet()),
	}

	if err := common.RenderFile(renderData, customResourceTemplate, "policy.go"); err != nil {
		log.Panic(err)
		return
	}
	fmt.Println("policy.go file generated successfully.")
}

// Generate template data for a struct, including fields and stringer fields
func generateTemplateData(t reflect.Type, visited set.StringSet) []ConvertType {
	typeName := t.Name()
	visited.Add(typeName)

	var fields []Field
	needUpdate := false
	// Iterate over fields and collect information
	var conversionList []ConvertType
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		fieldName := field.Name
		// Skip internal fields
		if len(fieldName) == 0 || !unicode.IsUpper(rune(fieldName[0])) {
			continue
		}

		// Create YAML tag from field name
		yamlTag := field.Tag.Get("crYaml")
		if strings.HasPrefix(yamlTag, "-") {
			continue
		}

		fieldType := field.Type.String()
		isSlice := strings.HasPrefix(fieldType, "[]")
		isStringer := strings.Contains(yamlTag, ",stringer")
		if isStringer {
			yamlTag = strings.Replace(yamlTag, ",stringer", "", 1)
			fieldType = utils.IfThenElse(isSlice, "[]string", "string")
		}
		isTimeStamp := strings.Contains(yamlTag, ",timestamp")
		if isTimeStamp {
			yamlTag = strings.Replace(yamlTag, ",timestamp", "", 1)
			fieldType = utils.IfThenElse(isSlice, "[]string", "string")
		}

		needConversion := !isStringer && !isTimeStamp && checkForConversion(field)
		if needConversion {
			if !visited.Contains(field.Name) {
				newList := generateTemplateData(getBaseType(field.Type), visited)
				conversionList = append(conversionList, newList...)
				if len(newList) == 0 {
					needConversion = false
				}
			}
			needUpdate = true
		}
		// Add the field to the fields slice
		fields = append(fields, Field{
			Name:           fieldName,
			Type:           fieldType,
			TrimmedType:    strings.Replace(fieldType, "storage.", "", 1),
			BaseType:       getBaseType(field.Type).Name(),
			YamlTag:        yamlTag,
			IsStringer:     isStringer,
			IsTimestamp:    isTimeStamp,
			IsSlice:        isSlice,
			NeedConversion: needConversion,
		})
	}
	if needUpdate {
		conversionList = append(conversionList, ConvertType{
			Fields:   fields,
			TypeName: getBaseType(t).Name(),
		})
	}
	return conversionList
}

// Check if a field type requires conversion (based on protobuf message types or structs)
func checkForConversion(field reflect.StructField) bool {
	return protoreflect.IsProtoMessage(getBaseType(field.Type))
}

func getBaseType(fieldType reflect.Type) reflect.Type {
	baseType := fieldType
	for baseType.Kind() == reflect.Slice || baseType.Kind() == reflect.Map || baseType.Kind() == reflect.Ptr {
		baseType = baseType.Elem()
	}

	return baseType
}

func newTemplate(tpl string) func(name string) *template.Template {
	return func(name string) *template.Template {
		return template.Must(template.New(name).Option("missingkey=error").Parse(autogenerated + tpl))
	}
}
