package main

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"path"
	"strings"
	"text/template"
	"unicode"

	// Embed is used to import the template files
	_ "embed"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"github.com/stackrox/rox/pkg/migrations"
	"github.com/stackrox/rox/pkg/utils"
)

//go:embed migration.go.tpl
var migrationFile string

//go:embed migration_impl.go.tpl
var migrationImplFile string

//go:embed migration_test.go.tpl
var migrationTestFile string

//go:embed seq_num.go.tpl
var seqNumFile string

//go:embed gen.go.tpl
var postgresGenFile string

const (
	autogenerated = "// Code generated by make bootstrap_migration generator. DO NOT EDIT."

	registrationPrefix = "github.com/stackrox/rox/migrator/migrations"
)

var (
	migrationTemplate     = newTemplate(autogenerated + migrationFile)
	migrationImplTemplate = newTemplate(migrationImplFile)
	migrationTestTemplate = newTemplate(migrationTestFile)
	seqNumTemplate        = newTemplate(autogenerated + seqNumFile)
	postgresGenTemplate   = newTemplate(autogenerated + postgresGenFile)
)

func closeFile(file *os.File) {
	if err := file.Close(); err != nil {
		fmt.Fprintf(os.Stderr, "Error closing file %q\n", file.Name())
	}
}

func main() {
	c := &cobra.Command{
		Use: "bootstrap datastore migration",
	}
	var migrationName string
	c.Flags().StringVar(&migrationName, "description", "", "a sentence describing the migration")
	utils.Must(c.MarkFlagRequired("description"))
	var rootDirectory string
	c.Flags().StringVar(&rootDirectory, "root", "", "the root directory of the source tree")
	utils.Must(c.MarkFlagRequired("root"))
	var storeObject string
	c.Flags().StringVar(&storeObject, "storeObject", "", "the objects to migrate (comma separated)")

	c.RunE = func(*cobra.Command, []string) error {
		// check to see if we should build the stores
		var buildStores bool
		if storeObject != "" {
			buildStores = true
		}

		startVersion := migrations.CurrentDBVersionSeqNum()
		migrationDirName := getMigrationDirName(startVersion, migrationName)
		_ = migrationDirName

		templateMap := map[string]interface{}{
			"nextSeqNum":          startVersion + 1,
			"packageName":         getPackageName(startVersion),
			"startSequenceNumber": startVersion,
			"storeObject":         storeObject,
		}

		var err error
		// Create migration directory
		fullMigrationDirPath := path.Join(rootDirectory, "migrator", "migrations", migrationDirName)
		err = os.MkdirAll(fullMigrationDirPath, 0755)
		if err != nil {
			return err
		}
		// Write migration file
		migrationFilePath := path.Join(fullMigrationDirPath, "migration.go")
		err = renderFile(templateMap, migrationTemplate, migrationFilePath)
		if err != nil {
			return err
		}
		// Write migration impl file
		migrationImplFilePath := path.Join(fullMigrationDirPath, "migration_impl.go")
		err = renderFile(templateMap, migrationImplTemplate, migrationImplFilePath)
		if err != nil {
			return err
		}
		// Write migration test file
		migrationTestFilePath := path.Join(fullMigrationDirPath, "migration_test.go")
		err = renderFile(templateMap, migrationTestTemplate, migrationTestFilePath)
		if err != nil {
			return err
		}

		if buildStores {
			// Parse the store objects and create the necessary paths
			stores := strings.Split(storeObject, ",")
			for _, store := range stores {
				templateMap["storeObject"] = store

				// Strip off the storage part of the object for the directories
				rawObjects := strings.Split(store, ".")
				if len(rawObjects) != 2 {
					return errors.New("Store objects improperly formatted.")
				}
				// Create store directory
				storeMigrationDirPath := path.Join(fullMigrationDirPath, strings.ToLower(rawObjects[1]), "store")
				err = os.MkdirAll(storeMigrationDirPath, 0755)
				if err != nil {
					return err
				}

				// Write migration postgres gen file
				migrationGenFilePath := path.Join(storeMigrationDirPath, "gen.go")
				err = renderFile(templateMap, postgresGenTemplate, migrationGenFilePath)
				if err != nil {
					return err
				}
			}
		}

		// Overwrite seqence number file
		seqNumFilePath := path.Join(rootDirectory, "pkg", "migrations", "internal", "seq_num.go")
		err = renderFile(templateMap, seqNumTemplate, seqNumFilePath)
		if err != nil {
			return err
		}
		// Register migration
		registrationFilePath := path.Join(rootDirectory, "migrator", "runner", "all.go")
		err = registerMigration(registrationFilePath, migrationDirName)
		if err != nil {
			return err
		}

		return nil
	}
	if err := c.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func addWord(elems []string, builder *strings.Builder) []string {
	word := strings.ToLower(builder.String())
	if len(word) > 0 {
		elems = append(elems, word)
		builder.Reset()
	}
	return elems
}

func convertDescriptionToSuffix(description string) string {
	elems := make([]string, 0)
	var builder strings.Builder
	for _, r := range description {
		if unicode.IsLetter(r) || unicode.IsNumber(r) {
			builder.WriteRune(r)
		} else {
			elems = addWord(elems, &builder)
		}
	}
	elems = addWord(elems, &builder)
	return strings.Join(elems, "_")
}

func getPackageName(startVersion int) string {
	return fmt.Sprintf("m%dtom%d", startVersion, startVersion+1)
}

func getMigrationDirName(startVersion int, description string) string {
	suffix := convertDescriptionToSuffix(description)
	return fmt.Sprintf("m_%d_to_m_%d_%s", startVersion, startVersion+1, suffix)
}

func readRegistrationFileAndRegisterMigration(registrationFilePath string, migrationDirName string) ([]string, error) {
	newFileLines := make([]string, 0)
	readFile, err := os.Open(registrationFilePath)
	defer closeFile(readFile)
	if err != nil {
		return nil, err
	}
	fileScanner := bufio.NewScanner(readFile)
	isInImports := false
	registered := false
	hasAutoGenerated := false
	for fileScanner.Scan() {
		line := fileScanner.Text()
		if strings.HasPrefix(line, autogenerated) {
			hasAutoGenerated = true
		}
		if strings.HasPrefix(line, "import (") {
			isInImports = true
		}
		if isInImports && strings.HasPrefix(line, ")") {
			if !registered {
				registeredPath := path.Join(registrationPrefix, migrationDirName)
				newFileLines = append(newFileLines, fmt.Sprintf("\t_ %q", registeredPath))
				registered = true
			}
			isInImports = false
		}
		newFileLines = append(newFileLines, line)
	}
	if !hasAutoGenerated {
		newFileLines = append([]string{autogenerated}, newFileLines...)
	}
	if isInImports {
		return nil, errors.New("Bad registration file format: import section is not properly closed")
	}
	if !registered {
		return nil, errors.New("Failed to register migration")
	}
	return newFileLines, nil
}

func registerMigration(registrationFilePath string, migrationDirName string) error {
	newFileLines, err := readRegistrationFileAndRegisterMigration(registrationFilePath, migrationDirName)
	if err != nil {
		return err
	}
	// Write back
	writeFile, err := os.OpenFile(registrationFilePath, os.O_RDWR, 0644)
	defer closeFile(writeFile)
	if err != nil {
		return err
	}
	for _, line := range newFileLines {
		fmt.Fprintln(writeFile, line)
	}
	return nil
}

func renderFile(templateMap map[string]interface{}, temp func(s string) *template.Template, templateFileName string) error {
	buf := bytes.NewBuffer(nil)
	if err := temp(templateFileName).Execute(buf, templateMap); err != nil {
		return err
	}
	file := buf.Bytes()

	if err := os.WriteFile(templateFileName, file, 0644); err != nil {
		return err
	}
	return nil
}

func newTemplate(tpl string) func(name string) *template.Template {
	return func(name string) *template.Template {
		return template.Must(template.New(name).Option("missingkey=error").Parse(tpl))
	}
}
