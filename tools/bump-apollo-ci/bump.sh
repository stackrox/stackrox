#!/usr/bin/env bash
set -euo pipefail

GIT_REPO_TOP="$(git rev-parse --show-toplevel)"

pull_latest_master() {
    git fetch origin master
    git merge --ff-only origin/master
}

find_references() {
    git grep -n "apollo-ci" -- . || true
}

categorize_references() {
    local references="$1"
    local direct_refs=""
    local comment_refs=""

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        if echo "$line" | grep -qE ":[0-9]+:\s*#.*apollo-ci"; then
            comment_refs+="$line"$'\n'
        else
            direct_refs+="$line"$'\n'
        fi
    done <<< "$references"

    echo "$direct_refs"$'\x1E'"$comment_refs"
}

update_build_image_version() {
    local version="$1"
    echo "stackrox-build-$version" > "$GIT_REPO_TOP/BUILD_IMAGE_VERSION"
}

update_direct_references() {
    local version="$1"
    local files

    files=$(git grep -l "quay\.io/stackrox-io/apollo-ci:" -- . ':!tools/bump-apollo-ci/' || true)

    while IFS= read -r file; do
        [[ -z "$file" ]] && continue
        sed -i.bak -E "s|(quay\.io/stackrox-io/apollo-ci:stackrox-test-)[^ \"']+|\1$version|g" "$GIT_REPO_TOP/$file"
        sed -i.bak -E "s|(quay\.io/stackrox-io/apollo-ci:scanner-test-)[^ \"']+|\1$version|g" "$GIT_REPO_TOP/$file"
        sed -i.bak -E "s|(quay\.io/stackrox-io/apollo-ci:stackrox-ui-test-)[^ \"']+|\1$version|g" "$GIT_REPO_TOP/$file"
        rm -f "$GIT_REPO_TOP/$file.bak"
    done <<< "$files"
}

print_comment_references() {
    local comment_refs="$1"
    if [[ -n "$comment_refs" ]]; then
        echo ""
        echo "============================================================="
        echo "Files with apollo-ci in comments (not updated automatically):"
        echo "============================================================="
        echo "$comment_refs"
        echo ""
    fi
}

create_or_switch_branch() {
    local branch_name="$1"

    if git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
        echo "Switching to existing branch: $branch_name"
        git fetch origin "$branch_name"
        git checkout "$branch_name"
        git pull origin "$branch_name"
    else
        echo "Creating new branch: $branch_name"
        git checkout -b "$branch_name"
    fi
}

stage_and_commit() {
    local version="$1"
    git add -A

    if git diff --cached --quiet; then
        echo "No changes to commit"
        return
    fi

    git commit -m "chore: bump apollo-ci to $version

This change updates all apollo-ci image references to version $version.

Partially generated by AI."
}

get_pr_body() {
    local version="$1"
    cat <<EOF
This PR updates all apollo-ci image references to version $version.

## Description

Updated apollo-ci image references across:
- BUILD_IMAGE_VERSION
- GitHub workflow files
- OpenShift CI configuration
- Test scripts
- Scale test manifests

## User-facing documentation

- [x] CHANGELOG.md is updated **OR** update is not needed
- [x] documentation PR is created and is linked above **OR** is not needed

## Testing and quality

- [x] the change is production ready: the change is GA, or otherwise the functionality is gated by a feature flag
- [ ] CI results are inspected

### Automated testing

No new tests needed - infrastructure change only.

### How I validated my change

Image references are updated by a script.
CI will validate the new image works correctly.
EOF
}

push_and_create_pr() {
    local version="$1"
    local current_branch
    current_branch=$(git branch --show-current)

    git push -u origin "$current_branch"

    local existing_pr
    existing_pr=$(gh pr list --head "$current_branch" --json number,url --jq '.[0] | "\(.number)|\(.url)"' 2>/dev/null || true)

    if [[ -n "$existing_pr" ]] && [[ "$existing_pr" != "null|null" ]] && [[ "$existing_pr" != "|" ]]; then
        local pr_number="${existing_pr%%|*}"
        local pr_url="${existing_pr#*|}"

        echo "PR already exists: $pr_url"
        echo "Updating PR title and body to match new version..."

        gh pr edit "$pr_number" \
            --title "chore: bump apollo-ci to $version" \
            --body "$(get_pr_body "$version")"

        echo "Updated the existing PR with new commits, title, and body"
    else
        local pr_url
        pr_url=$(gh pr create \
            --draft \
            --base master \
            --title "chore: bump apollo-ci to $version" \
            --body "$(get_pr_body "$version")")

        echo "> Created PR: $pr_url"
    fi
}

main() {
    local dry_run=false
    local new_version=""
    local branch_name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --branch)
                branch_name="$2"
                shift 2
                ;;
            *)
                new_version="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$new_version" ]] || [[ -z "$branch_name" ]]; then
        echo "Usage: $0 [--dry-run] --branch <branch_name> <new_version>" >&2
        echo "" >&2
        echo "Examples:" >&2
        echo "  $0 --branch chore-bump-apollo-ci-0.4.10-12-g1234567890 0.4.10-12-g1234567890" >&2
        echo "  $0 --dry-run --branch chore-bump-apollo-ci-0.4.10-12-g1234567890 0.4.11" >&2
        exit 1
    fi

    cd "$GIT_REPO_TOP"

    pull_latest_master

    if [[ "$dry_run" == true ]]; then
        local all_refs
        all_refs=$(find_references)

        local categorized
        categorized=$(categorize_references "$all_refs")
        local direct_refs="${categorized%%$'\x1E'*}"
        local comment_refs="${categorized#*$'\x1E'}"

        update_build_image_version "$new_version"
        update_direct_references "$new_version"

        echo "> Dry-run mode: stopping before branch creation"
        echo "> Changes made but not committed. Review with: git diff"
        print_comment_references "$comment_refs"
        exit 0
    fi

    create_or_switch_branch "$branch_name"

    local all_refs
    all_refs=$(find_references)

    local categorized
    categorized=$(categorize_references "$all_refs")
    local direct_refs="${categorized%%$'\x1E'*}"
    local comment_refs="${categorized#*$'\x1E'}"

    update_build_image_version "$new_version"
    update_direct_references "$new_version"

    stage_and_commit "$new_version"
    push_and_create_pr "$new_version"

    print_comment_references "$comment_refs"
}

main "$@"
