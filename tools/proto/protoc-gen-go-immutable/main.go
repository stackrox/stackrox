package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_2023
		gen.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_2023
		gen.SupportedFeatures |= uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}

		return nil
	})
}

// generateFile generates an immutable interface file for the proto messages.
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Messages) == 0 {
		return
	}

	// Create output filename with _immutable.go suffix
	// e.g., "storage/cluster.proto" -> "storage/cluster_immutable.go"
	filename := file.GeneratedFilenamePrefix + "_immutable.go"

	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-immutable. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Build a set of messages defined in this file for lookup
	localMessages := make(map[string]bool)
	var collectMessages func([]*protogen.Message)
	collectMessages = func(messages []*protogen.Message) {
		for _, m := range messages {
			localMessages[m.GoIdent.GoName] = true
			collectMessages(m.Messages) // Recursively collect nested messages
		}
	}
	collectMessages(file.Messages)

	// Store local messages in the file for access during generation
	for _, m := range file.Messages {
		generateMessageInterface(g, m, localMessages)
	}
}

func generateMessageInterface(g *protogen.GeneratedFile, msg *protogen.Message, localMessages map[string]bool) {
	if msg.Desc.IsMapEntry() {
		return
	}

	messageName := msg.GoIdent.GoName
	interfaceName := "Immutable" + messageName

	g.P()
	g.P("// ", interfaceName, " is an immutable interface for ", messageName)
	g.P("type ", interfaceName, " interface {")

	// Generate getter methods for all fields
	for _, field := range msg.Fields {
		generateFieldGetter(g, field, localMessages)
	}

	// Add VT proto functions
	g.P("\t// VT proto functions")
	g.P("\tSizeVT() int")
	g.P("\tMarshalVT() ([]byte, error)")
	// CloneVT returns the concrete type, not the interface
	g.P("\tCloneVT() *", messageName)

	g.P("}")

	// Recursively generate interfaces for nested messages
	for _, nested := range msg.Messages {
		generateMessageInterface(g, nested, localMessages)
	}
}

func generateFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, localMessages map[string]bool) {
	fieldName := field.GoName
	methodName := "Get" + fieldName

	// Determine the return type
	returnType := getFieldType(g, field, localMessages)

	// Add comment if available
	if field.Comments.Leading != "" {
		lines := strings.Split(strings.TrimSpace(string(field.Comments.Leading)), "\n")
		for _, line := range lines {
			g.P("\t// ", strings.TrimSpace(line))
		}
	}

	g.P("\t", methodName, "() ", returnType)
}

func getFieldType(g *protogen.GeneratedFile, field *protogen.Field, localMessages map[string]bool) string {
	// Handle maps first (before checking repeated, as maps are also repeated)
	if field.Desc.IsMap() {
		// Map fields have a message type with exactly 2 fields: key and value
		keyField := field.Message.Fields[0]
		valueField := field.Message.Fields[1]
		keyType := goType(g, keyField, localMessages)
		valueType := goType(g, valueField, localMessages)
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
	}

	// Handle repeated fields
	if field.Desc.Cardinality() == protoreflect.Repeated {
		elemType := getElementType(g, field, localMessages)
		return "[]" + elemType
	}

	return getElementType(g, field, localMessages)
}

func getElementType(g *protogen.GeneratedFile, field *protogen.Field, localMessages map[string]bool) string {
	switch field.Desc.Kind() {
	case protoreflect.EnumKind:
		// Enums are in the same package
		return g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.MessageKind, protoreflect.GroupKind:
		messageIdent := field.Message.GoIdent
		// Only use Immutable interface if the message is defined in the current file
		if localMessages[messageIdent.GoName] {
			immutableIdent := protogen.GoIdent{
				GoName:       "Immutable" + messageIdent.GoName,
				GoImportPath: messageIdent.GoImportPath,
			}
			return g.QualifiedGoIdent(immutableIdent)
		}
		// For external messages, use pointer to concrete type
		return "*" + g.QualifiedGoIdent(messageIdent)
	default:
		return goType(g, field, localMessages)
	}
}

func goType(g *protogen.GeneratedFile, field *protogen.Field, localMessages map[string]bool) string {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.EnumKind:
		return g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		messageIdent := field.Message.GoIdent
		// Only use Immutable interface if the message is defined in the current file
		if localMessages[messageIdent.GoName] {
			immutableIdent := protogen.GoIdent{
				GoName:       "Immutable" + messageIdent.GoName,
				GoImportPath: messageIdent.GoImportPath,
			}
			return g.QualifiedGoIdent(immutableIdent)
		}
		// For external messages, use pointer to concrete type
		return "*" + g.QualifiedGoIdent(messageIdent)
	case protoreflect.GroupKind:
		messageIdent := field.Message.GoIdent
		// Only use Immutable interface if the message is defined in the current file
		if localMessages[messageIdent.GoName] {
			immutableIdent := protogen.GoIdent{
				GoName:       "Immutable" + messageIdent.GoName,
				GoImportPath: messageIdent.GoImportPath,
			}
			return g.QualifiedGoIdent(immutableIdent)
		}
		// For external messages, use pointer to concrete type
		return "*" + g.QualifiedGoIdent(messageIdent)
	default:
		return "interface{}"
	}
}
