package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_2023
		gen.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_2023
		gen.SupportedFeatures |= uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}

		return nil
	})
}

// generateFile generates an immutable interface file for the proto messages.
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Messages) == 0 {
		return
	}

	// Create output filename with _immutable.go suffix
	// e.g., "storage/cluster.proto" -> "storage/cluster_immutable.go"
	filename := file.GeneratedFilenamePrefix + "_immutable.go"

	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-immutable. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P("\t\"iter\"")
	g.P(")")
	g.P()

	// Build a set of messages defined in this file for lookup
	localMessages := make(map[string]bool)
	var collectMessages func([]*protogen.Message)
	collectMessages = func(messages []*protogen.Message) {
		for _, m := range messages {
			localMessages[m.GoIdent.GoName] = true
			collectMessages(m.Messages) // Recursively collect nested messages
		}
	}
	collectMessages(file.Messages)

	// Store local messages in the file for access during generation
	for _, m := range file.Messages {
		generateMessageInterface(g, m, localMessages)
	}
}

func generateMessageInterface(g *protogen.GeneratedFile, msg *protogen.Message, localMessages map[string]bool) {
	if msg.Desc.IsMapEntry() {
		return
	}

	messageName := msg.GoIdent.GoName
	interfaceName := "Immutable" + messageName

	g.P()
	g.P("// ", interfaceName, " is an immutable interface for ", messageName)
	g.P("type ", interfaceName, " interface {")

	// Generate getter methods for all fields
	for _, field := range msg.Fields {
		generateFieldGetter(g, field, localMessages)
	}

	// Add VT proto functions
	g.P("\t// VT proto functions")
	g.P("\tSizeVT() int")
	g.P("\tMarshalVT() ([]byte, error)")
	// CloneVT returns the concrete type, not the interface
	g.P("\tCloneVT() *", messageName)

	g.P("}")
	g.P()

	// Generate wrapper methods for slice/map conversions
	generateWrapperMethods(g, msg, localMessages)

	// Recursively generate interfaces for nested messages
	for _, nested := range msg.Messages {
		generateMessageInterface(g, nested, localMessages)
	}
}

func generateFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, localMessages map[string]bool) {
	fieldName := field.GoName

	// For non-primitive message types, use "GetImmutable" prefix
	// For primitive types and external messages, use regular "Get" prefix
	methodName := "Get" + fieldName
	iterMethodName := ""
	if isNonPrimitiveType(field, localMessages) {
		methodName = "GetImmutable" + fieldName
		// Add iterator method for slices and maps
		if field.Desc.Cardinality() == protoreflect.Repeated && !field.Desc.IsMap() {
			iterMethodName = fieldName + "Iter"
		} else if field.Desc.IsMap() {
			iterMethodName = fieldName + "Iter"
		}
	}

	// Determine the return type
	returnType := getFieldType(g, field, localMessages)

	// Add comment if available
	if field.Comments.Leading != "" {
		lines := strings.Split(strings.TrimSpace(string(field.Comments.Leading)), "\n")
		for _, line := range lines {
			g.P("\t// ", strings.TrimSpace(line))
		}
	}

	g.P("\t", methodName, "() ", returnType)

	// Add iterator method for slices
	if iterMethodName != "" && field.Desc.Cardinality() == protoreflect.Repeated && !field.Desc.IsMap() {
		messageIdent := field.Message.GoIdent
		immutableType := "Immutable" + messageIdent.GoName
		g.P("\t// ", iterMethodName, " returns an iterator over ", fieldName)
		g.P("\t", iterMethodName, "() iter.Seq[", immutableType, "]")
	}

	// Add iterator method for maps
	if iterMethodName != "" && field.Desc.IsMap() {
		keyField := field.Message.Fields[0]
		valueField := field.Message.Fields[1]
		keyType := goType(g, keyField, localMessages)
		valueType := goType(g, valueField, localMessages)
		g.P("\t// ", iterMethodName, " returns an iterator over ", fieldName)
		g.P("\t", iterMethodName, "() iter.Seq2[", keyType, ", ", valueType, "]")
	}
}

func isNonPrimitiveType(field *protogen.Field, localMessages map[string]bool) bool {
	// Check if this is a message type that's defined locally
	if field.Desc.Kind() == protoreflect.MessageKind {
		return localMessages[field.Message.GoIdent.GoName]
	}
	return false
}

func getFieldType(g *protogen.GeneratedFile, field *protogen.Field, localMessages map[string]bool) string {
	// Handle maps first (before checking repeated, as maps are also repeated)
	if field.Desc.IsMap() {
		// Map fields have a message type with exactly 2 fields: key and value
		keyField := field.Message.Fields[0]
		valueField := field.Message.Fields[1]
		keyType := goType(g, keyField, localMessages)
		valueType := goType(g, valueField, localMessages)
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
	}

	// Handle repeated fields
	if field.Desc.Cardinality() == protoreflect.Repeated {
		elemType := getElementType(g, field, localMessages)
		return "[]" + elemType
	}

	return getElementType(g, field, localMessages)
}

func getElementType(g *protogen.GeneratedFile, field *protogen.Field, localMessages map[string]bool) string {
	switch field.Desc.Kind() {
	case protoreflect.EnumKind:
		// Enums are in the same package
		return g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.MessageKind, protoreflect.GroupKind:
		messageIdent := field.Message.GoIdent
		// Only use Immutable interface if the message is defined in the current file
		if localMessages[messageIdent.GoName] {
			immutableIdent := protogen.GoIdent{
				GoName:       "Immutable" + messageIdent.GoName,
				GoImportPath: messageIdent.GoImportPath,
			}
			return g.QualifiedGoIdent(immutableIdent)
		}
		// For external messages, use pointer to concrete type
		return "*" + g.QualifiedGoIdent(messageIdent)
	default:
		return goType(g, field, localMessages)
	}
}

func goType(g *protogen.GeneratedFile, field *protogen.Field, localMessages map[string]bool) string {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.EnumKind:
		return g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		messageIdent := field.Message.GoIdent
		// Only use Immutable interface if the message is defined in the current file
		if localMessages[messageIdent.GoName] {
			immutableIdent := protogen.GoIdent{
				GoName:       "Immutable" + messageIdent.GoName,
				GoImportPath: messageIdent.GoImportPath,
			}
			return g.QualifiedGoIdent(immutableIdent)
		}
		// For external messages, use pointer to concrete type
		return "*" + g.QualifiedGoIdent(messageIdent)
	case protoreflect.GroupKind:
		messageIdent := field.Message.GoIdent
		// Only use Immutable interface if the message is defined in the current file
		if localMessages[messageIdent.GoName] {
			immutableIdent := protogen.GoIdent{
				GoName:       "Immutable" + messageIdent.GoName,
				GoImportPath: messageIdent.GoImportPath,
			}
			return g.QualifiedGoIdent(immutableIdent)
		}
		// For external messages, use pointer to concrete type
		return "*" + g.QualifiedGoIdent(messageIdent)
	default:
		return "interface{}"
	}
}

func generateWrapperMethods(g *protogen.GeneratedFile, msg *protogen.Message, localMessages map[string]bool) {
	messageName := msg.GoIdent.GoName

	// Generate implementation methods for all fields
	for _, field := range msg.Fields {
		generateImplementationMethod(g, msg, field, localMessages)
	}

	// Add type assertion to verify implementation
	interfaceName := "Immutable" + messageName
	g.P()
	g.P("// Verify that ", messageName, " implements ", interfaceName)
	g.P("var _ ", interfaceName, " = (*", messageName, ")(nil)")
}

func generateImplementationMethod(g *protogen.GeneratedFile, msg *protogen.Message, field *protogen.Field, localMessages map[string]bool) {
	messageName := msg.GoIdent.GoName
	fieldName := field.GoName

	// Only generate implementation for non-primitive local message types
	if !isNonPrimitiveType(field, localMessages) {
		return
	}

	// Use "GetImmutable" prefix for non-primitive types
	methodName := "GetImmutable" + fieldName
	returnType := getFieldType(g, field, localMessages)

	g.P()
	g.P("// ", methodName, " implements Immutable", messageName)
	g.P("func (m *", messageName, ") ", methodName, "() ", returnType, " {")

	if field.Desc.Cardinality() == protoreflect.Repeated && !field.Desc.IsMap() {
		// Convert slice
		g.P("\tif m == nil || m.", fieldName, " == nil {")
		g.P("\t\treturn nil")
		g.P("\t}")
		g.P("\tresult := make(", returnType, ", len(m.", fieldName, "))")
		g.P("\tfor i, v := range m.", fieldName, " {")
		g.P("\t\tresult[i] = v")
		g.P("\t}")
		g.P("\treturn result")
		g.P("}")

		// Generate iterator method for slice
		iterMethodName := fieldName + "Iter"
		messageIdent := field.Message.GoIdent
		immutableType := "Immutable" + messageIdent.GoName

		g.P()
		g.P("// ", iterMethodName, " implements Immutable", messageName, " iterator")
		g.P("func (m *", messageName, ") ", iterMethodName, "() iter.Seq[", immutableType, "] {")
		g.P("\treturn func(yield func(", immutableType, ") bool) {")
		g.P("\t\tif m == nil || m.", fieldName, " == nil {")
		g.P("\t\t\treturn")
		g.P("\t\t}")
		g.P("\t\tfor _, v := range m.", fieldName, " {")
		g.P("\t\t\tif !yield(v) {")
		g.P("\t\t\t\treturn")
		g.P("\t\t\t}")
		g.P("\t\t}")
		g.P("\t}")
		g.P("}")
	} else if field.Desc.IsMap() {
		// Map field - generate iterator
		keyField := field.Message.Fields[0]
		valueField := field.Message.Fields[1]
		keyType := goType(g, keyField, localMessages)
		valueType := goType(g, valueField, localMessages)
		iterMethodName := fieldName + "Iter"

		g.P("\treturn m.Get", fieldName, "()")
		g.P("}")

		g.P()
		g.P("// ", iterMethodName, " implements Immutable", messageName, " iterator")
		g.P("func (m *", messageName, ") ", iterMethodName, "() iter.Seq2[", keyType, ", ", valueType, "] {")
		g.P("\treturn func(yield func(", keyType, ", ", valueType, ") bool) {")
		g.P("\t\tif m == nil || m.", fieldName, " == nil {")
		g.P("\t\t\treturn")
		g.P("\t\t}")
		g.P("\t\tfor k, v := range m.", fieldName, " {")
		g.P("\t\t\tif !yield(k, v) {")
		g.P("\t\t\t\treturn")
		g.P("\t\t\t}")
		g.P("\t\t}")
		g.P("\t}")
		g.P("}")
	} else {
		// Return singular field
		g.P("\treturn m.Get", fieldName, "()")
		g.P("}")
	}
}
