package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_PROTO3
		gen.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_PROTO3
		gen.SupportedFeatures |= uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
		gen.SupportedFeatures |= uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}

		return nil
	})
}

// generateFile generates an immutable interface file for the proto messages.
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Messages) == 0 {
		return
	}

	// Create output filename with _immutable.go suffix
	// e.g., "storage/cluster.proto" -> "storage/cluster_immutable.go"
	filename := file.GeneratedFilenamePrefix + "_immutable.pb.go"

	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-immutable. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Check if we need time and iter imports by scanning all fields
	needsTime := false
	needsIter := false
	var checkMessages func([]*protogen.Message)
	checkMessages = func(messages []*protogen.Message) {
		for _, m := range messages {
			for _, field := range m.Fields {
				// Check for well-known types that need time package
				if field.Desc.Kind() == protoreflect.MessageKind {
					fullName := string(field.Message.Desc.FullName())
					if fullName == "google.protobuf.Timestamp" || fullName == "google.protobuf.Duration" {
						needsTime = true
					}
				}
				// Check if we need iter package (for slices and maps)
				if field.Desc.Cardinality() == protoreflect.Repeated || field.Desc.IsMap() {
					needsIter = true
				}
			}
			checkMessages(m.Messages)
		}
	}
	checkMessages(file.Messages)

	// Only add imports block if we need any imports
	if needsIter || needsTime {
		g.P("import (")
		if needsIter {
			g.P("\t\"iter\"")
		}
		if needsTime {
			g.P("\t\"time\"")
		}
		g.P(")")
		g.P()
	}

	// Build a set of messages defined in this file for lookup
	localMessages := make(map[string]bool)
	var collectMessages func([]*protogen.Message)
	collectMessages = func(messages []*protogen.Message) {
		for _, m := range messages {
			localMessages[m.GoIdent.GoName] = true
			collectMessages(m.Messages) // Recursively collect nested messages
		}
	}
	collectMessages(file.Messages)

	// Store local messages in the file for access during generation
	for _, m := range file.Messages {
		generateMessageInterface(g, m, localMessages, file.GoImportPath)
	}
}

func generateMessageInterface(g *protogen.GeneratedFile, msg *protogen.Message, localMessages map[string]bool, currentPackage protogen.GoImportPath) {
	if msg.Desc.IsMapEntry() {
		return
	}

	messageName := msg.GoIdent.GoName
	interfaceName := "Immutable" + messageName

	g.P()
	g.P("// ", interfaceName, " is an immutable interface for ", messageName)
	g.P("type ", interfaceName, " interface {")

	// Generate getter methods for all fields
	for _, field := range msg.Fields {
		generateFieldGetter(g, field, localMessages, currentPackage)
	}

	// Add VT proto functions
	g.P("\t// VT proto functions")
	g.P("\tSizeVT() int")
	g.P("\tMarshalVT() ([]byte, error)")
	// CloneVT returns the concrete type, not the interface
	g.P("\tCloneVT() *", messageName)

	g.P("}")
	g.P()

	// Generate wrapper methods for slice/map conversions
	generateWrapperMethods(g, msg, localMessages, currentPackage)

	// Recursively generate interfaces for nested messages
	for _, nested := range msg.Messages {
		generateMessageInterface(g, nested, localMessages, currentPackage)
	}
}

func generateFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, localMessages map[string]bool, currentPackage protogen.GoImportPath) {
	fieldName := field.GoName

	// Add comment if available
	if field.Comments.Leading != "" {
		lines := strings.Split(strings.TrimSpace(string(field.Comments.Leading)), "\n")
		for _, line := range lines {
			g.P("\t// ", strings.TrimSpace(line))
		}
	}

	// ALL slices and maps use GetImmutable* with iterators (to prevent modification)
	isRepeated := field.Desc.Cardinality() == protoreflect.Repeated
	isMap := field.Desc.IsMap()

	if isRepeated || isMap {
		methodName := "GetImmutable" + fieldName

		if isMap {
			// Map - return iter.Seq2
			keyField := field.Message.Fields[0]
			valueField := field.Message.Fields[1]
			keyType := getIteratorElementType(g, keyField, localMessages, currentPackage)
			valueType := getIteratorElementType(g, valueField, localMessages, currentPackage)
			g.P("\t", methodName, "() iter.Seq2[", keyType, ", ", valueType, "]")
		} else {
			// Slice - return iter.Seq
			elemType := getIteratorElementType(g, field, localMessages, currentPackage)
			g.P("\t", methodName, "() iter.Seq[", elemType, "]")
		}
		return
	}

	// For singular fields, check what type to return

	// Well-known types convert to stdlib
	if wktType, ok := isWellKnownType(field); ok {
		methodName := "GetImmutable" + fieldName
		g.P("\t", methodName, "() ", wktType)
		return
	}

	// Local message types use Immutable interface
	if isNonPrimitiveType(field, localMessages) {
		methodName := "GetImmutable" + fieldName
		returnType := getFieldType(g, field, localMessages, currentPackage)
		g.P("\t", methodName, "() ", returnType)
		return
	}

	// Same-package external messages use Immutable interface
	if isSamePackageMessage(field, currentPackage) {
		methodName := "GetImmutable" + fieldName
		messageIdent := field.Message.GoIdent
		immutableType := "Immutable" + messageIdent.GoName
		g.P("\t", methodName, "() ", immutableType)
		return
	}

	// Primitive types and cross-package external messages use regular "Get" prefix
	methodName := "Get" + fieldName
	returnType := getFieldType(g, field, localMessages, currentPackage)
	g.P("\t", methodName, "() ", returnType)
}

func getIteratorElementType(g *protogen.GeneratedFile, field *protogen.Field, localMessages map[string]bool, currentPackage protogen.GoImportPath) string {
	// Check for well-known types first
	if wktType, ok := isWellKnownType(field); ok {
		return wktType
	}

	// Check if it's a message type
	if field.Desc.Kind() == protoreflect.MessageKind {
		messageIdent := field.Message.GoIdent

		// Local message - use Immutable interface
		if localMessages[messageIdent.GoName] {
			return "Immutable" + messageIdent.GoName
		}

		// Same-package message - use Immutable interface
		if messageIdent.GoImportPath == currentPackage {
			return "Immutable" + messageIdent.GoName
		}

		// Cross-package message - use concrete type
		return "*" + g.QualifiedGoIdent(messageIdent)
	}

	// For enums and primitives, use regular type
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.EnumKind:
		return g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	default:
		return "interface{}"
	}
}

func isNonPrimitiveType(field *protogen.Field, localMessages map[string]bool) bool {
	// Check if this is a message type that's defined locally
	if field.Desc.Kind() == protoreflect.MessageKind {
		return localMessages[field.Message.GoIdent.GoName]
	}
	return false
}

func isSamePackageMessage(field *protogen.Field, currentPackage protogen.GoImportPath) bool {
	if field.Desc.Kind() == protoreflect.MessageKind {
		return field.Message.GoIdent.GoImportPath == currentPackage
	}
	return false
}

func isWellKnownType(field *protogen.Field) (string, bool) {
	if field.Desc.Kind() != protoreflect.MessageKind {
		return "", false
	}
	fullName := string(field.Message.Desc.FullName())
	switch fullName {
	case "google.protobuf.Timestamp":
		return "time.Time", true
	case "google.protobuf.Duration":
		return "time.Duration", true
	}
	return "", false
}

func generateWellKnownConversion(g *protogen.GeneratedFile, field *protogen.Field, srcVar, dstVar string) {
	fullName := string(field.Message.Desc.FullName())
	switch fullName {
	case "google.protobuf.Timestamp":
		g.P("\t\t\t", dstVar, " := ", srcVar, ".AsTime()")
	case "google.protobuf.Duration":
		g.P("\t\t\t", dstVar, " := ", srcVar, ".AsDuration()")
	}
}

func getFieldType(g *protogen.GeneratedFile, field *protogen.Field, localMessages map[string]bool, currentPackage protogen.GoImportPath) string {
	// Handle maps first (before checking repeated, as maps are also repeated)
	if field.Desc.IsMap() {
		// Map fields have a message type with exactly 2 fields: key and value
		keyField := field.Message.Fields[0]
		valueField := field.Message.Fields[1]
		keyType := goType(g, keyField, localMessages, currentPackage)
		valueType := goType(g, valueField, localMessages, currentPackage)
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
	}

	// Handle repeated fields
	if field.Desc.Cardinality() == protoreflect.Repeated {
		elemType := getElementType(g, field, localMessages, currentPackage)
		return "[]" + elemType
	}

	return getElementType(g, field, localMessages, currentPackage)
}

func getElementType(g *protogen.GeneratedFile, field *protogen.Field, localMessages map[string]bool, currentPackage protogen.GoImportPath) string {
	switch field.Desc.Kind() {
	case protoreflect.EnumKind:
		// Enums are in the same package
		return g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.MessageKind, protoreflect.GroupKind:
		messageIdent := field.Message.GoIdent
		// Only use Immutable interface if the message is defined in the current file
		if localMessages[messageIdent.GoName] {
			immutableIdent := protogen.GoIdent{
				GoName:       "Immutable" + messageIdent.GoName,
				GoImportPath: messageIdent.GoImportPath,
			}
			return g.QualifiedGoIdent(immutableIdent)
		}
		// For external messages, use pointer to concrete type
		return "*" + g.QualifiedGoIdent(messageIdent)
	default:
		return goType(g, field, localMessages, currentPackage)
	}
}

func goType(g *protogen.GeneratedFile, field *protogen.Field, localMessages map[string]bool, currentPackage protogen.GoImportPath) string {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.EnumKind:
		return g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		messageIdent := field.Message.GoIdent
		// Only use Immutable interface if the message is defined in the current file
		if localMessages[messageIdent.GoName] {
			immutableIdent := protogen.GoIdent{
				GoName:       "Immutable" + messageIdent.GoName,
				GoImportPath: messageIdent.GoImportPath,
			}
			return g.QualifiedGoIdent(immutableIdent)
		}
		// For external messages, use pointer to concrete type
		return "*" + g.QualifiedGoIdent(messageIdent)
	case protoreflect.GroupKind:
		messageIdent := field.Message.GoIdent
		// Only use Immutable interface if the message is defined in the current file
		if localMessages[messageIdent.GoName] {
			immutableIdent := protogen.GoIdent{
				GoName:       "Immutable" + messageIdent.GoName,
				GoImportPath: messageIdent.GoImportPath,
			}
			return g.QualifiedGoIdent(immutableIdent)
		}
		// For external messages, use pointer to concrete type
		return "*" + g.QualifiedGoIdent(messageIdent)
	default:
		return "interface{}"
	}
}

func generateWrapperMethods(g *protogen.GeneratedFile, msg *protogen.Message, localMessages map[string]bool, currentPackage protogen.GoImportPath) {
	messageName := msg.GoIdent.GoName

	// Generate implementation methods for all fields
	for _, field := range msg.Fields {
		generateImplementationMethod(g, msg, field, localMessages, currentPackage)
	}

	// Add type assertion to verify implementation
	interfaceName := "Immutable" + messageName
	g.P()
	g.P("// Verify that ", messageName, " implements ", interfaceName)
	g.P("var _ ", interfaceName, " = (*", messageName, ")(nil)")
}

func generateImplementationMethod(g *protogen.GeneratedFile, msg *protogen.Message, field *protogen.Field, localMessages map[string]bool, currentPackage protogen.GoImportPath) {
	messageName := msg.GoIdent.GoName
	fieldName := field.GoName

	// Handle ALL slices and maps first (primitives and messages)
	isRepeated := field.Desc.Cardinality() == protoreflect.Repeated
	isMap := field.Desc.IsMap()

	if isRepeated || isMap {
		methodName := "GetImmutable" + fieldName
		g.P()
		g.P("// ", methodName, " implements Immutable", messageName)

		if isMap {
			// Map - generate iter.Seq2
			keyField := field.Message.Fields[0]
			valueField := field.Message.Fields[1]
			keyType := getIteratorElementType(g, keyField, localMessages, currentPackage)
			valueType := getIteratorElementType(g, valueField, localMessages, currentPackage)

			g.P("func (m *", messageName, ") ", methodName, "() iter.Seq2[", keyType, ", ", valueType, "] {")
			g.P("\treturn func(yield func(", keyType, ", ", valueType, ") bool) {")
			g.P("\t\tif m == nil || m.", fieldName, " == nil {")
			g.P("\t\t\treturn")
			g.P("\t\t}")
			g.P("\t\tfor k, v := range m.", fieldName, " {")

			// Check if we need conversion for well-known types
			if _, okValue := isWellKnownType(valueField); okValue {
				generateWellKnownConversion(g, valueField, "v", "convertedV")
				g.P("\t\t\tif !yield(k, convertedV) {")
			} else {
				g.P("\t\t\tif !yield(k, v) {")
			}

			g.P("\t\t\t\treturn")
			g.P("\t\t\t}")
			g.P("\t\t}")
			g.P("\t}")
			g.P("}")
		} else {
			// Slice - generate iter.Seq
			elemType := getIteratorElementType(g, field, localMessages, currentPackage)

			g.P("func (m *", messageName, ") ", methodName, "() iter.Seq[", elemType, "] {")
			g.P("\treturn func(yield func(", elemType, ") bool) {")
			g.P("\t\tif m == nil || m.", fieldName, " == nil {")
			g.P("\t\t\treturn")
			g.P("\t\t}")
			g.P("\t\tfor _, v := range m.", fieldName, " {")

			// Check if we need conversion for well-known types
			if _, ok := isWellKnownType(field); ok {
				generateWellKnownConversion(g, field, "v", "convertedV")
				g.P("\t\t\tif !yield(convertedV) {")
			} else {
				g.P("\t\t\tif !yield(v) {")
			}

			g.P("\t\t\t\treturn")
			g.P("\t\t\t}")
			g.P("\t\t}")
			g.P("\t}")
			g.P("}")
		}
		return
	}

	// Handle singular well-known types
	if wktType, ok := isWellKnownType(field); ok {
		methodName := "GetImmutable" + fieldName
		g.P()
		g.P("// ", methodName, " implements Immutable", messageName)
		g.P("func (m *", messageName, ") ", methodName, "() ", wktType, " {")

		// For oneof fields, use the getter method instead of direct field access
		if field.Oneof != nil {
			g.P("\tif m == nil || m.Get", fieldName, "() == nil {")
			if wktType == "time.Time" {
				g.P("\t\treturn time.Time{}")
			} else if wktType == "time.Duration" {
				g.P("\t\treturn 0")
			}
			g.P("\t}")
			if wktType == "time.Time" {
				g.P("\treturn m.Get", fieldName, "().AsTime()")
			} else if wktType == "time.Duration" {
				g.P("\treturn m.Get", fieldName, "().AsDuration()")
			}
		} else {
			// For regular fields, use direct field access
			g.P("\tif m == nil || m.", fieldName, " == nil {")
			if wktType == "time.Time" {
				g.P("\t\treturn time.Time{}")
			} else if wktType == "time.Duration" {
				g.P("\t\treturn 0")
			}
			g.P("\t}")
			if wktType == "time.Time" {
				g.P("\treturn m.", fieldName, ".AsTime()")
			} else if wktType == "time.Duration" {
				g.P("\treturn m.", fieldName, ".AsDuration()")
			}
		}
		g.P("}")
		return
	}

	// Handle singular local message types
	if isNonPrimitiveType(field, localMessages) {
		methodName := "GetImmutable" + fieldName
		returnType := getFieldType(g, field, localMessages, currentPackage)
		g.P()
		g.P("// ", methodName, " implements Immutable", messageName)
		g.P("func (m *", messageName, ") ", methodName, "() ", returnType, " {")
		// Both oneof and regular fields use the getter method for message types
		g.P("\treturn m.Get", fieldName, "()")
		g.P("}")
		return
	}

	// Handle singular same-package messages
	if isSamePackageMessage(field, currentPackage) {
		methodName := "GetImmutable" + fieldName
		messageIdent := field.Message.GoIdent
		immutableType := "Immutable" + messageIdent.GoName
		g.P()
		g.P("// ", methodName, " implements Immutable", messageName)
		g.P("func (m *", messageName, ") ", methodName, "() ", immutableType, " {")
		// Both oneof and regular fields use the getter method for message types
		g.P("\treturn m.Get", fieldName, "()")
		g.P("}")
		return
	}

	// No wrapper needed for primitive singular types and cross-package messages
}
