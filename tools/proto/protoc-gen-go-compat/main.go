package main

import (
	"path"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_2023
		gen.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_2023
		gen.SupportedFeatures |= uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}

		return nil
	})
}

// generateFile generates a _ascii.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_vtproto.pb.go"

	importPath := protogen.GoImportPath(path.Join(
		string(file.GoImportPath),
		string(file.GoPackageName),
	))

	if len(file.Messages) == 0 {
		return
	}

	g := gen.NewGeneratedFile(filename, importPath)
	g.P("// Code generated by protoc-gen-go-compat. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	g.P(`import "google.golang.org/protobuf/proto"`)

	for _, m := range file.Messages {
		generateMessage(g, m)
	}
}

func generateMessage(g *protogen.GeneratedFile, msg *protogen.Message) {
	if msg.Desc.IsMapEntry() {
		return
	}

	s := msg.GoIdent.String()
	name := s[strings.LastIndex(s, ".")+1:]

	g.P()
	g.P("func (m *", name, ") SizeVT() int { return proto.Size(m) }")
	g.P("func (m *", name, ") CloneVT() *", name, " { return proto.Clone(m).(*", name, ") }")
	g.P("func (m *", name, ") MarshalVT() ([]byte, error) { return proto.Marshal(m) }")
	g.P("func (m *", name, ") UnmarshalVT(dAtA []byte) error { return proto.Unmarshal(dAtA, m) }")
	g.P(`// Deprecated: Use UnmarshalVT instead.`)
	g.P("func (m *", name, ") UnmarshalVTUnsafe(dAtA []byte) error { return m.UnmarshalVT(dAtA) }")

	g.P()
	for _, m := range msg.Messages {
		generateMessage(g, m)
	}
}
