package main

import (
	"path"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// Standard library dependencies.
const (
	bytesPackage = protogen.GoImportPath("bytes")
	fmtPackage   = protogen.GoImportPath("fmt")
)

var (
	fprintf = fmtPackage.Ident("Fprintf")
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}

		return nil
	})
}

// generateFile generates a _ascii.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_json.pb.go"

	importPath := protogen.GoImportPath(path.Join(
		string(file.GoImportPath),
		string(file.GoPackageName),
	))

	g := gen.NewGeneratedFile(filename, importPath)
	g.P("// Code generated by protoc-gen-go-json. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.Import("bytes")
	g.Import("fmt")

	for _, m := range file.Messages {
		generateMessage(g, m)
	}
}

func generateMessage(g *protogen.GeneratedFile, msg *protogen.Message) {
	if msg.Desc.IsMapEntry() {
		return
	}

	s := msg.GoIdent.String()
	name := s[strings.LastIndex(s, ".")+1:]

	g.P()
	g.P("func (m *", name, ") MarshalJSON() (b []byte, err error) ", " { ")
	g.P("if m == nil { return nil, nil }")
	g.P("var buf ", bytesPackage.Ident("Buffer"))
	hasMapsOrList := false
	for _, f := range msg.Fields {
		hasMapsOrList = hasMapsOrList || f.Desc.IsMap() || f.Desc.IsList()
	}
	if hasMapsOrList {
		g.P("trailingComma := true")
	}
	w(g, "{")
	trailingComma := false
	for _, f := range msg.Fields {
		if trailingComma {
			w(g, ",")
		}
		trailingComma = true
		ident(g, f.Desc.JSONName())
		w(g, ":")
		if f.Desc.IsList() {
			g.P("trailingComma = false")
			w(g, "[")
			g.P(`for _, v := range m.Get`, f.GoName, "() {")
			g.P("if trailingComma { buf.WriteByte(',') }; trailingComma = true;")
			switch f.Desc.Kind() {
			case protoreflect.MessageKind:
				if f.Desc.Message().FullName() == "google.protobuf.Timestamp" {
					q(g, "v.String()")
				}
				g.P("b, err = v.MarshalJSON()")
				g.P("if err != nil { return nil, err }")
				g.P(`if len(b) != 0 { buf.Write(b) } else { buf.WriteString("null") }`)
			case protoreflect.StringKind:
				q(g, `v`)
			case protoreflect.BoolKind:
				g.P(`if v { buf.WriteString("true") } else { buf.WriteString("false") }`)
			case protoreflect.EnumKind, protoreflect.Int32Kind, protoreflect.Sint32Kind,
				protoreflect.Uint32Kind, protoreflect.Int64Kind, protoreflect.Sint64Kind,
				protoreflect.Uint64Kind, protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind,
				protoreflect.Sfixed64Kind, protoreflect.Fixed64Kind:
				g.P(fprintf, `(&buf, "%d", v)`)
			case protoreflect.FloatKind, protoreflect.DoubleKind:
				g.P(fprintf, `(&buf, "%f", v)`)
			case protoreflect.BytesKind:
				w(g, "null")
			default:
				panic(f.Location.SourceFile + "/" + f.GoName)
			}
			g.P("}")
			w(g, "]")
			continue
		}
		if f.Desc.IsMap() {
			g.P("trailingComma = false")
			w(g, "{")
			g.P(`for k, v := range m.Get`, f.GoName, "() {")
			g.P("if trailingComma { buf.WriteByte(',') }; trailingComma = true;")
			switch f.Desc.MapKey().Kind() {
			case protoreflect.StringKind:
				q(g, "k")
			case protoreflect.BoolKind:
				g.P(`if k { buf.WriteString("true") } else { buf.WriteString("false") }`)
			case protoreflect.EnumKind, protoreflect.Int32Kind, protoreflect.Sint32Kind,
				protoreflect.Uint32Kind, protoreflect.Int64Kind, protoreflect.Sint64Kind,
				protoreflect.Uint64Kind, protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind,
				protoreflect.Sfixed64Kind, protoreflect.Fixed64Kind:
				g.P(fprintf, `(&buf, "%d", k`)
			case protoreflect.FloatKind, protoreflect.DoubleKind:
				g.P(fprintf, `(&buf, "%f", k)`)
			default:
				panic(f)
			}
			w(g, ":")
			switch f.Desc.MapValue().Kind() {
			case protoreflect.MessageKind:
				g.P("b, err = v.MarshalJSON()")
				g.P("if err != nil { return nil, err }")
				g.P(`if len(b) != 0 { buf.Write(b) } else { buf.WriteString("null") }`)
			case protoreflect.StringKind:
				q(g, "v")
			case protoreflect.BoolKind:
				g.P(`if v { buf.WriteString("true") } else { buf.WriteString("false") }`)
			case protoreflect.EnumKind, protoreflect.Int32Kind, protoreflect.Sint32Kind,
				protoreflect.Uint32Kind, protoreflect.Int64Kind, protoreflect.Sint64Kind,
				protoreflect.Uint64Kind, protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind,
				protoreflect.Sfixed64Kind, protoreflect.Fixed64Kind:
				g.P(fprintf, `(&buf, "%d", v)`)
			case protoreflect.FloatKind, protoreflect.DoubleKind:
				g.P(fprintf, `(&buf, "%f", v)`)
			default:
				panic(f)
			}
			g.P("}")
			w(g, "}")
			continue
		}
		switch f.Desc.Kind() {
		case protoreflect.MessageKind:
			if f.Desc.Message().FullName() == "google.protobuf.Timestamp" {
				q(g, "m.Get"+f.GoName+"().String()")
				continue
			}
			if f.Desc.IsList() {
				w(g, "[")
				g.P(`for _, v := range m.Get`, f.GoName, "() {")
				g.P("	b, err = v.MarshalJSON()")
				g.P("	if err != nil { return nil, err }")
				g.P(`	if len(b) != 0 { buf.Write(b) } else { buf.WriteString("null") }`)
				g.P(`}`)
				w(g, "]")
				continue
			}
			g.P("b, err = m.Get", f.GoName, "().MarshalJSON()")
			g.P("if err != nil { return nil, err }")
			g.P(`if len(b) != 0 { buf.Write(b) } else { buf.WriteString("null") }`)
		case protoreflect.StringKind:
			q(g, `m.Get`+f.GoName+"()")
		case protoreflect.BoolKind:
			g.P("if m.Get", f.GoName, `() { buf.WriteString("true") } else { buf.WriteString("false") }`)
		case protoreflect.EnumKind, protoreflect.Int32Kind, protoreflect.Sint32Kind,
			protoreflect.Uint32Kind, protoreflect.Int64Kind, protoreflect.Sint64Kind,
			protoreflect.Uint64Kind, protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind,
			protoreflect.Sfixed64Kind, protoreflect.Fixed64Kind:
			g.P(fprintf, `(&buf, "%d", m.Get`, f.GoName, `())`)
		case protoreflect.FloatKind, protoreflect.DoubleKind:
			g.P(fprintf, `(&buf, "%f", m.Get`, f.GoName, `())`)
		case protoreflect.BytesKind:
			w(g, "null")
		default:
			panic(f.Location.SourceFile + "/" + f.GoName)
		}
	}
	w(g, "}")
	g.P(`return buf.Bytes(), nil`)
	g.P("}")
	g.P()
	for _, m := range msg.Messages {
		generateMessage(g, m)
	}
}

func w(g *protogen.GeneratedFile, s string) {
	g.P(`buf.WriteString("` + s + `")`)
}

func q(g *protogen.GeneratedFile, s string) {
	g.P(`buf.WriteString("\"" +` + s + `+ "\"")`)
}

func ident(g *protogen.GeneratedFile, s string) {
	g.P(`buf.WriteString("\""); buf.WriteString("` + s + `"); buf.WriteString("\"");`)

}
