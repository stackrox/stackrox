import { interactAndWaitForResponses } from '../../../helpers/request';
import { visit } from '../../../helpers/visit';

// Source of truth for keys in routeMatcherMap and staticResponseMap objects.
export const reportAlias = 'reports/configurations/id';
export const reportsAlias = 'reports/configurations';
export const reportsCountAlias = 'reports/configuration-count';

const routeMatcherMapForVulnerabilityReports = {
    [reportsAlias]: {
        method: 'GET',
        url: '/v2/reports/configurations?*',
    },
    [reportsCountAlias]: {
        method: 'GET',
        url: '/v2/reports/configuration-count?*',
    },
};

/*
// TODO either mock report with mock collection and mock notifier
// or create real report with real collection and real notifier.
const routeMatcherMapForVulnerabilityReport = {
    [reportAlias]: {
        method: 'GET',
        url: '/v2/reports/configurations/*',
    },
};
*/

const collectionsAlias = 'collections';
const notifiersAlias = 'notifiers';

const routeMatcherMapForWizardStep1 = {
    [collectionsAlias]: {
        method: 'GET',
        url: '/v1/collections?*',
    },
};

const routeMatcherMapForWizardStep2 = {
    [notifiersAlias]: {
        method: 'GET',
        url: '/v1/notifiers',
    },
};

export const vulnerabilityReportsBasePath = '/main/vulnerabilities/reports';
export const vulnerabilityReportsConfigurationPath = `${vulnerabilityReportsBasePath}/configuration`;
export const vulnerabilityReportsViewBasedPath = `${vulnerabilityReportsBasePath}/view-based`;

// visit

/**
 * @param {Record<string, { body: unknown } | { fixture: string }>} [staticResponseMap]
 */
export function visitVulnerabilityReports(staticResponseMap) {
    const interceptions = visit(
        vulnerabilityReportsBasePath,
        routeMatcherMapForVulnerabilityReports,
        staticResponseMap
    );

    assertReportsTable();
    return interceptions;
}

export function assertReportsTable() {
    cy.get('h1:contains("Vulnerability reporting")');
}

// wizard

export function clickCreateReport() {
    interactAndWaitForResponses(() => {
        cy.get('button:contains("Create report")').click();
    }, routeMatcherMapForWizardStep1);

    cy.get('h1:contains("Create report")');
}

export function clickNextToWizardStep2() {
    interactAndWaitForResponses(() => {
        cy.get('button:contains("Next")').click();
    }, routeMatcherMapForWizardStep2);
}

export function clickNextToWizardStep3() {
    cy.get('button:contains("Next")').click();
}

export function clickCancelAndConfirmInWizard() {
    cy.get('button:contains("Cancel")').click();
    interactAndWaitForResponses(() => {
        cy.get('[role="dialog"] button:contains("Confirm")').click();
    }, routeMatcherMapForVulnerabilityReports);
}

export function assertNextDisabledAndHelperTextError(text) {
    cy.get(`button:contains("Next")`).should('have.attr', 'disabled');
    cy.get(`.pf-v5-c-helper-text__item.pf-m-error:contains(${text})`);
}

export function tryDeleteReportConfiguration(reportConfigName) {
    const baseApiUrl = '/v2/reports/configurations';
    const auth = { bearer: Cypress.env('ROX_AUTH_TOKEN') };

    cy.request({
        url: `${baseApiUrl}?query=Report Name:${reportConfigName}`,
        auth,
    }).as('listReports');

    return cy.get('@listReports').then((res) => {
        const reportConfig = res.body.reportConfigs.find(({ name }) => name === reportConfigName);
        if (reportConfig) {
            const { id } = reportConfig;
            const url = `${baseApiUrl}/${id}`;
            return cy.request({ url, auth, method: 'DELETE' });
        }
        return Promise.resolve();
    });
}
