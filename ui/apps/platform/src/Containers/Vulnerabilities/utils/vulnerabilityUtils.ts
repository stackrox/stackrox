import { severityRankings } from 'constants/vulnerabilities';
import type { Exploit, VulnerabilitySeverity } from 'types/cve.proto';
import { isVulnerabilitySeverity } from 'types/cve.proto';
import type { NonEmptyArray } from 'utils/type.utils';

/**
 * Get the highest severity of any vulnerability in the component array.
 */
export function getHighestVulnerabilitySeverity(
    vulnerabilities: { severity: string }[]
): VulnerabilitySeverity {
    let topSeverity: VulnerabilitySeverity = 'UNKNOWN_VULNERABILITY_SEVERITY';
    vulnerabilities.forEach(({ severity }) => {
        if (
            isVulnerabilitySeverity(severity) &&
            severityRankings[severity] > severityRankings[topSeverity]
        ) {
            topSeverity = severity;
        }
    });
    return topSeverity;
}

/**
 * Get whether or not any component has any fixable vulnerabilities.
 */
export function getIsSomeVulnerabilityFixable(
    vulnerabilities: { fixedByVersion: string }[]
): boolean {
    return vulnerabilities.some(({ fixedByVersion }) => fixedByVersion !== '');
}

/**
 * Gets the highest CVSS score and its score version from all vulnerabilities in the component array.
 */
export function getHighestCvssScore(vulnerabilities: { cvss: number; scoreVersion: string }[]): {
    cvss: number;
    scoreVersion: string;
} {
    let topCvss = 0;
    let topScoreVersion = 'N/A';
    vulnerabilities.forEach(({ cvss, scoreVersion }) => {
        if (cvss > topCvss) {
            topCvss = cvss;
            topScoreVersion = scoreVersion;
        }
    });
    return { cvss: topCvss, scoreVersion: topScoreVersion };
}

export function getHighestNvdCvssScore(
    vulnerabilities: { nvdCvss: number; nvdScoreVersion: string }[]
): {
    nvdCvss: number;
    nvdScoreVersion: string;
} {
    let topCvss = 0;
    let topScoreVersion = 'UNKNOWN_VERSION'; // so CvssFormatted renders as Not available
    vulnerabilities.forEach(({ nvdCvss = 0, nvdScoreVersion = 'UNKNOWN_VERSION' }) => {
        if (nvdScoreVersion !== 'UNKNOWN_VERSION' && nvdCvss > topCvss) {
            topCvss = nvdCvss;
            topScoreVersion = nvdScoreVersion;
        }
    });
    return { nvdCvss: topCvss, nvdScoreVersion: topScoreVersion };
}

export function getEarliestDiscoveredAtTime(
    vulnerabilities: NonEmptyArray<{ discoveredAtImage: string }>
): string {
    let earliestDiscoveredAt = vulnerabilities[0].discoveredAtImage;
    vulnerabilities.forEach(({ discoveredAtImage }) => {
        if (discoveredAtImage < earliestDiscoveredAt) {
            earliestDiscoveredAt = discoveredAtImage;
        }
    });
    return earliestDiscoveredAt;
}

export function hasKnownExploit(exploit: Exploit | null | undefined): exploit is Exploit {
    return Boolean(exploit);
}

export function hasKnownRansomwareCampaignUse(exploit: Exploit | null | undefined) {
    return exploit?.knownRansomwareCampaignUse === 'Known';
}
