import React, { ReactElement, useEffect, useState } from 'react';
import {
    Alert,
    Card,
    CardBody,
    CardHeader,
    CardTitle,
    Flex,
    FlexItem,
} from '@patternfly/react-core';
import { CheckCircleIcon, ExclamationCircleIcon } from '@patternfly/react-icons';
import { differenceInMinutes } from 'date-fns';

import IconText from 'Components/PatternFly/IconText/IconText';
import { fetchVulnerabilityDefinitionsInfo } from 'services/IntegrationHealthService';
import { getAxiosErrorMessage } from 'utils/responseErrorUtils';

const dayInMinutes = 24 * 60;

// TODO Import from services/IntegrationHealthService after we rewrite it in TypeScript.
type VulnerabilityDefinitionsInfo = {
    lastUpdatedTimestamp: string;
};

type VulnerabilityDefinitionsHealthCardProps = {
    pollingCount: number;
};

const VulnerabilityDefinitionsHealthCard = ({
    pollingCount,
}: VulnerabilityDefinitionsHealthCardProps): ReactElement => {
    const [isFetching, setIsFetching] = useState(false);
    const [requestErrorMessage, setRequestErrorMessage] = useState('');
    const [vulnerabilityDefinitionsInfo, setVulnerabilityDefinitionsInfo] =
        useState<VulnerabilityDefinitionsInfo | null>(null);
    const [currentDatetime, setCurrentDatetime] = useState<Date | null>(null);

    useEffect(() => {
        setIsFetching(true);
        fetchVulnerabilityDefinitionsInfo()
            .then((info) => {
                setRequestErrorMessage('');
                setVulnerabilityDefinitionsInfo(info);
                setCurrentDatetime(new Date());
            })
            .catch((error) => {
                setRequestErrorMessage(getAxiosErrorMessage(error));
                setVulnerabilityDefinitionsInfo(null);
            })
            .finally(() => {
                setIsFetching(false);
            });
    }, [pollingCount]);

    /*
     * Wait for isFetching only until response to the initial request.
     * Otherwise info temporarily disappears during each subsequent request.
     */
    const hasInfo = (pollingCount !== 0 || !isFetching) && !requestErrorMessage;
    const lastUpdatedTimestamp = vulnerabilityDefinitionsInfo?.lastUpdatedTimestamp;
    // Beware: the order of the arguments in date-fns@1 (later, earlier)
    // will be reversed in date-fns@2 to differenceInMinutes(earlier, later).
    const isUpToDate =
        hasInfo &&
        lastUpdatedTimestamp &&
        currentDatetime !== null &&
        differenceInMinutes(currentDatetime, lastUpdatedTimestamp) < dayInMinutes;

    return (
        <Card isCompact>
            <CardHeader>
                <Flex className="pf-u-flex-grow-1">
                    <FlexItem>
                        <CardTitle component="h2">Vulnerability definitions</CardTitle>
                    </FlexItem>
                    {hasInfo && (
                        <FlexItem>
                            <IconText
                                icon={
                                    isUpToDate ? (
                                        <CheckCircleIcon color="var(--pf-global--success-color--100)" />
                                    ) : (
                                        <ExclamationCircleIcon color="var(--pf-global--danger-color--100)" />
                                    )
                                }
                                text={isUpToDate ? 'up to date' : 'out of date'}
                            />
                        </FlexItem>
                    )}
                    {hasInfo && lastUpdatedTimestamp && (
                        <FlexItem align={{ default: 'alignRight' }}>
                            {lastUpdatedTimestamp}
                        </FlexItem>
                    )}
                </Flex>
            </CardHeader>
            {requestErrorMessage && (
                <CardBody>
                    <Alert isInline variant="warning" title={requestErrorMessage} />
                </CardBody>
            )}
        </Card>
    );
};

export default VulnerabilityDefinitionsHealthCard;
