package registries

import (
	"context"
	"net/http"
	"testing"

	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/registries/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func newFakeRegistry(name, username, password, url string, auto bool) *fakeRegistry {
	return &fakeRegistry{
		name: name,
		config: &types.Config{
			Username:      username,
			Password:      password,
			URL:           url,
			Autogenerated: auto,
		},
	}
}

var _ types.ImageRegistry = (*fakeRegistry)(nil)

type fakeRegistry struct {
	name   string
	config *types.Config
}

func (f *fakeRegistry) Match(_ *storage.ImageName) bool { return false }

func (f *fakeRegistry) Metadata(_ *storage.Image) (*storage.ImageMetadata, error) {
	return nil, nil
}

func (f *fakeRegistry) Test() error {
	return nil
}

func (f *fakeRegistry) Config(ctx context.Context) *types.Config {
	return f.config
}

func (f *fakeRegistry) Name() string {
	return f.name
}

func (f *fakeRegistry) HTTPClient() *http.Client {
	return nil
}

func (f *fakeRegistry) DataSource() *storage.DataSource {
	return nil
}

func (f *fakeRegistry) Source() *storage.ImageIntegration {
	return nil
}

func TestSetSorting(t *testing.T) {
	userInput := newFakeRegistry("user-input", "username", "", "", false)
	autogenerated := newFakeRegistry("autogenerated", "username", "", "", true)
	def := newFakeRegistry("default", "", "", "", false)

	cases := []struct {
		integrations []types.ImageRegistry
	}{
		{
			integrations: []types.ImageRegistry{userInput, autogenerated, def},
		},
		{
			integrations: []types.ImageRegistry{userInput, def, autogenerated},
		},
		{
			integrations: []types.ImageRegistry{autogenerated, userInput, def},
		},
		{
			integrations: []types.ImageRegistry{autogenerated, def, userInput},
		},
		{
			integrations: []types.ImageRegistry{def, userInput, autogenerated},
		},
		{
			integrations: []types.ImageRegistry{def, autogenerated, userInput},
		},
	}
	sortedOrder := []types.ImageRegistry{
		userInput,
		autogenerated,
		def,
	}
	for _, c := range cases {
		t.Run(t.Name(), func(t *testing.T) {
			sortIntegrations(c.integrations)
			assert.Equal(t, sortedOrder, c.integrations)
		})
	}
}

func TestSetImpl_Get(t *testing.T) {
	reg1 := newFakeRegistry("testing", "username", "empty", "docker.io", false)

	set := &setImpl{integrations: map[string]types.ImageRegistry{
		"1": reg1,
	}}

	assert.Nil(t, set.Get(""))
	assert.Nil(t, set.Get("0"))
	assert.NotNil(t, set.Get("1"))
}

func TestSetImpl_GetAllUnique(t *testing.T) {
	reg1 := newFakeRegistry("testing", "username", "empty", "docker.io", false)
	reg2 := newFakeRegistry("testing", "username", "empty", "docker.io", true)
	reg3 := newFakeRegistry("testing", "username1", "empty", "docker.io", true)
	reg4 := newFakeRegistry("testing", "username2", "empty", "docker.io", false)
	reg5 := newFakeRegistry("testing", "username", "empty", "docker.io", true)

	set := &setImpl{integrations: map[string]types.ImageRegistry{
		"1": reg1,
		"2": reg2,
		"3": reg3,
		"4": reg4,
		"5": reg5,
	}}

	uniqueRegistries := set.GetAllUnique()

	assert.ElementsMatch(t, uniqueRegistries, []types.ImageRegistry{reg1, reg2, reg3, reg4})
}

func TestSetImpl_Clear(t *testing.T) {
	integration := func(id string) *storage.ImageIntegration {
		ii := &storage.ImageIntegration{}
		ii.SetId(id)
		ii.SetName(id)
		ii.SetType(types.DockerType)
		ii.IntegrationConfig = &storage.ImageIntegration_Docker{}
		return ii
	}

	factory := NewFactory(FactoryOptions{})

	set := NewSet(factory)
	assert.Equal(t, 0, set.Len())

	_, err := set.UpdateImageIntegration(integration("a"))
	require.NoError(t, err)
	assert.Equal(t, 1, set.Len())

	set.Clear()
	assert.Equal(t, 0, set.Len())

	_, err = set.UpdateImageIntegration(integration("b"))
	require.NoError(t, err)
	assert.Equal(t, 1, set.Len())
}

func TestUpdateImageIntegration(t *testing.T) {
	integration := func(id string) *storage.ImageIntegration {
		ii := &storage.ImageIntegration{}
		ii.SetId(id)
		ii.SetName(id)
		ii.SetType(types.DockerType)
		ii.IntegrationConfig = &storage.ImageIntegration_Docker{}
		return ii
	}

	t.Run("bool return correctly indicates if entry existed in set", func(t *testing.T) {
		factory := NewFactory(FactoryOptions{})
		set := NewSet(factory)

		fresh, err := set.UpdateImageIntegration(integration("a"))
		require.NoError(t, err)
		assert.True(t, fresh)

		// Repeat the same upsert, this time a prior entry should exist.
		fresh, err = set.UpdateImageIntegration(integration("a"))
		require.NoError(t, err)
		assert.False(t, fresh)

		// A different ID should yield a fresh insert.
		fresh, err = set.UpdateImageIntegration(integration("b"))
		require.NoError(t, err)
		assert.True(t, fresh)
	})
}
