package registries

import (
	"context"
	"net/http"
	"testing"

	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/registries/types"
	"github.com/stretchr/testify/assert"
)

func newFakeRegistry(name, username, password, url string, auto bool) *fakeRegistry {
	return &fakeRegistry{
		name: name,
		config: &types.Config{
			Username:      username,
			Password:      password,
			URL:           url,
			Autogenerated: auto,
		},
	}
}

var _ types.ImageRegistry = (*fakeRegistry)(nil)

type fakeRegistry struct {
	name   string
	config *types.Config
}

func (f *fakeRegistry) Match(_ *storage.ImageName) bool { return false }

func (f *fakeRegistry) Metadata(_ *storage.Image) (*storage.ImageMetadata, error) {
	return nil, nil
}

func (f *fakeRegistry) Test() error {
	return nil
}

func (f *fakeRegistry) Config(ctx context.Context) *types.Config {
	return f.config
}

func (f *fakeRegistry) Name() string {
	return f.name
}

func (f *fakeRegistry) HTTPClient() *http.Client {
	return nil
}

func (f *fakeRegistry) DataSource() *storage.DataSource {
	return nil
}

func (f *fakeRegistry) Source() *storage.ImageIntegration {
	return nil
}

func TestSetSorting(t *testing.T) {
	userInput := newFakeRegistry("user-input", "username", "", "", false)
	autogenerated := newFakeRegistry("autogenerated", "username", "", "", true)
	def := newFakeRegistry("default", "", "", "", false)

	cases := []struct {
		integrations []types.ImageRegistry
	}{
		{
			integrations: []types.ImageRegistry{userInput, autogenerated, def},
		},
		{
			integrations: []types.ImageRegistry{userInput, def, autogenerated},
		},
		{
			integrations: []types.ImageRegistry{autogenerated, userInput, def},
		},
		{
			integrations: []types.ImageRegistry{autogenerated, def, userInput},
		},
		{
			integrations: []types.ImageRegistry{def, userInput, autogenerated},
		},
		{
			integrations: []types.ImageRegistry{def, autogenerated, userInput},
		},
	}
	sortedOrder := []types.ImageRegistry{
		userInput,
		autogenerated,
		def,
	}
	for _, c := range cases {
		t.Run(t.Name(), func(t *testing.T) {
			sortIntegrations(c.integrations)
			assert.Equal(t, sortedOrder, c.integrations)
		})
	}
}

func TestSetImpl_GetAllUnique(t *testing.T) {
	reg1 := newFakeRegistry("testing", "username", "empty", "docker.io", false)
	reg2 := newFakeRegistry("testing", "username", "empty", "docker.io", true)
	reg3 := newFakeRegistry("testing", "username1", "empty", "docker.io", true)
	reg4 := newFakeRegistry("testing", "username2", "empty", "docker.io", false)
	reg5 := newFakeRegistry("testing", "username", "empty", "docker.io", true)

	set := &setImpl{integrations: map[string]types.ImageRegistry{
		"1": reg1,
		"2": reg2,
		"3": reg3,
		"4": reg4,
		"5": reg5,
	}}

	uniqueRegistries := set.GetAllUnique()

	assert.ElementsMatch(t, uniqueRegistries, []types.ImageRegistry{reg1, reg2, reg3, reg4})
}
