// Code generated by MockGen. DO NOT EDIT.
// Source: waitable.go
//
// Generated by this command:
//
//	mockgen -package mocks -destination mocks/waitable.go -source waitable.go
//
// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	proto "github.com/gogo/protobuf/proto"
	concurrency "github.com/stackrox/rox/pkg/concurrency"
	gomock "go.uber.org/mock/gomock"
)

// MockAcceptsKeyValue is a mock of AcceptsKeyValue interface.
type MockAcceptsKeyValue struct {
	ctrl     *gomock.Controller
	recorder *MockAcceptsKeyValueMockRecorder
}

// MockAcceptsKeyValueMockRecorder is the mock recorder for MockAcceptsKeyValue.
type MockAcceptsKeyValueMockRecorder struct {
	mock *MockAcceptsKeyValue
}

// NewMockAcceptsKeyValue creates a new mock instance.
func NewMockAcceptsKeyValue(ctrl *gomock.Controller) *MockAcceptsKeyValue {
	mock := &MockAcceptsKeyValue{ctrl: ctrl}
	mock.recorder = &MockAcceptsKeyValueMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAcceptsKeyValue) EXPECT() *MockAcceptsKeyValueMockRecorder {
	return m.recorder
}

// Push mocks base method.
func (m *MockAcceptsKeyValue) Push(key []byte, value proto.Message) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Push", key, value)
}

// Push indicates an expected call of Push.
func (mr *MockAcceptsKeyValueMockRecorder) Push(key, value any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockAcceptsKeyValue)(nil).Push), key, value)
}

// MockWaitableQueue is a mock of WaitableQueue interface.
type MockWaitableQueue struct {
	ctrl     *gomock.Controller
	recorder *MockWaitableQueueMockRecorder
}

// MockWaitableQueueMockRecorder is the mock recorder for MockWaitableQueue.
type MockWaitableQueueMockRecorder struct {
	mock *MockWaitableQueue
}

// NewMockWaitableQueue creates a new mock instance.
func NewMockWaitableQueue(ctrl *gomock.Controller) *MockWaitableQueue {
	mock := &MockWaitableQueue{ctrl: ctrl}
	mock.recorder = &MockWaitableQueueMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWaitableQueue) EXPECT() *MockWaitableQueueMockRecorder {
	return m.recorder
}

// Length mocks base method.
func (m *MockWaitableQueue) Length() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Length")
	ret0, _ := ret[0].(int)
	return ret0
}

// Length indicates an expected call of Length.
func (mr *MockWaitableQueueMockRecorder) Length() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Length", reflect.TypeOf((*MockWaitableQueue)(nil).Length))
}

// NotEmpty mocks base method.
func (m *MockWaitableQueue) NotEmpty() concurrency.Waitable {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NotEmpty")
	ret0, _ := ret[0].(concurrency.Waitable)
	return ret0
}

// NotEmpty indicates an expected call of NotEmpty.
func (mr *MockWaitableQueueMockRecorder) NotEmpty() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NotEmpty", reflect.TypeOf((*MockWaitableQueue)(nil).NotEmpty))
}

// Pop mocks base method.
func (m *MockWaitableQueue) Pop() ([]byte, proto.Message, *concurrency.Signal) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pop")
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(proto.Message)
	ret2, _ := ret[2].(*concurrency.Signal)
	return ret0, ret1, ret2
}

// Pop indicates an expected call of Pop.
func (mr *MockWaitableQueueMockRecorder) Pop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pop", reflect.TypeOf((*MockWaitableQueue)(nil).Pop))
}

// Push mocks base method.
func (m *MockWaitableQueue) Push(key []byte, value proto.Message) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Push", key, value)
}

// Push indicates an expected call of Push.
func (mr *MockWaitableQueueMockRecorder) Push(key, value any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockWaitableQueue)(nil).Push), key, value)
}

// PushSignal mocks base method.
func (m *MockWaitableQueue) PushSignal(signal *concurrency.Signal) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PushSignal", signal)
}

// PushSignal indicates an expected call of PushSignal.
func (mr *MockWaitableQueueMockRecorder) PushSignal(signal any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PushSignal", reflect.TypeOf((*MockWaitableQueue)(nil).PushSignal), signal)
}
