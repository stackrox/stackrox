package tokenbased

import (
	"context"
	"time"

	"github.com/pkg/errors"
	v1 "github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/pkg/auth/authproviders"
	"github.com/stackrox/rox/pkg/auth/permissions"
	"github.com/stackrox/rox/pkg/auth/tokens"
	"github.com/stackrox/rox/pkg/protoconv"
	"github.com/stackrox/rox/pkg/timeutil"
)

var (
	_ authproviders.Provider = (*tokenAuthProviderImpl)(nil)
	_ TokenAuthProvider      = (*tokenAuthProviderImpl)(nil)
	_ tokens.RevocationLayer = (*tokenAuthProviderImpl)(nil)
)

// tokenAuthProviderImpl aims at implementing the common denominator for
// the issuer sources or providers for all rox token generators
// in the central codebase. The token authentication code requires
// this token source to actually implement authproviders.Provider.
// Using authproviders.NewProvider is not a good fit here,
// since the resulting type then validates rox token claims using
// the internal authproviders.Backend instance (generated by
// the authproviders.BackendFactory passed with the
// authproviders.WithBackendFromFactory constructor option).
// Going that route would require implementing mostly empty shells
// for the backend-related interfaces. Cutting the complexity
// at the tokens.Source or authproviders.Provider interface is
// a better choice.
type tokenAuthProviderImpl struct {
	*noopProvider

	id         string
	name       string
	sourceType string

	revocationLayer tokens.RevocationLayer
	roleMapper      permissions.RoleMapper
}

func (s *tokenAuthProviderImpl) InitFromStore(ctx context.Context, tokenStore TokenStore) error {
	if tokenStore == nil {
		return nil
	}
	revokedTokenReq := &v1.GetAPITokensRequest{
		RevokedOneof: &v1.GetAPITokensRequest_Revoked{
			Revoked: true,
		},
	}
	existingTokens, err := tokenStore.GetTokens(ctx, revokedTokenReq)
	if err != nil {
		return errors.Wrap(err, "getting existing tokens")
	}

	for _, token := range existingTokens {
		expiry := protoconv.ConvertTimestampToTimeOrDefault(token.GetExpiration(), timeutil.Max)
		s.revocationLayer.Revoke(token.GetId(), expiry)
	}
	return nil
}

func (s *tokenAuthProviderImpl) Validate(ctx context.Context, claims *tokens.Claims) error {
	return s.revocationLayer.Validate(ctx, claims)
}

func (s *tokenAuthProviderImpl) Revoke(tokenID string, expiry time.Time) {
	s.revocationLayer.Revoke(tokenID, expiry)
}

func (s *tokenAuthProviderImpl) IsRevoked(tokenID string) bool {
	if s.revocationLayer == nil {
		return false
	}
	return s.revocationLayer.IsRevoked(tokenID)
}

func (s *tokenAuthProviderImpl) ID() string { return s.id }

func (s *tokenAuthProviderImpl) Name() string { return s.name }

func (s *tokenAuthProviderImpl) Type() string { return s.sourceType }

func (s *tokenAuthProviderImpl) Enabled() bool { return true }

func (s *tokenAuthProviderImpl) Active() bool { return true }

func (s *tokenAuthProviderImpl) RoleMapper() permissions.RoleMapper { return s.roleMapper }
