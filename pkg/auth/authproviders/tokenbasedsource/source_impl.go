package tokenbasedsource

import (
	"context"
	"time"

	"github.com/pkg/errors"
	v1 "github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/auth/authproviders"
	"github.com/stackrox/rox/pkg/auth/permissions"
	"github.com/stackrox/rox/pkg/auth/tokens"
	"github.com/stackrox/rox/pkg/auth/user"
	"github.com/stackrox/rox/pkg/protoconv"
	"github.com/stackrox/rox/pkg/timeutil"
)

var _ authproviders.Provider = (*tokenSourceImpl)(nil)
var _ TokenSource = (*tokenSourceImpl)(nil)
var _ tokens.RevocationLayer = (*tokenSourceImpl)(nil)

// tokenSource aims at implementing the common denominator for
// the issuer sources or providers for all rox token generators
// in the central codebase. The token authentication code requires
// this token source to actually implement authproviders.Provider.
// Using authproviders.NewProvider is not a good fit here,
// since the resulting type then validates rox token claims using
// the internal authproviders.Backend instance (generated by
// the authproviders.BackendFactory passed with the
// authproviders.WithBackendFromFactory constructor option).
// Going that route would require implementing mostly empty shells
// for the backend-related interfaces. Cutting the complexity
// at the tokens.Source or authproviders.Provider interface is
// a better choice.
type tokenSourceImpl struct {
	id         string
	name       string
	sourceType string

	revocationLayer tokens.RevocationLayer
	roleMapper      permissions.RoleMapper
}

func (s *tokenSourceImpl) InitFromStore(ctx context.Context, tokenStore TokenStore) error {
	if s.revocationLayer == nil {
		return nil
	}
	revokedTokenReq := &v1.GetAPITokensRequest{
		RevokedOneof: &v1.GetAPITokensRequest_Revoked{
			Revoked: true,
		},
	}
	existingTokens, err := tokenStore.GetTokens(ctx, revokedTokenReq)
	if err != nil {
		return errors.Wrap(err, "getting existing tokens")
	}

	for _, token := range existingTokens {
		expiry := protoconv.ConvertTimestampToTimeOrDefault(token.GetExpiration(), timeutil.Max)
		s.revocationLayer.Revoke(token.GetId(), expiry)
	}
	return nil
}

func (s *tokenSourceImpl) Validate(ctx context.Context, claims *tokens.Claims) error {
	if s.revocationLayer == nil {
		return nil
	}
	return s.revocationLayer.Validate(ctx, claims)
}

func (s *tokenSourceImpl) Revoke(tokenID string, expiry time.Time) {
	if s.revocationLayer == nil {
		return
	}
	s.revocationLayer.Revoke(tokenID, expiry)
}

func (s *tokenSourceImpl) IsRevoked(tokenID string) bool {
	if s.revocationLayer == nil {
		return false
	}
	return s.revocationLayer.IsRevoked(tokenID)
}

func (s *tokenSourceImpl) ID() string { return s.id }

func (s *tokenSourceImpl) Name() string { return s.name }

func (s *tokenSourceImpl) Type() string { return s.sourceType }

func (s *tokenSourceImpl) Enabled() bool { return true }

func (s *tokenSourceImpl) Active() bool { return true }

func (s *tokenSourceImpl) RoleMapper() permissions.RoleMapper { return s.roleMapper }

// region Unimplemented methods to satisfy authproviders.Provider.

func (s *tokenSourceImpl) MergeConfigInto(newCfg map[string]string) map[string]string { return newCfg }

func (s *tokenSourceImpl) StorageView() *storage.AuthProvider { return nil }

func (s *tokenSourceImpl) BackendFactory() authproviders.BackendFactory { return nil }

func (s *tokenSourceImpl) Backend() authproviders.Backend { return nil }

func (s *tokenSourceImpl) GetOrCreateBackend(_ context.Context) (authproviders.Backend, error) {
	return nil, nil
}

func (s *tokenSourceImpl) Issuer() tokens.Issuer { return nil }

func (s *tokenSourceImpl) AttributeVerifier() user.AttributeVerifier { return nil }

func (s *tokenSourceImpl) ApplyOptions(_ ...authproviders.ProviderOption) error { return nil }

func (s *tokenSourceImpl) MarkAsActive() error { return nil }

// endregion Unimplemented methods to satisfy authproviders.Provider.
