//go:build sql_integration

package requestmgr

import (
	"context"
	"testing"

	imageCVEDSMocks "github.com/stackrox/rox/central/cve/image/datastore/mocks"
	imageCVE2DSMocks "github.com/stackrox/rox/central/cve/image/v2/datastore/mocks"
	imageDSMocks "github.com/stackrox/rox/central/image/datastore/mocks"
	reprocessorMocks "github.com/stackrox/rox/central/reprocessor/mocks"
	sensorConnMgrMocks "github.com/stackrox/rox/central/sensor/service/connection/mocks"
	vulnReqCache "github.com/stackrox/rox/central/vulnmgmt/vulnerabilityrequest/cache"
	"github.com/stackrox/rox/central/vulnmgmt/vulnerabilityrequest/common"
	vulReqDS "github.com/stackrox/rox/central/vulnmgmt/vulnerabilityrequest/datastore"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/features"
	"github.com/stackrox/rox/pkg/fixtures"
	"github.com/stackrox/rox/pkg/grpc/authn"
	mockIdentity "github.com/stackrox/rox/pkg/grpc/authn/mocks"
	"github.com/stackrox/rox/pkg/postgres/pgtest"
	"github.com/stackrox/rox/pkg/protocompat"
	"github.com/stackrox/rox/pkg/sac"
	"github.com/stackrox/rox/pkg/search"
	"github.com/stretchr/testify/assert"
	"go.uber.org/mock/gomock"
)

func TestCreateWithUnifiedDeferralFlatDataModel(t *testing.T) {
	t.Setenv(features.UnifiedCVEDeferral.EnvVar(), "true")
	if !features.UnifiedCVEDeferral.Enabled() {
		t.Skipf("%s=false. Skipping test", features.UnifiedCVEDeferral.EnvVar())
	}
	if !features.FlattenCVEData.Enabled() {
		t.Skip()
	}
	testApprovalFlatDataModel(t)
}

func testApprovalFlatDataModel(t *testing.T) {
	mockCtrl := gomock.NewController(t)

	testDB := pgtest.ForT(t)

	pendingReqCache, activeReqCache := vulnReqCache.New(), vulnReqCache.New()
	datastore := vulReqDS.GetTestPostgresDataStore(t, testDB, pendingReqCache, activeReqCache)

	imageDataStore := imageDSMocks.NewMockDataStore(mockCtrl)
	sensorConnMgrMocks := sensorConnMgrMocks.NewMockManager(mockCtrl)
	reprocessor := reprocessorMocks.NewMockLoop(mockCtrl)
	imageCVEDataStore := imageCVEDSMocks.NewMockDataStore(mockCtrl)
	imageCVE2DataStore := imageCVE2DSMocks.NewMockDataStore(mockCtrl)
	manager := New(nil, datastore, pendingReqCache, activeReqCache, imageDataStore, imageCVEDataStore, imageCVE2DataStore, sensorConnMgrMocks, reprocessor)

	globalCVE1DefReq := fixtures.GetGlobalDeferralRequest("cve-1")
	globalCVE1FPReq := fixtures.GetGlobalFPRequest("cve-1")
	imageScopedCVE1Req := fixtures.GetImageScopeDeferralRequest("reg1", "img1", "1.0", "cve-1")
	allTagCVE1Req := fixtures.GetImageScopeDeferralRequest("reg1", "img1", ".*", "cve-1")
	otherImageReq := fixtures.GetImageScopeDeferralRequest("reg2", "img1", "1.0", "cve-2")

	globalCVE1DefUpdateReq := fixtures.GetGlobalDeferralRequest("cve-2")
	globalCVE1DefUpdateReq.UpdatedReq = &storage.VulnerabilityRequest_DeferralUpdate{
		DeferralUpdate: &storage.DeferralUpdate{
			CVEs: []string{"cve-1"},
			Expiry: &storage.RequestExpiry{
				Expiry: &storage.RequestExpiry_ExpiresOn{ExpiresOn: protocompat.TimestampNow()},
			},
		},
	}
	globalCVE1DefUpdateReq.Status = storage.RequestStatus_APPROVED_PENDING_UPDATE

	globalCVE1FpUpdateReq := fixtures.GetGlobalFPRequest("cve-2")
	globalCVE1FpUpdateReq.UpdatedReq = &storage.VulnerabilityRequest_FalsePositiveUpdate{
		FalsePositiveUpdate: &storage.FalsePositiveUpdate{
			CVEs: []string{"cve-1"},
		},
	}
	globalCVE1FpUpdateReq.Status = storage.RequestStatus_APPROVED_PENDING_UPDATE

	existingReqs := []*storage.VulnerabilityRequest{
		globalCVE1DefReq,
		globalCVE1FPReq,
		imageScopedCVE1Req,
		allTagCVE1Req,
		otherImageReq,
		globalCVE1DefUpdateReq,
		globalCVE1FpUpdateReq,
	}

	approver := &storage.SlimUser{
		Id:   "approver",
		Name: "approver",
	}
	mockID := mockIdentity.NewMockIdentity(mockCtrl)
	approverCtx := authn.ContextWithIdentity(sac.WithAllAccess(context.Background()), mockID, t)
	deniedReqQ := search.NewQueryBuilder().AddExactMatches(search.RequestStatus, storage.RequestStatus_DENIED.String()).ProtoQuery()
	for _, tc := range []struct {
		desc                    string
		approvedReq             *storage.VulnerabilityRequest
		expectedDeclined        []string
		expectedDeniedUpdateIDs []string
	}{
		{
			desc:                    "decline cve-1 requests and update requests in covered scopes; global, all tags, specific tag",
			approvedReq:             globalCVE1DefReq,
			expectedDeclined:        []string{globalCVE1FPReq.GetId(), allTagCVE1Req.GetId(), imageScopedCVE1Req.GetId()},
			expectedDeniedUpdateIDs: []string{globalCVE1DefUpdateReq.GetId(), globalCVE1FpUpdateReq.GetId()},
		},
		{
			desc:             "decline cve-1 requests in covered scopes; all tags, specific tag",
			approvedReq:      allTagCVE1Req,
			expectedDeclined: []string{imageScopedCVE1Req.GetId()},
		},
		{
			desc:        "none declined",
			approvedReq: otherImageReq,
		},
	} {
		t.Run(tc.desc, func(t *testing.T) {
			for _, req := range existingReqs {
				assert.NoError(t, datastore.AddRequest(allAccessCtx, req))
			}

			mockID.EXPECT().UID().Return(approver.Id).AnyTimes()
			mockID.EXPECT().FullName().Return(approver.Name).AnyTimes()
			mockID.EXPECT().FriendlyName().Return(approver.Name).AnyTimes()

			imageDataStore.EXPECT().Search(gomock.Any(), gomock.Any()).Return(nil, nil)
			_, err := manager.Approve(approverCtx, tc.approvedReq.GetId(), &common.VulnRequestParams{
				Comment: "test approval",
			})
			assert.NoError(t, err)
			results, err := datastore.Search(allAccessCtx, deniedReqQ)
			assert.NoError(t, err)
			assert.ElementsMatch(t, tc.expectedDeclined, search.ResultsToIDs(results))

			if features.UnifiedCVEDeferral.Enabled() {
				deniedUpdateIDs := getDeniedUpdateReqIDs(t, datastore)
				assert.ElementsMatch(t, tc.expectedDeniedUpdateIDs, deniedUpdateIDs)
			}

			for _, req := range existingReqs {
				assert.NoError(t, datastore.RemoveRequestsInternal(allAccessCtx, []string{req.GetId()}))
			}
		})
	}
}
