package datastore

import (
	"context"
	"fmt"
	"testing"

	namespaceDSMocks "github.com/stackrox/rox/central/namespace/datastore/mocks"
	"github.com/stackrox/rox/central/vulnmgmt/vulnerabilityrequest/cache"
	"github.com/stackrox/rox/central/vulnmgmt/vulnerabilityrequest/common"
	searcherMock "github.com/stackrox/rox/central/vulnmgmt/vulnerabilityrequest/datastore/internal/searcher/mocks"
	storeMock "github.com/stackrox/rox/central/vulnmgmt/vulnerabilityrequest/datastore/internal/store/mocks"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/features"
	"github.com/stackrox/rox/pkg/fixtures"
	"github.com/stackrox/rox/pkg/grpc/authn"
	mockIdentity "github.com/stackrox/rox/pkg/grpc/authn/mocks"
	"github.com/stackrox/rox/pkg/protoassert"
	"github.com/stackrox/rox/pkg/protocompat"
	"github.com/stackrox/rox/pkg/sac"
	"github.com/stackrox/rox/pkg/sac/resources"
	"github.com/stretchr/testify/suite"
	"go.uber.org/mock/gomock"
)

var (
	noVMAccessSac = sac.WithGlobalAccessScopeChecker(context.Background(),
		sac.AllowFixedScopes(
			sac.AccessModeScopeKeys(storage.Access_READ_ACCESS),
			sac.ResourceScopeKeys(resources.Alert)))
	requesterReadSac = sac.WithGlobalAccessScopeChecker(context.Background(),
		sac.AllowFixedScopes(
			sac.AccessModeScopeKeys(storage.Access_READ_ACCESS),
			sac.ResourceScopeKeys(resources.VulnerabilityManagementRequests)))
	requesterWriteSac = sac.WithGlobalAccessScopeChecker(context.Background(),
		sac.AllowFixedScopes(
			sac.AccessModeScopeKeys(storage.Access_READ_WRITE_ACCESS),
			sac.ResourceScopeKeys(resources.VulnerabilityManagementRequests)))
	requesterAllSac = sac.WithGlobalAccessScopeChecker(context.Background(),
		sac.AllowFixedScopes(
			sac.AccessModeScopeKeys(storage.Access_READ_ACCESS, storage.Access_READ_WRITE_ACCESS),
			sac.ResourceScopeKeys(resources.VulnerabilityManagementRequests)))
	approverReadSac = sac.WithGlobalAccessScopeChecker(context.Background(),
		sac.AllowFixedScopes(
			sac.AccessModeScopeKeys(storage.Access_READ_ACCESS),
			sac.ResourceScopeKeys(resources.VulnerabilityManagementApprovals)))
	approverWriteSac = sac.WithGlobalAccessScopeChecker(context.Background(),
		sac.AllowFixedScopes(
			sac.AccessModeScopeKeys(storage.Access_READ_WRITE_ACCESS),
			sac.ResourceScopeKeys(resources.VulnerabilityManagementApprovals)))
	approverAllSac = sac.WithGlobalAccessScopeChecker(context.Background(),
		sac.AllowFixedScopes(
			sac.AccessModeScopeKeys(storage.Access_READ_ACCESS, storage.Access_READ_WRITE_ACCESS),
			sac.ResourceScopeKeys(resources.VulnerabilityManagementApprovals)))
	selfApproverReadSac = sac.WithGlobalAccessScopeChecker(context.Background(),
		sac.AllowFixedScopes(
			sac.AccessModeScopeKeys(storage.Access_READ_ACCESS),
			sac.ResourceScopeKeys(resources.VulnerabilityManagementRequests, resources.VulnerabilityManagementApprovals)))
	selfApproverWriteSac = sac.WithGlobalAccessScopeChecker(context.Background(),
		sac.AllowFixedScopes(
			sac.AccessModeScopeKeys(storage.Access_READ_WRITE_ACCESS),
			sac.ResourceScopeKeys(resources.VulnerabilityManagementRequests, resources.VulnerabilityManagementApprovals)))
	selfApproverAllSac = sac.WithGlobalAccessScopeChecker(context.Background(),
		sac.AllowFixedScopes(
			sac.AccessModeScopeKeys(storage.Access_READ_ACCESS, storage.Access_READ_WRITE_ACCESS),
			sac.ResourceScopeKeys(resources.VulnerabilityManagementRequests, resources.VulnerabilityManagementApprovals)))
)

const (
	fakeUserID = "user-id-a"
)

func TestVulnRequestDataStore(t *testing.T) {
	suite.Run(t, new(VulnRequestDataStoreTestSuite))
	t.Setenv(features.UnifiedCVEDeferral.EnvVar(), "true")
	suite.Run(t, new(VulnRequestDataStoreTestSuite))
}

type VulnRequestDataStoreTestSuite struct {
	suite.Suite

	mockCtrl           *gomock.Controller
	mockStore          *storeMock.MockStore
	mockSearcher       *searcherMock.MockSearcher
	mockIdentity       *mockIdentity.MockIdentity
	mockNamespaceStore *namespaceDSMocks.MockDataStore

	datastore DataStore
}

func (s *VulnRequestDataStoreTestSuite) SetupTest() {
	s.mockCtrl = gomock.NewController(s.T())

	s.mockStore = storeMock.NewMockStore(s.mockCtrl)
	s.mockSearcher = searcherMock.NewMockSearcher(s.mockCtrl)
	s.mockIdentity = mockIdentity.NewMockIdentity(s.mockCtrl)
	s.mockIdentity.EXPECT().UID().Return(fakeUserID).AnyTimes()
	s.mockIdentity.EXPECT().FullName().Return("First Last").AnyTimes()
	s.mockIdentity.EXPECT().FriendlyName().Return("DefinitelyNotBob").AnyTimes()

	s.mockNamespaceStore = namespaceDSMocks.NewMockDataStore(s.mockCtrl)

	s.datastore = &datastoreImpl{
		store:              s.mockStore,
		searcher:           s.mockSearcher,
		pendingReqCache:    cache.New(),
		namespaceDatastore: s.mockNamespaceStore,
	}
}

func (s *VulnRequestDataStoreTestSuite) TestCountRequiresReadOnAny() {
	for _, ctx := range []context.Context{requesterReadSac, requesterAllSac, approverReadSac, approverAllSac, selfApproverReadSac, selfApproverAllSac} {
		s.mockSearcher.EXPECT().Count(ctx, nil).Return(0, nil)
		_, err := s.datastore.Count(ctx, nil)
		s.NoError(err)
	}

	_, err := s.datastore.Count(noVMAccessSac, nil)
	s.ErrorIs(err, sac.ErrResourceAccessDenied)
}

func (s *VulnRequestDataStoreTestSuite) TestExistsRequiresReadOnAny() {
	for _, ctx := range []context.Context{requesterReadSac, requesterAllSac, approverReadSac, approverAllSac, selfApproverReadSac, selfApproverAllSac} {
		s.mockStore.EXPECT().Exists(ctx, "id").Return(false, nil)
		_, err := s.datastore.Exists(ctx, "id")
		s.NoError(err)
	}

	_, err := s.datastore.Exists(noVMAccessSac, "id")
	s.ErrorIs(err, sac.ErrResourceAccessDenied)
}

func (s *VulnRequestDataStoreTestSuite) TestGetRequiresReadOnAny() {
	for _, ctx := range []context.Context{requesterReadSac, requesterAllSac, approverReadSac, approverAllSac, selfApproverReadSac, selfApproverAllSac} {
		s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(nil, false, nil)
		_, _, err := s.datastore.Get(ctx, "id")
		s.NoError(err)
	}

	_, _, err := s.datastore.Get(noVMAccessSac, "id")
	s.ErrorIs(err, sac.ErrResourceAccessDenied)
}

func (s *VulnRequestDataStoreTestSuite) TestGetManyRequiresReadOnAny() {
	for _, ctx := range []context.Context{requesterReadSac, requesterAllSac, approverReadSac, approverAllSac, selfApproverReadSac, selfApproverAllSac} {
		s.mockStore.EXPECT().GetMany(ctx, []string{"id"}).Return(nil, nil, nil)
		_, err := s.datastore.GetMany(ctx, []string{"id"})
		s.NoError(err)
	}

	_, err := s.datastore.GetMany(noVMAccessSac, []string{"id"})
	s.ErrorIs(err, sac.ErrResourceAccessDenied)
}

func (s *VulnRequestDataStoreTestSuite) TestOnlyRequesterWithWriteCanAddRequest() {
	for _, ctx := range []context.Context{requesterWriteSac, requesterAllSac, selfApproverWriteSac, selfApproverAllSac} {
		s.mockStore.EXPECT().Upsert(gomock.Any(), nil).Return(nil)
		err := s.datastore.AddRequest(ctx, nil)
		s.NoError(err)
	}

	for _, ctx := range []context.Context{requesterReadSac, approverReadSac, approverWriteSac, approverAllSac, selfApproverReadSac, noVMAccessSac} {
		err := s.datastore.AddRequest(ctx, nil)
		s.ErrorIs(err, sac.ErrResourceAccessDenied)
	}
}

func (s *VulnRequestDataStoreTestSuite) TestOnlyApproversWithWriteCanUpdateStatus() {
	for _, ctx := range []context.Context{approverWriteSac, approverAllSac, selfApproverWriteSac, selfApproverAllSac} {
		req := &storage.VulnerabilityRequest{Requestor: &storage.SlimUser{Id: fakeUserID}, Expired: false}
		s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
		s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
		_, err := s.datastore.UpdateRequestStatus(ctx, "id", "approved", storage.RequestStatus_APPROVED)
		s.NoError(err)
	}

	for _, ctx := range []context.Context{requesterReadSac, requesterWriteSac, approverReadSac, selfApproverReadSac, noVMAccessSac} {
		_, err := s.datastore.UpdateRequestStatus(ctx, "id", "approved", storage.RequestStatus_APPROVED)
		s.ErrorIs(err, sac.ErrResourceAccessDenied)
	}
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateStatus() {
	if features.UnifiedCVEDeferral.Enabled() {
		s.T().SkipNow()
	}
	pendingReq := &storage.VulnerabilityRequest{Requestor: &storage.SlimUser{Id: fakeUserID}, Expired: false}
	pendingUpdateReq := &storage.VulnerabilityRequest{
		Status:    storage.RequestStatus_APPROVED_PENDING_UPDATE,
		Requestor: &storage.SlimUser{Id: fakeUserID},
		Expired:   false,
		Req: &storage.VulnerabilityRequest_DeferralReq{DeferralReq: &storage.DeferralRequest{
			Expiry: &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresOn{ExpiresOn: protocompat.TimestampNow()}},
		}},
		UpdatedReq: &storage.VulnerabilityRequest_UpdatedDeferralReq{UpdatedDeferralReq: &storage.DeferralRequest{
			Expiry: &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}},
		}},
	}
	cases := []struct {
		name                string
		existingReq         *storage.VulnerabilityRequest
		status              storage.RequestStatus
		expectedStatus      storage.RequestStatus
		expectedDeferralReq *storage.DeferralRequest
		expectedFpRequest   *storage.FalsePositiveRequest
	}{
		{
			name:                "Pending request should be approved",
			existingReq:         pendingReq.CloneVT(),
			status:              storage.RequestStatus_APPROVED,
			expectedStatus:      storage.RequestStatus_APPROVED,
			expectedDeferralReq: pendingReq.GetDeferralReq().CloneVT(),
			expectedFpRequest:   pendingReq.GetFpRequest().CloneVT(),
		},
		{
			name:                "Pending request should be denied",
			existingReq:         pendingReq.CloneVT(),
			status:              storage.RequestStatus_DENIED,
			expectedStatus:      storage.RequestStatus_DENIED,
			expectedDeferralReq: pendingReq.GetDeferralReq().CloneVT(),
			expectedFpRequest:   pendingReq.GetFpRequest().CloneVT(),
		},
		{
			name:                "Request pending update that was denied should go back to old approved state",
			existingReq:         pendingUpdateReq.CloneVT(),
			status:              storage.RequestStatus_DENIED,
			expectedStatus:      storage.RequestStatus_APPROVED,
			expectedDeferralReq: pendingUpdateReq.GetDeferralReq().CloneVT(),
			expectedFpRequest:   pendingUpdateReq.GetFpRequest().CloneVT(),
		},
		{
			name:           "Deferral request pending update that was approved should have req updated",
			existingReq:    pendingUpdateReq.CloneVT(),
			status:         storage.RequestStatus_APPROVED,
			expectedStatus: storage.RequestStatus_APPROVED,
			expectedDeferralReq: &storage.DeferralRequest{Expiry: &storage.RequestExpiry{
				Expiry: &storage.RequestExpiry_ExpiresOn{
					ExpiresOn: pendingUpdateReq.GetDeferralReq().GetExpiry().GetExpiresOn(),
				},
			}},
			expectedFpRequest: nil,
		},
	}
	for _, c := range cases {
		s.T().Run(c.name, func(t *testing.T) {
			s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(c.existingReq, true, nil)
			s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)

			resp, err := s.datastore.UpdateRequestStatus(selfApproverAllSac, "id", "status changed", c.status)
			s.NoError(err)
			s.Len(resp.Approvers, 1)
			s.Len(resp.Comments, 1)
			s.Equal(resp.Comments[0].Message, "status changed")
			s.Equal(resp.Status, c.expectedStatus)
			protoassert.Equal(t, resp.GetDeferralReq(), c.expectedDeferralReq)
			protoassert.Equal(t, resp.GetFpRequest(), c.expectedFpRequest)
			s.Nil(resp.UpdatedReq)
		})
	}
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateStatusAddsApproversAndComments() {
	req := &storage.VulnerabilityRequest{Requestor: &storage.SlimUser{Id: fakeUserID}, Expired: false}
	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
	resp, err := s.datastore.UpdateRequestStatus(authn.ContextWithIdentity(selfApproverAllSac, s.mockIdentity, s.T()), "id", "approved", storage.RequestStatus_APPROVED)
	s.NoError(err)

	s.Len(resp.Comments, 1)
	s.Equal(resp.Comments[0].Message, "approved")
	s.Equal(resp.Comments[0].User.Name, s.mockIdentity.FullName())

	s.Len(resp.Approvers, 1)
	s.Equal(resp.Approvers[0].Name, s.mockIdentity.FullName())
}

func (s *VulnRequestDataStoreTestSuite) TestCannotUpdateStatusToPending() {
	_, err := s.datastore.UpdateRequestStatus(authn.ContextWithIdentity(selfApproverAllSac, s.mockIdentity, s.T()), "id", "approved", storage.RequestStatus_PENDING)
	s.EqualError(err, "vulnerability request cannot be moved to pending state")
}

func (s *VulnRequestDataStoreTestSuite) TestCannotUpdateStatusToApprovedPendingUpdate() {
	_, err := s.datastore.UpdateRequestStatus(authn.ContextWithIdentity(selfApproverAllSac, s.mockIdentity, s.T()), "id", "approved", storage.RequestStatus_APPROVED_PENDING_UPDATE)
	s.EqualError(err, "vulnerability request cannot be moved to pending state")
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateStatusRequiresComment() {
	_, err := s.datastore.UpdateRequestStatus(authn.ContextWithIdentity(selfApproverAllSac, s.mockIdentity, s.T()), "id", "", storage.RequestStatus_APPROVED)
	s.EqualError(err, "comment is required when approving/denying a vulnerability request")
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateStatus_UnifiedCVEDeferral() {
	if !features.UnifiedCVEDeferral.Enabled() {
		s.T().SkipNow()
	}
	pendingDefReq := fixtures.GetGlobalDeferralRequestV2("cve-1", "cve-2")
	defUpdate := &storage.VulnerabilityRequest_DeferralUpdate{
		DeferralUpdate: &storage.DeferralUpdate{
			Expiry: &storage.RequestExpiry{
				Expiry: &storage.RequestExpiry_ExpiresOn{ExpiresOn: protocompat.TimestampNow()},
			},
			CVEs: []string{"cve-1"},
		},
	}
	pendingDefUpdateReq := pendingDefReq.CloneVT()
	pendingDefUpdateReq.UpdatedReq = defUpdate
	pendingDefUpdateReq.Status = storage.RequestStatus_APPROVED_PENDING_UPDATE

	pendingFpReq := fixtures.GetGlobalFPRequestV2("cve-1", "cve-2")
	fpUpdate := &storage.VulnerabilityRequest_FalsePositiveUpdate{
		FalsePositiveUpdate: &storage.FalsePositiveUpdate{
			CVEs: []string{"cve-1"},
		},
	}
	pendingFpUpdateReq := pendingFpReq.CloneVT()
	pendingFpUpdateReq.UpdatedReq = fpUpdate
	pendingFpUpdateReq.Status = storage.RequestStatus_APPROVED_PENDING_UPDATE

	cases := []struct {
		name                string
		existingReq         *storage.VulnerabilityRequest
		status              storage.RequestStatus
		expectedStatus      storage.RequestStatus
		expectedDeferralReq *storage.DeferralRequest
		expectedFpRequest   *storage.FalsePositiveRequest
		expectedCVEs        []string
	}{
		{
			name:                "Pending request should be approved",
			existingReq:         pendingDefReq.CloneVT(),
			status:              storage.RequestStatus_APPROVED,
			expectedStatus:      storage.RequestStatus_APPROVED,
			expectedDeferralReq: pendingDefReq.GetDeferralReq().CloneVT(),
			expectedFpRequest:   pendingDefReq.GetFpRequest().CloneVT(),
			expectedCVEs:        pendingDefReq.CloneVT().GetCves().GetCves(),
		},
		{
			name:                "Pending request should be denied",
			existingReq:         pendingDefReq.CloneVT(),
			status:              storage.RequestStatus_DENIED,
			expectedStatus:      storage.RequestStatus_DENIED,
			expectedDeferralReq: pendingDefReq.GetDeferralReq().CloneVT(),
			expectedFpRequest:   pendingDefReq.GetFpRequest().CloneVT(),
			expectedCVEs:        pendingDefReq.CloneVT().GetCves().GetCves(),
		},
		{
			name:                "Request pending update that was denied should go back to old approved state",
			existingReq:         pendingDefUpdateReq.CloneVT(),
			status:              storage.RequestStatus_DENIED,
			expectedStatus:      storage.RequestStatus_APPROVED,
			expectedDeferralReq: pendingDefUpdateReq.GetDeferralReq().CloneVT(),
			expectedFpRequest:   pendingDefUpdateReq.GetFpRequest().CloneVT(),
			expectedCVEs:        pendingDefUpdateReq.CloneVT().GetCves().GetCves(),
		},
		{
			name:                "Deferral request pending update that was approved should have req and entities updated",
			existingReq:         pendingDefUpdateReq.CloneVT(),
			status:              storage.RequestStatus_APPROVED,
			expectedStatus:      storage.RequestStatus_APPROVED,
			expectedDeferralReq: &storage.DeferralRequest{Expiry: defUpdate.DeferralUpdate.GetExpiry()},
			expectedFpRequest:   nil,
			expectedCVEs:        defUpdate.DeferralUpdate.GetCVEs(),
		},
		{
			name:                "False positive request pending update that was approved should have req and entities updated",
			existingReq:         pendingFpUpdateReq,
			status:              storage.RequestStatus_APPROVED,
			expectedStatus:      storage.RequestStatus_APPROVED,
			expectedDeferralReq: nil,
			expectedFpRequest:   &storage.FalsePositiveRequest{},
			expectedCVEs:        fpUpdate.FalsePositiveUpdate.GetCVEs(),
		},
	}

	for _, c := range cases {
		s.T().Run(c.name, func(t *testing.T) {
			s.mockStore.EXPECT().Get(gomock.Any(), c.existingReq.GetId()).Return(c.existingReq, true, nil)
			s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
			if c.status == storage.RequestStatus_APPROVED {
				s.mockNamespaceStore.EXPECT().GetAllNamespaces(gomock.Any()).Return(nil, nil)
			}

			resp, err := s.datastore.UpdateRequestStatus(authn.ContextWithIdentity(selfApproverAllSac, s.mockIdentity, s.T()), c.existingReq.GetId(), "status changed", c.status)
			s.NoError(err)
			s.Len(resp.Comments, 2)
			s.Equal("status changed", resp.Comments[1].Message)
			s.Len(resp.ApproversV2, 1)
			s.Equal(resp.ApproversV2[0].Name, s.mockIdentity.FullName())
			s.Equal(c.expectedStatus, resp.Status)
			protoassert.Equal(t, c.expectedDeferralReq, resp.GetDeferralReq())
			protoassert.Equal(t, c.expectedFpRequest, resp.GetFpRequest())
			s.Equal(c.expectedCVEs, resp.GetCves().GetCves())
		})
	}
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestExpiryRequiresWriteOnAny() {
	expiry := &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}}
	req := fixtures.GetGlobalDeferralRequest("cve-a-b-c")
	req.Requestor = &storage.SlimUser{Id: fakeUserID}

	for _, ctx := range []context.Context{requesterWriteSac, requesterAllSac, approverWriteSac, approverAllSac, selfApproverWriteSac, selfApproverAllSac} {
		s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
		s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
		_, err := s.datastore.UpdateRequestExpiry(authn.ContextWithIdentity(ctx, s.mockIdentity, s.T()), "id", "update comment", expiry)
		s.NoError(err)
	}

	for _, ctx := range []context.Context{requesterReadSac, approverReadSac, selfApproverReadSac, noVMAccessSac} {
		_, err := s.datastore.UpdateRequestExpiry(ctx, "id", "update comment", expiry)
		s.ErrorIs(err, sac.ErrResourceAccessDenied)
	}
}

func (s *VulnRequestDataStoreTestSuite) TestRequesterCannotUpdateOthersRequestExpiry() {
	expiry := &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresOn{ExpiresOn: protocompat.TimestampNow()}}
	for _, ctx := range []context.Context{requesterWriteSac, requesterAllSac} {
		req := &storage.VulnerabilityRequest{Requestor: &storage.SlimUser{Id: "another users id"}, Expired: false}
		s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
		_, err := s.datastore.UpdateRequestExpiry(authn.ContextWithIdentity(ctx, s.mockIdentity, s.T()), "id", "comment", expiry)
		s.ErrorIs(err, sac.ErrResourceAccessDenied)
	}
}

func (s *VulnRequestDataStoreTestSuite) TestApproversCanUpdateOthersRequestExpiry() {
	expiry := &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}}
	req := fixtures.GetGlobalDeferralRequest("cve-a-b-c")
	req.Requestor = &storage.SlimUser{Id: "another users id"}

	for _, ctx := range []context.Context{approverWriteSac, approverAllSac, selfApproverWriteSac, selfApproverAllSac} {
		s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
		s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
		_, err := s.datastore.UpdateRequestExpiry(authn.ContextWithIdentity(ctx, s.mockIdentity, s.T()), "id", "comment", expiry)
		s.NoError(err)
	}
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateExpiryRequiresComment() {
	_, err := s.datastore.UpdateRequestExpiry(authn.ContextWithIdentity(selfApproverAllSac, s.mockIdentity, s.T()), "id", "",
		&storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}})
	s.EqualError(err, "comment is required when updating a request's expiry")
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestExpiryFailsINotDeferralRequest() {
	expiry := &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}}
	req := fixtures.GetGlobalFPRequest("cve-a-b-c")

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	_, err := s.datastore.UpdateRequestExpiry(authn.ContextWithIdentity(approverWriteSac, s.mockIdentity, s.T()), "id", "update comment", expiry)
	s.EqualError(err, fmt.Sprintf("request %s is not a deferral request thus doesn't have an expiry to update", req.GetId()))
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestExpiryFailsIfRequestWasDenied() {
	expiry := &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}}
	req := fixtures.GetGlobalDeferralRequest("cve-a-b-c")
	req.Status = storage.RequestStatus_DENIED

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	_, err := s.datastore.UpdateRequestExpiry(authn.ContextWithIdentity(approverWriteSac, s.mockIdentity, s.T()), "id", "update comment", expiry)
	s.EqualError(err, fmt.Sprintf("request %s already expired or denied thus cannot be updated", req.GetId()))
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestExpiryFailsIfRequestWasExpired() {
	expiry := &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}}
	req := fixtures.GetGlobalDeferralRequest("cve-a-b-c")
	req.Expired = true

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	_, err := s.datastore.UpdateRequestExpiry(authn.ContextWithIdentity(approverWriteSac, s.mockIdentity, s.T()), "id", "update comment", expiry)
	s.EqualError(err, fmt.Sprintf("request %s already expired or denied thus cannot be updated", req.GetId()))
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestExpiryUpdatesExpiryIfRequestWasPending() {
	expiry := &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}}
	req := fixtures.GetGlobalDeferralRequest("cve-a-b-c")
	req.Requestor = &storage.SlimUser{Id: fakeUserID}
	req.Status = storage.RequestStatus_PENDING

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
	resp, err := s.datastore.UpdateRequestExpiry(authn.ContextWithIdentity(requesterWriteSac, s.mockIdentity, s.T()), "id", "update comment", expiry)
	s.NoError(err)

	protoassert.Equal(s.T(), expiry, resp.GetDeferralReq().GetExpiry())
	s.Nilf(resp.GetUpdatedReq(), "updated field should be nil since original request was still pending")
	s.Equal(storage.RequestStatus_PENDING, resp.Status)
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestExpiryUpdatesExpiryIfRequestWasPendingUpdate() {
	expiry := &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}}
	req := fixtures.GetGlobalDeferralRequest("cve-a-b-c")
	req.UpdatedReq = &storage.VulnerabilityRequest_UpdatedDeferralReq{UpdatedDeferralReq: req.GetDeferralReq().CloneVT()}
	req.Requestor = &storage.SlimUser{Id: fakeUserID}
	req.Status = storage.RequestStatus_APPROVED_PENDING_UPDATE

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
	resp, err := s.datastore.UpdateRequestExpiry(authn.ContextWithIdentity(requesterWriteSac, s.mockIdentity, s.T()), "id", "update comment", expiry)
	s.NoError(err)

	protoassert.Equal(s.T(), expiry, resp.GetUpdatedDeferralReq().GetExpiry())
	protoassert.Equal(s.T(), req.GetDeferralReq(), resp.GetDeferralReq(), "original request should not have been updated")
	protoassert.Equal(s.T(), req.GetFpRequest(), resp.GetFpRequest(), "original request should not have been updated")
	s.Equal(storage.RequestStatus_APPROVED_PENDING_UPDATE, resp.Status)
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestExpirySetsUpdatedIfOriginallyApproved() {
	expiry := &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}}
	req := fixtures.GetGlobalDeferralRequest("cve-a-b-c")
	req.Requestor = &storage.SlimUser{Id: fakeUserID}
	req.Status = storage.RequestStatus_APPROVED

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
	resp, err := s.datastore.UpdateRequestExpiry(authn.ContextWithIdentity(requesterWriteSac, s.mockIdentity, s.T()), "id", "update comment", expiry)
	s.NoError(err)

	protoassert.Equal(s.T(), expiry, resp.GetUpdatedDeferralReq().GetExpiry())
	protoassert.Equal(s.T(), req.GetDeferralReq(), resp.GetDeferralReq(), "original request should not have been updated")
	protoassert.Equal(s.T(), req.GetFpRequest(), resp.GetFpRequest(), "original request should not have been updated")
	s.Equal(storage.RequestStatus_APPROVED_PENDING_UPDATE, resp.Status)
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestFailsIfRequestWasDenied() {
	if !features.UnifiedCVEDeferral.Enabled() {
		s.T().SkipNow()
	}
	update := &common.UpdateRequest{
		DeferralUpdate: &storage.DeferralUpdate{
			CVEs:   []string{"cve-1"},
			Expiry: &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}},
		},
	}

	req := fixtures.GetGlobalDeferralRequestV2("cve-a-b-c")
	req.Status = storage.RequestStatus_DENIED

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	_, err := s.datastore.UpdateRequest(authn.ContextWithIdentity(approverWriteSac, s.mockIdentity, s.T()), "id", update)
	s.EqualError(err, fmt.Sprintf("request %s cannot be updated because it has expired or has been denied", req.GetId()))
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestFailsIfTypeIsDifferent() {
	if !features.UnifiedCVEDeferral.Enabled() {
		s.T().SkipNow()
	}

	// Test deferral update on false positive request.
	update := &common.UpdateRequest{
		DeferralUpdate: &storage.DeferralUpdate{
			CVEs:   []string{"cve-1"},
			Expiry: &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}},
		},
	}

	req := fixtures.GetGlobalFPRequestV2("cve-a-b-c")
	req.Status = storage.RequestStatus_APPROVED

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	_, err := s.datastore.UpdateRequest(authn.ContextWithIdentity(approverWriteSac, s.mockIdentity, s.T()), "id", update)
	s.EqualError(err, fmt.Sprintf("exception %s cannot be updated. Exception type(defer/false positive) cannot be changed", req.GetId()))

	// Test false positive update on deferral request.
	update = &common.UpdateRequest{
		FalsePositiveUpdate: &storage.FalsePositiveUpdate{
			CVEs: []string{"cve-1"},
		},
	}

	req = fixtures.GetGlobalDeferralRequestV2("cve-a-b-c")
	req.Status = storage.RequestStatus_APPROVED

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	_, err = s.datastore.UpdateRequest(authn.ContextWithIdentity(approverWriteSac, s.mockIdentity, s.T()), "id", update)
	s.EqualError(err, fmt.Sprintf("exception %s cannot be updated. Exception type(defer/false positive) cannot be changed", req.GetId()))

}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestFailsIfNoOp() {
	if !features.UnifiedCVEDeferral.Enabled() {
		s.T().SkipNow()
	}

	// Test deferral update on false positive request.
	update := &common.UpdateRequest{
		DeferralUpdate: &storage.DeferralUpdate{
			CVEs:   []string{"cve-1"},
			Expiry: &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}},
		},
	}

	req := fixtures.GetGlobalDeferralRequestV2("cve-1")
	req.Status = storage.RequestStatus_APPROVED
	req.GetDeferralReq().Expiry = update.DeferralUpdate.GetExpiry().CloneVT()

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	_, err := s.datastore.UpdateRequest(authn.ContextWithIdentity(approverWriteSac, s.mockIdentity, s.T()), "id", update)
	s.EqualError(err, fmt.Sprintf("the update does not change the exception %s", req.GetId()))

	// Test false positive update on deferral request.
	update = &common.UpdateRequest{
		FalsePositiveUpdate: &storage.FalsePositiveUpdate{
			CVEs: []string{"cve-1"},
		},
	}

	req = fixtures.GetGlobalFPRequestV2("cve-1")
	req.Status = storage.RequestStatus_APPROVED

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	_, err = s.datastore.UpdateRequest(authn.ContextWithIdentity(approverWriteSac, s.mockIdentity, s.T()), "id", update)
	s.EqualError(err, fmt.Sprintf("the update does not change the exception %s", req.GetId()))
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestFailsIfRequestWasExpired() {
	if !features.UnifiedCVEDeferral.Enabled() {
		s.T().SkipNow()
	}
	update := &common.UpdateRequest{
		DeferralUpdate: &storage.DeferralUpdate{
			CVEs:   []string{"cve-1"},
			Expiry: &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}},
		},
	}
	req := fixtures.GetGlobalDeferralRequestV2("cve-a-b-c")
	req.Expired = true

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	_, err := s.datastore.UpdateRequest(authn.ContextWithIdentity(approverWriteSac, s.mockIdentity, s.T()), "id", update)
	s.EqualError(err, fmt.Sprintf("request %s cannot be updated because it has expired or has been denied", req.GetId()))
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestSucceedsIfDeferralRequestWasPending() {
	if !features.UnifiedCVEDeferral.Enabled() {
		s.T().SkipNow()
	}
	update := &common.UpdateRequest{
		DeferralUpdate: &storage.DeferralUpdate{
			CVEs:   []string{"cve-1"},
			Expiry: &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}},
		},
	}
	req := fixtures.GetGlobalDeferralRequestV2("cve-a-b-c")
	req.Requestor = &storage.SlimUser{Id: fakeUserID}
	req.Status = storage.RequestStatus_PENDING

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
	resp, err := s.datastore.UpdateRequest(authn.ContextWithIdentity(requesterWriteSac, s.mockIdentity, s.T()), "id", update)
	s.NoError(err)

	protoassert.Equal(s.T(), update.DeferralUpdate.GetExpiry(), resp.GetDeferralReq().GetExpiry())
	s.Equal(update.DeferralUpdate.GetCVEs(), resp.GetCves().GetCves())
	s.Nil(resp.GetUpdatedReq())
	s.Equal(storage.RequestStatus_PENDING, resp.Status)
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestSucceedsIfDeferralUpdateWasPending() {
	if !features.UnifiedCVEDeferral.Enabled() {
		s.T().SkipNow()
	}
	update := &common.UpdateRequest{
		DeferralUpdate: &storage.DeferralUpdate{
			CVEs:   []string{"cve-1"},
			Expiry: &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}},
		},
	}
	req := fixtures.GetGlobalDeferralRequestV2("cve-a-b-c")
	req.UpdatedReq = &storage.VulnerabilityRequest_UpdatedDeferralReq{UpdatedDeferralReq: req.GetDeferralReq().CloneVT()}
	req.Requestor = &storage.SlimUser{Id: fakeUserID}
	req.Status = storage.RequestStatus_APPROVED_PENDING_UPDATE

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
	resp, err := s.datastore.UpdateRequest(authn.ContextWithIdentity(requesterWriteSac, s.mockIdentity, s.T()), "id", update)
	s.NoError(err)

	protoassert.Equal(s.T(), update.DeferralUpdate, resp.GetDeferralUpdate())
	s.Equal([]string{"cve-a-b-c"}, resp.GetCves().GetCves())
	s.Equal(storage.RequestStatus_APPROVED_PENDING_UPDATE, resp.GetStatus())
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestSucceedsIfOriginalDeferralReqApproved() {
	if !features.UnifiedCVEDeferral.Enabled() {
		s.T().SkipNow()
	}
	update := &common.UpdateRequest{
		DeferralUpdate: &storage.DeferralUpdate{
			CVEs: []string{"cve-1"},
		},
	}
	req := fixtures.GetGlobalDeferralRequestV2("cve-a-b-c")
	req.Requestor = &storage.SlimUser{Id: fakeUserID}
	req.Status = storage.RequestStatus_APPROVED

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
	resp, err := s.datastore.UpdateRequest(authn.ContextWithIdentity(requesterWriteSac, s.mockIdentity, s.T()), "id", update)
	s.NoError(err)

	protoassert.Equal(s.T(), req.GetFalsePositiveUpdate(), resp.GetFalsePositiveUpdate())
	s.Equal([]string{"cve-a-b-c"}, req.GetCves().GetCves())
	s.Equal(storage.RequestStatus_APPROVED_PENDING_UPDATE, resp.GetStatus())
}

func (s *VulnRequestDataStoreTestSuite) TestUpdateRequestSucceedsIfOriginalFPReqApproved() {
	if !features.UnifiedCVEDeferral.Enabled() {
		s.T().SkipNow()
	}
	update := &common.UpdateRequest{
		DeferralUpdate: &storage.DeferralUpdate{
			CVEs:   []string{"cve-1"},
			Expiry: &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}},
		},
	}
	req := fixtures.GetGlobalDeferralRequestV2("cve-a-b-c")
	req.Requestor = &storage.SlimUser{Id: fakeUserID}
	req.Status = storage.RequestStatus_APPROVED

	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
	resp, err := s.datastore.UpdateRequest(authn.ContextWithIdentity(requesterWriteSac, s.mockIdentity, s.T()), "id", update)
	s.NoError(err)

	protoassert.Equal(s.T(), update.DeferralUpdate, resp.GetDeferralUpdate())
	s.Equal([]string{"cve-a-b-c"}, req.GetCves().GetCves())
	s.Equal(storage.RequestStatus_APPROVED_PENDING_UPDATE, resp.Status)
}

func (s *VulnRequestDataStoreTestSuite) TestMarkRequestInactiveRequiresWriteOnAny() {
	for _, ctx := range []context.Context{requesterWriteSac, requesterAllSac, approverWriteSac, approverAllSac, selfApproverWriteSac, selfApproverAllSac} {
		req := &storage.VulnerabilityRequest{Requestor: &storage.SlimUser{Id: fakeUserID}, Expired: false}
		s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
		s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
		_, err := s.datastore.MarkRequestInactive(authn.ContextWithIdentity(ctx, s.mockIdentity, s.T()), "id", "comment")
		s.NoError(err)
	}

	for _, ctx := range []context.Context{requesterReadSac, approverReadSac, selfApproverReadSac, noVMAccessSac} {
		_, err := s.datastore.MarkRequestInactive(ctx, "id", "comment")
		s.ErrorIs(err, sac.ErrResourceAccessDenied)
	}
}

func (s *VulnRequestDataStoreTestSuite) TestRequesterCannotMarkOthersRequestInactive() {
	for _, ctx := range []context.Context{requesterWriteSac, requesterAllSac} {
		req := &storage.VulnerabilityRequest{Requestor: &storage.SlimUser{Id: "another users id"}, Expired: false}
		s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
		_, err := s.datastore.MarkRequestInactive(authn.ContextWithIdentity(ctx, s.mockIdentity, s.T()), "id", "comment")
		s.ErrorIs(err, sac.ErrResourceAccessDenied)
	}
}

func (s *VulnRequestDataStoreTestSuite) TestApproversCanMarkOthersRequestInactive() {
	for _, ctx := range []context.Context{approverWriteSac, approverAllSac, selfApproverWriteSac, selfApproverAllSac} {
		req := &storage.VulnerabilityRequest{Requestor: &storage.SlimUser{Id: "another users id"}, Expired: false}
		s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
		s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
		_, err := s.datastore.MarkRequestInactive(authn.ContextWithIdentity(ctx, s.mockIdentity, s.T()), "id", "comment")
		s.NoError(err)
	}
}

func (s *VulnRequestDataStoreTestSuite) TestMarkRequestInactiveFailsWhenAlreadyInactive() {
	for _, ctx := range []context.Context{requesterWriteSac, requesterAllSac, approverWriteSac, approverAllSac, selfApproverWriteSac, selfApproverAllSac} {
		req := &storage.VulnerabilityRequest{Requestor: &storage.SlimUser{Id: fakeUserID}, Expired: true}
		s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
		_, err := s.datastore.MarkRequestInactive(authn.ContextWithIdentity(ctx, s.mockIdentity, s.T()), "id", "comment")
		s.EqualError(err, "vulnerability request id has expired. Undo is noop")
	}
}

func (s *VulnRequestDataStoreTestSuite) TestMarkRequestInactiveSetsComment() {
	req := &storage.VulnerabilityRequest{Requestor: &storage.SlimUser{Id: fakeUserID}, Expired: false}
	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Return(nil)
	resp, err := s.datastore.MarkRequestInactive(authn.ContextWithIdentity(selfApproverAllSac, s.mockIdentity, s.T()), "id", "this is a comment")
	s.NoError(err)
	s.Len(resp.Comments, 1)
	s.Equal(resp.Comments[0].Message, "this is a comment")
	s.Equal(resp.Comments[0].User.Name, s.mockIdentity.FullName())
}

func (s *VulnRequestDataStoreTestSuite) TestOnlyRequesterWithWriteCanRemoveOwnRequest() {
	for _, ctx := range []context.Context{requesterWriteSac, requesterAllSac, selfApproverWriteSac, selfApproverAllSac} {
		req := &storage.VulnerabilityRequest{Requestor: &storage.SlimUser{Id: fakeUserID}}
		s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
		s.mockStore.EXPECT().Delete(gomock.Any(), "id").Return(nil)
		err := s.datastore.RemoveRequest(authn.ContextWithIdentity(ctx, s.mockIdentity, s.T()), "id")
		s.NoError(err)
	}

	for _, ctx := range []context.Context{requesterReadSac, approverReadSac, approverWriteSac, approverAllSac, selfApproverReadSac, noVMAccessSac} {
		err := s.datastore.RemoveRequest(ctx, "id")
		s.ErrorIs(err, sac.ErrResourceAccessDenied)
	}
}

func (s *VulnRequestDataStoreTestSuite) TestOnlyRequesterWithWriteCannotRemoveOthersRequests() {
	for _, ctx := range []context.Context{requesterWriteSac, requesterAllSac, selfApproverWriteSac, selfApproverAllSac} {
		req := &storage.VulnerabilityRequest{Requestor: &storage.SlimUser{Id: "another users id"}}
		s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
		err := s.datastore.RemoveRequest(authn.ContextWithIdentity(ctx, s.mockIdentity, s.T()), "id")
		s.ErrorIs(err, sac.ErrResourceAccessDenied)
	}
}

func (s *VulnRequestDataStoreTestSuite) TestRemoveRequestPending() {
	req := &storage.VulnerabilityRequest{
		Requestor:  &storage.SlimUser{Id: fakeUserID},
		Expired:    false,
		Status:     storage.RequestStatus_PENDING,
		UpdatedReq: &storage.VulnerabilityRequest_UpdatedDeferralReq{},
	}
	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	s.mockStore.EXPECT().Delete(gomock.Any(), "id").Return(nil)
	err := s.datastore.RemoveRequest(authn.ContextWithIdentity(selfApproverAllSac, s.mockIdentity, s.T()), "id")
	s.NoError(err)
}

func (s *VulnRequestDataStoreTestSuite) TestRemoveRequestPendingUpdate() {
	req := &storage.VulnerabilityRequest{
		Requestor:  &storage.SlimUser{Id: fakeUserID},
		Expired:    false,
		Status:     storage.RequestStatus_APPROVED_PENDING_UPDATE,
		UpdatedReq: &storage.VulnerabilityRequest_UpdatedDeferralReq{},
	}
	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	s.mockStore.EXPECT().Upsert(gomock.Any(), gomock.Any()).Do(func(_ context.Context, req *storage.VulnerabilityRequest) {
		s.Equal(storage.RequestStatus_APPROVED, req.GetStatus())
		s.Nil(req.UpdatedReq)
	}).Return(nil)

	err := s.datastore.RemoveRequest(authn.ContextWithIdentity(selfApproverAllSac, s.mockIdentity, s.T()), "id")
	s.NoError(err)
}

func (s *VulnRequestDataStoreTestSuite) TestRemoveRequestApproved() {
	req := &storage.VulnerabilityRequest{
		Requestor:  &storage.SlimUser{Id: fakeUserID},
		Expired:    false,
		Status:     storage.RequestStatus_APPROVED,
		UpdatedReq: &storage.VulnerabilityRequest_UpdatedDeferralReq{},
	}
	s.mockStore.EXPECT().Get(gomock.Any(), "id").Return(req, true, nil)
	err := s.datastore.RemoveRequest(authn.ContextWithIdentity(selfApproverAllSac, s.mockIdentity, s.T()), "id")
	s.Error(err)
}
