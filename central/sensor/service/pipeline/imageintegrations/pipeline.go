package imageintegrations

import (
	"context"
	"fmt"
	"strings"

	"github.com/pkg/errors"
	clusterDatastore "github.com/stackrox/stackrox/central/cluster/datastore"
	"github.com/stackrox/stackrox/central/enrichment"
	"github.com/stackrox/stackrox/central/imageintegration/datastore"
	countMetrics "github.com/stackrox/stackrox/central/metrics"
	"github.com/stackrox/stackrox/central/reprocessor"
	"github.com/stackrox/stackrox/central/sensor/service/common"
	"github.com/stackrox/stackrox/central/sensor/service/pipeline"
	"github.com/stackrox/stackrox/central/sensor/service/pipeline/reconciliation"
	v1 "github.com/stackrox/stackrox/generated/api/v1"
	"github.com/stackrox/stackrox/generated/internalapi/central"
	"github.com/stackrox/stackrox/generated/storage"
	"github.com/stackrox/stackrox/pkg/env"
	"github.com/stackrox/stackrox/pkg/logging"
	"github.com/stackrox/stackrox/pkg/metrics"
	"github.com/stackrox/stackrox/pkg/tlscheck"
	"github.com/stackrox/stackrox/pkg/urlfmt"
)

var (
	log = logging.LoggerForModule()

	autogeneratedRegistriesDisabled = env.AutogeneratedRegistriesDisabled.BooleanSetting()
)

// GetPipeline returns an instantiation of this particular pipeline
func GetPipeline() pipeline.Fragment {
	return NewPipeline(enrichment.ManagerSingleton(),
		datastore.Singleton(),
		clusterDatastore.Singleton(),
		reprocessor.Singleton())
}

// NewPipeline returns a new instance of Pipeline.
func NewPipeline(integrationManager enrichment.Manager,
	datastore datastore.DataStore,
	clusterDatastore clusterDatastore.DataStore,
	enrichAndDetectLoop reprocessor.Loop) pipeline.Fragment {
	return &pipelineImpl{
		integrationManager:  integrationManager,
		datastore:           datastore,
		clusterDatastore:    clusterDatastore,
		enrichAndDetectLoop: enrichAndDetectLoop,
	}
}

type pipelineImpl struct {
	integrationManager enrichment.Manager

	datastore           datastore.DataStore
	clusterDatastore    clusterDatastore.DataStore
	enrichAndDetectLoop reprocessor.Loop
}

func (s *pipelineImpl) Reconcile(_ context.Context, _ string, _ *reconciliation.StoreMap) error {
	// Nothing to reconcile for image integrations
	return nil
}

func (s *pipelineImpl) Match(msg *central.MsgFromSensor) bool {
	return msg.GetEvent().GetImageIntegration() != nil
}

// matchesDockerAuth matches Docker integrations based on their authentication
// attributes.
func matchesDockerAuth(new, old *storage.ImageIntegration) bool {
	return new.GetDocker().GetUsername() == old.GetDocker().GetUsername() &&
		new.GetDocker().GetPassword() == old.GetDocker().GetPassword()
}

// matchesECRAuth matches ECR integrations based on their Authentication Data.
func matchesECRAuth(new, old *storage.ImageIntegration) bool {
	newAuth := new.GetEcr().GetAuthorizationData()
	oldAuth := old.GetEcr().GetAuthorizationData()
	return newAuth == nil && oldAuth == nil ||
		newAuth.GetUsername() == oldAuth.GetUsername() &&
			newAuth.GetPassword() == oldAuth.GetPassword() &&
			newAuth.GetExpiresAt().Equal(oldAuth.GetExpiresAt())
}

// matchingFunc returns true if the new integration matches the old integration.
type matchingFunc func(new, old *storage.ImageIntegration) bool

// getMatchingImageIntegration returns the image integration that exists and should be updated
// the second return value
func (s *pipelineImpl) getMatchingImageIntegration(matches matchingFunc, auto *storage.ImageIntegration, existingIntegrations []*storage.ImageIntegration) (*storage.ImageIntegration, bool) {
	for _, existing := range existingIntegrations {
		if auto.GetName() != existing.GetName() {
			continue
		}

		// If there exists a registry with an auto-generated name, and the user has somehow managed
		// (most likely through the API) to mark it as non-autogenerated, we do not want to overwrite
		// it.
		if !existing.GetAutogenerated() {
			return nil, false
		}

		// At this point, we just want to see if we already have an exact match
		// if so then we don't want to reprocess everything for no change.
		// The cluster ID can only be different if a cluster with this name was deleted
		// and then another with the same name was created. In this case, we do want to update
		// the integration, if only for the sake of updating the cluster ID.
		if matches(auto, existing) && auto.GetType() == existing.GetType() && auto.GetClusterId() == existing.GetClusterId() {
			return nil, false
		}
		return existing, true
	}

	return nil, true
}

func parseEndpointForURL(endpoint string) string {
	url := urlfmt.FormatURL(endpoint, urlfmt.HTTPS, urlfmt.NoTrailingSlash)

	server := urlfmt.GetServerFromURL(url)
	if strings.HasSuffix(server, "docker.io") || strings.HasSuffix(server, "docker.io:443") {
		return "https://registry-1.docker.io"
	}

	scheme := urlfmt.GetSchemeFromURL(url)
	defaultScheme := urlfmt.HTTPS
	if scheme == "http" {
		defaultScheme = urlfmt.InsecureHTTP
	}
	return urlfmt.FormatURL(server, defaultScheme, urlfmt.NoTrailingSlash)
}

// setUpIntegrationParams sets up the integration parameters based on its type
// and returns them.
func setUpIntegrationParams(ctx context.Context, imageIntegration *storage.ImageIntegration) (description string, matches matchingFunc, err error) {
	switch config := imageIntegration.GetIntegrationConfig().(type) {
	case *storage.ImageIntegration_Docker:
		dockerCfg := config.Docker
		var validTLS bool
		validTLS, err = tlscheck.CheckTLS(ctx, dockerCfg.GetEndpoint())
		if err != nil {
			err = errors.Wrapf(err, "reaching out for TLS check to %s", dockerCfg.GetEndpoint())
			return
		}
		dockerCfg.Insecure = !validTLS
		dockerCfg.Endpoint = parseEndpointForURL(dockerCfg.GetEndpoint())
		description = dockerCfg.GetEndpoint()
		matches = matchesDockerAuth
	case *storage.ImageIntegration_Ecr:
		description = config.Ecr.GetEndpoint()
		if description == "" {
			description = fmt.Sprintf("AWS account %s and region %s", config.Ecr.GetRegistryId(), config.Ecr.GetRegion())
		}
		matches = matchesECRAuth
	default:
		err = errors.Errorf("unsupported autogenerated integration type: %T", config)
	}
	return
}

// Run runs the pipeline template on the input and returns the output.
// Action is currently always update.
func (s *pipelineImpl) Run(ctx context.Context, clusterID string, msg *central.MsgFromSensor, _ common.MessageInjector) error {
	// Ignore autogenerated registries if they are disabled
	if autogeneratedRegistriesDisabled {
		return nil
	}

	defer countMetrics.IncrementResourceProcessedCounter(pipeline.ActionToOperation(msg.GetEvent().GetAction()), metrics.ImageIntegration)

	// Extract the cluster name.
	clusterName, exists, err := s.clusterDatastore.GetClusterName(ctx, clusterID)
	if err != nil {
		return errors.Wrapf(err, "error getting cluster name for cluster ID: %s", clusterID)
	}
	if !exists {
		return fmt.Errorf("cluster with id %q does not exist", clusterID)
	}

	// Set up the integration and update its parameters.
	imageIntegration := msg.GetEvent().GetImageIntegration()
	description, matches, err := setUpIntegrationParams(ctx, imageIntegration)
	if err != nil {
		return err
	}
	imageIntegration.Name = fmt.Sprintf("Autogenerated %s for cluster %s", description, clusterName)
	imageIntegration.ClusterId = clusterID

	// Fetch existing integration and determine if we should update by matching its configuration type.
	existingIntegrations, err := s.datastore.GetImageIntegrations(ctx, &v1.GetImageIntegrationsRequest{})
	if err != nil {
		return errors.Wrap(err, "fetching all image integrations")
	}
	integrationToUpdate, shouldInsert := s.getMatchingImageIntegration(matches, imageIntegration, existingIntegrations)
	if !shouldInsert {
		return nil
	}

	// Update or create.
	if integrationToUpdate == nil {
		if _, err := s.datastore.AddImageIntegration(ctx, imageIntegration); err != nil {
			return errors.Wrap(err, "adding integration")
		}
		if err := s.integrationManager.Upsert(imageIntegration); err != nil {
			return errors.Wrap(err, "notifying of image integration update")
		}
		// Only when adding the integration the first time do we need to run processing
		// Central receives many updates from OpenShift about the image integrations due to service accounts
		// So we can assume the other credentials were valid up to this point.
		// Also, they will eventually be picked up within an hour.
		s.enrichAndDetectLoop.ShortCircuit()
		return nil
	}

	imageIntegration.Id = integrationToUpdate.GetId()
	imageIntegration.Name = integrationToUpdate.GetName()
	if err := s.integrationManager.Upsert(imageIntegration); err != nil {
		return errors.Wrap(err, "notifying of image integration update")
	}
	if err := s.datastore.UpdateImageIntegration(ctx, imageIntegration); err != nil {
		return errors.Wrap(err, "updating integration")
	}
	return nil
}

func (s *pipelineImpl) OnFinish(_ string) {}
