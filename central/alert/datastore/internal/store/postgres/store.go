// Code generated by pg-bindings generator. DO NOT EDIT.

package postgres

import (
	"context"
	"time"

	"github.com/gogo/protobuf/proto"
	"github.com/jackc/pgx/v4"
	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/stackrox/rox/central/globaldb"
	"github.com/stackrox/rox/central/metrics"
	"github.com/stackrox/rox/generated/storage"
	ops "github.com/stackrox/rox/pkg/metrics"
	"github.com/stackrox/rox/pkg/postgres/pgutils"
)

const (
	baseTable  = "alerts"
	countStmt  = "SELECT COUNT(*) FROM alerts"
	existsStmt = "SELECT EXISTS(SELECT 1 FROM alerts WHERE Id = $1)"

	getStmt     = "SELECT serialized FROM alerts WHERE Id = $1"
	deleteStmt  = "DELETE FROM alerts WHERE Id = $1"
	walkStmt    = "SELECT serialized FROM alerts"
	getIDsStmt  = "SELECT Id FROM alerts"
	getManyStmt = "SELECT serialized FROM alerts WHERE Id = ANY($1::text[])"

	deleteManyStmt = "DELETE FROM alerts WHERE Id = ANY($1::text[])"
)

func init() {
	globaldb.RegisterTable(baseTable, "Alert")
}

type Store interface {
	Count(ctx context.Context) (int, error)
	Exists(ctx context.Context, id string) (bool, error)
	Get(ctx context.Context, id string) (*storage.Alert, bool, error)
	Upsert(ctx context.Context, obj *storage.Alert) error
	UpsertMany(ctx context.Context, objs []*storage.Alert) error
	Delete(ctx context.Context, id string) error
	GetIDs(ctx context.Context) ([]string, error)
	GetMany(ctx context.Context, ids []string) ([]*storage.Alert, []int, error)
	DeleteMany(ctx context.Context, ids []string) error

	Walk(ctx context.Context, fn func(obj *storage.Alert) error) error

	AckKeysIndexed(ctx context.Context, keys ...string) error
	GetKeysToIndex(ctx context.Context) ([]string, error)
}

type storeImpl struct {
	db *pgxpool.Pool
}

func createTableAlerts(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists alerts (
    Id varchar,
    Policy_Id varchar,
    Policy_Name varchar,
    Policy_Description varchar,
    Policy_Rationale varchar,
    Policy_Remediation varchar,
    Policy_Disabled bool,
    Policy_Categories text[],
    Policy_LifecycleStages int[],
    Policy_EventSource integer,
    Policy_Severity integer,
    Policy_EnforcementActions int[],
    Policy_Notifiers text[],
    Policy_LastUpdated timestamp,
    Policy_SORTName varchar,
    Policy_SORTLifecycleStage varchar,
    Policy_SORTEnforcement bool,
    Policy_PolicyVersion varchar,
    Policy_CriteriaLocked bool,
    Policy_MitreVectorsLocked bool,
    Policy_IsDefault bool,
    LifecycleStage integer,
    Deployment_Id varchar,
    Deployment_Name varchar,
    Deployment_Type varchar,
    Deployment_Namespace varchar,
    Deployment_NamespaceId varchar,
    Deployment_Labels jsonb,
    Deployment_ClusterId varchar,
    Deployment_ClusterName varchar,
    Deployment_Annotations jsonb,
    Deployment_Inactive bool,
    Image_Id varchar,
    Image_Name_Registry varchar,
    Image_Name_Remote varchar,
    Image_Name_Tag varchar,
    Image_Name_FullName varchar,
    Image_NotPullable bool,
    Image_IsClusterLocal bool,
    Resource_ResourceType integer,
    Resource_Name varchar,
    Resource_ClusterId varchar,
    Resource_ClusterName varchar,
    Resource_Namespace varchar,
    Resource_NamespaceId varchar,
    ProcessViolation_Message varchar,
    Enforcement_Action integer,
    Enforcement_Message varchar,
    Time timestamp,
    FirstOccurred timestamp,
    ResolvedAt timestamp,
    State integer,
    SnoozeTill timestamp,
    Tags text[],
    serialized bytea,
    PRIMARY KEY(Id)
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		panic("error creating table: " + table)
	}

	indexes := []string{}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			panic(err)
		}
	}

	createTableAlertsWhitelists(ctx, db)
	createTableAlertsExclusions(ctx, db)
	createTableAlertsScope(ctx, db)
	createTableAlertsPolicySections(ctx, db)
	createTableAlertsMitreAttackVectors(ctx, db)
	createTableAlertsContainers(ctx, db)
	createTableAlertsViolations(ctx, db)
	createTableAlertsProcesses(ctx, db)
}

func createTableAlertsWhitelists(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists alerts_Whitelists (
    alerts_Id varchar,
    idx integer,
    Name varchar,
    Deployment_Name varchar,
    Deployment_Scope_Cluster varchar,
    Deployment_Scope_Namespace varchar,
    Deployment_Scope_Label_Key varchar,
    Deployment_Scope_Label_Value varchar,
    Image_Name varchar,
    Expiration timestamp,
    PRIMARY KEY(alerts_Id, idx),
    CONSTRAINT fk_parent_table FOREIGN KEY (alerts_Id) REFERENCES alerts(Id) ON DELETE CASCADE
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		panic("error creating table: " + table)
	}

	indexes := []string{

		"create index if not exists alertsWhitelists_idx on alerts_Whitelists using btree(idx)",
	}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			panic(err)
		}
	}

}

func createTableAlertsExclusions(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists alerts_Exclusions (
    alerts_Id varchar,
    idx integer,
    Name varchar,
    Deployment_Name varchar,
    Deployment_Scope_Cluster varchar,
    Deployment_Scope_Namespace varchar,
    Deployment_Scope_Label_Key varchar,
    Deployment_Scope_Label_Value varchar,
    Image_Name varchar,
    Expiration timestamp,
    PRIMARY KEY(alerts_Id, idx),
    CONSTRAINT fk_parent_table FOREIGN KEY (alerts_Id) REFERENCES alerts(Id) ON DELETE CASCADE
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		panic("error creating table: " + table)
	}

	indexes := []string{

		"create index if not exists alertsExclusions_idx on alerts_Exclusions using btree(idx)",
	}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			panic(err)
		}
	}

}

func createTableAlertsScope(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists alerts_Scope (
    alerts_Id varchar,
    idx integer,
    Cluster varchar,
    Namespace varchar,
    Label_Key varchar,
    Label_Value varchar,
    PRIMARY KEY(alerts_Id, idx),
    CONSTRAINT fk_parent_table FOREIGN KEY (alerts_Id) REFERENCES alerts(Id) ON DELETE CASCADE
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		panic("error creating table: " + table)
	}

	indexes := []string{

		"create index if not exists alertsScope_idx on alerts_Scope using btree(idx)",
	}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			panic(err)
		}
	}

}

func createTableAlertsPolicySections(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists alerts_PolicySections (
    alerts_Id varchar,
    idx integer,
    SectionName varchar,
    PRIMARY KEY(alerts_Id, idx),
    CONSTRAINT fk_parent_table FOREIGN KEY (alerts_Id) REFERENCES alerts(Id) ON DELETE CASCADE
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		panic("error creating table: " + table)
	}

	indexes := []string{

		"create index if not exists alertsPolicySections_idx on alerts_PolicySections using btree(idx)",
	}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			panic(err)
		}
	}

	createTableAlertsPolicySectionsPolicyGroups(ctx, db)
}

func createTableAlertsPolicySectionsPolicyGroups(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists alerts_PolicySections_PolicyGroups (
    alerts_Id varchar,
    alerts_PolicySections_idx integer,
    idx integer,
    FieldName varchar,
    BooleanOperator integer,
    Negate bool,
    PRIMARY KEY(alerts_Id, alerts_PolicySections_idx, idx),
    CONSTRAINT fk_parent_table FOREIGN KEY (alerts_Id, alerts_PolicySections_idx) REFERENCES alerts_PolicySections(alerts_Id, idx) ON DELETE CASCADE
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		panic("error creating table: " + table)
	}

	indexes := []string{

		"create index if not exists alertsPolicySectionsPolicyGroups_idx on alerts_PolicySections_PolicyGroups using btree(idx)",
	}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			panic(err)
		}
	}

	createTableAlertsPolicySectionsPolicyGroupsValues(ctx, db)
}

func createTableAlertsPolicySectionsPolicyGroupsValues(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists alerts_PolicySections_PolicyGroups_Values (
    alerts_Id varchar,
    alerts_PolicySections_idx integer,
    alerts_PolicySections_PolicyGroups_idx integer,
    idx integer,
    Value varchar,
    PRIMARY KEY(alerts_Id, alerts_PolicySections_idx, alerts_PolicySections_PolicyGroups_idx, idx),
    CONSTRAINT fk_parent_table FOREIGN KEY (alerts_Id, alerts_PolicySections_idx, alerts_PolicySections_PolicyGroups_idx) REFERENCES alerts_PolicySections_PolicyGroups(alerts_Id, alerts_PolicySections_idx, idx) ON DELETE CASCADE
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		panic("error creating table: " + table)
	}

	indexes := []string{

		"create index if not exists alertsPolicySectionsPolicyGroupsValues_idx on alerts_PolicySections_PolicyGroups_Values using btree(idx)",
	}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			panic(err)
		}
	}

}

func createTableAlertsMitreAttackVectors(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists alerts_MitreAttackVectors (
    alerts_Id varchar,
    idx integer,
    Tactic varchar,
    Techniques text[],
    PRIMARY KEY(alerts_Id, idx),
    CONSTRAINT fk_parent_table FOREIGN KEY (alerts_Id) REFERENCES alerts(Id) ON DELETE CASCADE
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		panic("error creating table: " + table)
	}

	indexes := []string{

		"create index if not exists alertsMitreAttackVectors_idx on alerts_MitreAttackVectors using btree(idx)",
	}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			panic(err)
		}
	}

}

func createTableAlertsContainers(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists alerts_Containers (
    alerts_Id varchar,
    idx integer,
    Image_Id varchar,
    Image_Name_Registry varchar,
    Image_Name_Remote varchar,
    Image_Name_Tag varchar,
    Image_Name_FullName varchar,
    Image_NotPullable bool,
    Image_IsClusterLocal bool,
    Name varchar,
    PRIMARY KEY(alerts_Id, idx),
    CONSTRAINT fk_parent_table FOREIGN KEY (alerts_Id) REFERENCES alerts(Id) ON DELETE CASCADE
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		panic("error creating table: " + table)
	}

	indexes := []string{

		"create index if not exists alertsContainers_idx on alerts_Containers using btree(idx)",
	}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			panic(err)
		}
	}

}

func createTableAlertsViolations(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists alerts_Violations (
    alerts_Id varchar,
    idx integer,
    Message varchar,
    NetworkFlowInfo_Protocol integer,
    NetworkFlowInfo_Source_Name varchar,
    NetworkFlowInfo_Source_EntityType integer,
    NetworkFlowInfo_Source_DeploymentNamespace varchar,
    NetworkFlowInfo_Source_DeploymentType varchar,
    NetworkFlowInfo_Source_Port integer,
    NetworkFlowInfo_Destination_Name varchar,
    NetworkFlowInfo_Destination_EntityType integer,
    NetworkFlowInfo_Destination_DeploymentNamespace varchar,
    NetworkFlowInfo_Destination_DeploymentType varchar,
    NetworkFlowInfo_Destination_Port integer,
    Type integer,
    Time timestamp,
    PRIMARY KEY(alerts_Id, idx),
    CONSTRAINT fk_parent_table FOREIGN KEY (alerts_Id) REFERENCES alerts(Id) ON DELETE CASCADE
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		panic("error creating table: " + table)
	}

	indexes := []string{

		"create index if not exists alertsViolations_idx on alerts_Violations using btree(idx)",
	}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			panic(err)
		}
	}

	createTableAlertsViolationsAttrs(ctx, db)
}

func createTableAlertsViolationsAttrs(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists alerts_Violations_Attrs (
    alerts_Id varchar,
    alerts_Violations_idx integer,
    idx integer,
    Key varchar,
    Value varchar,
    PRIMARY KEY(alerts_Id, alerts_Violations_idx, idx),
    CONSTRAINT fk_parent_table FOREIGN KEY (alerts_Id, alerts_Violations_idx) REFERENCES alerts_Violations(alerts_Id, idx) ON DELETE CASCADE
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		panic("error creating table: " + table)
	}

	indexes := []string{

		"create index if not exists alertsViolationsAttrs_idx on alerts_Violations_Attrs using btree(idx)",
	}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			panic(err)
		}
	}

}

func createTableAlertsProcesses(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists alerts_Processes (
    alerts_Id varchar,
    idx integer,
    Id varchar,
    DeploymentId varchar,
    ContainerName varchar,
    PodId varchar,
    PodUid varchar,
    Signal_Id varchar,
    Signal_ContainerId varchar,
    Signal_Time timestamp,
    Signal_Name varchar,
    Signal_Args varchar,
    Signal_ExecFilePath varchar,
    Signal_Pid integer,
    Signal_Uid integer,
    Signal_Gid integer,
    Signal_Lineage text[],
    Signal_Scraped bool,
    ClusterId varchar,
    Namespace varchar,
    ContainerStartTime timestamp,
    ImageId varchar,
    PRIMARY KEY(alerts_Id, idx),
    CONSTRAINT fk_parent_table FOREIGN KEY (alerts_Id) REFERENCES alerts(Id) ON DELETE CASCADE
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		panic("error creating table: " + table)
	}

	indexes := []string{

		"create index if not exists alertsProcesses_idx on alerts_Processes using btree(idx)",
	}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			panic(err)
		}
	}

	createTableAlertsProcessesLineageInfo(ctx, db)
}

func createTableAlertsProcessesLineageInfo(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists alerts_Processes_LineageInfo (
    alerts_Id varchar,
    alerts_Processes_idx integer,
    idx integer,
    ParentUid integer,
    ParentExecFilePath varchar,
    PRIMARY KEY(alerts_Id, alerts_Processes_idx, idx),
    CONSTRAINT fk_parent_table FOREIGN KEY (alerts_Id, alerts_Processes_idx) REFERENCES alerts_Processes(alerts_Id, idx) ON DELETE CASCADE
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		panic("error creating table: " + table)
	}

	indexes := []string{

		"create index if not exists alertsProcessesLineageInfo_idx on alerts_Processes_LineageInfo using btree(idx)",
	}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			panic(err)
		}
	}

}

func insertIntoAlerts(ctx context.Context, tx pgx.Tx, obj *storage.Alert) error {

	serialized, marshalErr := obj.Marshal()
	if marshalErr != nil {
		return marshalErr
	}

	values := []interface{}{
		// parent primary keys start
		obj.GetId(),
		obj.GetPolicy().GetId(),
		obj.GetPolicy().GetName(),
		obj.GetPolicy().GetDescription(),
		obj.GetPolicy().GetRationale(),
		obj.GetPolicy().GetRemediation(),
		obj.GetPolicy().GetDisabled(),
		obj.GetPolicy().GetCategories(),
		obj.GetPolicy().GetLifecycleStages(),
		obj.GetPolicy().GetEventSource(),
		obj.GetPolicy().GetSeverity(),
		obj.GetPolicy().GetEnforcementActions(),
		obj.GetPolicy().GetNotifiers(),
		pgutils.NilOrStringTimestamp(obj.GetPolicy().GetLastUpdated()),
		obj.GetPolicy().GetSORTName(),
		obj.GetPolicy().GetSORTLifecycleStage(),
		obj.GetPolicy().GetSORTEnforcement(),
		obj.GetPolicy().GetPolicyVersion(),
		obj.GetPolicy().GetCriteriaLocked(),
		obj.GetPolicy().GetMitreVectorsLocked(),
		obj.GetPolicy().GetIsDefault(),
		obj.GetLifecycleStage(),
		obj.GetDeployment().GetId(),
		obj.GetDeployment().GetName(),
		obj.GetDeployment().GetType(),
		obj.GetDeployment().GetNamespace(),
		obj.GetDeployment().GetNamespaceId(),
		obj.GetDeployment().GetLabels(),
		obj.GetDeployment().GetClusterId(),
		obj.GetDeployment().GetClusterName(),
		obj.GetDeployment().GetAnnotations(),
		obj.GetDeployment().GetInactive(),
		obj.GetImage().GetId(),
		obj.GetImage().GetName().GetRegistry(),
		obj.GetImage().GetName().GetRemote(),
		obj.GetImage().GetName().GetTag(),
		obj.GetImage().GetName().GetFullName(),
		obj.GetImage().GetNotPullable(),
		obj.GetImage().GetIsClusterLocal(),
		obj.GetResource().GetResourceType(),
		obj.GetResource().GetName(),
		obj.GetResource().GetClusterId(),
		obj.GetResource().GetClusterName(),
		obj.GetResource().GetNamespace(),
		obj.GetResource().GetNamespaceId(),
		obj.GetProcessViolation().GetMessage(),
		obj.GetEnforcement().GetAction(),
		obj.GetEnforcement().GetMessage(),
		pgutils.NilOrStringTimestamp(obj.GetTime()),
		pgutils.NilOrStringTimestamp(obj.GetFirstOccurred()),
		pgutils.NilOrStringTimestamp(obj.GetResolvedAt()),
		obj.GetState(),
		pgutils.NilOrStringTimestamp(obj.GetSnoozeTill()),
		obj.GetTags(),
		serialized,
	}

	finalStr := "INSERT INTO alerts (Id, Policy_Id, Policy_Name, Policy_Description, Policy_Rationale, Policy_Remediation, Policy_Disabled, Policy_Categories, Policy_LifecycleStages, Policy_EventSource, Policy_Severity, Policy_EnforcementActions, Policy_Notifiers, Policy_LastUpdated, Policy_SORTName, Policy_SORTLifecycleStage, Policy_SORTEnforcement, Policy_PolicyVersion, Policy_CriteriaLocked, Policy_MitreVectorsLocked, Policy_IsDefault, LifecycleStage, Deployment_Id, Deployment_Name, Deployment_Type, Deployment_Namespace, Deployment_NamespaceId, Deployment_Labels, Deployment_ClusterId, Deployment_ClusterName, Deployment_Annotations, Deployment_Inactive, Image_Id, Image_Name_Registry, Image_Name_Remote, Image_Name_Tag, Image_Name_FullName, Image_NotPullable, Image_IsClusterLocal, Resource_ResourceType, Resource_Name, Resource_ClusterId, Resource_ClusterName, Resource_Namespace, Resource_NamespaceId, ProcessViolation_Message, Enforcement_Action, Enforcement_Message, Time, FirstOccurred, ResolvedAt, State, SnoozeTill, Tags, serialized) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52, $53, $54, $55) ON CONFLICT(Id) DO UPDATE SET Id = EXCLUDED.Id, Policy_Id = EXCLUDED.Policy_Id, Policy_Name = EXCLUDED.Policy_Name, Policy_Description = EXCLUDED.Policy_Description, Policy_Rationale = EXCLUDED.Policy_Rationale, Policy_Remediation = EXCLUDED.Policy_Remediation, Policy_Disabled = EXCLUDED.Policy_Disabled, Policy_Categories = EXCLUDED.Policy_Categories, Policy_LifecycleStages = EXCLUDED.Policy_LifecycleStages, Policy_EventSource = EXCLUDED.Policy_EventSource, Policy_Severity = EXCLUDED.Policy_Severity, Policy_EnforcementActions = EXCLUDED.Policy_EnforcementActions, Policy_Notifiers = EXCLUDED.Policy_Notifiers, Policy_LastUpdated = EXCLUDED.Policy_LastUpdated, Policy_SORTName = EXCLUDED.Policy_SORTName, Policy_SORTLifecycleStage = EXCLUDED.Policy_SORTLifecycleStage, Policy_SORTEnforcement = EXCLUDED.Policy_SORTEnforcement, Policy_PolicyVersion = EXCLUDED.Policy_PolicyVersion, Policy_CriteriaLocked = EXCLUDED.Policy_CriteriaLocked, Policy_MitreVectorsLocked = EXCLUDED.Policy_MitreVectorsLocked, Policy_IsDefault = EXCLUDED.Policy_IsDefault, LifecycleStage = EXCLUDED.LifecycleStage, Deployment_Id = EXCLUDED.Deployment_Id, Deployment_Name = EXCLUDED.Deployment_Name, Deployment_Type = EXCLUDED.Deployment_Type, Deployment_Namespace = EXCLUDED.Deployment_Namespace, Deployment_NamespaceId = EXCLUDED.Deployment_NamespaceId, Deployment_Labels = EXCLUDED.Deployment_Labels, Deployment_ClusterId = EXCLUDED.Deployment_ClusterId, Deployment_ClusterName = EXCLUDED.Deployment_ClusterName, Deployment_Annotations = EXCLUDED.Deployment_Annotations, Deployment_Inactive = EXCLUDED.Deployment_Inactive, Image_Id = EXCLUDED.Image_Id, Image_Name_Registry = EXCLUDED.Image_Name_Registry, Image_Name_Remote = EXCLUDED.Image_Name_Remote, Image_Name_Tag = EXCLUDED.Image_Name_Tag, Image_Name_FullName = EXCLUDED.Image_Name_FullName, Image_NotPullable = EXCLUDED.Image_NotPullable, Image_IsClusterLocal = EXCLUDED.Image_IsClusterLocal, Resource_ResourceType = EXCLUDED.Resource_ResourceType, Resource_Name = EXCLUDED.Resource_Name, Resource_ClusterId = EXCLUDED.Resource_ClusterId, Resource_ClusterName = EXCLUDED.Resource_ClusterName, Resource_Namespace = EXCLUDED.Resource_Namespace, Resource_NamespaceId = EXCLUDED.Resource_NamespaceId, ProcessViolation_Message = EXCLUDED.ProcessViolation_Message, Enforcement_Action = EXCLUDED.Enforcement_Action, Enforcement_Message = EXCLUDED.Enforcement_Message, Time = EXCLUDED.Time, FirstOccurred = EXCLUDED.FirstOccurred, ResolvedAt = EXCLUDED.ResolvedAt, State = EXCLUDED.State, SnoozeTill = EXCLUDED.SnoozeTill, Tags = EXCLUDED.Tags, serialized = EXCLUDED.serialized"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	var query string

	for childIdx, child := range obj.GetPolicy().GetWhitelists() {
		if err := insertIntoAlertsWhitelists(ctx, tx, child, obj.GetId(), childIdx); err != nil {
			return err
		}
	}

	query = "delete from alerts_Whitelists where alerts_Id = $1 AND idx >= $2"
	_, err = tx.Exec(ctx, query, obj.GetId(), len(obj.GetPolicy().GetWhitelists()))
	if err != nil {
		return err
	}
	for childIdx, child := range obj.GetPolicy().GetExclusions() {
		if err := insertIntoAlertsExclusions(ctx, tx, child, obj.GetId(), childIdx); err != nil {
			return err
		}
	}

	query = "delete from alerts_Exclusions where alerts_Id = $1 AND idx >= $2"
	_, err = tx.Exec(ctx, query, obj.GetId(), len(obj.GetPolicy().GetExclusions()))
	if err != nil {
		return err
	}
	for childIdx, child := range obj.GetPolicy().GetScope() {
		if err := insertIntoAlertsScope(ctx, tx, child, obj.GetId(), childIdx); err != nil {
			return err
		}
	}

	query = "delete from alerts_Scope where alerts_Id = $1 AND idx >= $2"
	_, err = tx.Exec(ctx, query, obj.GetId(), len(obj.GetPolicy().GetScope()))
	if err != nil {
		return err
	}
	for childIdx, child := range obj.GetPolicy().GetPolicySections() {
		if err := insertIntoAlertsPolicySections(ctx, tx, child, obj.GetId(), childIdx); err != nil {
			return err
		}
	}

	query = "delete from alerts_PolicySections where alerts_Id = $1 AND idx >= $2"
	_, err = tx.Exec(ctx, query, obj.GetId(), len(obj.GetPolicy().GetPolicySections()))
	if err != nil {
		return err
	}
	for childIdx, child := range obj.GetPolicy().GetMitreAttackVectors() {
		if err := insertIntoAlertsMitreAttackVectors(ctx, tx, child, obj.GetId(), childIdx); err != nil {
			return err
		}
	}

	query = "delete from alerts_MitreAttackVectors where alerts_Id = $1 AND idx >= $2"
	_, err = tx.Exec(ctx, query, obj.GetId(), len(obj.GetPolicy().GetMitreAttackVectors()))
	if err != nil {
		return err
	}
	for childIdx, child := range obj.GetDeployment().GetContainers() {
		if err := insertIntoAlertsContainers(ctx, tx, child, obj.GetId(), childIdx); err != nil {
			return err
		}
	}

	query = "delete from alerts_Containers where alerts_Id = $1 AND idx >= $2"
	_, err = tx.Exec(ctx, query, obj.GetId(), len(obj.GetDeployment().GetContainers()))
	if err != nil {
		return err
	}
	for childIdx, child := range obj.GetViolations() {
		if err := insertIntoAlertsViolations(ctx, tx, child, obj.GetId(), childIdx); err != nil {
			return err
		}
	}

	query = "delete from alerts_Violations where alerts_Id = $1 AND idx >= $2"
	_, err = tx.Exec(ctx, query, obj.GetId(), len(obj.GetViolations()))
	if err != nil {
		return err
	}
	for childIdx, child := range obj.GetProcessViolation().GetProcesses() {
		if err := insertIntoAlertsProcesses(ctx, tx, child, obj.GetId(), childIdx); err != nil {
			return err
		}
	}

	query = "delete from alerts_Processes where alerts_Id = $1 AND idx >= $2"
	_, err = tx.Exec(ctx, query, obj.GetId(), len(obj.GetProcessViolation().GetProcesses()))
	if err != nil {
		return err
	}
	return nil
}

func insertIntoAlertsWhitelists(ctx context.Context, tx pgx.Tx, obj *storage.Exclusion, alerts_Id string, idx int) error {

	values := []interface{}{
		// parent primary keys start
		alerts_Id,
		idx,
		obj.GetName(),
		obj.GetDeployment().GetName(),
		obj.GetDeployment().GetScope().GetCluster(),
		obj.GetDeployment().GetScope().GetNamespace(),
		obj.GetDeployment().GetScope().GetLabel().GetKey(),
		obj.GetDeployment().GetScope().GetLabel().GetValue(),
		obj.GetImage().GetName(),
		pgutils.NilOrStringTimestamp(obj.GetExpiration()),
	}

	finalStr := "INSERT INTO alerts_Whitelists (alerts_Id, idx, Name, Deployment_Name, Deployment_Scope_Cluster, Deployment_Scope_Namespace, Deployment_Scope_Label_Key, Deployment_Scope_Label_Value, Image_Name, Expiration) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) ON CONFLICT(alerts_Id, idx) DO UPDATE SET alerts_Id = EXCLUDED.alerts_Id, idx = EXCLUDED.idx, Name = EXCLUDED.Name, Deployment_Name = EXCLUDED.Deployment_Name, Deployment_Scope_Cluster = EXCLUDED.Deployment_Scope_Cluster, Deployment_Scope_Namespace = EXCLUDED.Deployment_Scope_Namespace, Deployment_Scope_Label_Key = EXCLUDED.Deployment_Scope_Label_Key, Deployment_Scope_Label_Value = EXCLUDED.Deployment_Scope_Label_Value, Image_Name = EXCLUDED.Image_Name, Expiration = EXCLUDED.Expiration"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	return nil
}

func insertIntoAlertsExclusions(ctx context.Context, tx pgx.Tx, obj *storage.Exclusion, alerts_Id string, idx int) error {

	values := []interface{}{
		// parent primary keys start
		alerts_Id,
		idx,
		obj.GetName(),
		obj.GetDeployment().GetName(),
		obj.GetDeployment().GetScope().GetCluster(),
		obj.GetDeployment().GetScope().GetNamespace(),
		obj.GetDeployment().GetScope().GetLabel().GetKey(),
		obj.GetDeployment().GetScope().GetLabel().GetValue(),
		obj.GetImage().GetName(),
		pgutils.NilOrStringTimestamp(obj.GetExpiration()),
	}

	finalStr := "INSERT INTO alerts_Exclusions (alerts_Id, idx, Name, Deployment_Name, Deployment_Scope_Cluster, Deployment_Scope_Namespace, Deployment_Scope_Label_Key, Deployment_Scope_Label_Value, Image_Name, Expiration) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) ON CONFLICT(alerts_Id, idx) DO UPDATE SET alerts_Id = EXCLUDED.alerts_Id, idx = EXCLUDED.idx, Name = EXCLUDED.Name, Deployment_Name = EXCLUDED.Deployment_Name, Deployment_Scope_Cluster = EXCLUDED.Deployment_Scope_Cluster, Deployment_Scope_Namespace = EXCLUDED.Deployment_Scope_Namespace, Deployment_Scope_Label_Key = EXCLUDED.Deployment_Scope_Label_Key, Deployment_Scope_Label_Value = EXCLUDED.Deployment_Scope_Label_Value, Image_Name = EXCLUDED.Image_Name, Expiration = EXCLUDED.Expiration"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	return nil
}

func insertIntoAlertsScope(ctx context.Context, tx pgx.Tx, obj *storage.Scope, alerts_Id string, idx int) error {

	values := []interface{}{
		// parent primary keys start
		alerts_Id,
		idx,
		obj.GetCluster(),
		obj.GetNamespace(),
		obj.GetLabel().GetKey(),
		obj.GetLabel().GetValue(),
	}

	finalStr := "INSERT INTO alerts_Scope (alerts_Id, idx, Cluster, Namespace, Label_Key, Label_Value) VALUES($1, $2, $3, $4, $5, $6) ON CONFLICT(alerts_Id, idx) DO UPDATE SET alerts_Id = EXCLUDED.alerts_Id, idx = EXCLUDED.idx, Cluster = EXCLUDED.Cluster, Namespace = EXCLUDED.Namespace, Label_Key = EXCLUDED.Label_Key, Label_Value = EXCLUDED.Label_Value"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	return nil
}

func insertIntoAlertsPolicySections(ctx context.Context, tx pgx.Tx, obj *storage.PolicySection, alerts_Id string, idx int) error {

	values := []interface{}{
		// parent primary keys start
		alerts_Id,
		idx,
		obj.GetSectionName(),
	}

	finalStr := "INSERT INTO alerts_PolicySections (alerts_Id, idx, SectionName) VALUES($1, $2, $3) ON CONFLICT(alerts_Id, idx) DO UPDATE SET alerts_Id = EXCLUDED.alerts_Id, idx = EXCLUDED.idx, SectionName = EXCLUDED.SectionName"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	var query string

	for childIdx, child := range obj.GetPolicyGroups() {
		if err := insertIntoAlertsPolicySectionsPolicyGroups(ctx, tx, child, alerts_Id, idx, childIdx); err != nil {
			return err
		}
	}

	query = "delete from alerts_PolicySections_PolicyGroups where alerts_Id = $1 AND alerts_PolicySections_idx = $2 AND idx >= $3"
	_, err = tx.Exec(ctx, query, alerts_Id, idx, len(obj.GetPolicyGroups()))
	if err != nil {
		return err
	}
	return nil
}

func insertIntoAlertsPolicySectionsPolicyGroups(ctx context.Context, tx pgx.Tx, obj *storage.PolicyGroup, alerts_Id string, alerts_PolicySections_idx int, idx int) error {

	values := []interface{}{
		// parent primary keys start
		alerts_Id,
		alerts_PolicySections_idx,
		idx,
		obj.GetFieldName(),
		obj.GetBooleanOperator(),
		obj.GetNegate(),
	}

	finalStr := "INSERT INTO alerts_PolicySections_PolicyGroups (alerts_Id, alerts_PolicySections_idx, idx, FieldName, BooleanOperator, Negate) VALUES($1, $2, $3, $4, $5, $6) ON CONFLICT(alerts_Id, alerts_PolicySections_idx, idx) DO UPDATE SET alerts_Id = EXCLUDED.alerts_Id, alerts_PolicySections_idx = EXCLUDED.alerts_PolicySections_idx, idx = EXCLUDED.idx, FieldName = EXCLUDED.FieldName, BooleanOperator = EXCLUDED.BooleanOperator, Negate = EXCLUDED.Negate"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	var query string

	for childIdx, child := range obj.GetValues() {
		if err := insertIntoAlertsPolicySectionsPolicyGroupsValues(ctx, tx, child, alerts_Id, alerts_PolicySections_idx, idx, childIdx); err != nil {
			return err
		}
	}

	query = "delete from alerts_PolicySections_PolicyGroups_Values where alerts_Id = $1 AND alerts_PolicySections_idx = $2 AND alerts_PolicySections_PolicyGroups_idx = $3 AND idx >= $4"
	_, err = tx.Exec(ctx, query, alerts_Id, alerts_PolicySections_idx, idx, len(obj.GetValues()))
	if err != nil {
		return err
	}
	return nil
}

func insertIntoAlertsPolicySectionsPolicyGroupsValues(ctx context.Context, tx pgx.Tx, obj *storage.PolicyValue, alerts_Id string, alerts_PolicySections_idx int, alerts_PolicySections_PolicyGroups_idx int, idx int) error {

	values := []interface{}{
		// parent primary keys start
		alerts_Id,
		alerts_PolicySections_idx,
		alerts_PolicySections_PolicyGroups_idx,
		idx,
		obj.GetValue(),
	}

	finalStr := "INSERT INTO alerts_PolicySections_PolicyGroups_Values (alerts_Id, alerts_PolicySections_idx, alerts_PolicySections_PolicyGroups_idx, idx, Value) VALUES($1, $2, $3, $4, $5) ON CONFLICT(alerts_Id, alerts_PolicySections_idx, alerts_PolicySections_PolicyGroups_idx, idx) DO UPDATE SET alerts_Id = EXCLUDED.alerts_Id, alerts_PolicySections_idx = EXCLUDED.alerts_PolicySections_idx, alerts_PolicySections_PolicyGroups_idx = EXCLUDED.alerts_PolicySections_PolicyGroups_idx, idx = EXCLUDED.idx, Value = EXCLUDED.Value"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	return nil
}

func insertIntoAlertsMitreAttackVectors(ctx context.Context, tx pgx.Tx, obj *storage.Policy_MitreAttackVectors, alerts_Id string, idx int) error {

	values := []interface{}{
		// parent primary keys start
		alerts_Id,
		idx,
		obj.GetTactic(),
		obj.GetTechniques(),
	}

	finalStr := "INSERT INTO alerts_MitreAttackVectors (alerts_Id, idx, Tactic, Techniques) VALUES($1, $2, $3, $4) ON CONFLICT(alerts_Id, idx) DO UPDATE SET alerts_Id = EXCLUDED.alerts_Id, idx = EXCLUDED.idx, Tactic = EXCLUDED.Tactic, Techniques = EXCLUDED.Techniques"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	return nil
}

func insertIntoAlertsContainers(ctx context.Context, tx pgx.Tx, obj *storage.Alert_Deployment_Container, alerts_Id string, idx int) error {

	values := []interface{}{
		// parent primary keys start
		alerts_Id,
		idx,
		obj.GetImage().GetId(),
		obj.GetImage().GetName().GetRegistry(),
		obj.GetImage().GetName().GetRemote(),
		obj.GetImage().GetName().GetTag(),
		obj.GetImage().GetName().GetFullName(),
		obj.GetImage().GetNotPullable(),
		obj.GetImage().GetIsClusterLocal(),
		obj.GetName(),
	}

	finalStr := "INSERT INTO alerts_Containers (alerts_Id, idx, Image_Id, Image_Name_Registry, Image_Name_Remote, Image_Name_Tag, Image_Name_FullName, Image_NotPullable, Image_IsClusterLocal, Name) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) ON CONFLICT(alerts_Id, idx) DO UPDATE SET alerts_Id = EXCLUDED.alerts_Id, idx = EXCLUDED.idx, Image_Id = EXCLUDED.Image_Id, Image_Name_Registry = EXCLUDED.Image_Name_Registry, Image_Name_Remote = EXCLUDED.Image_Name_Remote, Image_Name_Tag = EXCLUDED.Image_Name_Tag, Image_Name_FullName = EXCLUDED.Image_Name_FullName, Image_NotPullable = EXCLUDED.Image_NotPullable, Image_IsClusterLocal = EXCLUDED.Image_IsClusterLocal, Name = EXCLUDED.Name"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	return nil
}

func insertIntoAlertsViolations(ctx context.Context, tx pgx.Tx, obj *storage.Alert_Violation, alerts_Id string, idx int) error {

	values := []interface{}{
		// parent primary keys start
		alerts_Id,
		idx,
		obj.GetMessage(),
		obj.GetNetworkFlowInfo().GetProtocol(),
		obj.GetNetworkFlowInfo().GetSource().GetName(),
		obj.GetNetworkFlowInfo().GetSource().GetEntityType(),
		obj.GetNetworkFlowInfo().GetSource().GetDeploymentNamespace(),
		obj.GetNetworkFlowInfo().GetSource().GetDeploymentType(),
		obj.GetNetworkFlowInfo().GetSource().GetPort(),
		obj.GetNetworkFlowInfo().GetDestination().GetName(),
		obj.GetNetworkFlowInfo().GetDestination().GetEntityType(),
		obj.GetNetworkFlowInfo().GetDestination().GetDeploymentNamespace(),
		obj.GetNetworkFlowInfo().GetDestination().GetDeploymentType(),
		obj.GetNetworkFlowInfo().GetDestination().GetPort(),
		obj.GetType(),
		pgutils.NilOrStringTimestamp(obj.GetTime()),
	}

	finalStr := "INSERT INTO alerts_Violations (alerts_Id, idx, Message, NetworkFlowInfo_Protocol, NetworkFlowInfo_Source_Name, NetworkFlowInfo_Source_EntityType, NetworkFlowInfo_Source_DeploymentNamespace, NetworkFlowInfo_Source_DeploymentType, NetworkFlowInfo_Source_Port, NetworkFlowInfo_Destination_Name, NetworkFlowInfo_Destination_EntityType, NetworkFlowInfo_Destination_DeploymentNamespace, NetworkFlowInfo_Destination_DeploymentType, NetworkFlowInfo_Destination_Port, Type, Time) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16) ON CONFLICT(alerts_Id, idx) DO UPDATE SET alerts_Id = EXCLUDED.alerts_Id, idx = EXCLUDED.idx, Message = EXCLUDED.Message, NetworkFlowInfo_Protocol = EXCLUDED.NetworkFlowInfo_Protocol, NetworkFlowInfo_Source_Name = EXCLUDED.NetworkFlowInfo_Source_Name, NetworkFlowInfo_Source_EntityType = EXCLUDED.NetworkFlowInfo_Source_EntityType, NetworkFlowInfo_Source_DeploymentNamespace = EXCLUDED.NetworkFlowInfo_Source_DeploymentNamespace, NetworkFlowInfo_Source_DeploymentType = EXCLUDED.NetworkFlowInfo_Source_DeploymentType, NetworkFlowInfo_Source_Port = EXCLUDED.NetworkFlowInfo_Source_Port, NetworkFlowInfo_Destination_Name = EXCLUDED.NetworkFlowInfo_Destination_Name, NetworkFlowInfo_Destination_EntityType = EXCLUDED.NetworkFlowInfo_Destination_EntityType, NetworkFlowInfo_Destination_DeploymentNamespace = EXCLUDED.NetworkFlowInfo_Destination_DeploymentNamespace, NetworkFlowInfo_Destination_DeploymentType = EXCLUDED.NetworkFlowInfo_Destination_DeploymentType, NetworkFlowInfo_Destination_Port = EXCLUDED.NetworkFlowInfo_Destination_Port, Type = EXCLUDED.Type, Time = EXCLUDED.Time"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	var query string

	for childIdx, child := range obj.GetKeyValueAttrs().GetAttrs() {
		if err := insertIntoAlertsViolationsAttrs(ctx, tx, child, alerts_Id, idx, childIdx); err != nil {
			return err
		}
	}

	query = "delete from alerts_Violations_Attrs where alerts_Id = $1 AND alerts_Violations_idx = $2 AND idx >= $3"
	_, err = tx.Exec(ctx, query, alerts_Id, idx, len(obj.GetKeyValueAttrs().GetAttrs()))
	if err != nil {
		return err
	}
	return nil
}

func insertIntoAlertsViolationsAttrs(ctx context.Context, tx pgx.Tx, obj *storage.Alert_Violation_KeyValueAttrs_KeyValueAttr, alerts_Id string, alerts_Violations_idx int, idx int) error {

	values := []interface{}{
		// parent primary keys start
		alerts_Id,
		alerts_Violations_idx,
		idx,
		obj.GetKey(),
		obj.GetValue(),
	}

	finalStr := "INSERT INTO alerts_Violations_Attrs (alerts_Id, alerts_Violations_idx, idx, Key, Value) VALUES($1, $2, $3, $4, $5) ON CONFLICT(alerts_Id, alerts_Violations_idx, idx) DO UPDATE SET alerts_Id = EXCLUDED.alerts_Id, alerts_Violations_idx = EXCLUDED.alerts_Violations_idx, idx = EXCLUDED.idx, Key = EXCLUDED.Key, Value = EXCLUDED.Value"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	return nil
}

func insertIntoAlertsProcesses(ctx context.Context, tx pgx.Tx, obj *storage.ProcessIndicator, alerts_Id string, idx int) error {

	values := []interface{}{
		// parent primary keys start
		alerts_Id,
		idx,
		obj.GetId(),
		obj.GetDeploymentId(),
		obj.GetContainerName(),
		obj.GetPodId(),
		obj.GetPodUid(),
		obj.GetSignal().GetId(),
		obj.GetSignal().GetContainerId(),
		pgutils.NilOrStringTimestamp(obj.GetSignal().GetTime()),
		obj.GetSignal().GetName(),
		obj.GetSignal().GetArgs(),
		obj.GetSignal().GetExecFilePath(),
		obj.GetSignal().GetPid(),
		obj.GetSignal().GetUid(),
		obj.GetSignal().GetGid(),
		obj.GetSignal().GetLineage(),
		obj.GetSignal().GetScraped(),
		obj.GetClusterId(),
		obj.GetNamespace(),
		pgutils.NilOrStringTimestamp(obj.GetContainerStartTime()),
		obj.GetImageId(),
	}

	finalStr := "INSERT INTO alerts_Processes (alerts_Id, idx, Id, DeploymentId, ContainerName, PodId, PodUid, Signal_Id, Signal_ContainerId, Signal_Time, Signal_Name, Signal_Args, Signal_ExecFilePath, Signal_Pid, Signal_Uid, Signal_Gid, Signal_Lineage, Signal_Scraped, ClusterId, Namespace, ContainerStartTime, ImageId) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22) ON CONFLICT(alerts_Id, idx) DO UPDATE SET alerts_Id = EXCLUDED.alerts_Id, idx = EXCLUDED.idx, Id = EXCLUDED.Id, DeploymentId = EXCLUDED.DeploymentId, ContainerName = EXCLUDED.ContainerName, PodId = EXCLUDED.PodId, PodUid = EXCLUDED.PodUid, Signal_Id = EXCLUDED.Signal_Id, Signal_ContainerId = EXCLUDED.Signal_ContainerId, Signal_Time = EXCLUDED.Signal_Time, Signal_Name = EXCLUDED.Signal_Name, Signal_Args = EXCLUDED.Signal_Args, Signal_ExecFilePath = EXCLUDED.Signal_ExecFilePath, Signal_Pid = EXCLUDED.Signal_Pid, Signal_Uid = EXCLUDED.Signal_Uid, Signal_Gid = EXCLUDED.Signal_Gid, Signal_Lineage = EXCLUDED.Signal_Lineage, Signal_Scraped = EXCLUDED.Signal_Scraped, ClusterId = EXCLUDED.ClusterId, Namespace = EXCLUDED.Namespace, ContainerStartTime = EXCLUDED.ContainerStartTime, ImageId = EXCLUDED.ImageId"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	var query string

	for childIdx, child := range obj.GetSignal().GetLineageInfo() {
		if err := insertIntoAlertsProcessesLineageInfo(ctx, tx, child, alerts_Id, idx, childIdx); err != nil {
			return err
		}
	}

	query = "delete from alerts_Processes_LineageInfo where alerts_Id = $1 AND alerts_Processes_idx = $2 AND idx >= $3"
	_, err = tx.Exec(ctx, query, alerts_Id, idx, len(obj.GetSignal().GetLineageInfo()))
	if err != nil {
		return err
	}
	return nil
}

func insertIntoAlertsProcessesLineageInfo(ctx context.Context, tx pgx.Tx, obj *storage.ProcessSignal_LineageInfo, alerts_Id string, alerts_Processes_idx int, idx int) error {

	values := []interface{}{
		// parent primary keys start
		alerts_Id,
		alerts_Processes_idx,
		idx,
		obj.GetParentUid(),
		obj.GetParentExecFilePath(),
	}

	finalStr := "INSERT INTO alerts_Processes_LineageInfo (alerts_Id, alerts_Processes_idx, idx, ParentUid, ParentExecFilePath) VALUES($1, $2, $3, $4, $5) ON CONFLICT(alerts_Id, alerts_Processes_idx, idx) DO UPDATE SET alerts_Id = EXCLUDED.alerts_Id, alerts_Processes_idx = EXCLUDED.alerts_Processes_idx, idx = EXCLUDED.idx, ParentUid = EXCLUDED.ParentUid, ParentExecFilePath = EXCLUDED.ParentExecFilePath"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	return nil
}

// New returns a new Store instance using the provided sql instance.
func New(ctx context.Context, db *pgxpool.Pool) Store {
	createTableAlerts(ctx, db)

	return &storeImpl{
		db: db,
	}
}

func (s *storeImpl) upsert(ctx context.Context, objs ...*storage.Alert) error {
	conn, release := s.acquireConn(ctx, ops.Get, "Alert")
	defer release()

	for _, obj := range objs {
		tx, err := conn.Begin(ctx)
		if err != nil {
			return err
		}

		if err := insertIntoAlerts(ctx, tx, obj); err != nil {
			if err := tx.Rollback(ctx); err != nil {
				return err
			}
			return err
		}
		if err := tx.Commit(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (s *storeImpl) Upsert(ctx context.Context, obj *storage.Alert) error {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Upsert, "Alert")

	return s.upsert(ctx, obj)
}

func (s *storeImpl) UpsertMany(ctx context.Context, objs []*storage.Alert) error {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.UpdateMany, "Alert")

	return s.upsert(ctx, objs...)
}

// Count returns the number of objects in the store
func (s *storeImpl) Count(ctx context.Context) (int, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Count, "Alert")

	row := s.db.QueryRow(ctx, countStmt)
	var count int
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// Exists returns if the id exists in the store
func (s *storeImpl) Exists(ctx context.Context, id string) (bool, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Exists, "Alert")

	row := s.db.QueryRow(ctx, existsStmt, id)
	var exists bool
	if err := row.Scan(&exists); err != nil {
		return false, pgutils.ErrNilIfNoRows(err)
	}
	return exists, nil
}

// Get returns the object, if it exists from the store
func (s *storeImpl) Get(ctx context.Context, id string) (*storage.Alert, bool, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Get, "Alert")

	conn, release := s.acquireConn(ctx, ops.Get, "Alert")
	defer release()

	row := conn.QueryRow(ctx, getStmt, id)
	var data []byte
	if err := row.Scan(&data); err != nil {
		return nil, false, pgutils.ErrNilIfNoRows(err)
	}

	var msg storage.Alert
	if err := proto.Unmarshal(data, &msg); err != nil {
		return nil, false, err
	}
	return &msg, true, nil
}

func (s *storeImpl) acquireConn(ctx context.Context, op ops.Op, typ string) (*pgxpool.Conn, func()) {
	defer metrics.SetAcquireDBConnDuration(time.Now(), op, typ)
	conn, err := s.db.Acquire(ctx)
	if err != nil {
		panic(err)
	}
	return conn, conn.Release
}

// Delete removes the specified ID from the store
func (s *storeImpl) Delete(ctx context.Context, id string) error {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Remove, "Alert")

	conn, release := s.acquireConn(ctx, ops.Remove, "Alert")
	defer release()

	if _, err := conn.Exec(ctx, deleteStmt, id); err != nil {
		return err
	}
	return nil
}

// GetIDs returns all the IDs for the store
func (s *storeImpl) GetIDs(ctx context.Context) ([]string, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.GetAll, "storage.AlertIDs")

	rows, err := s.db.Query(ctx, getIDsStmt)
	if err != nil {
		return nil, pgutils.ErrNilIfNoRows(err)
	}
	defer rows.Close()
	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	return ids, nil
}

// GetMany returns the objects specified by the IDs or the index in the missing indices slice
func (s *storeImpl) GetMany(ctx context.Context, ids []string) ([]*storage.Alert, []int, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.GetMany, "Alert")

	conn, release := s.acquireConn(ctx, ops.GetMany, "Alert")
	defer release()

	rows, err := conn.Query(ctx, getManyStmt, ids)
	if err != nil {
		if err == pgx.ErrNoRows {
			missingIndices := make([]int, 0, len(ids))
			for i := range ids {
				missingIndices = append(missingIndices, i)
			}
			return nil, missingIndices, nil
		}
		return nil, nil, err
	}
	defer rows.Close()
	resultsByID := make(map[string]*storage.Alert)
	for rows.Next() {
		var data []byte
		if err := rows.Scan(&data); err != nil {
			return nil, nil, err
		}
		msg := &storage.Alert{}
		if err := proto.Unmarshal(data, msg); err != nil {
			return nil, nil, err
		}
		resultsByID[msg.GetId()] = msg
	}
	missingIndices := make([]int, 0, len(ids)-len(resultsByID))
	// It is important that the elems are populated in the same order as the input ids
	// slice, since some calling code relies on that to maintain order.
	elems := make([]*storage.Alert, 0, len(resultsByID))
	for i, id := range ids {
		if result, ok := resultsByID[id]; !ok {
			missingIndices = append(missingIndices, i)
		} else {
			elems = append(elems, result)
		}
	}
	return elems, missingIndices, nil
}

// Delete removes the specified IDs from the store
func (s *storeImpl) DeleteMany(ctx context.Context, ids []string) error {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.RemoveMany, "Alert")

	conn, release := s.acquireConn(ctx, ops.RemoveMany, "Alert")
	defer release()
	if _, err := conn.Exec(ctx, deleteManyStmt, ids); err != nil {
		return err
	}
	return nil
}

// Walk iterates over all of the objects in the store and applies the closure
func (s *storeImpl) Walk(ctx context.Context, fn func(obj *storage.Alert) error) error {
	rows, err := s.db.Query(ctx, walkStmt)
	if err != nil {
		return pgutils.ErrNilIfNoRows(err)
	}
	defer rows.Close()
	for rows.Next() {
		var data []byte
		if err := rows.Scan(&data); err != nil {
			return err
		}
		var msg storage.Alert
		if err := proto.Unmarshal(data, &msg); err != nil {
			return err
		}
		if err := fn(&msg); err != nil {
			return err
		}
	}
	return nil
}

//// Used for testing

func dropTableAlerts(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS alerts CASCADE")
	dropTableAlertsWhitelists(ctx, db)
	dropTableAlertsExclusions(ctx, db)
	dropTableAlertsScope(ctx, db)
	dropTableAlertsPolicySections(ctx, db)
	dropTableAlertsMitreAttackVectors(ctx, db)
	dropTableAlertsContainers(ctx, db)
	dropTableAlertsViolations(ctx, db)
	dropTableAlertsProcesses(ctx, db)

}

func dropTableAlertsWhitelists(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS alerts_Whitelists CASCADE")

}

func dropTableAlertsExclusions(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS alerts_Exclusions CASCADE")

}

func dropTableAlertsScope(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS alerts_Scope CASCADE")

}

func dropTableAlertsPolicySections(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS alerts_PolicySections CASCADE")
	dropTableAlertsPolicySectionsPolicyGroups(ctx, db)

}

func dropTableAlertsPolicySectionsPolicyGroups(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS alerts_PolicySections_PolicyGroups CASCADE")
	dropTableAlertsPolicySectionsPolicyGroupsValues(ctx, db)

}

func dropTableAlertsPolicySectionsPolicyGroupsValues(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS alerts_PolicySections_PolicyGroups_Values CASCADE")

}

func dropTableAlertsMitreAttackVectors(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS alerts_MitreAttackVectors CASCADE")

}

func dropTableAlertsContainers(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS alerts_Containers CASCADE")

}

func dropTableAlertsViolations(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS alerts_Violations CASCADE")
	dropTableAlertsViolationsAttrs(ctx, db)

}

func dropTableAlertsViolationsAttrs(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS alerts_Violations_Attrs CASCADE")

}

func dropTableAlertsProcesses(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS alerts_Processes CASCADE")
	dropTableAlertsProcessesLineageInfo(ctx, db)

}

func dropTableAlertsProcessesLineageInfo(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS alerts_Processes_LineageInfo CASCADE")

}

func Destroy(ctx context.Context, db *pgxpool.Pool) {
	dropTableAlerts(ctx, db)
}

//// Stubs for satisfying legacy interfaces

// AckKeysIndexed acknowledges the passed keys were indexed
func (s *storeImpl) AckKeysIndexed(ctx context.Context, keys ...string) error {
	return nil
}

// GetKeysToIndex returns the keys that need to be indexed
func (s *storeImpl) GetKeysToIndex(ctx context.Context) ([]string, error) {
	return nil, nil
}
