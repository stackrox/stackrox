package resolvers

import (
	"context"

	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/set"
	"github.com/stackrox/rox/pkg/utils"
)

func init() {
	schema := getBuilder()
	utils.Must(
		schema.AddType("VulnerabilityCounter", []string{
			"all: VulnerabilityFixableCounterResolver!",
			"low: VulnerabilityFixableCounterResolver!",
			"medium: VulnerabilityFixableCounterResolver!",
			"high: VulnerabilityFixableCounterResolver!",
			"critical: VulnerabilityFixableCounterResolver!",
		}),
		schema.AddType("VulnerabilityFixableCounterResolver", []string{
			"total: Int!",
			"fixable: Int!",
		}),
	)
}

// VulnerabilityCounterResolver returns the counts of vulnerabilities in a couple different buckets.
type VulnerabilityCounterResolver struct {
	all      *VulnerabilityFixableCounterResolver
	low      *VulnerabilityFixableCounterResolver
	medium   *VulnerabilityFixableCounterResolver
	high     *VulnerabilityFixableCounterResolver
	critical *VulnerabilityFixableCounterResolver
}

// All returns the counter for vulnerabilities of all severity levels.
func (evr *VulnerabilityCounterResolver) All(ctx context.Context) *VulnerabilityFixableCounterResolver {
	return evr.all
}

// Low returns the number of low impact vulnerabilities
func (evr *VulnerabilityCounterResolver) Low(ctx context.Context) *VulnerabilityFixableCounterResolver {
	return evr.low
}

// Medium returns the number of medium impact vulnerabilities
func (evr *VulnerabilityCounterResolver) Medium(ctx context.Context) *VulnerabilityFixableCounterResolver {
	return evr.medium
}

// High returns the number of high impact vulnerabilities
func (evr *VulnerabilityCounterResolver) High(ctx context.Context) *VulnerabilityFixableCounterResolver {
	return evr.high
}

// Critical returns the number of critical vulnerabilities
func (evr *VulnerabilityCounterResolver) Critical(ctx context.Context) *VulnerabilityFixableCounterResolver {
	return evr.critical
}

// VulnerabilityFixableCounterResolver is a counter that differentiates between fixable and all vulnerabilities.
type VulnerabilityFixableCounterResolver struct {
	total   int32
	fixable int32
}

// Total returns the total number of vulnerabilities
func (evr *VulnerabilityFixableCounterResolver) Total(ctx context.Context) int32 {
	return evr.total
}

// Fixable returns the number of fixable vulnerabilities
func (evr *VulnerabilityFixableCounterResolver) Fixable(ctx context.Context) int32 {
	return evr.fixable
}

// Static helpers.
//////////////////

func emptyVulnerabilityCounter() *VulnerabilityCounterResolver {
	return &VulnerabilityCounterResolver{
		all:      &VulnerabilityFixableCounterResolver{},
		low:      &VulnerabilityFixableCounterResolver{},
		medium:   &VulnerabilityFixableCounterResolver{},
		high:     &VulnerabilityFixableCounterResolver{},
		critical: &VulnerabilityFixableCounterResolver{},
	}
}

func mapVulnsToVulnerabilityCounter(vulns []*storage.EmbeddedVulnerability) *VulnerabilityCounterResolver {
	counter := emptyVulnerabilityCounter()
	for _, vuln := range vulns {
		isFixable := vuln.GetFixedBy() != ""
		counter.all.total++
		if isFixable {
			counter.all.fixable++
		}

		if vuln.GetCvssV3() != nil {
			incCounterV3(counter, vuln.GetCvssV3(), isFixable)
		} else if vuln.GetCvssV2() != nil {
			incCounterV2(counter, vuln.GetCvssV2(), isFixable)
		}
	}
	return counter
}

func mapCVEsToVulnerabilityCounter(fixable, unFixable []*storage.CVE) *VulnerabilityCounterResolver {
	counter := emptyVulnerabilityCounter()
	seenVulns := set.NewStringSet()
	for _, vuln := range fixable {
		counter.all.total++
		counter.all.fixable++
		if vuln.GetCvssV3() != nil {
			incCounterV3(counter, vuln.GetCvssV3(), true)
		} else if vuln.GetCvssV2() != nil {
			incCounterV2(counter, vuln.GetCvssV2(), true)
		}
		seenVulns.Add(vuln.GetId())
	}

	for _, vuln := range unFixable {
		if seenVulns.Contains(vuln.GetId()) {
			continue
		}

		counter.all.total++
		if vuln.GetCvssV3() != nil {
			incCounterV3(counter, vuln.GetCvssV3(), false)
		} else if vuln.GetCvssV2() != nil {
			incCounterV2(counter, vuln.GetCvssV2(), false)
		}
	}
	return counter
}

func incCounterV3(counter *VulnerabilityCounterResolver, provider *storage.CVSSV3, fixable bool) {
	if provider == nil {
		return
	}
	switch provider.GetSeverity() {
	case storage.CVSSV3_LOW:
		counter.low.total++
		if fixable {
			counter.low.fixable++
		}
	case storage.CVSSV3_MEDIUM:
		counter.medium.total++
		if fixable {
			counter.medium.fixable++
		}
	case storage.CVSSV3_HIGH:
		counter.high.total++
		if fixable {
			counter.high.fixable++
		}
	case storage.CVSSV3_CRITICAL:
		counter.critical.total++
		if fixable {
			counter.critical.fixable++
		}
	}
}

func incCounterV2(counter *VulnerabilityCounterResolver, provider *storage.CVSSV2, fixable bool) {
	if provider == nil {
		return
	}
	switch provider.GetSeverity() {
	case storage.CVSSV2_LOW:
		counter.low.total++
		if fixable {
			counter.low.fixable++
		}
	case storage.CVSSV2_MEDIUM:
		counter.medium.total++
		if fixable {
			counter.medium.fixable++
		}
	case storage.CVSSV2_HIGH:
		counter.high.total++
		if fixable {
			counter.high.fixable++
		}
	}
}
