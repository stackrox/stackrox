// Code generated by graphql-generator. DO NOT EDIT.

package resolvers

import (
	"context"
	"encoding/base64"
	"reflect"

	"github.com/graph-gophers/graphql-go"
	"github.com/stackrox/rox/central/graphql/generator"
{{- range $i, $_ := .Imports }}
	"{{$i}}"
{{- end}} // end range imports
	"github.com/stackrox/rox/pkg/protocompat"
	"github.com/stackrox/rox/pkg/utils"
)

func registerGeneratedTypes(builder generator.SchemaBuilder) {
	utils.Must(builder.AddType("Label", []string{"key: String!", "value: String!"}))
{{- range $td := .Entries }}
{{- if isEnum $td.Data.Type }}
	generator.RegisterProtoEnum(builder, reflect.TypeOf({{ importedName $td.Data.Type }}(0)))
{{- else }}
{{- if not $td.Data.Name }}
{{- continue}}
{{- end}}
{{- if $td.Data.IsInputType }}
	utils.Must(builder.AddInput("{{ $td.Data.Name }}", []string{
{{- else }}
	utils.Must(builder.AddType("{{ $td.Data.Name }}", []string{
{{- end }}
{{- $hasFields := false }}
{{- $hasAnyMethods := false }}
{{- range $td.Data.FieldData }}{{ if schemaType . }}
		"{{ lower .Name}}: {{ schemaType .}}",
{{- $hasFields = true }}
{{- end }}{{ $vt := valueType . }}{{ if $vt }}{{ $hasAnyMethods = true }}{{ end }}{{ end }}
{{- range $td.Data.UnionData }}
		"{{lower .Name }}: {{ $td.Data.Name }}{{.Name}}",
{{- $hasFields = true }}
{{- $hasAnyMethods = true }}
{{- end }}
{{- if not $hasFields }}{{ if not $hasAnyMethods }}
		"placeholder: Boolean!",
{{- end }}{{ end }}
	}))
{{- range $ud := $td.Data.UnionData }}
	utils.Must(builder.AddUnionType("{{ $td.Data.Name }}{{ $ud.Name }}", []string{
{{- range $ud.Entries }}
		"{{ schemaType . }}",
{{- end }}
	}))
{{- end }}
{{- end }}
{{- end }}
}
{{range $td := .Entries}}{{if isEnum $td.Data.Type}}
func to{{.Data.Name}}(value *string) {{importedName .Data.Type}} {
	if value != nil {
		return {{importedName .Data.Type}}({{importedName .Data.Type}}_value[*value])
	}
	return {{importedName .Data.Type}}(0)
}

func to{{plural .Data.Name}}(values *[]string) []{{importedName .Data.Type}} {
	if values == nil {
		return nil
	}
	output := make([]{{importedName .Data.Type}}, len(*values))
	for i, v := range *values {
		output[i] = to{{.Data.Name}}(&v)
	}
	return output
}
{{else if not $td.Data.IsInputType }}
type {{lower .Data.Name}}Resolver struct {
	ctx  context.Context
	root *Resolver
	data *{{importedName .Data.Type}}
{{- if .ListData}}
	list *{{listName .Data}}
{{- end}}
}

func (resolver *Resolver) wrap{{.Data.Name}}(value *{{importedName .Data.Type}}, ok bool, err error) (*{{lower .Data.Name}}Resolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &{{lower .Data.Name}}Resolver{root: resolver, data: value{{if .ListData}}, list: nil{{end}}}, nil
}

func (resolver *Resolver) wrap{{plural .Data.Name}}(values []*{{importedName .Data.Type}}, err error) ([]*{{lower .Data.Name}}Resolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*{{lower .Data.Name}}Resolver, len(values))
	for i, v := range values {
		output[i] = &{{lower .Data.Name}}Resolver{root: resolver, data: v{{if .ListData}}, list: nil{{end}}}
	}
	return output, nil
}

func (resolver *Resolver) wrap{{.Data.Name}}WithContext(ctx context.Context, value *{{importedName .Data.Type}}, ok bool, err error) (*{{lower .Data.Name}}Resolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &{{lower .Data.Name}}Resolver{ctx: ctx, root: resolver, data: value{{if .ListData}}, list: nil{{end}}}, nil
}

func (resolver *Resolver) wrap{{plural .Data.Name}}WithContext(ctx context.Context, values []*{{importedName .Data.Type}}, err error) ([]*{{lower .Data.Name}}Resolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*{{lower .Data.Name}}Resolver, len(values))
	for i, v := range values {
		output[i] = &{{lower .Data.Name}}Resolver{ctx: ctx, root: resolver, data: v{{if .ListData}}, list: nil{{end}}}
	}
	return output, nil
}
{{if .ListData}}
func (resolver *Resolver) wrapList{{plural .Data.Name}}(values []*{{listName .Data}}, err error) ([]*{{lower .Data.Name}}Resolver, error) {
	if err != nil || values == nil {
		return nil, err
	}
	output := make([]*{{lower .Data.Name}}Resolver, len(values))
	for i, v := range values {
		output[i] = &{{lower .Data.Name}}Resolver{root: resolver, data: nil, list: v}
	}
	return output, nil
}

func (resolver *{{lower .Data.Name}}Resolver) ensureData(ctx context.Context) {
	if resolver.data == nil {
		resolver.data = resolver.root.get{{.Data.Name}}(ctx, resolver.list.GetId())
	}
}
{{end -}}
{{range $_, $fd := .Data.FieldData -}}
{{$vt := valueType $fd}}{{if $vt}}
func (resolver *{{lower $td.Data.Name}}Resolver) {{ $fd.Name }}(ctx context.Context) {{ $vt }} {
{{- if $td.ListData}}{{if nonListField $td $fd}}
	resolver.ensureData(ctx)
{{- end}}{{end}}
	value := resolver.data.Get{{$fd.Name}}()
{{- if listField $td $fd}}
	if resolver.data == nil {
		value = resolver.list.Get{{$fd.Name}}()
	}
{{- end}}
	return {{translator $fd }}
}
{{end -}}
{{end}}
{{- $hasAnyFields := false }}
{{- range $_, $fd := .Data.FieldData }}{{$vt := valueType $fd}}{{if $vt}}{{$hasAnyFields = true}}{{end}}{{end}}
{{- range $td.Data.UnionData }}{{$hasAnyFields = true}}{{end}}
{{- if not $hasAnyFields }}
func (resolver *{{lower $td.Data.Name}}Resolver) Placeholder(ctx context.Context) bool {
	return false
}
{{end}}
{{- range $ud := $td.Data.UnionData}}
type {{lower $td.Data.Name}}{{$ud.Name}}Resolver struct {
	resolver interface{}
}

func (resolver *{{lower $td.Data.Name}}Resolver) {{$ud.Name}}() *{{lower $td.Data.Name}}{{$ud.Name}}Resolver {
{{- range $ut := $ud.Entries }}
	if val := resolver.data.Get{{$ut.Name}}(); val != nil {
		return &{{lower $td.Data.Name}}{{$ud.Name}}Resolver{
			resolver: &{{lower $ut.Type.Elem.Name}}Resolver{root: resolver.root, data: val},
		}
	}
{{- end}}
	return nil
}
{{range $ut := $ud.Entries}}
func (resolver *{{lower $td.Data.Name}}{{$ud.Name}}Resolver) To{{$ut.Type.Elem.Name}}() (*{{lower $ut.Type.Elem.Name}}Resolver, bool) {
	res, ok := resolver.resolver.(*{{lower $ut.Type.Elem.Name}}Resolver)
	return res, ok
}
{{end}}{{end}}{{end}}{{- end -}}
