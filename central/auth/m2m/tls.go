package m2m

import (
	"crypto/tls"
	"crypto/x509"
	"os"

	"github.com/stackrox/rox/pkg/logging"
)

const (
	// serviceCAPath holds the CA of the service CA operator to verify certs generated by it.
	serviceCAPath = "/var/run/secrets/kubernetes.io/serviceaccount/service-ca.crt"
	// k8sCAPath holds the CA of the underlying cluster.
	k8sCAPath = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
	// cnoTrustedCAPath holds the injected CA bundle from the Cluster Network Operator used to manage custom CAs in
	// an OpenShift cluster.
	cnoTrustedCAPath = "/etc/pki/injected-ca-trust/tls-ca-bundle.pem"
)

func tlsConfigWithCustomCertPool() (*tls.Config, error) {
	certPool, err := systemCertPoolWithInjectedCAs()
	if err != nil {
		return nil, err
	}
	return &tls.Config{RootCAs: certPool}, nil
}

func systemCertPoolWithInjectedCAs() (*x509.CertPool, error) {
	certPool, err := x509.SystemCertPool()
	if err != nil {
		return nil, err
	}

	for _, path := range []string{serviceCAPath, k8sCAPath, cnoTrustedCAPath} {
		caBytes, err := os.ReadFile(path)
		if err != nil {
			log.Errorw("Failed to read CA file for token verifier",
				logging.String("path", path), logging.Err(err))
			continue
		}
		if !certPool.AppendCertsFromPEM(caBytes) {
			log.Errorw("Couldn't add CA to cert pool for token verifier",
				logging.String("path", path))
		}
	}

	return certPool, nil
}
