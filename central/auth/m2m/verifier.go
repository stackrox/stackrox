package m2m

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"net/http"
	"os"
	"time"

	"github.com/coreos/go-oidc/v3/oidc"
	"github.com/pkg/errors"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/httputil/proxy"
	"github.com/stackrox/rox/pkg/logging"
)

const (
	// serviceCAPath holds the CA of the service CA operator to verify certs generated by it.
	serviceCAPath = "/var/run/secrets/kubernetes.io/serviceaccount/service-ca.crt"
	// k8sCAPath holds the CA of the underlying cluster.
	k8sCAPath = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
	// cnoTrustedCAPath holds the injected CA bundle from the Cluster Network Operator used to manage custom CAs in
	// an OpenShift cluster.
	cnoTrustedCAPath = "/etc/pki/injected-ca-trust/tls-ca-bundle.pem"
)

var (
	_ tokenVerifier = (*genericTokenVerifier)(nil)
)

type tokenVerifier interface {
	VerifyIDToken(ctx context.Context, rawIDToken string) (*oidc.IDToken, error)
}

func tokenVerifierFromConfig(ctx context.Context, config *storage.AuthMachineToMachineConfig) (tokenVerifier, error) {
	tlsConfig, err := tlsConfigWithCustomCertPool()
	if err != nil {
		return nil, errors.Wrap(err, "creating TLS config for token verification")
	}
	provider, err := oidc.NewProvider(
		oidc.ClientContext(ctx, &http.Client{Timeout: time.Minute,
			Transport: proxy.RoundTripperWithTLSConfig(tlsConfig)}),
		config.GetIssuer(),
	)
	if err != nil {
		return nil, errors.Wrapf(err, "creating OIDC provider for issuer %q", config.GetIssuer())
	}

	return &genericTokenVerifier{provider: provider}, nil
}

type genericTokenVerifier struct {
	provider *oidc.Provider
}

func (g *genericTokenVerifier) VerifyIDToken(ctx context.Context, rawIDToken string) (*oidc.IDToken, error) {
	verifier := g.provider.Verifier(&oidc.Config{
		// We currently provide no config to expose the client ID that's associated with the ID token.
		// The reason for this is the following:
		// - A magnitude of client IDs would have to be configured (i.e. in the case of GitHub actions, this would be
		// all repository URLs including their potential customizations).
		// - Client IDs (i.e. the "sub" claim) _may_ be part for the mappings within the
		// config. So, essentially the client ID check is deferred to a latter point, as the mappings _may_ be used
		// for mapping, but it currently isn't a requirement.
		SkipClientIDCheck: true,
	})

	return verifier.Verify(ctx, rawIDToken)
}

func tlsConfigWithCustomCertPool() (*tls.Config, error) {
	certPool, err := systemCertPoolWithInjectedCAs()
	if err != nil {
		return nil, err
	}
	return &tls.Config{RootCAs: certPool}, nil
}

func systemCertPoolWithInjectedCAs() (*x509.CertPool, error) {
	certPool, err := x509.SystemCertPool()
	if err != nil {
		return nil, err
	}

	for _, path := range []string{serviceCAPath, k8sCAPath, cnoTrustedCAPath} {
		caBytes, err := os.ReadFile(path)
		if err != nil {
			log.Errorw("Failed to read CA file for token verifier",
				logging.String("path", path), logging.Err(err))
			continue
		}
		if !certPool.AppendCertsFromPEM(caBytes) {
			log.Errorw("Couldn't add CA to cert pool for token verifier",
				logging.String("path", path))
		}
	}

	return certPool, nil
}
