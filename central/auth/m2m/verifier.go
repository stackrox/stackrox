package m2m

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"net/http"
	"os"
	"time"

	"github.com/coreos/go-oidc/v3/oidc"
	"github.com/pkg/errors"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/httputil/proxy"
	"github.com/stackrox/rox/pkg/logging"
)

const (
	// serviceCAPath holds the CA of the service CA operator to verify certs generated by it.
	serviceCAPath = "/var/run/secrets/kubernetes.io/serviceaccount/service-ca.crt"
	// k8sCAPath holds the CA of the underlying cluster.
	k8sCAPath = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
	// cnoTrustedCAPath holds the injected CA bundle from the Cluster Network Operator used to manage custom CAs in
	// an OpenShift cluster.
	cnoTrustedCAPath = "/etc/pki/injected-ca-trust/tls-ca-bundle.pem"
)

var (
	_ tokenVerifier = (*genericTokenVerifier)(nil)
)

type tokenVerifier interface {
	VerifyIDToken(ctx context.Context, rawIDToken string) (*oidc.IDToken, error)
}

type authenticatedRoundTripper struct {
	roundTripper http.RoundTripper
	token        string
}

// RoundTrip here inserts an HTTP "Authorization" header with the given bearer token.
func (a authenticatedRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	// It's generally not recommended to make more than one actual round trip inside the RoundTrip function,
	// but we have no reasonable alternative if we want to utilize the oidc provider interface.
	// NOTE: This has only been tested with GET requests used by the oidc library to fetch JWKS config

	// First try without any auth header
	resp, err := a.roundTripper.RoundTrip(req)
	if err == nil && resp.StatusCode >= 400 {
		// GKE's issuer endpoint responds with HTTP 400 if Authorization header is set.
		// At the same time, the Kube docs indicate that auth should be required by default.
		// Thus, try first with no auth.
		// If a response was received but it was a 4xx/5xx status code, try with the auth header.
		// Note that we don't try with the auth header if a proper HTTP response was not received, i.e. err != nil
		log.Warnf("Unauthenticated oidc config request failed with %d. Trying again with k8s serivce account token.", resp.StatusCode)
		authReq := req.Clone(req.Context())
		authReq.Header.Add("Authorization", fmt.Sprintf("Bearer %s", a.token))
		resp, err = a.roundTripper.RoundTrip(authReq)
	}
	return resp, err
}

func tokenVerifierFromConfig(ctx context.Context, config *storage.AuthMachineToMachineConfig) (tokenVerifier, error) {
	tlsConfig, err := tlsConfigWithCustomCertPool()
	if err != nil {
		return nil, errors.Wrap(err, "creating TLS config for token verification")
	}

	roundTripper := proxy.RoundTripper(proxy.WithTLSConfig(tlsConfig))
	if config.Type == storage.AuthMachineToMachineConfig_KUBE_SERVICE_ACCOUNT {
		token, err := kubeServiceAccountTokenReader{}.readToken()
		if err != nil {
			return nil, errors.Wrap(err, "Failed to read kube service account token")
		}

		// By default k8s requires authentication to fetch the OIDC resources for service account tokens
		// https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-issuer-discovery
		roundTripper = authenticatedRoundTripper{roundTripper: roundTripper, token: token}
	}

	provider, err := oidc.NewProvider(
		oidc.ClientContext(ctx, &http.Client{Timeout: time.Minute, Transport: roundTripper}),
		config.GetIssuer(),
	)
	if err != nil {
		return nil, errors.Wrapf(err, "creating OIDC provider for issuer %q", config.GetIssuer())
	}

	return &genericTokenVerifier{provider: provider}, nil
}

type genericTokenVerifier struct {
	provider *oidc.Provider
}

func (g *genericTokenVerifier) VerifyIDToken(ctx context.Context, rawIDToken string) (*oidc.IDToken, error) {
	verifier := g.provider.Verifier(&oidc.Config{
		// We currently provide no config to expose the client ID that's associated with the ID token.
		// The reason for this is the following:
		// - A magnitude of client IDs would have to be configured (i.e. in the case of GitHub actions, this would be
		// all repository URLs including their potential customizations).
		// - Client IDs (i.e. the "sub" claim) _may_ be part for the mappings within the
		// config. So, essentially the client ID check is deferred to a latter point, as the mappings _may_ be used
		// for mapping, but it currently isn't a requirement.
		SkipClientIDCheck: true,
	})

	return verifier.Verify(ctx, rawIDToken)
}

func tlsConfigWithCustomCertPool() (*tls.Config, error) {
	certPool, err := systemCertPoolWithInjectedCAs()
	if err != nil {
		return nil, err
	}
	return &tls.Config{RootCAs: certPool}, nil
}

func systemCertPoolWithInjectedCAs() (*x509.CertPool, error) {
	certPool, err := x509.SystemCertPool()
	if err != nil {
		return nil, err
	}

	for _, path := range []string{serviceCAPath, k8sCAPath, cnoTrustedCAPath} {
		caBytes, err := os.ReadFile(path)
		if err != nil {
			log.Errorw("Failed to read CA file for token verifier",
				logging.String("path", path), logging.Err(err))
			continue
		}
		if !certPool.AppendCertsFromPEM(caBytes) {
			log.Errorw("Couldn't add CA to cert pool for token verifier",
				logging.String("path", path))
		}
	}

	return certPool, nil
}
