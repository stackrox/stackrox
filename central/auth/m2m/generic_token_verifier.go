package m2m

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"os"

	"github.com/coreos/go-oidc/v3/oidc"
	"github.com/stackrox/rox/pkg/logging"
)

const (
	// serviceCAPath holds the CA of the service CA operator to verify certs generated by it.
	serviceCAPath = "/var/run/secrets/kubernetes.io/serviceaccount/service-ca.crt"
	// k8sCAPath holds the CA of the underlying cluster.
	k8sCAPath = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
	// cnoTrustedCAPath holds the injected CA bundle from the Cluster Network Operator used to manage custom CAs in
	// an OpenShift cluster.
	cnoTrustedCAPath = "/etc/pki/injected-ca-trust/tls-ca-bundle.pem"
)

type genericTokenVerifier struct {
	provider *oidc.Provider
}

var _ tokenVerifier = (*genericTokenVerifier)(nil)

func (g *genericTokenVerifier) VerifyIDToken(ctx context.Context, rawIDToken string) (*IDToken, error) {
	verifier := g.provider.Verifier(&oidc.Config{
		// We currently provide no config to expose the client ID that's associated with the ID token.
		// The reason for this is the following:
		// - A magnitude of client IDs would have to be configured (i.e. in the case of GitHub actions, this would be
		// all repository URLs including their potential customizations).
		// - Client IDs (i.e. the "sub" claim) _may_ be part for the mappings within the
		// config. So, essentially the client ID check is deferred to a latter point, as the mappings _may_ be used
		// for mapping, but it currently isn't a requirement.
		SkipClientIDCheck: true,
	})

	token, err := verifier.Verify(ctx, rawIDToken)
	if err != nil {
		return nil, err
	}
	return &IDToken{
		Subject:  token.Subject,
		Audience: token.Audience,
		Claims:   token.Claims,
	}, nil
}

func tlsConfigWithCustomCertPool() (*tls.Config, error) {
	certPool, err := systemCertPoolWithInjectedCAs()
	if err != nil {
		return nil, err
	}
	return &tls.Config{RootCAs: certPool}, nil
}

func systemCertPoolWithInjectedCAs() (*x509.CertPool, error) {
	certPool, err := x509.SystemCertPool()
	if err != nil {
		return nil, err
	}

	for _, path := range []string{serviceCAPath, k8sCAPath, cnoTrustedCAPath} {
		caBytes, err := os.ReadFile(path)
		if err != nil {
			log.Errorw("Failed to read CA file for token verifier",
				logging.String("path", path), logging.Err(err))
			continue
		}
		if !certPool.AppendCertsFromPEM(caBytes) {
			log.Errorw("Couldn't add CA to cert pool for token verifier",
				logging.String("path", path))
		}
	}

	return certPool, nil
}
