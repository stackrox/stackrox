package manager

import (
	"context"
	"sort"
	"testing"
	"time"

	"github.com/blevesearch/bleve"
	"github.com/gogo/protobuf/proto"
	"github.com/gogo/protobuf/types"
	"github.com/golang/mock/gomock"
	clusterIndex "github.com/stackrox/rox/central/cluster/index"
	componentCVEEdgeDackBox "github.com/stackrox/rox/central/componentcveedge/dackbox"
	componentCVEEdgeIndex "github.com/stackrox/rox/central/componentcveedge/index"
	cveDackbox "github.com/stackrox/rox/central/cve/dackbox"
	cveDS "github.com/stackrox/rox/central/cve/datastore"
	cveIndex "github.com/stackrox/rox/central/cve/index"
	cveSearcher "github.com/stackrox/rox/central/cve/search"
	cveStore "github.com/stackrox/rox/central/cve/store/dackbox"
	transformations "github.com/stackrox/rox/central/dackbox"
	deploymentMockDS "github.com/stackrox/rox/central/deployment/datastore/mocks"
	deploymentIndex "github.com/stackrox/rox/central/deployment/index"
	"github.com/stackrox/rox/central/globalindex"
	imageDackBox "github.com/stackrox/rox/central/image/dackbox"
	imageDS "github.com/stackrox/rox/central/image/datastore"
	imageIndex "github.com/stackrox/rox/central/image/index"
	componentDackBox "github.com/stackrox/rox/central/imagecomponent/dackbox"
	componentIndex "github.com/stackrox/rox/central/imagecomponent/index"
	imageComponentEdgeDackBox "github.com/stackrox/rox/central/imagecomponentedge/dackbox"
	imageComponentEdgeIndex "github.com/stackrox/rox/central/imagecomponentedge/index"
	imageCVEEdgeDackBox "github.com/stackrox/rox/central/imagecveedge/dackbox"
	imageCVEEdgeDS "github.com/stackrox/rox/central/imagecveedge/datastore"
	imageCVEEdgeIndex "github.com/stackrox/rox/central/imagecveedge/index"
	imageCVEEdgeSearcher "github.com/stackrox/rox/central/imagecveedge/search"
	imageCVEEdgeStore "github.com/stackrox/rox/central/imagecveedge/store/dackbox"
	"github.com/stackrox/rox/central/ranking"
	riskManager "github.com/stackrox/rox/central/risk/manager/mocks"
	sensorConnMgrMocks "github.com/stackrox/rox/central/sensor/service/connection/mocks"
	vulnReqDS "github.com/stackrox/rox/central/vulnerabilityrequest/datastore"
	v1 "github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/concurrency"
	"github.com/stackrox/rox/pkg/dackbox"
	"github.com/stackrox/rox/pkg/dackbox/crud"
	"github.com/stackrox/rox/pkg/dackbox/edges"
	"github.com/stackrox/rox/pkg/dackbox/indexer"
	"github.com/stackrox/rox/pkg/dackbox/keys/transformation"
	"github.com/stackrox/rox/pkg/dackbox/utils/queue"
	"github.com/stackrox/rox/pkg/features"
	"github.com/stackrox/rox/pkg/fixtures"
	"github.com/stackrox/rox/pkg/protoconv"
	"github.com/stackrox/rox/pkg/rocksdb"
	"github.com/stackrox/rox/pkg/sac"
	"github.com/stackrox/rox/pkg/search"
	"github.com/stackrox/rox/pkg/testutils/envisolator"
	"github.com/stackrox/rox/pkg/testutils/rocksdbtest"
	"github.com/stretchr/testify/suite"
)

var (
	allAllowedCtx             = sac.WithAllAccess(context.Background())
	expiryLoopDurationForTest = 5 * time.Second // use a much quicker loop for testing purposes
)

func TestVulnRequestManager(t *testing.T) {
	suite.Run(t, new(VulnRequestManagerTestSuite))
}

type VulnRequestManagerTestSuite struct {
	mockCtrl *gomock.Controller
	suite.Suite
	envIsolator *envisolator.EnvIsolator

	db                 *rocksdb.RocksDB
	indexQ             queue.WaitableQueue
	bleveIndex         bleve.Index
	vulnReqDataStore   vulnReqDS.DataStore
	deployments        *deploymentMockDS.MockDataStore
	cveDataStore       cveDS.DataStore
	imageDataStore     imageDS.DataStore
	imageCVEDataStore  imageCVEEdgeDS.DataStore
	sensorConnMgrMocks *sensorConnMgrMocks.MockManager
	riskManager        *riskManager.MockManager

	manager *managerImpl
}

func (s *VulnRequestManagerTestSuite) SetupSuite() {
	s.mockCtrl = gomock.NewController(s.T())
	s.db = rocksdbtest.RocksDBForT(s.T())
}

func (s *VulnRequestManagerTestSuite) TearDownSuite() {
	rocksdbtest.TearDownRocksDB(s.db)
	// This needs to be set again because the feature flag was reset.
	s.updateGlobalVars()
	s.mockCtrl.Finish()
}

func (s *VulnRequestManagerTestSuite) updateGlobalVars() {
	setImageCVEEdgeTransformation()
	imageCVEEdgeDackBox.Upserter = crud.NewUpserter(
		crud.WithKeyFunction(crud.PrefixKey(imageCVEEdgeDackBox.Bucket, func(msg proto.Message) []byte {
			return []byte(msg.(*storage.ImageCVEEdge).GetId())
		})),
		crud.AddToIndexIfFeatureEnabled(features.VulnRiskManagement),
	)
	imageCVEEdgeDackBox.Deleter = crud.NewDeleter(
		crud.Shared(),
		crud.RemoveFromIndexIfFeatureEnabled(features.VulnRiskManagement),
	)
}

func (s *VulnRequestManagerTestSuite) SetupTest() {
	s.envIsolator = envisolator.NewEnvIsolator(s.T())
	s.envIsolator.Setenv(features.VulnRiskManagement.EnvVar(), "true")

	// This needs to be set again because the feature flag was updated.
	s.updateGlobalVars()

	bleveIndex, err := globalindex.MemOnlyIndex()
	s.Require().NoError(err)
	s.bleveIndex = bleveIndex

	s.indexQ = queue.NewWaitableQueue()
	dacky, err := dackbox.NewRocksDBDackBox(s.db, s.indexQ, []byte("graph"), []byte("dirty"), []byte("valid"))
	s.Require().NoError(err, "failed to create dackbox")

	reg := indexer.NewWrapperRegistry()
	indexer.NewLazy(s.indexQ, reg, bleveIndex, dacky.AckIndexed).Start()
	reg.RegisterWrapper(cveDackbox.Bucket, cveIndex.Wrapper{})
	reg.RegisterWrapper(componentDackBox.Bucket, componentIndex.Wrapper{})
	reg.RegisterWrapper(componentCVEEdgeDackBox.Bucket, componentCVEEdgeIndex.Wrapper{})
	reg.RegisterWrapper(imageDackBox.Bucket, imageIndex.Wrapper{})
	reg.RegisterWrapper(imageComponentEdgeDackBox.Bucket, imageComponentEdgeIndex.Wrapper{})
	reg.RegisterWrapper(imageCVEEdgeDackBox.Bucket, imageCVEEdgeIndex.Wrapper{})

	s.createImageDataStore(dacky)
	s.createCVEDataStore(dacky)
	s.createImageCVEDataStore(dacky)
	s.createVulnRequestDataStore(dacky)
	s.deployments = deploymentMockDS.NewMockDataStore(s.mockCtrl)
	s.sensorConnMgrMocks = sensorConnMgrMocks.NewMockManager(s.mockCtrl)
	s.riskManager = riskManager.NewMockManager(s.mockCtrl)

	s.manager = &managerImpl{
		deployments:                      s.deployments,
		images:                           s.imageDataStore,
		imageCVEEdges:                    s.imageCVEDataStore,
		vulnReqs:                         s.vulnReqDataStore,
		connManager:                      s.sensorConnMgrMocks,
		riskManager:                      s.riskManager,
		reObserveDeferralsTickerDuration: expiryLoopDurationForTest,
		stopSig:                          concurrency.NewSignal(),
		stopped:                          concurrency.NewSignal(),
		cache:                            newVulnReqCache(),
	}

	if !features.VulnRiskManagement.Enabled() {
		s.T().Skip("Skip vuln management manager test")
		s.T().SkipNow()
	}
}

func (s *VulnRequestManagerTestSuite) createImageDataStore(dacky *dackbox.DackBox) {
	imageDataStore := imageDS.New(dacky, concurrency.NewKeyFence(), s.bleveIndex, true, nil, ranking.ImageRanker(), ranking.ComponentRanker())
	s.imageDataStore = imageDataStore
}

func (s *VulnRequestManagerTestSuite) createCVEDataStore(dacky *dackbox.DackBox) {
	cveStore := cveStore.New(dacky, concurrency.NewKeyFence())
	cveIndexer := cveIndex.New(s.bleveIndex)
	cveDataStore, err := cveDS.New(dacky,
		cveStore,
		cveIndexer,
		cveSearcher.New(cveStore, dacky, cveIndexer, nil, nil, nil, nil, imageCVEEdgeIndex.New(s.bleveIndex), nil, nil, nil, nil, nil),
	)
	s.Require().NoError(err)
	s.cveDataStore = cveDataStore
}

func (s *VulnRequestManagerTestSuite) createImageCVEDataStore(dacky *dackbox.DackBox) {
	imageCVEEdgeStore := imageCVEEdgeStore.New(dacky, concurrency.NewKeyFence())
	s.imageCVEDataStore = imageCVEEdgeDS.New(dacky,
		imageCVEEdgeStore,
		imageCVEEdgeSearcher.New(imageCVEEdgeStore,
			cveIndex.New(s.bleveIndex),
			imageCVEEdgeIndex.New(s.bleveIndex),
			componentCVEEdgeIndex.New(s.bleveIndex),
			componentIndex.New(s.bleveIndex),
			imageComponentEdgeIndex.New(s.bleveIndex),
			imageIndex.New(s.bleveIndex),
			deploymentIndex.New(s.bleveIndex, nil),
			clusterIndex.New(s.bleveIndex),
		),
	)
}

func (s *VulnRequestManagerTestSuite) createVulnRequestDataStore(dacky *dackbox.DackBox) {
	ds, err := vulnReqDS.NewForTestOnly(s.T(), s.db, s.bleveIndex)
	s.NoError(err)
	s.vulnReqDataStore = ds
}

func (s *VulnRequestManagerTestSuite) TestSnoozeAndUnsnoozeVulns() {
	img := fixtures.GetImage()
	var allCVEs, cvesToDefer []string
	for _, comp := range img.GetScan().GetComponents() {
		if len(comp.GetVulns()) > 0 {
			cvesToDefer = append(cvesToDefer, comp.GetVulns()[0].GetCve())
			for _, vuln := range comp.GetVulns() {
				allCVEs = append(allCVEs, vuln.GetCve())
			}
		}
	}

	err := s.imageDataStore.UpsertImage(allAllowedCtx, img)
	s.NoError(err)

	s.forceIndexing()
	s.verifyCVEState(storage.VulnerabilityState_OBSERVED, img.GetId(), cvesToDefer...)

	var reqs []*storage.VulnerabilityRequest
	for _, cve := range cvesToDefer {
		reqs = append(reqs, &storage.VulnerabilityRequest{
			Status: storage.RequestStatus_APPROVED,
			Entities: &storage.VulnerabilityRequest_Cves{
				Cves: &storage.VulnerabilityRequest_CVEs{
					Ids: []string{cve},
				},
			},
			TargetState: storage.VulnerabilityState_DEFERRED,
			Scope: &storage.VulnerabilityRequest_Scope{
				Info: &storage.VulnerabilityRequest_Scope_ImageScope{
					ImageScope: &storage.VulnerabilityRequest_Scope_Image{
						Registry: img.GetName().GetRegistry(),
						Remote:   img.GetName().GetRemote(),
						Tag:      img.GetName().GetTag(),
					},
				},
			},
		})
	}

	depQuery := search.ConjunctionQuery(
		search.NewQueryBuilder().AddExactMatches(search.ImageSHA, img.GetId()).ProtoQuery(),
		search.NewQueryBuilder().AddStringsHighlighted(search.ClusterID, search.WildcardString).ProtoQuery(),
	)
	for _, req := range reqs {
		s.riskManager.EXPECT().CalculateRiskAndUpsertImage(gomock.Any()).Return(nil)
		s.deployments.EXPECT().SearchDeployments(allAllowedCtx, depQuery).Return(
			[]*v1.SearchResult{
				{
					Id: "dep1",
					FieldToMatches: map[string]*v1.SearchResult_Matches{
						"deployment.cluster_id": {Values: []string{"c1"}},
					},
				},
			},
			nil)
		s.sensorConnMgrMocks.EXPECT().GetConnection("c1").Return(nil)
		err := s.manager.SnoozeVulnerabilityOnRequest(allAllowedCtx, req)
		s.NoError(err)
	}

	s.forceIndexing()
	s.verifyCVEState(storage.VulnerabilityState_DEFERRED, img.GetId(), cvesToDefer...)
	s.verifySearchByCVEState(storage.VulnerabilityState_DEFERRED, cvesToDefer...)

	for _, req := range reqs {
		s.riskManager.EXPECT().CalculateRiskAndUpsertImage(gomock.Any()).Return(nil)
		s.deployments.EXPECT().SearchDeployments(allAllowedCtx, depQuery).Return(
			[]*v1.SearchResult{
				{
					Id: "dep1",
					FieldToMatches: map[string]*v1.SearchResult_Matches{
						"deployment.cluster_id": {Values: []string{"c1"}},
					},
				},
			},
			nil)
		s.sensorConnMgrMocks.EXPECT().GetConnection("c1").Return(nil)
		err := s.manager.UnSnoozeVulnerabilityOnRequest(allAllowedCtx, req)
		s.NoError(err)
	}

	s.forceIndexing()
	s.verifyCVEState(storage.VulnerabilityState_OBSERVED, img.GetId(), cvesToDefer...)
	s.verifySearchByCVEState(storage.VulnerabilityState_OBSERVED, allCVEs...)

}

func (s *VulnRequestManagerTestSuite) forceIndexing() {
	indexingDone := concurrency.NewSignal()
	s.indexQ.PushSignal(&indexingDone)
	indexingDone.Wait()
}

func (s *VulnRequestManagerTestSuite) verifyCVEState(state storage.VulnerabilityState, image string, cves ...string) {
	for _, cve := range cves {
		edgeID := edges.EdgeID{ParentID: image, ChildID: cve}.ToString()
		edge, found, err := s.imageCVEDataStore.Get(allAllowedCtx, edgeID)
		s.NoError(err)
		s.True(found)
		s.Equal(state, edge.GetState())
	}
}

func (s *VulnRequestManagerTestSuite) verifySearchByCVEState(state storage.VulnerabilityState, expectedCVEs ...string) {
	results, err := s.cveDataStore.Search(
		allAllowedCtx,
		search.NewQueryBuilder().AddStrings(
			search.VulnerabilityState,
			state.String()).ProtoQuery(),
	)
	s.NoError(err)
	s.Len(results, len(expectedCVEs))
	actual := search.ResultsToIDs(results)

	sort.SliceStable(actual, func(i, j int) bool {
		return actual[i] < actual[j]
	})
	sort.SliceStable(expectedCVEs, func(i, j int) bool {
		return expectedCVEs[i] < expectedCVEs[j]
	})
	s.Equal(expectedCVEs, actual)
}

func (s *VulnRequestManagerTestSuite) TestReObserveExpiredDeferralsMarksAllAsInactive() {
	expiredOneDayAgo := protoconv.ConvertTimeToTimestamp(time.Now().Add(-24 * time.Hour))
	expiresInFuture := protoconv.ConvertTimeToTimestamp(time.Now().Add(30 * 24 * time.Hour))

	fpRequest := fixtures.GetGlobalFPRequest("cve-a-b")
	fpRequest.Status = storage.RequestStatus_APPROVED

	cases := []struct {
		name             string
		vulnRequest      *storage.VulnerabilityRequest
		shouldBeActive   bool
		shouldGetComment bool
	}{
		{
			name:             "Active and approved deferral with expiry in past should be marked inactive with comment",
			vulnRequest:      newDeferral("req-active-def", false, storage.RequestStatus_APPROVED, expiredOneDayAgo),
			shouldBeActive:   false,
			shouldGetComment: true,
		},
		{
			name:             "Active and approved deferral with a pending request should still be inactive if expiry is in past",
			vulnRequest:      newDeferral("req-updated-def", false, storage.RequestStatus_APPROVED_PENDING_UPDATE, expiredOneDayAgo),
			shouldBeActive:   false,
			shouldGetComment: true,
		},
		{
			name:             "Inactive deferral should remain inactive but with no additional comment",
			vulnRequest:      newDeferral("req-inactive-def", true, storage.RequestStatus_APPROVED, expiredOneDayAgo),
			shouldBeActive:   false,
			shouldGetComment: false,
		},
		{
			name:             "Pending deferral should not be marked as inactive",
			vulnRequest:      newDeferral("req-pending-def", false, storage.RequestStatus_PENDING, expiredOneDayAgo),
			shouldBeActive:   true,
			shouldGetComment: false,
		},
		{
			name:             "Denied deferral should not be marked as inactive",
			vulnRequest:      newDeferral("req-denied-def", false, storage.RequestStatus_DENIED, expiredOneDayAgo),
			shouldBeActive:   true,
			shouldGetComment: false,
		},
		{
			name:             "Deferral with expiry in future should not be marked as inactive",
			vulnRequest:      newDeferral("req-unexpired-def", false, storage.RequestStatus_APPROVED, expiresInFuture),
			shouldBeActive:   true,
			shouldGetComment: false,
		},
		{
			name:             "Deferrals with expires when fixed should not be marked as inactive",
			vulnRequest:      newDeferralExpiresWhenFixed("req-whenfixed-def", false, storage.RequestStatus_APPROVED),
			shouldBeActive:   true,
			shouldGetComment: false,
		},
		{
			name:             "False positive requests should not be marked as inactive",
			vulnRequest:      fpRequest,
			shouldBeActive:   true,
			shouldGetComment: false,
		},
	}
	for _, c := range cases {
		s.T().Run(c.name, func(t *testing.T) {
			err := s.vulnReqDataStore.AddRequest(allAllowedCtx, c.vulnRequest)
			s.NoError(err)

			s.manager.reObserveExpiredDeferrals()

			r, ok, err := s.vulnReqDataStore.Get(allAllowedCtx, c.vulnRequest.GetId())
			s.NoError(err)
			s.True(ok)
			s.Equal(c.shouldBeActive, !r.Expired)

			if c.shouldGetComment {
				s.Len(r.Comments, 1)
				s.Equal(r.Comments[0].Message, "[System Generated] Request expired")
				s.Nil(r.Comments[0].User) // system generated so no user identity
			} else {
				s.Len(r.Comments, 0)
			}
		})
	}
}

func (s *VulnRequestManagerTestSuite) TestProcessorDoesntInactivateOnceStopped() {
	s.manager.Start()
	time.Sleep(expiryLoopDurationForTest) // wait for it to run at least once

	// Now stop it
	s.manager.Stop()

	// Add in a request that should be expired if it wasn't stopped
	req := newDeferral("req", false, storage.RequestStatus_APPROVED, protoconv.ConvertTimeToTimestamp(time.Now().Add(-24*time.Hour)))
	err := s.vulnReqDataStore.AddRequest(allAllowedCtx, req)
	s.NoError(err)

	// Wait again for what would've been two loops
	time.Sleep(expiryLoopDurationForTest * 2)

	// Verify request wasn't marked inactive
	r, ok, err := s.vulnReqDataStore.Get(allAllowedCtx, req.GetId())
	s.NoError(err)
	s.True(ok)
	s.False(r.Expired)
}

func newDeferral(id string, expired bool, status storage.RequestStatus, expiry *types.Timestamp) *storage.VulnerabilityRequest {
	return &storage.VulnerabilityRequest{
		Id:      id,
		Status:  status,
		Expired: expired,
		Req: &storage.VulnerabilityRequest_DeferralReq{
			DeferralReq: &storage.DeferralRequest{
				Expiry: &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresOn{ExpiresOn: expiry}},
			},
		},
		Scope: &storage.VulnerabilityRequest_Scope{
			Info: &storage.VulnerabilityRequest_Scope_GlobalScope{
				GlobalScope: &storage.VulnerabilityRequest_Scope_Global{},
			},
		},
	}
}

func newDeferralExpiresWhenFixed(id string, expired bool, status storage.RequestStatus) *storage.VulnerabilityRequest {
	return &storage.VulnerabilityRequest{
		Id:      id,
		Status:  status,
		Expired: expired,
		Req: &storage.VulnerabilityRequest_DeferralReq{
			DeferralReq: &storage.DeferralRequest{
				Expiry: &storage.RequestExpiry{Expiry: &storage.RequestExpiry_ExpiresWhenFixed{ExpiresWhenFixed: true}},
			},
		},
	}
}

// This is clone of `setImageCVEEdgeTransformation()` at "github.com/stackrox/rox/central/dackbox/cve.go"
func setImageCVEEdgeTransformation() {
	if features.VulnRiskManagement.Enabled() {
		// CombineReversed ( { k1, k2 }
		//          CVEs,
		//          CVE (backwards) Image,
		//          )
		transformations.CVETransformations[v1.SearchCategory_IMAGE_VULN_EDGE] = transformation.ReverseEdgeKeys(
			transformations.DoNothing,
			transformation.AddPrefix(cveDackbox.Bucket).
				ThenMapToMany(transformation.BackwardFromContext(imageDackBox.Bucket)).
				ThenMapEachToOne(transformation.StripPrefixUnchecked(imageDackBox.Bucket)).
				Then(transformation.Dedupe()),
		)
	}

	// CombineReversed ( { k1, k2 }
	//          CVEs,
	//          CVE (backwards) Components (backwards) Image,
	//          )
	transformations.CVETransformations[v1.SearchCategory_IMAGE_VULN_EDGE] = transformation.ReverseEdgeKeys(
		transformations.DoNothing,
		transformation.AddPrefix(cveDackbox.Bucket).
			ThenMapToMany(transformation.BackwardFromContext(componentDackBox.Bucket)).
			ThenMapEachToMany(transformation.BackwardFromContext(imageDackBox.Bucket)).
			ThenMapEachToOne(transformation.StripPrefixUnchecked(imageDackBox.Bucket)).
			Then(transformation.Dedupe()),
	)
}
