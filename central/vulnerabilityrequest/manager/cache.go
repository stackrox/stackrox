package manager

import (
	"fmt"

	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/sync"
)

type slimRequest struct {
	requestID   string
	targetState storage.VulnerabilityState
	cves        []string
}

func newVulnReqCache() *vulnReqCacheImpl {
	return &vulnReqCacheImpl{
		vulnReqByScope:  make(map[string]map[string]*slimRequest),
		scopeByVulnReqs: make(map[string]string),
	}
}

type vulnReqCacheImpl struct {
	vulnReqByScope  map[string]map[string]*slimRequest
	scopeByVulnReqs map[string]string

	lock sync.RWMutex
}

func (c *vulnReqCacheImpl) getVulnsWithState(registry, remote, tag string) map[string]storage.VulnerabilityState {
	c.lock.RLock()
	defer c.lock.RUnlock()

	vulns := make(map[string]storage.VulnerabilityState)
	for _, scope := range []string{
		// Start with the largest scope because state from the smallest scope takes precedence.
		allImagesRegexStr,
		imageNameToScopeStr(registry, remote, allTagsRegexStr),
		imageNameToScopeStr(registry, remote, tag),
	} {

		reqMap := c.vulnReqByScope[scope]
		if reqMap == nil {
			continue
		}

		for _, req := range reqMap {
			if req == nil {
				continue
			}
			for _, cve := range req.cves {
				vulns[cve] = req.targetState
			}
		}
	}
	return vulns
}

func (c *vulnReqCacheImpl) add(request *storage.VulnerabilityRequest) bool {
	c.lock.Lock()
	defer c.lock.Unlock()

	return c.addNoLock(request)
}

func (c *vulnReqCacheImpl) addNoLock(request *storage.VulnerabilityRequest) bool {
	image := c.scopeByVulnReqs[request.GetId()]
	if image != "" {
		return false
	}
	image = toScopeStr(request.GetScope())
	c.scopeByVulnReqs[request.GetId()] = image

	if c.vulnReqByScope[image] == nil {
		c.vulnReqByScope[image] = make(map[string]*slimRequest)
	}
	if c.vulnReqByScope[image][request.GetId()] != nil {
		return false
	}
	c.vulnReqByScope[image][request.GetId()] = &slimRequest{
		requestID:   request.GetId(),
		targetState: request.GetTargetState(),
		cves:        request.GetCves().GetIds(),
	}
	return true
}

func (c *vulnReqCacheImpl) remove(requestID string) bool {
	c.lock.Lock()
	defer c.lock.Unlock()

	image := c.scopeByVulnReqs[requestID]
	if image == "" {
		return false
	}
	delete(c.scopeByVulnReqs, requestID)

	reqMap := c.vulnReqByScope[image]
	if reqMap == nil {
		return false
	}
	delete(reqMap, requestID)

	if len(reqMap) == 0 {
		delete(c.vulnReqByScope, image)
	}
	return true
}

func toScopeStr(scope *storage.VulnerabilityRequest_Scope) string {
	if scope.GetGlobalScope() != nil {
		return allImagesRegexStr
	}
	if imgScope := scope.GetImageScope(); imgScope != nil {
		return imageNameToScopeStr(imgScope.GetRegistry(), imgScope.GetRemote(), imgScope.GetTag())
	}
	return ""
}

func imageNameToScopeStr(registry, remote, tag string) string {
	return fmt.Sprintf("%s/%s:%s", registry, remote, tag)
}
