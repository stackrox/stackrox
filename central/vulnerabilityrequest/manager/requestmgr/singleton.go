package requestmgr

import (
	imageCVEDataStore "github.com/stackrox/rox/central/cve/image/datastore"
	deploymentDataStore "github.com/stackrox/rox/central/deployment/datastore"
	imageDataStore "github.com/stackrox/rox/central/image/datastore"
	"github.com/stackrox/rox/central/reprocessor"
	"github.com/stackrox/rox/central/sensor/service/connection"
	"github.com/stackrox/rox/central/vulnerabilityrequest/cache"
	vulnReqDataStore "github.com/stackrox/rox/central/vulnerabilityrequest/datastore"
	"github.com/stackrox/rox/pkg/concurrency"
	"github.com/stackrox/rox/pkg/env"
	"github.com/stackrox/rox/pkg/logging"
	"github.com/stackrox/rox/pkg/sync"
	"golang.org/x/sync/semaphore"
)

var (
	once     sync.Once
	instance Manager

	log = logging.LoggerForModule()
)

func initialize() {
	instance = New(
		deploymentDataStore.Singleton(),
		vulnReqDataStore.Singleton(),
		cache.PendingReqsCacheSingleton(),
		cache.ActiveReqsCacheSingleton(),
		imageDataStore.Singleton(),
		imageCVEDataStore.Singleton(),
		connection.ManagerSingleton(),
		reprocessor.Singleton(),
	)
}

// Singleton provides the instance of Manager to use.
func Singleton() Manager {
	once.Do(initialize)
	return instance
}

// New returns an initialized manager, and starts the manager's processing loop in the background.
func New(
	deployments deploymentDataStore.DataStore,
	vulnReqs vulnReqDataStore.DataStore,
	pendingVulnReqsCache cache.VulnReqCache,
	activeVulnReqsCache cache.VulnReqCache,
	images imageDataStore.DataStore,
	imageCVEs imageCVEDataStore.DataStore,
	sensorConnMgr connection.Manager,
	reprocessor reprocessor.Loop,
) Manager {
	return &managerImpl{
		deployments:         deployments,
		images:              images,
		imageCVEs:           imageCVEs,
		vulnReqs:            vulnReqs,
		connManager:         sensorConnMgr,
		reprocessor:         reprocessor,
		pendingReqCache:     pendingVulnReqsCache,
		activeReqCache:      activeVulnReqsCache,
		lastKnownSeqNumInfo: &monthSeqNumPair{},

		revertTimedDeferralsTickerDuration:      env.VulnDeferralTimedReObserveInterval.DurationSetting(),
		revertFixableCVEDeferralsTickerDuration: env.VulnDeferralFixableReObserveInterval.DurationSetting(),
		stopper:                                 concurrency.NewStopper(),

		upsertSem: semaphore.NewWeighted(1),
	}
}
