//go:build sql_integration

package requestmgr

import (
	"context"
	"fmt"
	"testing"
	"time"

	imageCVEDS "github.com/stackrox/rox/central/cve/image/datastore"
	deploymentMockDS "github.com/stackrox/rox/central/deployment/datastore/mocks"
	imageDS "github.com/stackrox/rox/central/image/datastore"
	imageCVEEdgeDS "github.com/stackrox/rox/central/imagecveedge/datastore"
	reprocessorMocks "github.com/stackrox/rox/central/reprocessor/mocks"
	sensorConnMgrMocks "github.com/stackrox/rox/central/sensor/service/connection/mocks"
	vulnReqCache "github.com/stackrox/rox/central/vulnerabilityrequest/cache"
	"github.com/stackrox/rox/central/vulnerabilityrequest/common"
	vulnReqDS "github.com/stackrox/rox/central/vulnerabilityrequest/datastore"
	v1 "github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/generated/internalapi/central"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/concurrency"
	"github.com/stackrox/rox/pkg/cve"
	"github.com/stackrox/rox/pkg/features"
	"github.com/stackrox/rox/pkg/fixtures"
	"github.com/stackrox/rox/pkg/postgres/pgtest"
	"github.com/stackrox/rox/pkg/protocompat"
	"github.com/stackrox/rox/pkg/protoconv"
	"github.com/stackrox/rox/pkg/sac"
	"github.com/stackrox/rox/pkg/search"
	"github.com/stackrox/rox/pkg/set"
	"github.com/stackrox/rox/pkg/sliceutils"
	"github.com/stackrox/rox/pkg/uuid"
	"github.com/stretchr/testify/suite"
	"go.uber.org/mock/gomock"
	"golang.org/x/sync/semaphore"
)

const (
	imageOS = "windows-me"
)

var (
	allAllowedCtx             = sac.WithAllAccess(context.Background())
	expiryLoopDurationForTest = 5 * time.Second // use a much quicker loop for testing purposes
)

func TestVulnRequestManager(t *testing.T) {
	suite.Run(t, new(VulnRequestManagerTestSuite))
}

type VulnRequestManagerTestSuite struct {
	mockCtrl *gomock.Controller
	suite.Suite

	ctx    context.Context
	testDB *pgtest.TestPostgres

	vulnReqDataStore      vulnReqDS.DataStore
	deployments           *deploymentMockDS.MockDataStore
	imageDataStore        imageDS.DataStore
	imageCVEDataStore     imageCVEDS.DataStore
	imageCVEEdgeDataStore imageCVEEdgeDS.DataStore
	sensorConnMgrMocks    *sensorConnMgrMocks.MockManager
	reprocessor           *reprocessorMocks.MockLoop
	manager               *managerImpl
	pendingReqCache       vulnReqCache.VulnReqCache
	activeReqCache        vulnReqCache.VulnReqCache
}

func (s *VulnRequestManagerTestSuite) SetupTest() {
	s.ctx = context.Background()
	s.mockCtrl = gomock.NewController(s.T())
	s.testDB = pgtest.ForT(s.T())

	s.pendingReqCache, s.activeReqCache = vulnReqCache.New(), vulnReqCache.New()
	s.setupDataStores(s.pendingReqCache, s.activeReqCache)

	s.deployments = deploymentMockDS.NewMockDataStore(s.mockCtrl)
	s.sensorConnMgrMocks = sensorConnMgrMocks.NewMockManager(s.mockCtrl)
	s.reprocessor = reprocessorMocks.NewMockLoop(s.mockCtrl)
	s.manager = &managerImpl{
		deployments:                             s.deployments,
		images:                                  s.imageDataStore,
		imageCVEs:                               s.imageCVEDataStore,
		vulnReqs:                                s.vulnReqDataStore,
		connManager:                             s.sensorConnMgrMocks,
		reprocessor:                             s.reprocessor,
		pendingReqCache:                         s.pendingReqCache,
		activeReqCache:                          s.activeReqCache,
		revertTimedDeferralsTickerDuration:      expiryLoopDurationForTest,
		revertFixableCVEDeferralsTickerDuration: expiryLoopDurationForTest,
		stopper:                                 concurrency.NewStopper(),
		upsertSem:                               semaphore.NewWeighted(1),
	}
}

func (s *VulnRequestManagerTestSuite) TearDownTest() {
	s.testDB.Teardown(s.T())
}

func (s *VulnRequestManagerTestSuite) setupDataStores(pendingReqCache vulnReqCache.VulnReqCache, activeReqCache vulnReqCache.VulnReqCache) {
	var err error
	s.imageDataStore = imageDS.GetTestPostgresDataStore(s.T(), s.testDB.DB)
	s.imageCVEDataStore = imageCVEDS.GetTestPostgresDataStore(s.T(), s.testDB.DB)
	s.Require().NoError(err)
	s.imageCVEEdgeDataStore = imageCVEEdgeDS.GetTestPostgresDataStore(s.T(), s.testDB.DB)
	s.vulnReqDataStore = vulnReqDS.GetTestPostgresDataStore(s.T(), s.testDB.DB, pendingReqCache, activeReqCache)
}

func (s *VulnRequestManagerTestSuite) TestSnoozeAndUnsnoozeVulns() {
	s.validateSnoozeAndUnsnoozeVulns(fixtures.GetImageWithUniqueComponents(5), false)
}

func (s *VulnRequestManagerTestSuite) TestSnoozeAndUnsnoozeVulnsWithTaglessImages() {
	img := fixtures.GetImageWithUniqueComponents(5)
	img.GetName().Tag = ""
	s.validateSnoozeAndUnsnoozeVulns(img, false)
}

func (s *VulnRequestManagerTestSuite) TestSnoozeAndUnsnoozeBulkVulns() {
	s.validateSnoozeAndUnsnoozeVulns(fixtures.GetImageWithUniqueComponents(5), true)
}

func (s *VulnRequestManagerTestSuite) TestSnoozeAndUnsnoozeBulkVulnsWithTaglessImages() {
	img := fixtures.GetImageWithUniqueComponents(5)
	img.GetName().Tag = ""
	s.validateSnoozeAndUnsnoozeVulns(img, true)
}

func (s *VulnRequestManagerTestSuite) validateSnoozeAndUnsnoozeVulns(img *storage.Image, bulkCVEs bool) {
	imageName := img.GetName()
	img.GetScan().OperatingSystem = imageOS // Force the image to have a consistent OS to make searching easier

	var allCVEs, cvesToDefer []string
	for _, comp := range img.GetScan().GetComponents() {
		if len(comp.GetVulns()) > 0 {
			cvesToDefer = append(cvesToDefer, comp.GetVulns()[0].GetCve())
			for _, vuln := range comp.GetVulns() {
				allCVEs = append(allCVEs, vuln.GetCve())
			}
		}
	}

	err := s.imageDataStore.UpsertImage(allAllowedCtx, img)
	s.NoError(err)

	// Verify all CVEs are observed.
	s.verifyCVEState(storage.VulnerabilityState_OBSERVED, img.GetId(), allCVEs...)

	// Snooze; all tags.
	var falsePositiveExceptionAllTags []*storage.VulnerabilityRequest
	if bulkCVEs {
		falsePositiveExceptionAllTags = []*storage.VulnerabilityRequest{getBulkFalsePositiveVulnReq(imageName.GetRegistry(), imageName.GetRemote(), ".*", cvesToDefer)}
	} else {
		falsePositiveExceptionAllTags = getFPVulnReqs(imageName.GetRegistry(), imageName.GetRemote(), ".*", cvesToDefer)
	}
	for _, req := range falsePositiveExceptionAllTags {
		s.snooze(req, img)
	}
	s.verifyCVEState(storage.VulnerabilityState_FALSE_POSITIVE, img.GetId(), cvesToDefer...)
	s.verifyImageCVESearchByCVEState(storage.VulnerabilityState_FALSE_POSITIVE, cvesToDefer...)
	// Some CVEs are observed and some are deferred, hence both state searches must return the image.
	s.verifyImageSearchByCVEState(img.GetId(), storage.VulnerabilityState_FALSE_POSITIVE, false)
	s.verifyImageSearchByCVEState(img.GetId(), storage.VulnerabilityState_OBSERVED, false)

	// Snooze; one tag.
	var deferralExceptionOneTag []*storage.VulnerabilityRequest
	if bulkCVEs {
		deferralExceptionOneTag = []*storage.VulnerabilityRequest{getBulkDeferralVulnReq(imageName.GetRegistry(), imageName.GetRemote(), imageName.GetTag(), cvesToDefer)}
	} else {
		deferralExceptionOneTag = getDeferralVulnReqs(imageName.GetRegistry(), imageName.GetRemote(), imageName.GetTag(), cvesToDefer)
	}
	for _, req := range deferralExceptionOneTag {
		s.snooze(req, img)
	}
	s.verifyCVEState(storage.VulnerabilityState_DEFERRED, img.GetId(), cvesToDefer...)
	s.verifyImageCVESearchByCVEState(storage.VulnerabilityState_DEFERRED, cvesToDefer...)
	// Some CVEs are observed and some are deferred, hence both state searches must return the image.
	s.verifyImageSearchByCVEState(img.GetId(), storage.VulnerabilityState_DEFERRED, false)
	s.verifyImageSearchByCVEState(img.GetId(), storage.VulnerabilityState_OBSERVED, false)

	// Unsnooze; one tag
	for _, req := range deferralExceptionOneTag {
		s.unsnooze(req, img)
	}
	// Specific tag exception is removed but there still exists exception that applies to all tag. Hence, the CVE state changes to false-positive.
	s.verifyCVEState(storage.VulnerabilityState_FALSE_POSITIVE, img.GetId(), cvesToDefer...)
	s.verifyImageSearchByCVEState(img.GetId(), storage.VulnerabilityState_OBSERVED, false)
	s.verifyImageSearchByCVEState(img.GetId(), storage.VulnerabilityState_DEFERRED, true)

	// Unsnooze; all tags
	for _, req := range falsePositiveExceptionAllTags {
		s.unsnooze(req, img)
	}
	s.verifyCVEState(storage.VulnerabilityState_OBSERVED, img.GetId(), allCVEs...)
	s.verifyImageCVESearchByCVEState(storage.VulnerabilityState_OBSERVED, allCVEs...)
	s.verifyImageSearchByCVEState(img.GetId(), storage.VulnerabilityState_OBSERVED, false)
	s.verifyImageSearchByCVEState(img.GetId(), storage.VulnerabilityState_DEFERRED, true)
	s.verifyImageSearchByCVEState(img.GetId(), storage.VulnerabilityState_FALSE_POSITIVE, true)
}

func (s *VulnRequestManagerTestSuite) snooze(req *storage.VulnerabilityRequest, image *storage.Image) {
	sensorMsg := getSensorMsg(image)
	depQuery := search.ConjunctionQuery(
		search.NewQueryBuilder().AddExactMatches(search.ImageSHA, image.GetId()).ProtoQuery(),
		search.NewQueryBuilder().AddStringsHighlighted(search.ClusterID, search.WildcardString).ProtoQuery(),
	)

	s.sensorConnMgrMocks.EXPECT().BroadcastMessage(sensorMsg)
	s.deployments.EXPECT().SearchDeployments(allAllowedCtx, depQuery).Return(
		[]*v1.SearchResult{
			{
				Id: "dep1",
				FieldToMatches: map[string]*v1.SearchResult_Matches{
					"deployment.cluster_id": {Values: []string{"c1"}},
				},
			},
		},
		nil)
	s.reprocessor.EXPECT().ReprocessRiskForDeployments("dep1")
	s.sensorConnMgrMocks.EXPECT().GetConnection("c1").Return(nil)
	err := s.manager.SnoozeVulnerabilityOnRequest(allAllowedCtx, req)
	s.NoError(err)
}

func (s *VulnRequestManagerTestSuite) unsnooze(req *storage.VulnerabilityRequest, image *storage.Image) {
	sensorMsg := getSensorMsg(image)
	depQuery := search.ConjunctionQuery(
		search.NewQueryBuilder().AddExactMatches(search.ImageSHA, image.GetId()).ProtoQuery(),
		search.NewQueryBuilder().AddStringsHighlighted(search.ClusterID, search.WildcardString).ProtoQuery(),
	)

	s.sensorConnMgrMocks.EXPECT().BroadcastMessage(sensorMsg)
	s.deployments.EXPECT().SearchDeployments(allAllowedCtx, depQuery).Return(
		[]*v1.SearchResult{
			{
				Id: "dep1",
				FieldToMatches: map[string]*v1.SearchResult_Matches{
					"deployment.cluster_id": {Values: []string{"c1"}},
				},
			},
		},
		nil)
	s.reprocessor.EXPECT().ReprocessRiskForDeployments("dep1")
	s.sensorConnMgrMocks.EXPECT().GetConnection("c1").Return(nil)
	err := s.manager.UnSnoozeVulnerabilityOnRequest(allAllowedCtx, req)
	s.NoError(err)
}

func (s *VulnRequestManagerTestSuite) verifyCVEState(state storage.VulnerabilityState, imageID string, cves ...string) {
	cveSet := set.NewStringSet(cves...)
	obj, found, err := s.imageDataStore.GetImage(allAllowedCtx, imageID)
	s.NoError(err)
	s.True(found)
	for _, component := range obj.GetScan().GetComponents() {
		for _, vuln := range component.GetVulns() {
			if cveSet.Contains(vuln.GetCve()) {
				s.Equal(state, vuln.GetState())
			}
		}
	}
}

func (s *VulnRequestManagerTestSuite) verifyImageSearchByCVEState(imgID string, state storage.VulnerabilityState, verifyNotFound bool) {
	results, err := s.imageDataStore.Search(
		allAllowedCtx,
		search.NewQueryBuilder().AddStrings(search.VulnerabilityState, state.String()).ProtoQuery(),
	)
	s.NoError(err)
	if verifyNotFound {
		s.Nil(results)
	} else {
		s.ElementsMatch([]string{imgID}, search.ResultsToIDs(results))
	}
}

func (s *VulnRequestManagerTestSuite) verifyImageCVESearchByCVEState(state storage.VulnerabilityState, expectedCVEs ...string) {
	results, err := s.imageCVEDataStore.Search(
		allAllowedCtx,
		search.NewQueryBuilder().AddStrings(search.VulnerabilityState, state.String()).ProtoQuery(),
	)
	s.NoError(err)
	expected := sliceutils.Map(expectedCVEs, func(cveName string) string {
		return cve.ID(cveName, imageOS)
	})
	s.ElementsMatch(expected, search.ResultsToIDs(results))
}

func (s *VulnRequestManagerTestSuite) TestProcessorDoesntExpireOnceStopped() {
	s.manager.Start()
	time.Sleep(expiryLoopDurationForTest) // wait for it to run at least once

	// Now stop it
	s.manager.Stop()

	// Add in a request that should be expired if it wasn't stopped
	req := newDeferral("req", false, storage.RequestStatus_APPROVED, time.Now().Add(-24*time.Hour))
	err := s.vulnReqDataStore.AddRequest(allAllowedCtx, req)
	s.NoError(err)

	// Wait again for what would've been two loops
	time.Sleep(expiryLoopDurationForTest * 2)

	// Verify request wasn't marked inactive
	r, ok, err := s.vulnReqDataStore.Get(allAllowedCtx, req.GetId())
	s.NoError(err)
	s.True(ok)
	s.False(r.Expired)
}

func (s *VulnRequestManagerTestSuite) TestBuildCacheActiveRequests() {
	reqs := []*storage.VulnerabilityRequest{
		newFalsePositive("approved-fp", "cve-approved-fp", false, storage.RequestStatus_APPROVED, nil),
		newFalsePositive("approved-pending-update-fp", "cve-approved-pending-update-fp", false, storage.RequestStatus_APPROVED_PENDING_UPDATE, nil),
		newFalsePositive("expired-fp", "cve-expired-fp", true, storage.RequestStatus_APPROVED, nil),
		newFalsePositive("denied-fp", "cve-denied-fp", false, storage.RequestStatus_DENIED, nil),
		newFalsePositive("pending-fp", "cve-pending-fp", false, storage.RequestStatus_PENDING, nil),
	}
	for _, r := range reqs {
		err := s.vulnReqDataStore.AddRequest(allAllowedCtx, r)
		s.NoError(err)
	}

	s.NoError(s.manager.buildCache())
	states := s.activeReqCache.GetVulnsWithState("registry", "remote", ".*")
	// Only two states (for the two approved reqs) should be in the activeReqCache.
	s.Len(states, 2)
	s.Equal(states["cve-approved-fp"], storage.VulnerabilityState_FALSE_POSITIVE)
	s.Equal(states["cve-approved-pending-update-fp"], storage.VulnerabilityState_FALSE_POSITIVE)

	states = s.pendingReqCache.GetVulnsWithState("registry", "remote", ".*")
	// Only pending requests should be in the pendingReqCache.
	s.Len(states, 2)
	s.Equal(states["cve-pending-fp"], storage.VulnerabilityState_FALSE_POSITIVE)
	s.Equal(states["cve-approved-pending-update-fp"], storage.VulnerabilityState_FALSE_POSITIVE)
}

//// start test utilities

func newDeferral(id string, expired bool, status storage.RequestStatus, expiry time.Time, cves ...string) *storage.VulnerabilityRequest {
	id = id + "-" + uuid.NewV4().String()
	ret := &storage.VulnerabilityRequest{
		Id:          id,
		Name:        id,
		Status:      status,
		Expired:     expired,
		TargetState: storage.VulnerabilityState_DEFERRED,
		Req: &storage.VulnerabilityRequest_DeferralReq{
			DeferralReq: &storage.DeferralRequest{
				Expiry: &storage.RequestExpiry{
					Expiry: &storage.RequestExpiry_ExpiresOn{
						ExpiresOn: protocompat.ConvertTimeToTimestampOrNil(&expiry),
					},
				},
			},
		},
		Scope: &storage.VulnerabilityRequest_Scope{
			Info: &storage.VulnerabilityRequest_Scope_GlobalScope{
				GlobalScope: &storage.VulnerabilityRequest_Scope_Global{},
			},
		},
	}
	if len(cves) > 0 {
		ret.Entities = &storage.VulnerabilityRequest_Cves{
			Cves: &storage.VulnerabilityRequest_CVEs{
				Cves: cves,
			},
		}
	}
	return ret
}

func newDeferralExpiresWhenFixable(id string, expired bool, status storage.RequestStatus, imgScope *storage.VulnerabilityRequest_Scope, allFixable bool, cves ...string) *storage.VulnerabilityRequest {
	req := &storage.VulnerabilityRequest{
		Id:          id,
		Name:        id,
		Status:      status,
		Expired:     expired,
		TargetState: storage.VulnerabilityState_DEFERRED,
		Req: &storage.VulnerabilityRequest_DeferralReq{
			DeferralReq: &storage.DeferralRequest{
				Expiry: &storage.RequestExpiry{
					Expiry: &storage.RequestExpiry_ExpiresWhenFixed{
						// In v1, only any fixable was supported.
						ExpiresWhenFixed: !allFixable,
					},
					ExpiryType: func() storage.RequestExpiry_ExpiryType {
						if allFixable {
							return storage.RequestExpiry_ALL_CVE_FIXABLE
						}
						return storage.RequestExpiry_ANY_CVE_FIXABLE
					}(),
				},
			},
		},
		Scope: func() *storage.VulnerabilityRequest_Scope {
			if features.UnifiedCVEDeferral.Enabled() {
				return &storage.VulnerabilityRequest_Scope{
					Info: &storage.VulnerabilityRequest_Scope_ImageScope{
						ImageScope: &storage.VulnerabilityRequest_Scope_Image{
							Registry: common.MatchAll,
							Remote:   common.MatchAll,
							Tag:      common.MatchAll,
						},
					},
				}
			}
			return &storage.VulnerabilityRequest_Scope{
				Info: &storage.VulnerabilityRequest_Scope_GlobalScope{
					GlobalScope: &storage.VulnerabilityRequest_Scope_Global{},
				},
			}
		}(),
		Entities: &storage.VulnerabilityRequest_Cves{
			Cves: &storage.VulnerabilityRequest_CVEs{
				Cves: cves,
			},
		},
	}
	if imgScope != nil {
		req.Scope = imgScope
	}
	return req
}

func newFalsePositive(id, cve string, expired bool, status storage.RequestStatus, imgScope *storage.VulnerabilityRequest_Scope) *storage.VulnerabilityRequest {
	req := &storage.VulnerabilityRequest{
		Id:          id,
		Name:        id,
		Status:      status,
		Expired:     expired,
		TargetState: storage.VulnerabilityState_FALSE_POSITIVE,
		Req: &storage.VulnerabilityRequest_FpRequest{
			FpRequest: &storage.FalsePositiveRequest{},
		},
		Scope: &storage.VulnerabilityRequest_Scope{
			Info: &storage.VulnerabilityRequest_Scope_GlobalScope{
				GlobalScope: &storage.VulnerabilityRequest_Scope_Global{},
			},
		},
		Entities: &storage.VulnerabilityRequest_Cves{
			Cves: &storage.VulnerabilityRequest_CVEs{
				Cves: []string{cve},
			},
		},
	}
	if imgScope != nil {
		req.Scope = imgScope
	}
	return req
}

func vulnScopeFromImage(img *storage.Image, allTags bool) *storage.VulnerabilityRequest_Scope {
	scope := &storage.VulnerabilityRequest_Scope{
		Info: &storage.VulnerabilityRequest_Scope_ImageScope{
			ImageScope: &storage.VulnerabilityRequest_Scope_Image{
				Registry: img.GetName().GetRegistry(),
				Remote:   img.GetName().GetRemote(),
				Tag:      img.GetName().GetTag(),
			},
		},
	}
	if allTags {
		scope.GetImageScope().Tag = common.MatchAll
	}
	return scope
}

func getDeferralVulnReqs(registry, remote, tag string, cvesToDefer []string) []*storage.VulnerabilityRequest {
	var reqs []*storage.VulnerabilityRequest
	for _, cve := range cvesToDefer {
		req := fixtures.GetImageScopeDeferralRequest(registry, remote, tag, cve)
		req.Status = storage.RequestStatus_APPROVED
		reqs = append(reqs, req)
	}
	return reqs
}

func getFPVulnReqs(registry, remote, tag string, cvesToDefer []string) []*storage.VulnerabilityRequest {
	var reqs []*storage.VulnerabilityRequest
	for _, cve := range cvesToDefer {
		req := fixtures.GetImageScopeFPRequest(registry, remote, tag, cve)
		req.Status = storage.RequestStatus_APPROVED
		reqs = append(reqs, req)
	}
	return reqs
}

func getBulkDeferralVulnReq(registry, remote, tag string, cvesToDefer []string) *storage.VulnerabilityRequest {
	req := fixtures.GetImageScopeDeferralRequest(registry, remote, tag, cvesToDefer...)
	req.Status = storage.RequestStatus_APPROVED
	return req
}

func getBulkFalsePositiveVulnReq(registry, remote, tag string, cvesToDefer []string) *storage.VulnerabilityRequest {
	req := fixtures.GetImageScopeFPRequest(registry, remote, tag, cvesToDefer...)
	req.Status = storage.RequestStatus_APPROVED
	return req
}

func getDeferralExpiryTimeUpdate(addHrToNow time.Duration) *storage.VulnerabilityRequest_UpdatedDeferralReq {
	return &storage.VulnerabilityRequest_UpdatedDeferralReq{
		UpdatedDeferralReq: &storage.DeferralRequest{
			Expiry: &storage.RequestExpiry{
				Expiry: &storage.RequestExpiry_ExpiresOn{
					ExpiresOn: protoconv.ConvertTimeToTimestamp(time.Now().Add(addHrToNow)),
				},
				ExpiryType: storage.RequestExpiry_TIME,
			},
		},
	}
}

func getDeferralExpiryFixableUpdate(anyFixable bool) *storage.VulnerabilityRequest_UpdatedDeferralReq {
	return &storage.VulnerabilityRequest_UpdatedDeferralReq{
		UpdatedDeferralReq: &storage.DeferralRequest{
			Expiry: &storage.RequestExpiry{
				Expiry: &storage.RequestExpiry_ExpiresWhenFixed{
					ExpiresWhenFixed: anyFixable,
				},
				ExpiryType: func() storage.RequestExpiry_ExpiryType {
					if anyFixable {
						return storage.RequestExpiry_ANY_CVE_FIXABLE
					}
					return storage.RequestExpiry_ALL_CVE_FIXABLE
				}(),
			},
		},
	}
}

func getImageWithVulnerableComponents(registry, remote, tag, id string, fixableCVECount int) *storage.Image {
	img := fixtures.GetImageWithUniqueComponents(5)
	img.Name = &storage.ImageName{
		Registry: registry,
		Remote:   remote,
		Tag:      tag,
		FullName: fmt.Sprintf("%s/%s:%s", registry, remote, tag),
	}
	img.Id = id
	img.GetScan().OperatingSystem = imageOS
	components := img.GetScan().GetComponents()

	// First two vulns are fixable, the rest are not
	for _, comp := range components {
		for i, vuln := range comp.GetVulns() {
			if i >= fixableCVECount {
				vuln.SetFixedBy = nil
			}
		}
	}

	// Add a new fixable vuln that's same across both components
	clonedVuln := components[0].GetVulns()[1].Clone()
	clonedVuln.Cve = "CVE-SAME-VULN"
	components[0].Vulns = append(components[0].Vulns, clonedVuln.Clone())
	components[1].Vulns = append(components[1].Vulns, clonedVuln.Clone())

	// Add another vuln that's same across both components but is fixable only for the 1st component
	clonedVuln = components[0].GetVulns()[1].Clone()
	clonedVuln.Cve = "CVE-SAME-VULN-2"
	components[0].Vulns = append(components[0].Vulns, clonedVuln.Clone())
	v := clonedVuln.Clone()
	v.SetFixedBy = nil
	components[1].Vulns = append(components[1].Vulns, v)

	return img
}

func getSensorMsg(img *storage.Image) *central.MsgToSensor {
	return &central.MsgToSensor{
		Msg: &central.MsgToSensor_InvalidateImageCache{
			InvalidateImageCache: &central.InvalidateImageCache{
				ImageKeys: []*central.InvalidateImageCache_ImageKey{
					{
						ImageId:       img.GetId(),
						ImageFullName: img.GetName().GetFullName(),
					},
				},
			},
		},
	}
}

//// end test utilities
