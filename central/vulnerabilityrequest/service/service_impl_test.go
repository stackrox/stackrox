package service

import (
	"context"
	"testing"

	"github.com/gogo/protobuf/types"
	"github.com/golang/mock/gomock"
	dsMock "github.com/stackrox/rox/central/vulnerabilityrequest/datastore/mocks"
	mgrMock "github.com/stackrox/rox/central/vulnerabilityrequest/manager/mocks"
	"github.com/stackrox/rox/central/vulnerabilityrequest/utils"
	v1 "github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/fixtures"
	"github.com/stackrox/rox/pkg/sac"
	"github.com/stackrox/rox/pkg/testutils/envisolator"
	"github.com/stretchr/testify/suite"
)

var (
	allAllowedCtx = sac.WithAllAccess(context.Background())
)

func TestVulnRequestService(t *testing.T) {
	suite.Run(t, new(VulnRequestServiceTestSuite))
}

type VulnRequestServiceTestSuite struct {
	suite.Suite
	envIsolator *envisolator.EnvIsolator

	mockCtrl  *gomock.Controller
	datastore *dsMock.MockDataStore
	manager   *mgrMock.MockManager

	service Service
}

func (s *VulnRequestServiceTestSuite) SetupTest() {
	s.envIsolator = envisolator.NewEnvIsolator(s.T())
	s.mockCtrl = gomock.NewController(s.T())

	s.datastore = dsMock.NewMockDataStore(s.mockCtrl)
	s.manager = mgrMock.NewMockManager(s.mockCtrl)
	s.service = New(s.datastore, s.manager)
}

func (s *VulnRequestServiceTestSuite) TestDeferVulnerabilityCreatesDeferRequest() {
	req := s.getDeferralRequest()

	s.datastore.EXPECT().SearchRawRequests(allAllowedCtx, gomock.Any()).Return([]*storage.VulnerabilityRequest{}, nil)
	s.datastore.EXPECT().AddRequest(allAllowedCtx, gomock.Any()).Return(nil)

	resp, err := s.service.DeferVulnerability(allAllowedCtx, req)
	s.NoError(err)
	s.Equal(req.GetExpiresOn(), resp.GetRequestInfo().GetDeferralReq().GetExpiry().GetExpiresOn())
}

func (s *VulnRequestServiceTestSuite) TestCreateReqErrorsIfRequestAlreadyExists() {
	cve := "CVE-2021-1031"
	globalDefReq := fixtures.GetGlobalDeferralRequest(cve)
	globalFPReq := fixtures.GetGlobalFPRequest(cve)
	globalDefReqApproved := fixtures.GetGlobalDeferralRequest(cve)
	globalDefReqApproved.Status = storage.RequestStatus_APPROVED
	globalFPReqApproved := fixtures.GetGlobalDeferralRequest(cve)
	globalFPReqApproved.Status = storage.RequestStatus_APPROVED

	cases := []struct {
		name         string
		existingReqs []*storage.VulnerabilityRequest
		reqType      storage.VulnerabilityState
		allow        bool
	}{
		{
			name:         "[DEFER] allow if no other reqs for this cve",
			existingReqs: []*storage.VulnerabilityRequest{},
			reqType:      storage.VulnerabilityState_DEFERRED,
			allow:        true,
		},
		{
			name:         "[DEFER] allow if scope is different",
			existingReqs: []*storage.VulnerabilityRequest{fixtures.GetImageScopeDeferralRequest("k8s.gcr.io", "kube-proxy", ".*", cve)},
			reqType:      storage.VulnerabilityState_DEFERRED,
			allow:        true,
		},
		{
			name:         "[DEFER] disallow if exact same cve + scope pending request already exists",
			existingReqs: []*storage.VulnerabilityRequest{globalDefReq},
			reqType:      storage.VulnerabilityState_DEFERRED,
			allow:        false,
		},
		{
			name:         "[DEFER] disallow if exact same cve + scope approved request already exists",
			existingReqs: []*storage.VulnerabilityRequest{globalDefReqApproved},
			reqType:      storage.VulnerabilityState_DEFERRED,
			allow:        false,
		},
		{
			name:         "[DEFER] disallow if exact same cve + scope request already exists even if for FP",
			existingReqs: []*storage.VulnerabilityRequest{globalFPReq},
			reqType:      storage.VulnerabilityState_DEFERRED,
			allow:        false,
		},
		{
			name:         "[FP] allow if no other reqs for this cve",
			existingReqs: []*storage.VulnerabilityRequest{},
			reqType:      storage.VulnerabilityState_FALSE_POSITIVE,
			allow:        true,
		},
		{
			name:         "[FP] allow if scope is different",
			existingReqs: []*storage.VulnerabilityRequest{fixtures.GetImageScopeFPRequest("k8s.gcr.io", "kube-proxy", ".*", cve)},
			reqType:      storage.VulnerabilityState_FALSE_POSITIVE,
			allow:        true,
		},
		{
			name:         "[FP] disallow if exact same cve + scope pending request already exists",
			existingReqs: []*storage.VulnerabilityRequest{globalFPReq},
			reqType:      storage.VulnerabilityState_FALSE_POSITIVE,
			allow:        false,
		},
		{
			name:         "[FP] disallow if exact same cve + scope approved request already exists",
			existingReqs: []*storage.VulnerabilityRequest{globalFPReqApproved},
			reqType:      storage.VulnerabilityState_FALSE_POSITIVE,
			allow:        false,
		},
		{
			name:         "[FP] disallow if exact same cve + scope request already exists even if for deferral",
			existingReqs: []*storage.VulnerabilityRequest{globalDefReq},
			reqType:      storage.VulnerabilityState_FALSE_POSITIVE,
			allow:        false,
		},
	}
	for _, c := range cases {
		s.T().Run(c.name, func(t *testing.T) {
			s.datastore.EXPECT().SearchRawRequests(allAllowedCtx, utils.GetQueryForApprovedReqsWithSimilarScope(cve)).Return(c.existingReqs, nil)
			if c.allow {
				s.datastore.EXPECT().AddRequest(allAllowedCtx, gomock.Any()).Return(nil)
			}

			var err error
			var resp interface{}
			if c.reqType == storage.VulnerabilityState_DEFERRED {
				resp, err = s.service.DeferVulnerability(allAllowedCtx, s.getDeferralRequest())
			} else {
				resp, err = s.service.FalsePositiveVulnerability(allAllowedCtx, s.getFPRequest())
			}

			if c.allow {
				s.NoError(err)
				s.NotNil(resp)
			} else {
				s.Error(err)
			}
		})
	}
}

func (s *VulnRequestServiceTestSuite) TestApproveRequestSnoozesVuln() {
	pendingReq := fixtures.GetGlobalFPRequest("cve-abcd")
	req := &v1.ApproveVulnRequest{
		Id:      pendingReq.GetId(),
		Comment: "approved",
	}
	approvedReq := pendingReq.Clone()
	approvedReq.Status = storage.RequestStatus_APPROVED

	s.datastore.EXPECT().UpdateRequestStatus(allAllowedCtx, pendingReq.GetId(), req.GetComment(), storage.RequestStatus_APPROVED).Return(approvedReq, nil)
	s.manager.EXPECT().SnoozeVulnerabilityOnRequest(allAllowedCtx, approvedReq).Return(nil)

	resp, err := s.service.ApproveVulnerabilityRequest(allAllowedCtx, req)
	s.NoError(err)
	s.Equal(approvedReq, resp.GetRequestInfo())
}

func (s *VulnRequestServiceTestSuite) TestDenyRequest() {
	pendingReq := fixtures.GetGlobalFPRequest("cve-abcd")
	req := &v1.DenyVulnRequest{
		Id:      pendingReq.GetId(),
		Comment: "denied",
	}
	deniedReq := pendingReq.Clone()
	deniedReq.Status = storage.RequestStatus_DENIED

	s.datastore.EXPECT().UpdateRequestStatus(allAllowedCtx, pendingReq.GetId(), req.GetComment(), storage.RequestStatus_DENIED).Return(deniedReq, nil)

	resp, err := s.service.DenyVulnerabilityRequest(allAllowedCtx, req)
	s.NoError(err)
	s.Equal(deniedReq, resp.GetRequestInfo())
}

func (s *VulnRequestServiceTestSuite) TestUndoRequestUnSnoozesVuln() {
	pendingReq := fixtures.GetGlobalFPRequest("cve-abcd")
	req := &v1.ResourceByID{
		Id: pendingReq.GetId(),
	}
	inactiveReq := pendingReq.Clone()
	inactiveReq.Expired = true

	s.datastore.EXPECT().MarkRequestInactive(allAllowedCtx, pendingReq.GetId(), "[System Generated] Request undone").Return(inactiveReq, nil)
	s.manager.EXPECT().UnSnoozeVulnerabilityOnRequest(allAllowedCtx, inactiveReq).Return(nil)

	resp, err := s.service.UndoVulnerabilityRequest(allAllowedCtx, req)
	s.NoError(err)
	s.Equal(inactiveReq, resp.GetRequestInfo())
}

func (s *VulnRequestServiceTestSuite) getFPRequest() *v1.FalsePositiveVulnRequest {
	return &v1.FalsePositiveVulnRequest{
		Cve:     "CVE-2021-1031",
		Comment: "no u",
		Scope: &storage.VulnerabilityRequest_Scope{
			Info: &storage.VulnerabilityRequest_Scope_GlobalScope{GlobalScope: &storage.VulnerabilityRequest_Scope_Global{}},
		},
	}
}

func (s *VulnRequestServiceTestSuite) getDeferralRequest() *v1.DeferVulnRequest {
	return &v1.DeferVulnRequest{
		Cve:     "CVE-2021-1031",
		Comment: "cant be bothered to fix it",
		Scope: &storage.VulnerabilityRequest_Scope{
			Info: &storage.VulnerabilityRequest_Scope_GlobalScope{GlobalScope: &storage.VulnerabilityRequest_Scope_Global{}},
		},
		Expiry: &v1.DeferVulnRequest_ExpiresOn{
			ExpiresOn: types.TimestampNow(),
		},
	}
}
