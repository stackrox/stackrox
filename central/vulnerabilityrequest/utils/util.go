package utils

import (
	"context"

	"github.com/gogo/protobuf/types"
	v1 "github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/grpc/authn"
	"github.com/stackrox/rox/pkg/search"
	"github.com/stackrox/rox/pkg/stringutils"
	"github.com/stackrox/rox/pkg/uuid"
)

// CreateVulnRequestProto creates a generic *storage.VulnerabilityRequest object.
func CreateVulnRequestProto(
	ctx context.Context,
	cve string,
	reqType storage.VulnerabilityState,
	scope *storage.VulnerabilityRequest_Scope,
	comment string,
) *storage.VulnerabilityRequest {
	now := types.TimestampNow()
	proto := &storage.VulnerabilityRequest{
		CreatedAt:   now,
		LastUpdated: now,
		TargetState: reqType,
		Status:      storage.RequestStatus_PENDING,
		Requestor:   UserFromContext(ctx),
		Comments: []*storage.RequestComment{
			CreateRequestCommentProto(ctx, comment),
		},
		Entities: &storage.VulnerabilityRequest_Cves{
			Cves: &storage.VulnerabilityRequest_CVEs{
				Ids: []string{cve},
			},
		},
		Scope: scope,
	}

	switch reqType {
	case storage.VulnerabilityState_DEFERRED:
		proto.Req = &storage.VulnerabilityRequest_DeferralReq{DeferralReq: &storage.DeferralRequest{}}
	case storage.VulnerabilityState_FALSE_POSITIVE:
		proto.Req = &storage.VulnerabilityRequest_FpRequest{FpRequest: &storage.FalsePositiveRequest{}}
	default:
		// no req object for other states
	}

	return proto
}

// CreateRequestCommentProto creates *storage.RequestComment object.
func CreateRequestCommentProto(ctx context.Context, message string) *storage.RequestComment {
	return &storage.RequestComment{
		Id:        uuid.NewV4().String(),
		CreatedAt: types.TimestampNow(),
		Message:   message,
		User:      UserFromContext(ctx),
	}
}

// UserFromContext creates *storage.SlimUser object
func UserFromContext(ctx context.Context) *storage.SlimUser {
	identity := authn.IdentityFromContextOrNil(ctx)
	if identity == nil {
		return nil
	}
	return &storage.SlimUser{
		Id:   identity.UID(),
		Name: stringutils.FirstNonEmpty(identity.FullName(), identity.FriendlyName()),
	}
}

// GetQueryForApprovedReqsWithSimilarScope returns a *v1.Query which will search for all requests for a CVE with similar scope that has been approved
func GetQueryForApprovedReqsWithSimilarScope(cve string) *v1.Query {
	return search.ConjunctionQuery(
		search.NewQueryBuilder().AddExactMatches(search.CVE, cve).AddBools(search.ExpiredRequest, false).ProtoQuery(),
		search.NewQueryBuilder().AddExactMatches(search.RequestStatus, storage.RequestStatus_APPROVED.String(), storage.RequestStatus_APPROVED_PENDING_UPDATE.String()).ProtoQuery(),
	)
}
