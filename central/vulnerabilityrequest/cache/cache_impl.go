package cache

import (
	"fmt"

	"github.com/stackrox/rox/central/vulnerabilityrequest/common"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/sync"
)

type slimRequest struct {
	requestID   string
	targetState storage.VulnerabilityState
	cves        []string
}

type vulnReqCacheImpl struct {
	// vulnReqByScope is map of scope to request IDs to (slimmed) request object.
	vulnReqByScope map[string]map[string]*slimRequest
	// scopeByVulnReqs is map of vulnerability requests IDs to vuln request scope strings.
	scopeByVulnReqs map[string]string

	lock sync.RWMutex
}

func (c *vulnReqCacheImpl) GetVulnsWithState(registry, remote, tag string) map[string]storage.VulnerabilityState {
	c.lock.RLock()
	defer c.lock.RUnlock()

	vulns := make(map[string]storage.VulnerabilityState)
	for _, scope := range []string{
		// Start with the largest scope because state from the smallest scope takes precedence.
		common.MatchAll,
		imageNameToScopeStr(registry, remote, common.MatchAll),
		imageNameToScopeStr(registry, remote, tag),
	} {

		reqMap := c.vulnReqByScope[scope]
		if reqMap == nil {
			continue
		}

		for _, req := range reqMap {
			if req == nil {
				continue
			}
			for _, cve := range req.cves {
				vulns[cve] = req.targetState
			}
		}
	}
	return vulns
}

func (c *vulnReqCacheImpl) Add(request *storage.VulnerabilityRequest) bool {
	c.lock.Lock()
	defer c.lock.Unlock()

	return c.addNoLock(request)
}

func (c *vulnReqCacheImpl) AddMany(requests ...*storage.VulnerabilityRequest) {
	c.lock.Lock()
	defer c.lock.Unlock()

	for _, request := range requests {
		c.addNoLock(request)
	}
}

func (c *vulnReqCacheImpl) addNoLock(request *storage.VulnerabilityRequest) bool {
	scope := c.scopeByVulnReqs[request.GetId()]
	if scope != "" {
		return false
	}
	scope = toScopeStr(request.GetScope())
	c.scopeByVulnReqs[request.GetId()] = scope

	if c.vulnReqByScope[scope] == nil {
		c.vulnReqByScope[scope] = make(map[string]*slimRequest)
	}
	if c.vulnReqByScope[scope][request.GetId()] != nil {
		return false
	}
	c.vulnReqByScope[scope][request.GetId()] = &slimRequest{
		requestID:   request.GetId(),
		targetState: request.GetTargetState(),
		cves:        request.GetCves().GetIds(),
	}
	return true
}

func (c *vulnReqCacheImpl) Remove(requestID string) bool {
	c.lock.Lock()
	defer c.lock.Unlock()

	scope := c.scopeByVulnReqs[requestID]
	if scope == "" {
		return false
	}
	delete(c.scopeByVulnReqs, requestID)

	reqMap := c.vulnReqByScope[scope]
	if reqMap == nil {
		return false
	}
	delete(reqMap, requestID)

	if len(reqMap) == 0 {
		delete(c.vulnReqByScope, scope)
	}
	return true
}

func toScopeStr(scope *storage.VulnerabilityRequest_Scope) string {
	if scope.GetGlobalScope() != nil {
		return common.MatchAll
	}
	if imgScope := scope.GetImageScope(); imgScope != nil {
		return imageNameToScopeStr(imgScope.GetRegistry(), imgScope.GetRemote(), imgScope.GetTag())
	}
	return ""
}

func imageNameToScopeStr(registry, remote, tag string) string {
	return fmt.Sprintf("%s/%s:%s", registry, remote, tag)
}
