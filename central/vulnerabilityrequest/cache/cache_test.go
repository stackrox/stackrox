package cache

import (
	"testing"

	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/fixtures"
	"github.com/stretchr/testify/assert"
)

func TestCache(t *testing.T) {
	img := fixtures.GetImage()
	registry := img.GetName().GetRegistry()
	remote := img.GetName().GetRemote()
	tag := img.GetName().GetTag()
	vuln1 := img.Scan.Components[0].Vulns[0].GetCve()
	vuln2 := img.Scan.Components[0].Vulns[1].GetCve()
	vuln3 := img.Scan.Components[0].Vulns[2].GetCve()

	req1 := fixtures.GetGlobalFPRequest(vuln1)
	req2 := fixtures.GetGlobalDeferralRequest(vuln2)
	req3 := fixtures.GetImageScopeDeferralRequest(registry, remote, tag, vuln1)
	req4 := fixtures.GetImageScopeDeferralRequest(registry, remote, tag, vuln3)

	cache := New()
	for _, req := range []*storage.VulnerabilityRequest{req1, req2, req3, req4} {
		assert.True(t, cache.Add(req))
	}

	// Test that the vulnerability state is scoped to the smallest scope.
	response := cache.GetVulnsWithState(registry, remote, tag)
	assert.Len(t, response, 3)
	assert.Equal(t, storage.VulnerabilityState_DEFERRED, response[vuln1])
	assert.Equal(t, storage.VulnerabilityState_DEFERRED, response[vuln2])
	assert.Equal(t, storage.VulnerabilityState_DEFERRED, response[vuln3])

	// Remove the image scoped request for vuln1
	cache.Remove(req3.GetId())

	// Test that the vulnerability state is scoped to the remaining scope i.e. global.
	response = cache.GetVulnsWithState(registry, remote, tag)
	assert.Equal(t, storage.VulnerabilityState_FALSE_POSITIVE, response[vuln1])
}
