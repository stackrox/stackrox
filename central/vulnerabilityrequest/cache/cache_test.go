package cache

import (
	"testing"

	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/fixtures"
	"github.com/stretchr/testify/assert"
)

func TestCache(t *testing.T) {
	img := fixtures.GetImage()
	registry := img.GetName().GetRegistry()
	remote := img.GetName().GetRemote()
	tag := img.GetName().GetTag()
	vuln1 := img.Scan.Components[0].Vulns[0].GetCve()
	vuln2 := img.Scan.Components[0].Vulns[1].GetCve()
	vuln3 := img.Scan.Components[0].Vulns[2].GetCve()

	req1 := fixtures.GetGlobalFPRequest(vuln1)
	req1.Id = "req1"
	req2 := fixtures.GetGlobalDeferralRequest(vuln2)
	req2.Id = "req2"
	req3 := fixtures.GetImageScopeDeferralRequest(registry, remote, tag, vuln1)
	req3.Id = "req3"
	req4 := fixtures.GetImageScopeDeferralRequest(registry, remote, tag, vuln3)
	req4.Id = "req4"

	cache := New()
	for _, req := range []*storage.VulnerabilityRequest{req1, req2, req3, req4} {
		assert.True(t, cache.Add(req))
	}

	// Test that the vulnerability state is scoped to the smallest scope.
	response := cache.GetVulnsWithState(registry, remote, tag)
	assert.Len(t, response, 3)
	assert.Equal(t, storage.VulnerabilityState_DEFERRED, response[vuln1])
	assert.Equal(t, storage.VulnerabilityState_DEFERRED, response[vuln2])
	assert.Equal(t, storage.VulnerabilityState_DEFERRED, response[vuln3])

	// Given a smallest scoped request, test if the scope is returned correctly.
	response = cache.GetEffectiveVulnState([]string{vuln1}, req3.GetId())
	assert.Equal(t, storage.VulnerabilityState_DEFERRED, response[vuln1])

	// Given no request, test if the scope is returned correctly i.e. scoped to image scope because of req3.
	response = cache.GetEffectiveVulnState([]string{vuln1, vuln2, vuln3})
	assert.Equal(t, storage.VulnerabilityState_DEFERRED, response[vuln1])
	assert.Equal(t, storage.VulnerabilityState_DEFERRED, response[vuln2])
	assert.Equal(t, storage.VulnerabilityState_DEFERRED, response[vuln3])

	// Remove the image scoped request for vuln1
	cache.Remove(req3.GetId())

	// Test that the vulnerability state is scoped to the remaining scope i.e. global.
	response = cache.GetVulnsWithState(registry, remote, tag)
	assert.Equal(t, storage.VulnerabilityState_FALSE_POSITIVE, response[vuln1])

	// Test that the vulnerability state is scoped to global.
	response = cache.GetEffectiveVulnState([]string{vuln1})
	assert.Equal(t, storage.VulnerabilityState_FALSE_POSITIVE, response[vuln1])
}
