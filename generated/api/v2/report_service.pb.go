// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/v2/report_service.proto

package v2

import (
	context "context"
	fmt "fmt"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type NotificationMethod int32

const (
	NotificationMethod_EMAIL    NotificationMethod = 0
	NotificationMethod_DOWNLOAD NotificationMethod = 1
)

var NotificationMethod_name = map[int32]string{
	0: "EMAIL",
	1: "DOWNLOAD",
}

var NotificationMethod_value = map[string]int32{
	"EMAIL":    0,
	"DOWNLOAD": 1,
}

func (x NotificationMethod) String() string {
	return proto.EnumName(NotificationMethod_name, int32(x))
}

func (NotificationMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{0}
}

type ReportConfiguration_ReportType int32

const (
	ReportConfiguration_VULNERABILITY ReportConfiguration_ReportType = 0
)

var ReportConfiguration_ReportType_name = map[int32]string{
	0: "VULNERABILITY",
}

var ReportConfiguration_ReportType_value = map[string]int32{
	"VULNERABILITY": 0,
}

func (x ReportConfiguration_ReportType) String() string {
	return proto.EnumName(ReportConfiguration_ReportType_name, int32(x))
}

func (ReportConfiguration_ReportType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{0, 0}
}

type VulnerabilityReportFilters_Fixability int32

const (
	VulnerabilityReportFilters_BOTH        VulnerabilityReportFilters_Fixability = 0
	VulnerabilityReportFilters_FIXABLE     VulnerabilityReportFilters_Fixability = 1
	VulnerabilityReportFilters_NOT_FIXABLE VulnerabilityReportFilters_Fixability = 2
)

var VulnerabilityReportFilters_Fixability_name = map[int32]string{
	0: "BOTH",
	1: "FIXABLE",
	2: "NOT_FIXABLE",
}

var VulnerabilityReportFilters_Fixability_value = map[string]int32{
	"BOTH":        0,
	"FIXABLE":     1,
	"NOT_FIXABLE": 2,
}

func (x VulnerabilityReportFilters_Fixability) String() string {
	return proto.EnumName(VulnerabilityReportFilters_Fixability_name, int32(x))
}

func (VulnerabilityReportFilters_Fixability) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{1, 0}
}

type VulnerabilityReportFilters_VulnerabilitySeverity int32

const (
	VulnerabilityReportFilters_UNKNOWN_VULNERABILITY_SEVERITY   VulnerabilityReportFilters_VulnerabilitySeverity = 0
	VulnerabilityReportFilters_LOW_VULNERABILITY_SEVERITY       VulnerabilityReportFilters_VulnerabilitySeverity = 1
	VulnerabilityReportFilters_MODERATE_VULNERABILITY_SEVERITY  VulnerabilityReportFilters_VulnerabilitySeverity = 2
	VulnerabilityReportFilters_IMPORTANT_VULNERABILITY_SEVERITY VulnerabilityReportFilters_VulnerabilitySeverity = 3
	VulnerabilityReportFilters_CRITICAL_VULNERABILITY_SEVERITY  VulnerabilityReportFilters_VulnerabilitySeverity = 4
)

var VulnerabilityReportFilters_VulnerabilitySeverity_name = map[int32]string{
	0: "UNKNOWN_VULNERABILITY_SEVERITY",
	1: "LOW_VULNERABILITY_SEVERITY",
	2: "MODERATE_VULNERABILITY_SEVERITY",
	3: "IMPORTANT_VULNERABILITY_SEVERITY",
	4: "CRITICAL_VULNERABILITY_SEVERITY",
}

var VulnerabilityReportFilters_VulnerabilitySeverity_value = map[string]int32{
	"UNKNOWN_VULNERABILITY_SEVERITY":   0,
	"LOW_VULNERABILITY_SEVERITY":       1,
	"MODERATE_VULNERABILITY_SEVERITY":  2,
	"IMPORTANT_VULNERABILITY_SEVERITY": 3,
	"CRITICAL_VULNERABILITY_SEVERITY":  4,
}

func (x VulnerabilityReportFilters_VulnerabilitySeverity) String() string {
	return proto.EnumName(VulnerabilityReportFilters_VulnerabilitySeverity_name, int32(x))
}

func (VulnerabilityReportFilters_VulnerabilitySeverity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{1, 1}
}

type VulnerabilityReportFilters_ImageType int32

const (
	VulnerabilityReportFilters_DEPLOYED VulnerabilityReportFilters_ImageType = 0
	VulnerabilityReportFilters_WATCHED  VulnerabilityReportFilters_ImageType = 1
)

var VulnerabilityReportFilters_ImageType_name = map[int32]string{
	0: "DEPLOYED",
	1: "WATCHED",
}

var VulnerabilityReportFilters_ImageType_value = map[string]int32{
	"DEPLOYED": 0,
	"WATCHED":  1,
}

func (x VulnerabilityReportFilters_ImageType) String() string {
	return proto.EnumName(VulnerabilityReportFilters_ImageType_name, int32(x))
}

func (VulnerabilityReportFilters_ImageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{1, 2}
}

type ReportSchedule_IntervalType int32

const (
	ReportSchedule_UNSET   ReportSchedule_IntervalType = 0
	ReportSchedule_WEEKLY  ReportSchedule_IntervalType = 1
	ReportSchedule_MONTHLY ReportSchedule_IntervalType = 2
)

var ReportSchedule_IntervalType_name = map[int32]string{
	0: "UNSET",
	1: "WEEKLY",
	2: "MONTHLY",
}

var ReportSchedule_IntervalType_value = map[string]int32{
	"UNSET":   0,
	"WEEKLY":  1,
	"MONTHLY": 2,
}

func (x ReportSchedule_IntervalType) String() string {
	return proto.EnumName(ReportSchedule_IntervalType_name, int32(x))
}

func (ReportSchedule_IntervalType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{2, 0}
}

type ReportStatus_RunState int32

const (
	ReportStatus_WAITING   ReportStatus_RunState = 0
	ReportStatus_PREPARING ReportStatus_RunState = 1
	ReportStatus_SUCCESS   ReportStatus_RunState = 2
	ReportStatus_FAILURE   ReportStatus_RunState = 3
)

var ReportStatus_RunState_name = map[int32]string{
	0: "WAITING",
	1: "PREPARING",
	2: "SUCCESS",
	3: "FAILURE",
}

var ReportStatus_RunState_value = map[string]int32{
	"WAITING":   0,
	"PREPARING": 1,
	"SUCCESS":   2,
	"FAILURE":   3,
}

func (x ReportStatus_RunState) String() string {
	return proto.EnumName(ReportStatus_RunState_name, int32(x))
}

func (ReportStatus_RunState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{14, 0}
}

type ReportStatus_ReportMethod int32

const (
	ReportStatus_ON_DEMAND ReportStatus_ReportMethod = 0
	ReportStatus_SCHEDULED ReportStatus_ReportMethod = 1
)

var ReportStatus_ReportMethod_name = map[int32]string{
	0: "ON_DEMAND",
	1: "SCHEDULED",
}

var ReportStatus_ReportMethod_value = map[string]int32{
	"ON_DEMAND": 0,
	"SCHEDULED": 1,
}

func (x ReportStatus_ReportMethod) String() string {
	return proto.EnumName(ReportStatus_ReportMethod_name, int32(x))
}

func (ReportStatus_ReportMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{14, 1}
}

type ReportConfiguration struct {
	Id          string                         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name        string                         `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description string                         `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Type        ReportConfiguration_ReportType `protobuf:"varint,4,opt,name=type,proto3,enum=v2.ReportConfiguration_ReportType" json:"type,omitempty"`
	// Types that are valid to be assigned to Filter:
	//	*ReportConfiguration_VulnReportFilters
	Filter               isReportConfiguration_Filter `protobuf_oneof:"filter"`
	Schedule             *ReportSchedule              `protobuf:"bytes,6,opt,name=schedule,proto3" json:"schedule,omitempty"`
	ResourceScope        *ResourceScope               `protobuf:"bytes,7,opt,name=resource_scope,json=resourceScope,proto3" json:"resource_scope,omitempty"`
	Notifiers            []*NotifierConfiguration     `protobuf:"bytes,8,rep,name=notifiers,proto3" json:"notifiers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *ReportConfiguration) Reset()         { *m = ReportConfiguration{} }
func (m *ReportConfiguration) String() string { return proto.CompactTextString(m) }
func (*ReportConfiguration) ProtoMessage()    {}
func (*ReportConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{0}
}
func (m *ReportConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportConfiguration.Merge(m, src)
}
func (m *ReportConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *ReportConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_ReportConfiguration proto.InternalMessageInfo

type isReportConfiguration_Filter interface {
	isReportConfiguration_Filter()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isReportConfiguration_Filter
}

type ReportConfiguration_VulnReportFilters struct {
	VulnReportFilters *VulnerabilityReportFilters `protobuf:"bytes,5,opt,name=vuln_report_filters,json=vulnReportFilters,proto3,oneof" json:"vuln_report_filters,omitempty"`
}

func (*ReportConfiguration_VulnReportFilters) isReportConfiguration_Filter() {}
func (m *ReportConfiguration_VulnReportFilters) Clone() isReportConfiguration_Filter {
	if m == nil {
		return nil
	}
	cloned := new(ReportConfiguration_VulnReportFilters)
	*cloned = *m

	cloned.VulnReportFilters = m.VulnReportFilters.Clone()
	return cloned
}

func (m *ReportConfiguration) GetFilter() isReportConfiguration_Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *ReportConfiguration) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ReportConfiguration) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ReportConfiguration) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ReportConfiguration) GetType() ReportConfiguration_ReportType {
	if m != nil {
		return m.Type
	}
	return ReportConfiguration_VULNERABILITY
}

func (m *ReportConfiguration) GetVulnReportFilters() *VulnerabilityReportFilters {
	if x, ok := m.GetFilter().(*ReportConfiguration_VulnReportFilters); ok {
		return x.VulnReportFilters
	}
	return nil
}

func (m *ReportConfiguration) GetSchedule() *ReportSchedule {
	if m != nil {
		return m.Schedule
	}
	return nil
}

func (m *ReportConfiguration) GetResourceScope() *ResourceScope {
	if m != nil {
		return m.ResourceScope
	}
	return nil
}

func (m *ReportConfiguration) GetNotifiers() []*NotifierConfiguration {
	if m != nil {
		return m.Notifiers
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReportConfiguration) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReportConfiguration_VulnReportFilters)(nil),
	}
}

func (m *ReportConfiguration) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ReportConfiguration) Clone() *ReportConfiguration {
	if m == nil {
		return nil
	}
	cloned := new(ReportConfiguration)
	*cloned = *m

	if m.Filter != nil {
		cloned.Filter = m.Filter.Clone()
	}
	cloned.Schedule = m.Schedule.Clone()
	cloned.ResourceScope = m.ResourceScope.Clone()
	if m.Notifiers != nil {
		cloned.Notifiers = make([]*NotifierConfiguration, len(m.Notifiers))
		for idx, v := range m.Notifiers {
			cloned.Notifiers[idx] = v.Clone()
		}
	}
	return cloned
}

type VulnerabilityReportFilters struct {
	Fixability VulnerabilityReportFilters_Fixability              `protobuf:"varint,1,opt,name=fixability,proto3,enum=v2.VulnerabilityReportFilters_Fixability" json:"fixability,omitempty"`
	Severities []VulnerabilityReportFilters_VulnerabilitySeverity `protobuf:"varint,2,rep,packed,name=severities,proto3,enum=v2.VulnerabilityReportFilters_VulnerabilitySeverity" json:"severities,omitempty"`
	ImageTypes []VulnerabilityReportFilters_ImageType             `protobuf:"varint,3,rep,packed,name=image_types,json=imageTypes,proto3,enum=v2.VulnerabilityReportFilters_ImageType" json:"image_types,omitempty"`
	// Types that are valid to be assigned to CvesSince:
	//	*VulnerabilityReportFilters_AllVuln
	//	*VulnerabilityReportFilters_SinceLastSentScheduledReport
	//	*VulnerabilityReportFilters_SinceStartDate
	CvesSince            isVulnerabilityReportFilters_CvesSince `protobuf_oneof:"cves_since"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *VulnerabilityReportFilters) Reset()         { *m = VulnerabilityReportFilters{} }
func (m *VulnerabilityReportFilters) String() string { return proto.CompactTextString(m) }
func (*VulnerabilityReportFilters) ProtoMessage()    {}
func (*VulnerabilityReportFilters) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{1}
}
func (m *VulnerabilityReportFilters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VulnerabilityReportFilters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VulnerabilityReportFilters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VulnerabilityReportFilters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VulnerabilityReportFilters.Merge(m, src)
}
func (m *VulnerabilityReportFilters) XXX_Size() int {
	return m.Size()
}
func (m *VulnerabilityReportFilters) XXX_DiscardUnknown() {
	xxx_messageInfo_VulnerabilityReportFilters.DiscardUnknown(m)
}

var xxx_messageInfo_VulnerabilityReportFilters proto.InternalMessageInfo

type isVulnerabilityReportFilters_CvesSince interface {
	isVulnerabilityReportFilters_CvesSince()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isVulnerabilityReportFilters_CvesSince
}

type VulnerabilityReportFilters_AllVuln struct {
	AllVuln bool `protobuf:"varint,4,opt,name=all_vuln,json=allVuln,proto3,oneof" json:"all_vuln,omitempty"`
}
type VulnerabilityReportFilters_SinceLastSentScheduledReport struct {
	SinceLastSentScheduledReport bool `protobuf:"varint,5,opt,name=since_last_sent_scheduled_report,json=sinceLastSentScheduledReport,proto3,oneof" json:"since_last_sent_scheduled_report,omitempty"`
}
type VulnerabilityReportFilters_SinceStartDate struct {
	SinceStartDate *types.Timestamp `protobuf:"bytes,6,opt,name=since_start_date,json=sinceStartDate,proto3,oneof" json:"since_start_date,omitempty"`
}

func (*VulnerabilityReportFilters_AllVuln) isVulnerabilityReportFilters_CvesSince() {}
func (m *VulnerabilityReportFilters_AllVuln) Clone() isVulnerabilityReportFilters_CvesSince {
	if m == nil {
		return nil
	}
	cloned := new(VulnerabilityReportFilters_AllVuln)
	*cloned = *m

	return cloned
}
func (*VulnerabilityReportFilters_SinceLastSentScheduledReport) isVulnerabilityReportFilters_CvesSince() {
}
func (m *VulnerabilityReportFilters_SinceLastSentScheduledReport) Clone() isVulnerabilityReportFilters_CvesSince {
	if m == nil {
		return nil
	}
	cloned := new(VulnerabilityReportFilters_SinceLastSentScheduledReport)
	*cloned = *m

	return cloned
}
func (*VulnerabilityReportFilters_SinceStartDate) isVulnerabilityReportFilters_CvesSince() {}
func (m *VulnerabilityReportFilters_SinceStartDate) Clone() isVulnerabilityReportFilters_CvesSince {
	if m == nil {
		return nil
	}
	cloned := new(VulnerabilityReportFilters_SinceStartDate)
	*cloned = *m

	cloned.SinceStartDate = m.SinceStartDate.Clone()
	return cloned
}

func (m *VulnerabilityReportFilters) GetCvesSince() isVulnerabilityReportFilters_CvesSince {
	if m != nil {
		return m.CvesSince
	}
	return nil
}

func (m *VulnerabilityReportFilters) GetFixability() VulnerabilityReportFilters_Fixability {
	if m != nil {
		return m.Fixability
	}
	return VulnerabilityReportFilters_BOTH
}

func (m *VulnerabilityReportFilters) GetSeverities() []VulnerabilityReportFilters_VulnerabilitySeverity {
	if m != nil {
		return m.Severities
	}
	return nil
}

func (m *VulnerabilityReportFilters) GetImageTypes() []VulnerabilityReportFilters_ImageType {
	if m != nil {
		return m.ImageTypes
	}
	return nil
}

func (m *VulnerabilityReportFilters) GetAllVuln() bool {
	if x, ok := m.GetCvesSince().(*VulnerabilityReportFilters_AllVuln); ok {
		return x.AllVuln
	}
	return false
}

func (m *VulnerabilityReportFilters) GetSinceLastSentScheduledReport() bool {
	if x, ok := m.GetCvesSince().(*VulnerabilityReportFilters_SinceLastSentScheduledReport); ok {
		return x.SinceLastSentScheduledReport
	}
	return false
}

func (m *VulnerabilityReportFilters) GetSinceStartDate() *types.Timestamp {
	if x, ok := m.GetCvesSince().(*VulnerabilityReportFilters_SinceStartDate); ok {
		return x.SinceStartDate
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VulnerabilityReportFilters) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VulnerabilityReportFilters_AllVuln)(nil),
		(*VulnerabilityReportFilters_SinceLastSentScheduledReport)(nil),
		(*VulnerabilityReportFilters_SinceStartDate)(nil),
	}
}

func (m *VulnerabilityReportFilters) MessageClone() proto.Message {
	return m.Clone()
}
func (m *VulnerabilityReportFilters) Clone() *VulnerabilityReportFilters {
	if m == nil {
		return nil
	}
	cloned := new(VulnerabilityReportFilters)
	*cloned = *m

	if m.Severities != nil {
		cloned.Severities = make([]VulnerabilityReportFilters_VulnerabilitySeverity, len(m.Severities))
		copy(cloned.Severities, m.Severities)
	}
	if m.ImageTypes != nil {
		cloned.ImageTypes = make([]VulnerabilityReportFilters_ImageType, len(m.ImageTypes))
		copy(cloned.ImageTypes, m.ImageTypes)
	}
	if m.CvesSince != nil {
		cloned.CvesSince = m.CvesSince.Clone()
	}
	return cloned
}

type ReportSchedule struct {
	IntervalType ReportSchedule_IntervalType `protobuf:"varint,1,opt,name=interval_type,json=intervalType,proto3,enum=v2.ReportSchedule_IntervalType" json:"interval_type,omitempty"`
	Hour         int32                       `protobuf:"varint,2,opt,name=hour,proto3" json:"hour,omitempty"`
	Minute       int32                       `protobuf:"varint,3,opt,name=minute,proto3" json:"minute,omitempty"`
	// Types that are valid to be assigned to Interval:
	//	*ReportSchedule_DaysOfWeek_
	//	*ReportSchedule_DaysOfMonth_
	Interval             isReportSchedule_Interval `protobuf_oneof:"Interval"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ReportSchedule) Reset()         { *m = ReportSchedule{} }
func (m *ReportSchedule) String() string { return proto.CompactTextString(m) }
func (*ReportSchedule) ProtoMessage()    {}
func (*ReportSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{2}
}
func (m *ReportSchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportSchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportSchedule.Merge(m, src)
}
func (m *ReportSchedule) XXX_Size() int {
	return m.Size()
}
func (m *ReportSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_ReportSchedule proto.InternalMessageInfo

type isReportSchedule_Interval interface {
	isReportSchedule_Interval()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isReportSchedule_Interval
}

type ReportSchedule_DaysOfWeek_ struct {
	DaysOfWeek *ReportSchedule_DaysOfWeek `protobuf:"bytes,4,opt,name=days_of_week,json=daysOfWeek,proto3,oneof" json:"days_of_week,omitempty"`
}
type ReportSchedule_DaysOfMonth_ struct {
	DaysOfMonth *ReportSchedule_DaysOfMonth `protobuf:"bytes,5,opt,name=days_of_month,json=daysOfMonth,proto3,oneof" json:"days_of_month,omitempty"`
}

func (*ReportSchedule_DaysOfWeek_) isReportSchedule_Interval() {}
func (m *ReportSchedule_DaysOfWeek_) Clone() isReportSchedule_Interval {
	if m == nil {
		return nil
	}
	cloned := new(ReportSchedule_DaysOfWeek_)
	*cloned = *m

	cloned.DaysOfWeek = m.DaysOfWeek.Clone()
	return cloned
}
func (*ReportSchedule_DaysOfMonth_) isReportSchedule_Interval() {}
func (m *ReportSchedule_DaysOfMonth_) Clone() isReportSchedule_Interval {
	if m == nil {
		return nil
	}
	cloned := new(ReportSchedule_DaysOfMonth_)
	*cloned = *m

	cloned.DaysOfMonth = m.DaysOfMonth.Clone()
	return cloned
}

func (m *ReportSchedule) GetInterval() isReportSchedule_Interval {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *ReportSchedule) GetIntervalType() ReportSchedule_IntervalType {
	if m != nil {
		return m.IntervalType
	}
	return ReportSchedule_UNSET
}

func (m *ReportSchedule) GetHour() int32 {
	if m != nil {
		return m.Hour
	}
	return 0
}

func (m *ReportSchedule) GetMinute() int32 {
	if m != nil {
		return m.Minute
	}
	return 0
}

func (m *ReportSchedule) GetDaysOfWeek() *ReportSchedule_DaysOfWeek {
	if x, ok := m.GetInterval().(*ReportSchedule_DaysOfWeek_); ok {
		return x.DaysOfWeek
	}
	return nil
}

func (m *ReportSchedule) GetDaysOfMonth() *ReportSchedule_DaysOfMonth {
	if x, ok := m.GetInterval().(*ReportSchedule_DaysOfMonth_); ok {
		return x.DaysOfMonth
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReportSchedule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReportSchedule_DaysOfWeek_)(nil),
		(*ReportSchedule_DaysOfMonth_)(nil),
	}
}

func (m *ReportSchedule) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ReportSchedule) Clone() *ReportSchedule {
	if m == nil {
		return nil
	}
	cloned := new(ReportSchedule)
	*cloned = *m

	if m.Interval != nil {
		cloned.Interval = m.Interval.Clone()
	}
	return cloned
}

// Sunday = 1, Monday = 2, .... Saturday =  7
type ReportSchedule_DaysOfWeek struct {
	Days                 []int32  `protobuf:"varint,1,rep,packed,name=days,proto3" json:"days,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportSchedule_DaysOfWeek) Reset()         { *m = ReportSchedule_DaysOfWeek{} }
func (m *ReportSchedule_DaysOfWeek) String() string { return proto.CompactTextString(m) }
func (*ReportSchedule_DaysOfWeek) ProtoMessage()    {}
func (*ReportSchedule_DaysOfWeek) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{2, 0}
}
func (m *ReportSchedule_DaysOfWeek) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportSchedule_DaysOfWeek) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportSchedule_DaysOfWeek.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportSchedule_DaysOfWeek) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportSchedule_DaysOfWeek.Merge(m, src)
}
func (m *ReportSchedule_DaysOfWeek) XXX_Size() int {
	return m.Size()
}
func (m *ReportSchedule_DaysOfWeek) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportSchedule_DaysOfWeek.DiscardUnknown(m)
}

var xxx_messageInfo_ReportSchedule_DaysOfWeek proto.InternalMessageInfo

func (m *ReportSchedule_DaysOfWeek) GetDays() []int32 {
	if m != nil {
		return m.Days
	}
	return nil
}

func (m *ReportSchedule_DaysOfWeek) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ReportSchedule_DaysOfWeek) Clone() *ReportSchedule_DaysOfWeek {
	if m == nil {
		return nil
	}
	cloned := new(ReportSchedule_DaysOfWeek)
	*cloned = *m

	if m.Days != nil {
		cloned.Days = make([]int32, len(m.Days))
		copy(cloned.Days, m.Days)
	}
	return cloned
}

// 1 for 1st, 2 for 2nd .... 31 for 31st
type ReportSchedule_DaysOfMonth struct {
	Days                 []int32  `protobuf:"varint,1,rep,packed,name=days,proto3" json:"days,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportSchedule_DaysOfMonth) Reset()         { *m = ReportSchedule_DaysOfMonth{} }
func (m *ReportSchedule_DaysOfMonth) String() string { return proto.CompactTextString(m) }
func (*ReportSchedule_DaysOfMonth) ProtoMessage()    {}
func (*ReportSchedule_DaysOfMonth) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{2, 1}
}
func (m *ReportSchedule_DaysOfMonth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportSchedule_DaysOfMonth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportSchedule_DaysOfMonth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportSchedule_DaysOfMonth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportSchedule_DaysOfMonth.Merge(m, src)
}
func (m *ReportSchedule_DaysOfMonth) XXX_Size() int {
	return m.Size()
}
func (m *ReportSchedule_DaysOfMonth) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportSchedule_DaysOfMonth.DiscardUnknown(m)
}

var xxx_messageInfo_ReportSchedule_DaysOfMonth proto.InternalMessageInfo

func (m *ReportSchedule_DaysOfMonth) GetDays() []int32 {
	if m != nil {
		return m.Days
	}
	return nil
}

func (m *ReportSchedule_DaysOfMonth) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ReportSchedule_DaysOfMonth) Clone() *ReportSchedule_DaysOfMonth {
	if m == nil {
		return nil
	}
	cloned := new(ReportSchedule_DaysOfMonth)
	*cloned = *m

	if m.Days != nil {
		cloned.Days = make([]int32, len(m.Days))
		copy(cloned.Days, m.Days)
	}
	return cloned
}

type ResourceScope struct {
	// Types that are valid to be assigned to ScopeReference:
	//	*ResourceScope_CollectionScope
	ScopeReference       isResourceScope_ScopeReference `protobuf_oneof:"scope_reference"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *ResourceScope) Reset()         { *m = ResourceScope{} }
func (m *ResourceScope) String() string { return proto.CompactTextString(m) }
func (*ResourceScope) ProtoMessage()    {}
func (*ResourceScope) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{3}
}
func (m *ResourceScope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceScope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceScope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceScope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceScope.Merge(m, src)
}
func (m *ResourceScope) XXX_Size() int {
	return m.Size()
}
func (m *ResourceScope) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceScope.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceScope proto.InternalMessageInfo

type isResourceScope_ScopeReference interface {
	isResourceScope_ScopeReference()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isResourceScope_ScopeReference
}

type ResourceScope_CollectionScope struct {
	CollectionScope *CollectionReference `protobuf:"bytes,1,opt,name=collection_scope,json=collectionScope,proto3,oneof" json:"collection_scope,omitempty"`
}

func (*ResourceScope_CollectionScope) isResourceScope_ScopeReference() {}
func (m *ResourceScope_CollectionScope) Clone() isResourceScope_ScopeReference {
	if m == nil {
		return nil
	}
	cloned := new(ResourceScope_CollectionScope)
	*cloned = *m

	cloned.CollectionScope = m.CollectionScope.Clone()
	return cloned
}

func (m *ResourceScope) GetScopeReference() isResourceScope_ScopeReference {
	if m != nil {
		return m.ScopeReference
	}
	return nil
}

func (m *ResourceScope) GetCollectionScope() *CollectionReference {
	if x, ok := m.GetScopeReference().(*ResourceScope_CollectionScope); ok {
		return x.CollectionScope
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ResourceScope) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ResourceScope_CollectionScope)(nil),
	}
}

func (m *ResourceScope) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ResourceScope) Clone() *ResourceScope {
	if m == nil {
		return nil
	}
	cloned := new(ResourceScope)
	*cloned = *m

	if m.ScopeReference != nil {
		cloned.ScopeReference = m.ScopeReference.Clone()
	}
	return cloned
}

type CollectionReference struct {
	CollectionId         string   `protobuf:"bytes,1,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	CollectionName       string   `protobuf:"bytes,2,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CollectionReference) Reset()         { *m = CollectionReference{} }
func (m *CollectionReference) String() string { return proto.CompactTextString(m) }
func (*CollectionReference) ProtoMessage()    {}
func (*CollectionReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{4}
}
func (m *CollectionReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionReference.Merge(m, src)
}
func (m *CollectionReference) XXX_Size() int {
	return m.Size()
}
func (m *CollectionReference) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionReference.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionReference proto.InternalMessageInfo

func (m *CollectionReference) GetCollectionId() string {
	if m != nil {
		return m.CollectionId
	}
	return ""
}

func (m *CollectionReference) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *CollectionReference) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CollectionReference) Clone() *CollectionReference {
	if m == nil {
		return nil
	}
	cloned := new(CollectionReference)
	*cloned = *m

	return cloned
}

type NotifierConfiguration struct {
	// Types that are valid to be assigned to NotifierConfig:
	//	*NotifierConfiguration_EmailConfig
	NotifierConfig       isNotifierConfiguration_NotifierConfig `protobuf_oneof:"notifier_config"`
	NotifierName         string                                 `protobuf:"bytes,2,opt,name=notifier_name,json=notifierName,proto3" json:"notifier_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *NotifierConfiguration) Reset()         { *m = NotifierConfiguration{} }
func (m *NotifierConfiguration) String() string { return proto.CompactTextString(m) }
func (*NotifierConfiguration) ProtoMessage()    {}
func (*NotifierConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{5}
}
func (m *NotifierConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotifierConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotifierConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotifierConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotifierConfiguration.Merge(m, src)
}
func (m *NotifierConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *NotifierConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_NotifierConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_NotifierConfiguration proto.InternalMessageInfo

type isNotifierConfiguration_NotifierConfig interface {
	isNotifierConfiguration_NotifierConfig()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isNotifierConfiguration_NotifierConfig
}

type NotifierConfiguration_EmailConfig struct {
	EmailConfig *EmailNotifierConfiguration `protobuf:"bytes,1,opt,name=email_config,json=emailConfig,proto3,oneof" json:"email_config,omitempty"`
}

func (*NotifierConfiguration_EmailConfig) isNotifierConfiguration_NotifierConfig() {}
func (m *NotifierConfiguration_EmailConfig) Clone() isNotifierConfiguration_NotifierConfig {
	if m == nil {
		return nil
	}
	cloned := new(NotifierConfiguration_EmailConfig)
	*cloned = *m

	cloned.EmailConfig = m.EmailConfig.Clone()
	return cloned
}

func (m *NotifierConfiguration) GetNotifierConfig() isNotifierConfiguration_NotifierConfig {
	if m != nil {
		return m.NotifierConfig
	}
	return nil
}

func (m *NotifierConfiguration) GetEmailConfig() *EmailNotifierConfiguration {
	if x, ok := m.GetNotifierConfig().(*NotifierConfiguration_EmailConfig); ok {
		return x.EmailConfig
	}
	return nil
}

func (m *NotifierConfiguration) GetNotifierName() string {
	if m != nil {
		return m.NotifierName
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NotifierConfiguration) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NotifierConfiguration_EmailConfig)(nil),
	}
}

func (m *NotifierConfiguration) MessageClone() proto.Message {
	return m.Clone()
}
func (m *NotifierConfiguration) Clone() *NotifierConfiguration {
	if m == nil {
		return nil
	}
	cloned := new(NotifierConfiguration)
	*cloned = *m

	if m.NotifierConfig != nil {
		cloned.NotifierConfig = m.NotifierConfig.Clone()
	}
	return cloned
}

type EmailNotifierConfiguration struct {
	NotifierId           string   `protobuf:"bytes,1,opt,name=notifier_id,json=notifierId,proto3" json:"notifier_id,omitempty"`
	MailingLists         []string `protobuf:"bytes,2,rep,name=mailing_lists,json=mailingLists,proto3" json:"mailing_lists,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmailNotifierConfiguration) Reset()         { *m = EmailNotifierConfiguration{} }
func (m *EmailNotifierConfiguration) String() string { return proto.CompactTextString(m) }
func (*EmailNotifierConfiguration) ProtoMessage()    {}
func (*EmailNotifierConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{6}
}
func (m *EmailNotifierConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmailNotifierConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmailNotifierConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmailNotifierConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmailNotifierConfiguration.Merge(m, src)
}
func (m *EmailNotifierConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *EmailNotifierConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_EmailNotifierConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_EmailNotifierConfiguration proto.InternalMessageInfo

func (m *EmailNotifierConfiguration) GetNotifierId() string {
	if m != nil {
		return m.NotifierId
	}
	return ""
}

func (m *EmailNotifierConfiguration) GetMailingLists() []string {
	if m != nil {
		return m.MailingLists
	}
	return nil
}

func (m *EmailNotifierConfiguration) MessageClone() proto.Message {
	return m.Clone()
}
func (m *EmailNotifierConfiguration) Clone() *EmailNotifierConfiguration {
	if m == nil {
		return nil
	}
	cloned := new(EmailNotifierConfiguration)
	*cloned = *m

	if m.MailingLists != nil {
		cloned.MailingLists = make([]string, len(m.MailingLists))
		copy(cloned.MailingLists, m.MailingLists)
	}
	return cloned
}

type ListReportConfigurationsResponse struct {
	ReportConfigs        []*ReportConfiguration `protobuf:"bytes,1,rep,name=report_configs,json=reportConfigs,proto3" json:"report_configs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ListReportConfigurationsResponse) Reset()         { *m = ListReportConfigurationsResponse{} }
func (m *ListReportConfigurationsResponse) String() string { return proto.CompactTextString(m) }
func (*ListReportConfigurationsResponse) ProtoMessage()    {}
func (*ListReportConfigurationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{7}
}
func (m *ListReportConfigurationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListReportConfigurationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListReportConfigurationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListReportConfigurationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListReportConfigurationsResponse.Merge(m, src)
}
func (m *ListReportConfigurationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListReportConfigurationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListReportConfigurationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListReportConfigurationsResponse proto.InternalMessageInfo

func (m *ListReportConfigurationsResponse) GetReportConfigs() []*ReportConfiguration {
	if m != nil {
		return m.ReportConfigs
	}
	return nil
}

func (m *ListReportConfigurationsResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ListReportConfigurationsResponse) Clone() *ListReportConfigurationsResponse {
	if m == nil {
		return nil
	}
	cloned := new(ListReportConfigurationsResponse)
	*cloned = *m

	if m.ReportConfigs != nil {
		cloned.ReportConfigs = make([]*ReportConfiguration, len(m.ReportConfigs))
		for idx, v := range m.ReportConfigs {
			cloned.ReportConfigs[idx] = v.Clone()
		}
	}
	return cloned
}

type CountReportConfigurationsResponse struct {
	Count                int32    `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CountReportConfigurationsResponse) Reset()         { *m = CountReportConfigurationsResponse{} }
func (m *CountReportConfigurationsResponse) String() string { return proto.CompactTextString(m) }
func (*CountReportConfigurationsResponse) ProtoMessage()    {}
func (*CountReportConfigurationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{8}
}
func (m *CountReportConfigurationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CountReportConfigurationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CountReportConfigurationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CountReportConfigurationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CountReportConfigurationsResponse.Merge(m, src)
}
func (m *CountReportConfigurationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *CountReportConfigurationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CountReportConfigurationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CountReportConfigurationsResponse proto.InternalMessageInfo

func (m *CountReportConfigurationsResponse) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *CountReportConfigurationsResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CountReportConfigurationsResponse) Clone() *CountReportConfigurationsResponse {
	if m == nil {
		return nil
	}
	cloned := new(CountReportConfigurationsResponse)
	*cloned = *m

	return cloned
}

type GetReportHistoryRequest struct {
	Id                   string    `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ReportParamQuery     *RawQuery `protobuf:"bytes,2,opt,name=report_param_query,json=reportParamQuery,proto3" json:"report_param_query,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetReportHistoryRequest) Reset()         { *m = GetReportHistoryRequest{} }
func (m *GetReportHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*GetReportHistoryRequest) ProtoMessage()    {}
func (*GetReportHistoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{9}
}
func (m *GetReportHistoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetReportHistoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetReportHistoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetReportHistoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetReportHistoryRequest.Merge(m, src)
}
func (m *GetReportHistoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetReportHistoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetReportHistoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetReportHistoryRequest proto.InternalMessageInfo

func (m *GetReportHistoryRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GetReportHistoryRequest) GetReportParamQuery() *RawQuery {
	if m != nil {
		return m.ReportParamQuery
	}
	return nil
}

func (m *GetReportHistoryRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetReportHistoryRequest) Clone() *GetReportHistoryRequest {
	if m == nil {
		return nil
	}
	cloned := new(GetReportHistoryRequest)
	*cloned = *m

	cloned.ReportParamQuery = m.ReportParamQuery.Clone()
	return cloned
}

type ReportHistoryResponse struct {
	ReportSnapshots      []*ReportSnapshot `protobuf:"bytes,1,rep,name=report_snapshots,json=reportSnapshots,proto3" json:"report_snapshots,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ReportHistoryResponse) Reset()         { *m = ReportHistoryResponse{} }
func (m *ReportHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*ReportHistoryResponse) ProtoMessage()    {}
func (*ReportHistoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{10}
}
func (m *ReportHistoryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportHistoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportHistoryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportHistoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportHistoryResponse.Merge(m, src)
}
func (m *ReportHistoryResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReportHistoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportHistoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReportHistoryResponse proto.InternalMessageInfo

func (m *ReportHistoryResponse) GetReportSnapshots() []*ReportSnapshot {
	if m != nil {
		return m.ReportSnapshots
	}
	return nil
}

func (m *ReportHistoryResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ReportHistoryResponse) Clone() *ReportHistoryResponse {
	if m == nil {
		return nil
	}
	cloned := new(ReportHistoryResponse)
	*cloned = *m

	if m.ReportSnapshots != nil {
		cloned.ReportSnapshots = make([]*ReportSnapshot, len(m.ReportSnapshots))
		for idx, v := range m.ReportSnapshots {
			cloned.ReportSnapshots[idx] = v.Clone()
		}
	}
	return cloned
}

type ReportStatusResponse struct {
	Status               *ReportStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ReportStatusResponse) Reset()         { *m = ReportStatusResponse{} }
func (m *ReportStatusResponse) String() string { return proto.CompactTextString(m) }
func (*ReportStatusResponse) ProtoMessage()    {}
func (*ReportStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{11}
}
func (m *ReportStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportStatusResponse.Merge(m, src)
}
func (m *ReportStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReportStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReportStatusResponse proto.InternalMessageInfo

func (m *ReportStatusResponse) GetStatus() *ReportStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ReportStatusResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ReportStatusResponse) Clone() *ReportStatusResponse {
	if m == nil {
		return nil
	}
	cloned := new(ReportStatusResponse)
	*cloned = *m

	cloned.Status = m.Status.Clone()
	return cloned
}

type CollectionSnapshot struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CollectionSnapshot) Reset()         { *m = CollectionSnapshot{} }
func (m *CollectionSnapshot) String() string { return proto.CompactTextString(m) }
func (*CollectionSnapshot) ProtoMessage()    {}
func (*CollectionSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{12}
}
func (m *CollectionSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionSnapshot.Merge(m, src)
}
func (m *CollectionSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *CollectionSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionSnapshot proto.InternalMessageInfo

func (m *CollectionSnapshot) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CollectionSnapshot) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CollectionSnapshot) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CollectionSnapshot) Clone() *CollectionSnapshot {
	if m == nil {
		return nil
	}
	cloned := new(CollectionSnapshot)
	*cloned = *m

	return cloned
}

type ReportSnapshot struct {
	ReportConfigId string `protobuf:"bytes,1,opt,name=report_config_id,json=reportConfigId,proto3" json:"report_config_id,omitempty"`
	ReportJobId    string `protobuf:"bytes,2,opt,name=report_job_id,json=reportJobId,proto3" json:"report_job_id,omitempty"`
	Name           string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description    string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Types that are valid to be assigned to Filter:
	//	*ReportSnapshot_VulnReportFilters
	Filter               isReportSnapshot_Filter  `protobuf_oneof:"filter"`
	CollectionSnapshot   *CollectionSnapshot      `protobuf:"bytes,6,opt,name=collection_snapshot,json=collectionSnapshot,proto3" json:"collection_snapshot,omitempty"`
	Schedule             *ReportSchedule          `protobuf:"bytes,7,opt,name=schedule,proto3" json:"schedule,omitempty"`
	ReportStatus         *ReportStatus            `protobuf:"bytes,8,opt,name=report_status,json=reportStatus,proto3" json:"report_status,omitempty"`
	Notifiers            []*NotifierConfiguration `protobuf:"bytes,9,rep,name=notifiers,proto3" json:"notifiers,omitempty"`
	User                 *SlimUser                `protobuf:"bytes,10,opt,name=user,proto3" json:"user,omitempty"`
	IsDownloadAvailable  bool                     `protobuf:"varint,11,opt,name=is_download_available,json=isDownloadAvailable,proto3" json:"is_download_available,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *ReportSnapshot) Reset()         { *m = ReportSnapshot{} }
func (m *ReportSnapshot) String() string { return proto.CompactTextString(m) }
func (*ReportSnapshot) ProtoMessage()    {}
func (*ReportSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{13}
}
func (m *ReportSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportSnapshot.Merge(m, src)
}
func (m *ReportSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *ReportSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_ReportSnapshot proto.InternalMessageInfo

type isReportSnapshot_Filter interface {
	isReportSnapshot_Filter()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isReportSnapshot_Filter
}

type ReportSnapshot_VulnReportFilters struct {
	VulnReportFilters *VulnerabilityReportFilters `protobuf:"bytes,5,opt,name=vuln_report_filters,json=vulnReportFilters,proto3,oneof" json:"vuln_report_filters,omitempty"`
}

func (*ReportSnapshot_VulnReportFilters) isReportSnapshot_Filter() {}
func (m *ReportSnapshot_VulnReportFilters) Clone() isReportSnapshot_Filter {
	if m == nil {
		return nil
	}
	cloned := new(ReportSnapshot_VulnReportFilters)
	*cloned = *m

	cloned.VulnReportFilters = m.VulnReportFilters.Clone()
	return cloned
}

func (m *ReportSnapshot) GetFilter() isReportSnapshot_Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *ReportSnapshot) GetReportConfigId() string {
	if m != nil {
		return m.ReportConfigId
	}
	return ""
}

func (m *ReportSnapshot) GetReportJobId() string {
	if m != nil {
		return m.ReportJobId
	}
	return ""
}

func (m *ReportSnapshot) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ReportSnapshot) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ReportSnapshot) GetVulnReportFilters() *VulnerabilityReportFilters {
	if x, ok := m.GetFilter().(*ReportSnapshot_VulnReportFilters); ok {
		return x.VulnReportFilters
	}
	return nil
}

func (m *ReportSnapshot) GetCollectionSnapshot() *CollectionSnapshot {
	if m != nil {
		return m.CollectionSnapshot
	}
	return nil
}

func (m *ReportSnapshot) GetSchedule() *ReportSchedule {
	if m != nil {
		return m.Schedule
	}
	return nil
}

func (m *ReportSnapshot) GetReportStatus() *ReportStatus {
	if m != nil {
		return m.ReportStatus
	}
	return nil
}

func (m *ReportSnapshot) GetNotifiers() []*NotifierConfiguration {
	if m != nil {
		return m.Notifiers
	}
	return nil
}

func (m *ReportSnapshot) GetUser() *SlimUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ReportSnapshot) GetIsDownloadAvailable() bool {
	if m != nil {
		return m.IsDownloadAvailable
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReportSnapshot) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReportSnapshot_VulnReportFilters)(nil),
	}
}

func (m *ReportSnapshot) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ReportSnapshot) Clone() *ReportSnapshot {
	if m == nil {
		return nil
	}
	cloned := new(ReportSnapshot)
	*cloned = *m

	if m.Filter != nil {
		cloned.Filter = m.Filter.Clone()
	}
	cloned.CollectionSnapshot = m.CollectionSnapshot.Clone()
	cloned.Schedule = m.Schedule.Clone()
	cloned.ReportStatus = m.ReportStatus.Clone()
	if m.Notifiers != nil {
		cloned.Notifiers = make([]*NotifierConfiguration, len(m.Notifiers))
		for idx, v := range m.Notifiers {
			cloned.Notifiers[idx] = v.Clone()
		}
	}
	cloned.User = m.User.Clone()
	return cloned
}

type ReportStatus struct {
	RunState                 ReportStatus_RunState     `protobuf:"varint,1,opt,name=run_state,json=runState,proto3,enum=v2.ReportStatus_RunState" json:"run_state,omitempty"`
	CompletedAt              *types.Timestamp          `protobuf:"bytes,2,opt,name=completed_at,json=completedAt,proto3" json:"completed_at,omitempty"`
	ErrorMsg                 string                    `protobuf:"bytes,3,opt,name=error_msg,json=errorMsg,proto3" json:"error_msg,omitempty"`
	ReportRequestType        ReportStatus_ReportMethod `protobuf:"varint,4,opt,name=report_request_type,json=reportRequestType,proto3,enum=v2.ReportStatus_ReportMethod" json:"report_request_type,omitempty"`
	ReportNotificationMethod NotificationMethod        `protobuf:"varint,5,opt,name=report_notification_method,json=reportNotificationMethod,proto3,enum=v2.NotificationMethod" json:"report_notification_method,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}                  `json:"-"`
	XXX_unrecognized         []byte                    `json:"-"`
	XXX_sizecache            int32                     `json:"-"`
}

func (m *ReportStatus) Reset()         { *m = ReportStatus{} }
func (m *ReportStatus) String() string { return proto.CompactTextString(m) }
func (*ReportStatus) ProtoMessage()    {}
func (*ReportStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{14}
}
func (m *ReportStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportStatus.Merge(m, src)
}
func (m *ReportStatus) XXX_Size() int {
	return m.Size()
}
func (m *ReportStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ReportStatus proto.InternalMessageInfo

func (m *ReportStatus) GetRunState() ReportStatus_RunState {
	if m != nil {
		return m.RunState
	}
	return ReportStatus_WAITING
}

func (m *ReportStatus) GetCompletedAt() *types.Timestamp {
	if m != nil {
		return m.CompletedAt
	}
	return nil
}

func (m *ReportStatus) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

func (m *ReportStatus) GetReportRequestType() ReportStatus_ReportMethod {
	if m != nil {
		return m.ReportRequestType
	}
	return ReportStatus_ON_DEMAND
}

func (m *ReportStatus) GetReportNotificationMethod() NotificationMethod {
	if m != nil {
		return m.ReportNotificationMethod
	}
	return NotificationMethod_EMAIL
}

func (m *ReportStatus) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ReportStatus) Clone() *ReportStatus {
	if m == nil {
		return nil
	}
	cloned := new(ReportStatus)
	*cloned = *m

	cloned.CompletedAt = m.CompletedAt.Clone()
	return cloned
}

type RunReportRequest struct {
	ReportConfigId           string             `protobuf:"bytes,1,opt,name=report_config_id,json=reportConfigId,proto3" json:"report_config_id,omitempty"`
	ReportNotificationMethod NotificationMethod `protobuf:"varint,2,opt,name=report_notification_method,json=reportNotificationMethod,proto3,enum=v2.NotificationMethod" json:"report_notification_method,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}           `json:"-"`
	XXX_unrecognized         []byte             `json:"-"`
	XXX_sizecache            int32              `json:"-"`
}

func (m *RunReportRequest) Reset()         { *m = RunReportRequest{} }
func (m *RunReportRequest) String() string { return proto.CompactTextString(m) }
func (*RunReportRequest) ProtoMessage()    {}
func (*RunReportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{15}
}
func (m *RunReportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunReportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunReportRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunReportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunReportRequest.Merge(m, src)
}
func (m *RunReportRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunReportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunReportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunReportRequest proto.InternalMessageInfo

func (m *RunReportRequest) GetReportConfigId() string {
	if m != nil {
		return m.ReportConfigId
	}
	return ""
}

func (m *RunReportRequest) GetReportNotificationMethod() NotificationMethod {
	if m != nil {
		return m.ReportNotificationMethod
	}
	return NotificationMethod_EMAIL
}

func (m *RunReportRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *RunReportRequest) Clone() *RunReportRequest {
	if m == nil {
		return nil
	}
	cloned := new(RunReportRequest)
	*cloned = *m

	return cloned
}

type RunReportResponse struct {
	ReportConfigId       string   `protobuf:"bytes,1,opt,name=report_config_id,json=reportConfigId,proto3" json:"report_config_id,omitempty"`
	ReportId             string   `protobuf:"bytes,2,opt,name=report_id,json=reportId,proto3" json:"report_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunReportResponse) Reset()         { *m = RunReportResponse{} }
func (m *RunReportResponse) String() string { return proto.CompactTextString(m) }
func (*RunReportResponse) ProtoMessage()    {}
func (*RunReportResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{16}
}
func (m *RunReportResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunReportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunReportResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunReportResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunReportResponse.Merge(m, src)
}
func (m *RunReportResponse) XXX_Size() int {
	return m.Size()
}
func (m *RunReportResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RunReportResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RunReportResponse proto.InternalMessageInfo

func (m *RunReportResponse) GetReportConfigId() string {
	if m != nil {
		return m.ReportConfigId
	}
	return ""
}

func (m *RunReportResponse) GetReportId() string {
	if m != nil {
		return m.ReportId
	}
	return ""
}

func (m *RunReportResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *RunReportResponse) Clone() *RunReportResponse {
	if m == nil {
		return nil
	}
	cloned := new(RunReportResponse)
	*cloned = *m

	return cloned
}

type DownloadReportRequest struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadReportRequest) Reset()         { *m = DownloadReportRequest{} }
func (m *DownloadReportRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadReportRequest) ProtoMessage()    {}
func (*DownloadReportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{17}
}
func (m *DownloadReportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadReportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadReportRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadReportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadReportRequest.Merge(m, src)
}
func (m *DownloadReportRequest) XXX_Size() int {
	return m.Size()
}
func (m *DownloadReportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadReportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadReportRequest proto.InternalMessageInfo

func (m *DownloadReportRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DownloadReportRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *DownloadReportRequest) Clone() *DownloadReportRequest {
	if m == nil {
		return nil
	}
	cloned := new(DownloadReportRequest)
	*cloned = *m

	return cloned
}

type DownloadReportResponse struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadReportResponse) Reset()         { *m = DownloadReportResponse{} }
func (m *DownloadReportResponse) String() string { return proto.CompactTextString(m) }
func (*DownloadReportResponse) ProtoMessage()    {}
func (*DownloadReportResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1e2917f181293be, []int{18}
}
func (m *DownloadReportResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadReportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadReportResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadReportResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadReportResponse.Merge(m, src)
}
func (m *DownloadReportResponse) XXX_Size() int {
	return m.Size()
}
func (m *DownloadReportResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadReportResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadReportResponse proto.InternalMessageInfo

func (m *DownloadReportResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *DownloadReportResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *DownloadReportResponse) Clone() *DownloadReportResponse {
	if m == nil {
		return nil
	}
	cloned := new(DownloadReportResponse)
	*cloned = *m

	if m.Data != nil {
		cloned.Data = make([]byte, len(m.Data))
		copy(cloned.Data, m.Data)
	}
	return cloned
}

func init() {
	proto.RegisterEnum("v2.NotificationMethod", NotificationMethod_name, NotificationMethod_value)
	proto.RegisterEnum("v2.ReportConfiguration_ReportType", ReportConfiguration_ReportType_name, ReportConfiguration_ReportType_value)
	proto.RegisterEnum("v2.VulnerabilityReportFilters_Fixability", VulnerabilityReportFilters_Fixability_name, VulnerabilityReportFilters_Fixability_value)
	proto.RegisterEnum("v2.VulnerabilityReportFilters_VulnerabilitySeverity", VulnerabilityReportFilters_VulnerabilitySeverity_name, VulnerabilityReportFilters_VulnerabilitySeverity_value)
	proto.RegisterEnum("v2.VulnerabilityReportFilters_ImageType", VulnerabilityReportFilters_ImageType_name, VulnerabilityReportFilters_ImageType_value)
	proto.RegisterEnum("v2.ReportSchedule_IntervalType", ReportSchedule_IntervalType_name, ReportSchedule_IntervalType_value)
	proto.RegisterEnum("v2.ReportStatus_RunState", ReportStatus_RunState_name, ReportStatus_RunState_value)
	proto.RegisterEnum("v2.ReportStatus_ReportMethod", ReportStatus_ReportMethod_name, ReportStatus_ReportMethod_value)
	proto.RegisterType((*ReportConfiguration)(nil), "v2.ReportConfiguration")
	proto.RegisterType((*VulnerabilityReportFilters)(nil), "v2.VulnerabilityReportFilters")
	proto.RegisterType((*ReportSchedule)(nil), "v2.ReportSchedule")
	proto.RegisterType((*ReportSchedule_DaysOfWeek)(nil), "v2.ReportSchedule.DaysOfWeek")
	proto.RegisterType((*ReportSchedule_DaysOfMonth)(nil), "v2.ReportSchedule.DaysOfMonth")
	proto.RegisterType((*ResourceScope)(nil), "v2.ResourceScope")
	proto.RegisterType((*CollectionReference)(nil), "v2.CollectionReference")
	proto.RegisterType((*NotifierConfiguration)(nil), "v2.NotifierConfiguration")
	proto.RegisterType((*EmailNotifierConfiguration)(nil), "v2.EmailNotifierConfiguration")
	proto.RegisterType((*ListReportConfigurationsResponse)(nil), "v2.ListReportConfigurationsResponse")
	proto.RegisterType((*CountReportConfigurationsResponse)(nil), "v2.CountReportConfigurationsResponse")
	proto.RegisterType((*GetReportHistoryRequest)(nil), "v2.GetReportHistoryRequest")
	proto.RegisterType((*ReportHistoryResponse)(nil), "v2.ReportHistoryResponse")
	proto.RegisterType((*ReportStatusResponse)(nil), "v2.ReportStatusResponse")
	proto.RegisterType((*CollectionSnapshot)(nil), "v2.CollectionSnapshot")
	proto.RegisterType((*ReportSnapshot)(nil), "v2.ReportSnapshot")
	proto.RegisterType((*ReportStatus)(nil), "v2.ReportStatus")
	proto.RegisterType((*RunReportRequest)(nil), "v2.RunReportRequest")
	proto.RegisterType((*RunReportResponse)(nil), "v2.RunReportResponse")
	proto.RegisterType((*DownloadReportRequest)(nil), "v2.DownloadReportRequest")
	proto.RegisterType((*DownloadReportResponse)(nil), "v2.DownloadReportResponse")
}

func init() { proto.RegisterFile("api/v2/report_service.proto", fileDescriptor_c1e2917f181293be) }

var fileDescriptor_c1e2917f181293be = []byte{
	// 2042 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcb, 0x6e, 0xe3, 0xd6,
	0x19, 0xd6, 0xc5, 0x17, 0xe9, 0x97, 0x2c, 0xd3, 0xc7, 0xe3, 0x89, 0x2c, 0x4f, 0x6c, 0x0d, 0x33,
	0xc9, 0x38, 0x46, 0x46, 0x06, 0xd4, 0x34, 0x4d, 0x03, 0xa4, 0x88, 0x2c, 0x69, 0x46, 0x6c, 0x64,
	0xc9, 0x39, 0x92, 0xc7, 0x99, 0x6c, 0x08, 0x9a, 0x3c, 0xb6, 0x99, 0xa1, 0x48, 0x85, 0x87, 0xd2,
	0x44, 0x08, 0xba, 0xe9, 0x13, 0x14, 0x6d, 0x17, 0xdd, 0xf4, 0x19, 0xba, 0xe8, 0xa2, 0xaf, 0x50,
	0xa0, 0x9b, 0x02, 0x7d, 0x81, 0x62, 0xda, 0x17, 0xe8, 0x1b, 0x14, 0xe7, 0x42, 0x8a, 0xb2, 0x25,
	0xdb, 0xbd, 0xec, 0x78, 0xfe, 0xfb, 0xed, 0xfc, 0xe7, 0x93, 0x60, 0xc7, 0x18, 0xda, 0x87, 0xe3,
	0xea, 0xa1, 0x4f, 0x86, 0x9e, 0x1f, 0xe8, 0x94, 0xf8, 0x63, 0xdb, 0x24, 0x95, 0xa1, 0xef, 0x05,
	0x1e, 0x4a, 0x8d, 0xab, 0xa5, 0xbd, 0x4b, 0xcf, 0xbb, 0x74, 0xc8, 0x21, 0xa7, 0x9c, 0x8f, 0x2e,
	0x0e, 0x03, 0x7b, 0x40, 0x68, 0x60, 0x0c, 0x86, 0x42, 0xa8, 0xb4, 0x29, 0x2d, 0x98, 0xde, 0x60,
	0xe0, 0xb9, 0x92, 0xb8, 0x2d, 0x89, 0x94, 0x18, 0xbe, 0x79, 0xa5, 0x7f, 0x37, 0x22, 0xfe, 0x44,
	0xb2, 0x1e, 0x49, 0x83, 0x4c, 0xc2, 0x70, 0x5d, 0x2f, 0x30, 0x02, 0xdb, 0x73, 0xa9, 0xe4, 0x6e,
	0x48, 0xc5, 0x11, 0x25, 0xbe, 0x20, 0xa9, 0x7f, 0x4c, 0xc3, 0x26, 0xe6, 0xe1, 0xd5, 0x3d, 0xf7,
	0xc2, 0xbe, 0x1c, 0xf9, 0x5c, 0x03, 0x15, 0x20, 0x65, 0x5b, 0xc5, 0x64, 0x39, 0xb9, 0x9f, 0xc5,
	0x29, 0xdb, 0x42, 0x08, 0x96, 0x5c, 0x63, 0x40, 0x8a, 0x29, 0x4e, 0xe1, 0xdf, 0xa8, 0x0c, 0x39,
	0x8b, 0x50, 0xd3, 0xb7, 0x87, 0x4c, 0xa5, 0x98, 0xe6, 0xac, 0x38, 0x09, 0x7d, 0x02, 0x4b, 0xc1,
	0x64, 0x48, 0x8a, 0x4b, 0xe5, 0xe4, 0x7e, 0xa1, 0xaa, 0x56, 0xc6, 0xd5, 0xca, 0x1c, 0x67, 0x92,
	0xd6, 0x9f, 0x0c, 0x09, 0xe6, 0xf2, 0xe8, 0x04, 0x36, 0xc7, 0x23, 0xc7, 0xd5, 0x65, 0xe1, 0x2e,
	0x6c, 0x27, 0x20, 0x3e, 0x2d, 0x2e, 0x97, 0x93, 0xfb, 0xb9, 0xea, 0x2e, 0x33, 0xf3, 0x72, 0xe4,
	0xb8, 0xc4, 0x37, 0xce, 0x6d, 0xc7, 0x0e, 0x26, 0x42, 0xff, 0xb9, 0x90, 0x6a, 0x25, 0xf0, 0x06,
	0x53, 0x9e, 0x21, 0xa2, 0x0a, 0x64, 0xa8, 0x79, 0x45, 0xac, 0x91, 0x43, 0x8a, 0x2b, 0xdc, 0x0c,
	0x9a, 0x46, 0xd3, 0x93, 0x1c, 0x1c, 0xc9, 0xa0, 0x4f, 0xa1, 0xe0, 0x13, 0xea, 0x8d, 0x7c, 0x93,
	0xe8, 0xd4, 0xf4, 0x86, 0xa4, 0xb8, 0xca, 0xb5, 0x36, 0x84, 0x96, 0xe0, 0xf4, 0x18, 0x03, 0xaf,
	0xf9, 0xf1, 0x23, 0xfa, 0x09, 0x64, 0x5d, 0x2f, 0xb0, 0x2f, 0x6c, 0x16, 0x71, 0xa6, 0x9c, 0xde,
	0xcf, 0x55, 0xb7, 0x99, 0x52, 0x47, 0x12, 0x67, 0x52, 0xc7, 0x53, 0x59, 0x75, 0x0f, 0x60, 0x5a,
	0x08, 0xb4, 0x01, 0x6b, 0x2f, 0x4f, 0xdb, 0x9d, 0x26, 0xae, 0x1d, 0x69, 0x6d, 0xad, 0xff, 0x4a,
	0x49, 0x1c, 0x65, 0x60, 0x45, 0x54, 0x42, 0xfd, 0xd7, 0x32, 0x94, 0x16, 0x57, 0x00, 0x69, 0x00,
	0x17, 0xf6, 0xf7, 0x92, 0xc5, 0x9b, 0x58, 0xa8, 0x7e, 0x78, 0x7b, 0xd5, 0x2a, 0xcf, 0x23, 0x05,
	0x1c, 0x53, 0x46, 0x7d, 0x00, 0x4a, 0xc6, 0xc4, 0xb7, 0x03, 0x9b, 0xd0, 0x62, 0xaa, 0x9c, 0xde,
	0x2f, 0x54, 0x3f, 0xbe, 0xc3, 0xd4, 0x0c, 0xab, 0x27, 0xb4, 0x27, 0x38, 0x66, 0x07, 0x69, 0x90,
	0xb3, 0x07, 0xc6, 0x25, 0xd1, 0x59, 0xb7, 0x69, 0x31, 0xcd, 0xcd, 0xee, 0xdf, 0x61, 0x56, 0x63,
	0x1a, 0x7c, 0x48, 0xc0, 0x0e, 0x3f, 0x29, 0xda, 0x81, 0x8c, 0xe1, 0x38, 0x3a, 0xeb, 0x38, 0x1f,
	0xb3, 0x4c, 0x2b, 0x81, 0x57, 0x0d, 0xc7, 0x61, 0x86, 0x50, 0x0b, 0xca, 0xd4, 0x76, 0x4d, 0xa2,
	0x3b, 0x06, 0x65, 0xf7, 0xcf, 0x0d, 0xf4, 0xb0, 0xc3, 0x96, 0x1c, 0x2e, 0x3e, 0x54, 0x4c, 0xe9,
	0x11, 0x97, 0x6c, 0x1b, 0x34, 0xe8, 0x11, 0x37, 0x1a, 0x09, 0x4b, 0xc4, 0x80, 0x9e, 0x83, 0x22,
	0x2c, 0xd1, 0xc0, 0xf0, 0x03, 0xdd, 0x32, 0x82, 0x70, 0x8e, 0x4a, 0x15, 0x71, 0xe7, 0x2a, 0xe1,
	0x25, 0xae, 0xf4, 0xc3, 0x4b, 0xdc, 0x4a, 0xe0, 0x02, 0xd7, 0xea, 0x31, 0xa5, 0x86, 0x11, 0x10,
	0xf5, 0x63, 0x80, 0x69, 0xa5, 0x51, 0x06, 0x96, 0x8e, 0xba, 0xfd, 0x96, 0x92, 0x40, 0x39, 0x58,
	0x7d, 0xae, 0x7d, 0x5d, 0x3b, 0x6a, 0x37, 0x95, 0x24, 0x5a, 0x87, 0x5c, 0xa7, 0xdb, 0xd7, 0x43,
	0x42, 0x4a, 0xfd, 0x4b, 0x12, 0xb6, 0xe6, 0x56, 0x15, 0xa9, 0xb0, 0x7b, 0xda, 0xf9, 0xb2, 0xd3,
	0x3d, 0xeb, 0xe8, 0x33, 0xe3, 0xa2, 0xf7, 0x9a, 0x2f, 0x9b, 0x98, 0xcf, 0x0d, 0xda, 0x85, 0x52,
	0xbb, 0x7b, 0xb6, 0x88, 0x9f, 0x44, 0xef, 0xc1, 0xde, 0x71, 0xb7, 0xd1, 0xc4, 0xb5, 0x7e, 0x73,
	0x91, 0x50, 0x0a, 0x3d, 0x81, 0xb2, 0x76, 0x7c, 0xd2, 0xc5, 0xfd, 0x5a, 0xa7, 0xbf, 0x48, 0x2a,
	0xcd, 0x4c, 0xd5, 0xb1, 0xd6, 0xd7, 0xea, 0xb5, 0xf6, 0x22, 0xa1, 0x25, 0xf5, 0x03, 0xc8, 0x46,
	0xbd, 0x44, 0x79, 0xc8, 0x34, 0x9a, 0x27, 0xed, 0xee, 0xab, 0x66, 0x43, 0x94, 0xe1, 0xac, 0xd6,
	0xaf, 0xb7, 0x9a, 0x0d, 0x25, 0x79, 0x94, 0x07, 0x30, 0xc7, 0x84, 0xea, 0xbc, 0x84, 0xea, 0xaf,
	0xd2, 0x50, 0x98, 0xbd, 0xae, 0xa8, 0x01, 0x6b, 0xb6, 0x1b, 0x10, 0x7f, 0x6c, 0x38, 0x7c, 0x92,
	0xe4, 0xa8, 0xef, 0xdd, 0xbc, 0xd9, 0x15, 0x4d, 0xca, 0xf1, 0xf9, 0xc9, 0xdb, 0xb1, 0x13, 0x5b,
	0x6d, 0x57, 0xde, 0xc8, 0xe7, 0xab, 0x6d, 0x19, 0xf3, 0x6f, 0xf4, 0x10, 0x56, 0x06, 0xb6, 0x3b,
	0x0a, 0x08, 0xdf, 0x6a, 0xcb, 0x58, 0x9e, 0x50, 0x0d, 0xf2, 0x96, 0x31, 0xa1, 0xba, 0x77, 0xa1,
	0xbf, 0x21, 0xe4, 0x35, 0x9f, 0xb8, 0x5c, 0xf5, 0xdd, 0x39, 0x0e, 0x1b, 0xc6, 0x84, 0x76, 0x2f,
	0xce, 0x08, 0x79, 0xdd, 0x4a, 0x60, 0xb0, 0xa2, 0x13, 0x0b, 0x3a, 0x34, 0x31, 0xf0, 0xdc, 0xe0,
	0x2a, 0xbe, 0xd5, 0xe6, 0xda, 0x38, 0x66, 0x52, 0xad, 0x04, 0xce, 0x59, 0xd3, 0x63, 0xa9, 0x0c,
	0x30, 0xf5, 0xc0, 0x52, 0x60, 0xcc, 0x62, 0xb2, 0x9c, 0x66, 0x29, 0xb0, 0xef, 0xd2, 0x63, 0xc8,
	0xc5, 0xf4, 0xe7, 0x89, 0xa8, 0x55, 0xc8, 0xc7, 0xeb, 0x82, 0xb2, 0xb0, 0x7c, 0xda, 0xe9, 0x35,
	0xfb, 0x4a, 0x02, 0x01, 0xac, 0x9c, 0x35, 0x9b, 0x5f, 0xb6, 0xd9, 0x7c, 0xe4, 0x60, 0xf5, 0xb8,
	0xdb, 0xe9, 0xb7, 0xda, 0xaf, 0x94, 0xd4, 0x11, 0x40, 0x26, 0xd4, 0x51, 0xaf, 0x60, 0x6d, 0x66,
	0x15, 0xa2, 0x06, 0x28, 0xa6, 0xe7, 0x38, 0xc4, 0x64, 0xbb, 0x4d, 0xee, 0xcd, 0x24, 0x4f, 0xef,
	0x1d, 0x96, 0x5e, 0x3d, 0xe2, 0x61, 0x72, 0x41, 0x7c, 0xe2, 0x9a, 0xa4, 0x95, 0xc0, 0xeb, 0x53,
	0x15, 0x6e, 0xe5, 0x68, 0x03, 0xd6, 0xb9, 0xaa, 0xee, 0x87, 0x52, 0xaa, 0x09, 0x9b, 0x73, 0x94,
	0xd1, 0x7b, 0xb0, 0x16, 0xf3, 0x17, 0x3d, 0x58, 0xf9, 0x29, 0x51, 0xb3, 0xd0, 0x53, 0x88, 0x79,
	0xd0, 0x63, 0xaf, 0x58, 0x61, 0x4a, 0xee, 0x18, 0x03, 0xa2, 0xfe, 0x36, 0x09, 0x5b, 0x73, 0xb7,
	0x34, 0xaa, 0x43, 0x9e, 0x0c, 0x0c, 0xdb, 0xd1, 0x4d, 0x4e, 0x96, 0x39, 0xf1, 0x96, 0x35, 0x19,
	0x7d, 0xae, 0x16, 0x6b, 0x19, 0xd7, 0x12, 0x54, 0x16, 0x6c, 0xb8, 0xec, 0xe3, 0x51, 0xe4, 0x43,
	0x22, 0x8b, 0x81, 0xe5, 0x1e, 0x09, 0x09, 0x67, 0xea, 0x39, 0x94, 0x16, 0x3b, 0x41, 0x7b, 0x90,
	0x8b, 0x14, 0xa2, 0x02, 0x40, 0x48, 0xd2, 0x2c, 0xe6, 0x96, 0x69, 0xdb, 0xee, 0xa5, 0xee, 0xd8,
	0x34, 0x10, 0x4b, 0x3c, 0x8b, 0xf3, 0x92, 0xd8, 0x66, 0x34, 0xf5, 0x1c, 0xca, 0xec, 0x63, 0xce,
	0xe3, 0x4c, 0x31, 0xa1, 0x43, 0xcf, 0xa5, 0x04, 0xfd, 0x8c, 0x3d, 0x89, 0xfc, 0x3d, 0x16, 0x81,
	0x89, 0x59, 0x92, 0xad, 0x9d, 0xa3, 0xc9, 0x1e, 0xc6, 0x29, 0x91, 0xaa, 0x3f, 0x85, 0xc7, 0x75,
	0x6f, 0xe4, 0xde, 0xee, 0xe4, 0x01, 0x2c, 0x9b, 0x4c, 0x88, 0x27, 0xb2, 0x8c, 0xc5, 0x41, 0x25,
	0xf0, 0xce, 0x0b, 0x22, 0x15, 0x5b, 0x36, 0x0d, 0x3c, 0x7f, 0x82, 0xc9, 0x77, 0x23, 0x42, 0x83,
	0x1b, 0x40, 0xe5, 0x33, 0x40, 0x32, 0xca, 0xa1, 0xe1, 0x1b, 0x03, 0x81, 0x8e, 0x78, 0xa9, 0x73,
	0xd5, 0x3c, 0x8f, 0xd4, 0x78, 0xf3, 0x15, 0xa3, 0x61, 0x45, 0xc8, 0x9d, 0x30, 0x31, 0x4e, 0x51,
	0x5f, 0xc2, 0xd6, 0x35, 0x1f, 0x32, 0xaa, 0xcf, 0x41, 0x09, 0x31, 0x9c, 0x6b, 0x0c, 0xe9, 0x95,
	0x17, 0x84, 0xc9, 0xc7, 0x51, 0x84, 0x64, 0xe1, 0x75, 0x7f, 0xe6, 0x4c, 0xd5, 0x2f, 0xe0, 0x81,
	0x14, 0x09, 0x8c, 0x60, 0x34, 0x4d, 0x76, 0x1f, 0x56, 0x28, 0xa7, 0xc8, 0x81, 0x52, 0x62, 0xc6,
	0x84, 0xa4, 0xe4, 0xab, 0x9f, 0x02, 0x9a, 0xce, 0x7f, 0x68, 0xf8, 0x3e, 0x20, 0x4d, 0xfd, 0xc3,
	0x52, 0xb4, 0x36, 0x43, 0xb5, 0xfd, 0x28, 0x1b, 0xd1, 0xc8, 0xe9, 0xdc, 0x14, 0xe2, 0x1d, 0xd3,
	0x2c, 0xa4, 0x82, 0xec, 0xa1, 0xfe, 0xad, 0x77, 0xce, 0xc4, 0x84, 0xe5, 0x9c, 0x20, 0xfe, 0xdc,
	0x3b, 0xd7, 0xa6, 0x4e, 0xd3, 0x8b, 0x91, 0xe1, 0xd2, 0x4d, 0x64, 0xf8, 0xff, 0x47, 0x78, 0x2f,
	0x60, 0x33, 0xbe, 0x7b, 0x64, 0xb2, 0xf2, 0x91, 0x7e, 0x38, 0xbb, 0x7e, 0xa2, 0x56, 0x21, 0xf3,
	0x66, 0x55, 0xe3, 0x50, 0x71, 0xf5, 0x1e, 0x50, 0xf1, 0xc7, 0x51, 0x91, 0x64, 0x33, 0x33, 0x0b,
	0x9a, 0x99, 0xf7, 0x63, 0xa7, 0x59, 0x9c, 0x98, 0xbd, 0x3f, 0x4e, 0x44, 0x65, 0x58, 0x62, 0x00,
	0xbe, 0x08, 0xd3, 0x99, 0xee, 0x39, 0xf6, 0xe0, 0x94, 0x12, 0x1f, 0x73, 0x0e, 0xaa, 0xc2, 0x96,
	0x4d, 0x75, 0xcb, 0x7b, 0xe3, 0x3a, 0x9e, 0x61, 0xe9, 0xc6, 0xd8, 0xb0, 0x1d, 0xe3, 0xdc, 0x21,
	0xc5, 0x1c, 0xc3, 0x3a, 0x78, 0xd3, 0xa6, 0x0d, 0xc9, 0xab, 0x85, 0xac, 0x18, 0xb8, 0xfc, 0x53,
	0x1a, 0xf2, 0xf1, 0xb8, 0xd1, 0x27, 0x90, 0xf5, 0x47, 0x2e, 0xcf, 0x2e, 0x7c, 0x62, 0xb7, 0xaf,
	0x27, 0x57, 0xc1, 0x23, 0x97, 0x7d, 0x11, 0x9c, 0xf1, 0xe5, 0x17, 0xfa, 0x1c, 0xf2, 0xa6, 0x37,
	0x18, 0x3a, 0x24, 0x20, 0x96, 0x6e, 0x04, 0xf2, 0x12, 0xde, 0x82, 0x97, 0x70, 0x2e, 0x92, 0xaf,
	0x05, 0x68, 0x07, 0xb2, 0xc4, 0xf7, 0x3d, 0x5f, 0x1f, 0xd0, 0x4b, 0x39, 0x5d, 0x19, 0x4e, 0x38,
	0xa6, 0x97, 0xe8, 0x18, 0x36, 0x65, 0xd1, 0x7d, 0xb1, 0x08, 0xf4, 0xd8, 0x0f, 0x8d, 0x77, 0x6f,
	0x46, 0xc7, 0x0f, 0xc7, 0x24, 0xb8, 0xf2, 0x2c, 0xbc, 0x21, 0x34, 0xe5, 0x06, 0xe1, 0x2f, 0x5f,
	0x1f, 0x4a, 0xd2, 0x9c, 0xa8, 0xb3, 0xc9, 0xab, 0xae, 0x0f, 0xb8, 0x02, 0x9f, 0xca, 0x82, 0x98,
	0xa1, 0x4e, 0x8c, 0x2d, 0xcd, 0x15, 0x85, 0xe6, 0x4d, 0x8e, 0xfa, 0x05, 0x64, 0xc2, 0xb2, 0x08,
	0x64, 0xa3, 0xf5, 0xb5, 0xce, 0x0b, 0x25, 0x81, 0xd6, 0x20, 0x7b, 0x82, 0x9b, 0x27, 0x35, 0xcc,
	0x8e, 0xfc, 0x81, 0xed, 0x9d, 0xd6, 0xeb, 0xcd, 0x5e, 0x4f, 0x49, 0x71, 0x24, 0x58, 0xd3, 0xda,
	0xa7, 0xb8, 0xa9, 0xa4, 0xd5, 0x8f, 0xc2, 0x56, 0x08, 0x8b, 0x4c, 0xb1, 0xdb, 0xd1, 0x1b, 0xcd,
	0xe3, 0x5a, 0xa7, 0x21, 0xec, 0xf4, 0x18, 0x58, 0x3a, 0x6d, 0x33, 0xc0, 0xa4, 0xfe, 0x3a, 0x09,
	0x0a, 0x1e, 0xc9, 0x7b, 0x11, 0x2e, 0xc8, 0xfb, 0xdf, 0xf6, 0xdb, 0x8b, 0x90, 0xfa, 0x2f, 0x8b,
	0xf0, 0x0d, 0x6c, 0xc4, 0x62, 0x8a, 0x36, 0xdf, 0x7d, 0x83, 0xda, 0x81, 0xac, 0x94, 0x8c, 0xd6,
	0x4f, 0x46, 0x10, 0x34, 0x4b, 0x7d, 0x0a, 0x5b, 0xe1, 0x24, 0xcf, 0x26, 0x7d, 0x6d, 0x33, 0xaa,
	0x1f, 0xc1, 0xc3, 0xeb, 0x82, 0x32, 0x12, 0x8e, 0x8b, 0x02, 0x83, 0xcb, 0xe6, 0x31, 0xff, 0x3e,
	0x78, 0x06, 0xe8, 0x66, 0x22, 0x0c, 0x1d, 0x35, 0x8f, 0x6b, 0x5a, 0x5b, 0x49, 0x70, 0xd0, 0xda,
	0x3d, 0xeb, 0xb4, 0xbb, 0xb5, 0x86, 0x92, 0xac, 0xfe, 0x1e, 0x18, 0x0e, 0xe2, 0xd3, 0x26, 0x7e,
	0xe1, 0x23, 0x1f, 0xde, 0x39, 0xf1, 0xe6, 0x3e, 0xa7, 0x68, 0xd1, 0x6b, 0x59, 0x5a, 0xc4, 0x50,
	0xdf, 0xff, 0xe5, 0xdf, 0xfe, 0xf9, 0x9b, 0xd4, 0x9e, 0x5a, 0x9a, 0xfe, 0x95, 0x40, 0x0f, 0xcd,
	0x99, 0xe7, 0xf3, 0xb3, 0xe4, 0x01, 0x7a, 0x0d, 0xdb, 0xa7, 0x43, 0xf6, 0xbb, 0xe4, 0x3f, 0xf2,
	0x9a, 0x15, 0x18, 0x66, 0x18, 0x4c, 0xd4, 0x03, 0xee, 0xe7, 0x49, 0x69, 0x6f, 0xb1, 0x9f, 0xc3,
	0x1f, 0x6c, 0xeb, 0x17, 0xcc, 0x99, 0x0f, 0xc5, 0x45, 0x78, 0x01, 0xcd, 0xbc, 0xb2, 0xa5, 0x27,
	0xec, 0x74, 0x17, 0xb6, 0x50, 0x55, 0xee, 0xfb, 0x11, 0xba, 0x25, 0x47, 0x34, 0x81, 0xed, 0x85,
	0xf8, 0xe1, 0x9a, 0xd3, 0xf7, 0xc5, 0xba, 0xbf, 0x03, 0x6c, 0xa8, 0x4f, 0xb9, 0xd7, 0xc7, 0x68,
	0x71, 0xc6, 0xcf, 0x38, 0xfe, 0x40, 0x0e, 0x3c, 0x8c, 0xf0, 0xc7, 0x6c, 0x61, 0x95, 0xf8, 0xff,
	0x01, 0x47, 0x13, 0xad, 0xb1, 0xb8, 0x8f, 0x77, 0x7b, 0x13, 0xf5, 0x45, 0x06, 0x6c, 0x37, 0x08,
	0xdb, 0x82, 0xf7, 0x73, 0x18, 0x6b, 0xa1, 0x74, 0x71, 0x70, 0xa7, 0x0b, 0x13, 0xd6, 0xa3, 0x84,
	0xe4, 0x96, 0xbf, 0x69, 0xb8, 0x78, 0xe3, 0x05, 0x0b, 0x0b, 0xf7, 0x84, 0xfb, 0xd9, 0x45, 0x8f,
	0xe2, 0x7e, 0xbe, 0xf5, 0xce, 0x85, 0xf5, 0x43, 0xf1, 0x0e, 0x22, 0x0f, 0x76, 0x5e, 0x90, 0x80,
	0xfd, 0xa2, 0x8e, 0x1b, 0x91, 0x37, 0xbb, 0xf1, 0xbf, 0x3b, 0x64, 0x3f, 0xea, 0x9f, 0x09, 0x5f,
	0x22, 0xab, 0x1f, 0x40, 0xb9, 0x0e, 0x13, 0xd1, 0x0e, 0xb3, 0xb9, 0x00, 0x3c, 0x96, 0x62, 0xcf,
	0xd8, 0x35, 0xc8, 0xa7, 0x1e, 0x72, 0x8f, 0x1f, 0xa2, 0xa7, 0x77, 0x94, 0xf2, 0xf0, 0x4a, 0x3a,
	0xea, 0x43, 0x36, 0xda, 0x73, 0xe8, 0x01, 0x37, 0x7c, 0x6d, 0x15, 0x97, 0xb6, 0xae, 0x51, 0xa5,
	0xab, 0x12, 0x77, 0xf5, 0x40, 0x5d, 0x8f, 0xbb, 0xf2, 0x47, 0x2e, 0xbb, 0x68, 0x5f, 0x41, 0xbe,
	0x6e, 0xb8, 0x26, 0x71, 0xa4, 0xe1, 0x5b, 0xdb, 0x2f, 0xab, 0x74, 0xb0, 0xa0, 0x2d, 0x26, 0x37,
	0x84, 0x3c, 0x28, 0xcc, 0xee, 0x42, 0xc4, 0xcb, 0x30, 0x77, 0x91, 0x96, 0x4a, 0xf3, 0x58, 0x32,
	0xee, 0x0f, 0xb8, 0xbb, 0x32, 0xda, 0x9d, 0xef, 0x2e, 0xc4, 0x1f, 0x47, 0x95, 0x3f, 0xbf, 0xdd,
	0x4d, 0xfe, 0xf5, 0xed, 0x6e, 0xf2, 0xef, 0x6f, 0x77, 0x93, 0xbf, 0xfb, 0xc7, 0x6e, 0x02, 0x8a,
	0xb6, 0x57, 0xa1, 0x81, 0x61, 0xbe, 0xf6, 0xbd, 0xef, 0x05, 0x0e, 0xa8, 0x18, 0x43, 0xbb, 0x32,
	0xae, 0x7e, 0x93, 0x1a, 0x57, 0xbf, 0x4e, 0x9f, 0xaf, 0x70, 0xda, 0x8f, 0xfe, 0x1d, 0x00, 0x00,
	0xff, 0xff, 0x5e, 0xa0, 0xb9, 0xb5, 0x41, 0x15, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ReportServiceClient is the client API for ReportService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConnInterface.NewStream.
type ReportServiceClient interface {
	// PostReportConfiguration creates a report configuration
	PostReportConfiguration(ctx context.Context, in *ReportConfiguration, opts ...grpc.CallOption) (*ReportConfiguration, error)
	// UpdateReportConfiguration updates a report configuration
	UpdateReportConfiguration(ctx context.Context, in *ReportConfiguration, opts ...grpc.CallOption) (*Empty, error)
	// ListReportConfigurations returns report configurations matching given query
	ListReportConfigurations(ctx context.Context, in *RawQuery, opts ...grpc.CallOption) (*ListReportConfigurationsResponse, error)
	// CountReportConfigurations returns the number of report configurations.
	CountReportConfigurations(ctx context.Context, in *RawQuery, opts ...grpc.CallOption) (*CountReportConfigurationsResponse, error)
	// GetReportConfiguration returns the report configuration with given ID
	GetReportConfiguration(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*ReportConfiguration, error)
	// DeleteReportConfiguration removes the report configuration with given ID
	DeleteReportConfiguration(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*Empty, error)
	// GetReportStatus returns report status for the given report id
	GetReportStatus(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*ReportStatusResponse, error)
	// GetReportStatusConfigID returns report status for a report config id
	GetLastReportStatusConfigID(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*ReportStatusResponse, error)
	// GetReportHistory returns the full history for a report configuration with the specified ID.
	GetReportHistory(ctx context.Context, in *GetReportHistoryRequest, opts ...grpc.CallOption) (*ReportHistoryResponse, error)
	// Submits a new report generation request if the user requesting this report does not have another waiting or preparing
	// report for the same report configuration.
	RunReport(ctx context.Context, in *RunReportRequest, opts ...grpc.CallOption) (*RunReportResponse, error)
	// Cancels a queued report job for the given report id. If the job is not active, it is a noop.
	// If a report is already being prepared, it won't be cancelled.
	CancelReport(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*Empty, error)
	// Downloads a generated report for the given report id
	DownloadReport(ctx context.Context, in *DownloadReportRequest, opts ...grpc.CallOption) (*DownloadReportResponse, error)
}

type reportServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReportServiceClient(cc grpc.ClientConnInterface) ReportServiceClient {
	return &reportServiceClient{cc}
}

func (c *reportServiceClient) PostReportConfiguration(ctx context.Context, in *ReportConfiguration, opts ...grpc.CallOption) (*ReportConfiguration, error) {
	out := new(ReportConfiguration)
	err := c.cc.Invoke(ctx, "/v2.ReportService/PostReportConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) UpdateReportConfiguration(ctx context.Context, in *ReportConfiguration, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/v2.ReportService/UpdateReportConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) ListReportConfigurations(ctx context.Context, in *RawQuery, opts ...grpc.CallOption) (*ListReportConfigurationsResponse, error) {
	out := new(ListReportConfigurationsResponse)
	err := c.cc.Invoke(ctx, "/v2.ReportService/ListReportConfigurations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) CountReportConfigurations(ctx context.Context, in *RawQuery, opts ...grpc.CallOption) (*CountReportConfigurationsResponse, error) {
	out := new(CountReportConfigurationsResponse)
	err := c.cc.Invoke(ctx, "/v2.ReportService/CountReportConfigurations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) GetReportConfiguration(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*ReportConfiguration, error) {
	out := new(ReportConfiguration)
	err := c.cc.Invoke(ctx, "/v2.ReportService/GetReportConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) DeleteReportConfiguration(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/v2.ReportService/DeleteReportConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) GetReportStatus(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*ReportStatusResponse, error) {
	out := new(ReportStatusResponse)
	err := c.cc.Invoke(ctx, "/v2.ReportService/GetReportStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) GetLastReportStatusConfigID(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*ReportStatusResponse, error) {
	out := new(ReportStatusResponse)
	err := c.cc.Invoke(ctx, "/v2.ReportService/GetLastReportStatusConfigID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) GetReportHistory(ctx context.Context, in *GetReportHistoryRequest, opts ...grpc.CallOption) (*ReportHistoryResponse, error) {
	out := new(ReportHistoryResponse)
	err := c.cc.Invoke(ctx, "/v2.ReportService/GetReportHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) RunReport(ctx context.Context, in *RunReportRequest, opts ...grpc.CallOption) (*RunReportResponse, error) {
	out := new(RunReportResponse)
	err := c.cc.Invoke(ctx, "/v2.ReportService/RunReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) CancelReport(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/v2.ReportService/CancelReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) DownloadReport(ctx context.Context, in *DownloadReportRequest, opts ...grpc.CallOption) (*DownloadReportResponse, error) {
	out := new(DownloadReportResponse)
	err := c.cc.Invoke(ctx, "/v2.ReportService/DownloadReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReportServiceServer is the server API for ReportService service.
type ReportServiceServer interface {
	// PostReportConfiguration creates a report configuration
	PostReportConfiguration(context.Context, *ReportConfiguration) (*ReportConfiguration, error)
	// UpdateReportConfiguration updates a report configuration
	UpdateReportConfiguration(context.Context, *ReportConfiguration) (*Empty, error)
	// ListReportConfigurations returns report configurations matching given query
	ListReportConfigurations(context.Context, *RawQuery) (*ListReportConfigurationsResponse, error)
	// CountReportConfigurations returns the number of report configurations.
	CountReportConfigurations(context.Context, *RawQuery) (*CountReportConfigurationsResponse, error)
	// GetReportConfiguration returns the report configuration with given ID
	GetReportConfiguration(context.Context, *ResourceByID) (*ReportConfiguration, error)
	// DeleteReportConfiguration removes the report configuration with given ID
	DeleteReportConfiguration(context.Context, *ResourceByID) (*Empty, error)
	// GetReportStatus returns report status for the given report id
	GetReportStatus(context.Context, *ResourceByID) (*ReportStatusResponse, error)
	// GetReportStatusConfigID returns report status for a report config id
	GetLastReportStatusConfigID(context.Context, *ResourceByID) (*ReportStatusResponse, error)
	// GetReportHistory returns the full history for a report configuration with the specified ID.
	GetReportHistory(context.Context, *GetReportHistoryRequest) (*ReportHistoryResponse, error)
	// Submits a new report generation request if the user requesting this report does not have another waiting or preparing
	// report for the same report configuration.
	RunReport(context.Context, *RunReportRequest) (*RunReportResponse, error)
	// Cancels a queued report job for the given report id. If the job is not active, it is a noop.
	// If a report is already being prepared, it won't be cancelled.
	CancelReport(context.Context, *ResourceByID) (*Empty, error)
	// Downloads a generated report for the given report id
	DownloadReport(context.Context, *DownloadReportRequest) (*DownloadReportResponse, error)
}

// UnimplementedReportServiceServer can be embedded to have forward compatible implementations.
type UnimplementedReportServiceServer struct {
}

func (*UnimplementedReportServiceServer) PostReportConfiguration(ctx context.Context, req *ReportConfiguration) (*ReportConfiguration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostReportConfiguration not implemented")
}
func (*UnimplementedReportServiceServer) UpdateReportConfiguration(ctx context.Context, req *ReportConfiguration) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReportConfiguration not implemented")
}
func (*UnimplementedReportServiceServer) ListReportConfigurations(ctx context.Context, req *RawQuery) (*ListReportConfigurationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReportConfigurations not implemented")
}
func (*UnimplementedReportServiceServer) CountReportConfigurations(ctx context.Context, req *RawQuery) (*CountReportConfigurationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountReportConfigurations not implemented")
}
func (*UnimplementedReportServiceServer) GetReportConfiguration(ctx context.Context, req *ResourceByID) (*ReportConfiguration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReportConfiguration not implemented")
}
func (*UnimplementedReportServiceServer) DeleteReportConfiguration(ctx context.Context, req *ResourceByID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReportConfiguration not implemented")
}
func (*UnimplementedReportServiceServer) GetReportStatus(ctx context.Context, req *ResourceByID) (*ReportStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReportStatus not implemented")
}
func (*UnimplementedReportServiceServer) GetLastReportStatusConfigID(ctx context.Context, req *ResourceByID) (*ReportStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastReportStatusConfigID not implemented")
}
func (*UnimplementedReportServiceServer) GetReportHistory(ctx context.Context, req *GetReportHistoryRequest) (*ReportHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReportHistory not implemented")
}
func (*UnimplementedReportServiceServer) RunReport(ctx context.Context, req *RunReportRequest) (*RunReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunReport not implemented")
}
func (*UnimplementedReportServiceServer) CancelReport(ctx context.Context, req *ResourceByID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelReport not implemented")
}
func (*UnimplementedReportServiceServer) DownloadReport(ctx context.Context, req *DownloadReportRequest) (*DownloadReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadReport not implemented")
}

func RegisterReportServiceServer(s *grpc.Server, srv ReportServiceServer) {
	s.RegisterService(&_ReportService_serviceDesc, srv)
}

func _ReportService_PostReportConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportConfiguration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).PostReportConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ReportService/PostReportConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).PostReportConfiguration(ctx, req.(*ReportConfiguration))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_UpdateReportConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportConfiguration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).UpdateReportConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ReportService/UpdateReportConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).UpdateReportConfiguration(ctx, req.(*ReportConfiguration))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_ListReportConfigurations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).ListReportConfigurations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ReportService/ListReportConfigurations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).ListReportConfigurations(ctx, req.(*RawQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_CountReportConfigurations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).CountReportConfigurations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ReportService/CountReportConfigurations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).CountReportConfigurations(ctx, req.(*RawQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_GetReportConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).GetReportConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ReportService/GetReportConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).GetReportConfiguration(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_DeleteReportConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).DeleteReportConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ReportService/DeleteReportConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).DeleteReportConfiguration(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_GetReportStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).GetReportStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ReportService/GetReportStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).GetReportStatus(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_GetLastReportStatusConfigID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).GetLastReportStatusConfigID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ReportService/GetLastReportStatusConfigID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).GetLastReportStatusConfigID(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_GetReportHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReportHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).GetReportHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ReportService/GetReportHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).GetReportHistory(ctx, req.(*GetReportHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_RunReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).RunReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ReportService/RunReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).RunReport(ctx, req.(*RunReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_CancelReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).CancelReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ReportService/CancelReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).CancelReport(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_DownloadReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).DownloadReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ReportService/DownloadReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).DownloadReport(ctx, req.(*DownloadReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ReportService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v2.ReportService",
	HandlerType: (*ReportServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PostReportConfiguration",
			Handler:    _ReportService_PostReportConfiguration_Handler,
		},
		{
			MethodName: "UpdateReportConfiguration",
			Handler:    _ReportService_UpdateReportConfiguration_Handler,
		},
		{
			MethodName: "ListReportConfigurations",
			Handler:    _ReportService_ListReportConfigurations_Handler,
		},
		{
			MethodName: "CountReportConfigurations",
			Handler:    _ReportService_CountReportConfigurations_Handler,
		},
		{
			MethodName: "GetReportConfiguration",
			Handler:    _ReportService_GetReportConfiguration_Handler,
		},
		{
			MethodName: "DeleteReportConfiguration",
			Handler:    _ReportService_DeleteReportConfiguration_Handler,
		},
		{
			MethodName: "GetReportStatus",
			Handler:    _ReportService_GetReportStatus_Handler,
		},
		{
			MethodName: "GetLastReportStatusConfigID",
			Handler:    _ReportService_GetLastReportStatusConfigID_Handler,
		},
		{
			MethodName: "GetReportHistory",
			Handler:    _ReportService_GetReportHistory_Handler,
		},
		{
			MethodName: "RunReport",
			Handler:    _ReportService_RunReport_Handler,
		},
		{
			MethodName: "CancelReport",
			Handler:    _ReportService_CancelReport_Handler,
		},
		{
			MethodName: "DownloadReport",
			Handler:    _ReportService_DownloadReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v2/report_service.proto",
}

func (m *ReportConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Notifiers) > 0 {
		for iNdEx := len(m.Notifiers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Notifiers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReportService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ResourceScope != nil {
		{
			size, err := m.ResourceScope.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Schedule != nil {
		{
			size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Filter != nil {
		{
			size := m.Filter.Size()
			i -= size
			if _, err := m.Filter.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Type != 0 {
		i = encodeVarintReportService(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportConfiguration_VulnReportFilters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportConfiguration_VulnReportFilters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VulnReportFilters != nil {
		{
			size, err := m.VulnReportFilters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *VulnerabilityReportFilters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VulnerabilityReportFilters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VulnerabilityReportFilters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CvesSince != nil {
		{
			size := m.CvesSince.Size()
			i -= size
			if _, err := m.CvesSince.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.ImageTypes) > 0 {
		dAtA5 := make([]byte, len(m.ImageTypes)*10)
		var j4 int
		for _, num := range m.ImageTypes {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintReportService(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Severities) > 0 {
		dAtA7 := make([]byte, len(m.Severities)*10)
		var j6 int
		for _, num := range m.Severities {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintReportService(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x12
	}
	if m.Fixability != 0 {
		i = encodeVarintReportService(dAtA, i, uint64(m.Fixability))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VulnerabilityReportFilters_AllVuln) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VulnerabilityReportFilters_AllVuln) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.AllVuln {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *VulnerabilityReportFilters_SinceLastSentScheduledReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VulnerabilityReportFilters_SinceLastSentScheduledReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.SinceLastSentScheduledReport {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *VulnerabilityReportFilters_SinceStartDate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VulnerabilityReportFilters_SinceStartDate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SinceStartDate != nil {
		{
			size, err := m.SinceStartDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ReportSchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportSchedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportSchedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Interval != nil {
		{
			size := m.Interval.Size()
			i -= size
			if _, err := m.Interval.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Minute != 0 {
		i = encodeVarintReportService(dAtA, i, uint64(m.Minute))
		i--
		dAtA[i] = 0x18
	}
	if m.Hour != 0 {
		i = encodeVarintReportService(dAtA, i, uint64(m.Hour))
		i--
		dAtA[i] = 0x10
	}
	if m.IntervalType != 0 {
		i = encodeVarintReportService(dAtA, i, uint64(m.IntervalType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReportSchedule_DaysOfWeek_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportSchedule_DaysOfWeek_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaysOfWeek != nil {
		{
			size, err := m.DaysOfWeek.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ReportSchedule_DaysOfMonth_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportSchedule_DaysOfMonth_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DaysOfMonth != nil {
		{
			size, err := m.DaysOfMonth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ReportSchedule_DaysOfWeek) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportSchedule_DaysOfWeek) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportSchedule_DaysOfWeek) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Days) > 0 {
		dAtA12 := make([]byte, len(m.Days)*10)
		var j11 int
		for _, num1 := range m.Days {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintReportService(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportSchedule_DaysOfMonth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportSchedule_DaysOfMonth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportSchedule_DaysOfMonth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Days) > 0 {
		dAtA14 := make([]byte, len(m.Days)*10)
		var j13 int
		for _, num1 := range m.Days {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintReportService(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceScope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceScope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceScope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ScopeReference != nil {
		{
			size := m.ScopeReference.Size()
			i -= size
			if _, err := m.ScopeReference.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResourceScope_CollectionScope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceScope_CollectionScope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CollectionScope != nil {
		{
			size, err := m.CollectionScope.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CollectionReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CollectionId) > 0 {
		i -= len(m.CollectionId)
		copy(dAtA[i:], m.CollectionId)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.CollectionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NotifierConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotifierConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotifierConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NotifierName) > 0 {
		i -= len(m.NotifierName)
		copy(dAtA[i:], m.NotifierName)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.NotifierName)))
		i--
		dAtA[i] = 0x12
	}
	if m.NotifierConfig != nil {
		{
			size := m.NotifierConfig.Size()
			i -= size
			if _, err := m.NotifierConfig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *NotifierConfiguration_EmailConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotifierConfiguration_EmailConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EmailConfig != nil {
		{
			size, err := m.EmailConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *EmailNotifierConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmailNotifierConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmailNotifierConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MailingLists) > 0 {
		for iNdEx := len(m.MailingLists) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MailingLists[iNdEx])
			copy(dAtA[i:], m.MailingLists[iNdEx])
			i = encodeVarintReportService(dAtA, i, uint64(len(m.MailingLists[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NotifierId) > 0 {
		i -= len(m.NotifierId)
		copy(dAtA[i:], m.NotifierId)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.NotifierId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListReportConfigurationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListReportConfigurationsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListReportConfigurationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ReportConfigs) > 0 {
		for iNdEx := len(m.ReportConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReportConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReportService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CountReportConfigurationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountReportConfigurationsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CountReportConfigurationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintReportService(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetReportHistoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetReportHistoryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetReportHistoryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReportParamQuery != nil {
		{
			size, err := m.ReportParamQuery.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportHistoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportHistoryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportHistoryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ReportSnapshots) > 0 {
		for iNdEx := len(m.ReportSnapshots) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReportSnapshots[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReportService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReportStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectionSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsDownloadAvailable {
		i--
		if m.IsDownloadAvailable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Notifiers) > 0 {
		for iNdEx := len(m.Notifiers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Notifiers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReportService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.ReportStatus != nil {
		{
			size, err := m.ReportStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Schedule != nil {
		{
			size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.CollectionSnapshot != nil {
		{
			size, err := m.CollectionSnapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Filter != nil {
		{
			size := m.Filter.Size()
			i -= size
			if _, err := m.Filter.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ReportJobId) > 0 {
		i -= len(m.ReportJobId)
		copy(dAtA[i:], m.ReportJobId)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.ReportJobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ReportConfigId) > 0 {
		i -= len(m.ReportConfigId)
		copy(dAtA[i:], m.ReportConfigId)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.ReportConfigId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportSnapshot_VulnReportFilters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportSnapshot_VulnReportFilters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VulnReportFilters != nil {
		{
			size, err := m.VulnReportFilters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ReportStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReportNotificationMethod != 0 {
		i = encodeVarintReportService(dAtA, i, uint64(m.ReportNotificationMethod))
		i--
		dAtA[i] = 0x28
	}
	if m.ReportRequestType != 0 {
		i = encodeVarintReportService(dAtA, i, uint64(m.ReportRequestType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ErrorMsg) > 0 {
		i -= len(m.ErrorMsg)
		copy(dAtA[i:], m.ErrorMsg)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.ErrorMsg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CompletedAt != nil {
		{
			size, err := m.CompletedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReportService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RunState != 0 {
		i = encodeVarintReportService(dAtA, i, uint64(m.RunState))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RunReportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunReportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunReportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReportNotificationMethod != 0 {
		i = encodeVarintReportService(dAtA, i, uint64(m.ReportNotificationMethod))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ReportConfigId) > 0 {
		i -= len(m.ReportConfigId)
		copy(dAtA[i:], m.ReportConfigId)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.ReportConfigId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunReportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunReportResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunReportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ReportId) > 0 {
		i -= len(m.ReportId)
		copy(dAtA[i:], m.ReportId)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.ReportId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ReportConfigId) > 0 {
		i -= len(m.ReportConfigId)
		copy(dAtA[i:], m.ReportConfigId)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.ReportConfigId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadReportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadReportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadReportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadReportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadReportResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadReportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintReportService(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintReportService(dAtA []byte, offset int, v uint64) int {
	offset -= sovReportService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ReportConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovReportService(uint64(m.Type))
	}
	if m.Filter != nil {
		n += m.Filter.Size()
	}
	if m.Schedule != nil {
		l = m.Schedule.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.ResourceScope != nil {
		l = m.ResourceScope.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	if len(m.Notifiers) > 0 {
		for _, e := range m.Notifiers {
			l = e.Size()
			n += 1 + l + sovReportService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportConfiguration_VulnReportFilters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VulnReportFilters != nil {
		l = m.VulnReportFilters.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	return n
}
func (m *VulnerabilityReportFilters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fixability != 0 {
		n += 1 + sovReportService(uint64(m.Fixability))
	}
	if len(m.Severities) > 0 {
		l = 0
		for _, e := range m.Severities {
			l += sovReportService(uint64(e))
		}
		n += 1 + sovReportService(uint64(l)) + l
	}
	if len(m.ImageTypes) > 0 {
		l = 0
		for _, e := range m.ImageTypes {
			l += sovReportService(uint64(e))
		}
		n += 1 + sovReportService(uint64(l)) + l
	}
	if m.CvesSince != nil {
		n += m.CvesSince.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VulnerabilityReportFilters_AllVuln) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *VulnerabilityReportFilters_SinceLastSentScheduledReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *VulnerabilityReportFilters_SinceStartDate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SinceStartDate != nil {
		l = m.SinceStartDate.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	return n
}
func (m *ReportSchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IntervalType != 0 {
		n += 1 + sovReportService(uint64(m.IntervalType))
	}
	if m.Hour != 0 {
		n += 1 + sovReportService(uint64(m.Hour))
	}
	if m.Minute != 0 {
		n += 1 + sovReportService(uint64(m.Minute))
	}
	if m.Interval != nil {
		n += m.Interval.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportSchedule_DaysOfWeek_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaysOfWeek != nil {
		l = m.DaysOfWeek.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	return n
}
func (m *ReportSchedule_DaysOfMonth_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DaysOfMonth != nil {
		l = m.DaysOfMonth.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	return n
}
func (m *ReportSchedule_DaysOfWeek) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Days) > 0 {
		l = 0
		for _, e := range m.Days {
			l += sovReportService(uint64(e))
		}
		n += 1 + sovReportService(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportSchedule_DaysOfMonth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Days) > 0 {
		l = 0
		for _, e := range m.Days {
			l += sovReportService(uint64(e))
		}
		n += 1 + sovReportService(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceScope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScopeReference != nil {
		n += m.ScopeReference.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceScope_CollectionScope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CollectionScope != nil {
		l = m.CollectionScope.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	return n
}
func (m *CollectionReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionId)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NotifierConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NotifierConfig != nil {
		n += m.NotifierConfig.Size()
	}
	l = len(m.NotifierName)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NotifierConfiguration_EmailConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EmailConfig != nil {
		l = m.EmailConfig.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	return n
}
func (m *EmailNotifierConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NotifierId)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	if len(m.MailingLists) > 0 {
		for _, s := range m.MailingLists {
			l = len(s)
			n += 1 + l + sovReportService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListReportConfigurationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ReportConfigs) > 0 {
		for _, e := range m.ReportConfigs {
			l = e.Size()
			n += 1 + l + sovReportService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CountReportConfigurationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovReportService(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetReportHistoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.ReportParamQuery != nil {
		l = m.ReportParamQuery.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportHistoryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ReportSnapshots) > 0 {
		for _, e := range m.ReportSnapshots {
			l = e.Size()
			n += 1 + l + sovReportService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectionSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReportConfigId)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	l = len(m.ReportJobId)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.Filter != nil {
		n += m.Filter.Size()
	}
	if m.CollectionSnapshot != nil {
		l = m.CollectionSnapshot.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.Schedule != nil {
		l = m.Schedule.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.ReportStatus != nil {
		l = m.ReportStatus.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	if len(m.Notifiers) > 0 {
		for _, e := range m.Notifiers {
			l = e.Size()
			n += 1 + l + sovReportService(uint64(l))
		}
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.IsDownloadAvailable {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportSnapshot_VulnReportFilters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VulnReportFilters != nil {
		l = m.VulnReportFilters.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	return n
}
func (m *ReportStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RunState != 0 {
		n += 1 + sovReportService(uint64(m.RunState))
	}
	if m.CompletedAt != nil {
		l = m.CompletedAt.Size()
		n += 1 + l + sovReportService(uint64(l))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.ReportRequestType != 0 {
		n += 1 + sovReportService(uint64(m.ReportRequestType))
	}
	if m.ReportNotificationMethod != 0 {
		n += 1 + sovReportService(uint64(m.ReportNotificationMethod))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunReportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReportConfigId)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.ReportNotificationMethod != 0 {
		n += 1 + sovReportService(uint64(m.ReportNotificationMethod))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunReportResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReportConfigId)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	l = len(m.ReportId)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadReportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadReportResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovReportService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovReportService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozReportService(x uint64) (n int) {
	return sovReportService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReportConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ReportConfiguration_ReportType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VulnReportFilters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VulnerabilityReportFilters{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Filter = &ReportConfiguration_VulnReportFilters{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schedule == nil {
				m.Schedule = &ReportSchedule{}
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceScope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceScope == nil {
				m.ResourceScope = &ResourceScope{}
			}
			if err := m.ResourceScope.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notifiers = append(m.Notifiers, &NotifierConfiguration{})
			if err := m.Notifiers[len(m.Notifiers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VulnerabilityReportFilters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VulnerabilityReportFilters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VulnerabilityReportFilters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixability", wireType)
			}
			m.Fixability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fixability |= VulnerabilityReportFilters_Fixability(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v VulnerabilityReportFilters_VulnerabilitySeverity
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReportService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= VulnerabilityReportFilters_VulnerabilitySeverity(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Severities = append(m.Severities, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReportService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthReportService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthReportService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Severities) == 0 {
					m.Severities = make([]VulnerabilityReportFilters_VulnerabilitySeverity, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v VulnerabilityReportFilters_VulnerabilitySeverity
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReportService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= VulnerabilityReportFilters_VulnerabilitySeverity(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Severities = append(m.Severities, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Severities", wireType)
			}
		case 3:
			if wireType == 0 {
				var v VulnerabilityReportFilters_ImageType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReportService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= VulnerabilityReportFilters_ImageType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ImageTypes = append(m.ImageTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReportService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthReportService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthReportService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ImageTypes) == 0 {
					m.ImageTypes = make([]VulnerabilityReportFilters_ImageType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v VulnerabilityReportFilters_ImageType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReportService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= VulnerabilityReportFilters_ImageType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ImageTypes = append(m.ImageTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageTypes", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllVuln", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CvesSince = &VulnerabilityReportFilters_AllVuln{b}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinceLastSentScheduledReport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CvesSince = &VulnerabilityReportFilters_SinceLastSentScheduledReport{b}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinceStartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Timestamp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CvesSince = &VulnerabilityReportFilters_SinceStartDate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportSchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportSchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportSchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalType", wireType)
			}
			m.IntervalType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalType |= ReportSchedule_IntervalType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hour", wireType)
			}
			m.Hour = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hour |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minute", wireType)
			}
			m.Minute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minute |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaysOfWeek", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReportSchedule_DaysOfWeek{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Interval = &ReportSchedule_DaysOfWeek_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaysOfMonth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReportSchedule_DaysOfMonth{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Interval = &ReportSchedule_DaysOfMonth_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportSchedule_DaysOfWeek) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaysOfWeek: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaysOfWeek: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReportService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Days = append(m.Days, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReportService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthReportService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthReportService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Days) == 0 {
					m.Days = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReportService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Days = append(m.Days, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Days", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportSchedule_DaysOfMonth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaysOfMonth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaysOfMonth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReportService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Days = append(m.Days, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReportService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthReportService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthReportService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Days) == 0 {
					m.Days = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReportService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Days = append(m.Days, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Days", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceScope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceScope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceScope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionScope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CollectionReference{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ScopeReference = &ResourceScope_CollectionScope{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotifierConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotifierConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotifierConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EmailNotifierConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NotifierConfig = &NotifierConfiguration_EmailConfig{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotifierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmailNotifierConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailNotifierConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailNotifierConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifierId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotifierId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailingLists", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailingLists = append(m.MailingLists, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListReportConfigurationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListReportConfigurationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListReportConfigurationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportConfigs = append(m.ReportConfigs, &ReportConfiguration{})
			if err := m.ReportConfigs[len(m.ReportConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountReportConfigurationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountReportConfigurationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountReportConfigurationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetReportHistoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetReportHistoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetReportHistoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportParamQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportParamQuery == nil {
				m.ReportParamQuery = &RawQuery{}
			}
			if err := m.ReportParamQuery.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportHistoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportHistoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportHistoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportSnapshots", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportSnapshots = append(m.ReportSnapshots, &ReportSnapshot{})
			if err := m.ReportSnapshots[len(m.ReportSnapshots)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ReportStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportConfigId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportConfigId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportJobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportJobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VulnReportFilters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VulnerabilityReportFilters{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Filter = &ReportSnapshot_VulnReportFilters{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionSnapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionSnapshot == nil {
				m.CollectionSnapshot = &CollectionSnapshot{}
			}
			if err := m.CollectionSnapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schedule == nil {
				m.Schedule = &ReportSchedule{}
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportStatus == nil {
				m.ReportStatus = &ReportStatus{}
			}
			if err := m.ReportStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notifiers = append(m.Notifiers, &NotifierConfiguration{})
			if err := m.Notifiers[len(m.Notifiers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &SlimUser{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDownloadAvailable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDownloadAvailable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunState", wireType)
			}
			m.RunState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunState |= ReportStatus_RunState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletedAt == nil {
				m.CompletedAt = &types.Timestamp{}
			}
			if err := m.CompletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportRequestType", wireType)
			}
			m.ReportRequestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportRequestType |= ReportStatus_ReportMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportNotificationMethod", wireType)
			}
			m.ReportNotificationMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportNotificationMethod |= NotificationMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunReportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunReportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunReportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportConfigId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportConfigId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportNotificationMethod", wireType)
			}
			m.ReportNotificationMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportNotificationMethod |= NotificationMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunReportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunReportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunReportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportConfigId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportConfigId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadReportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadReportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadReportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadReportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadReportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadReportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthReportService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthReportService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReportService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReportService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipReportService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowReportService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReportService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthReportService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupReportService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthReportService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthReportService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowReportService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupReportService = fmt.Errorf("proto: unexpected end of group")
)
