// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/v1/compliance_service.proto

package v1

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	storage "github.com/stackrox/rox/generated/storage"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ComplianceStandardMetadata_Scope int32

const (
	ComplianceStandardMetadata_UNSET      ComplianceStandardMetadata_Scope = 0
	ComplianceStandardMetadata_CLUSTER    ComplianceStandardMetadata_Scope = 1
	ComplianceStandardMetadata_NAMESPACE  ComplianceStandardMetadata_Scope = 2
	ComplianceStandardMetadata_DEPLOYMENT ComplianceStandardMetadata_Scope = 3
	ComplianceStandardMetadata_NODE       ComplianceStandardMetadata_Scope = 4
)

var ComplianceStandardMetadata_Scope_name = map[int32]string{
	0: "UNSET",
	1: "CLUSTER",
	2: "NAMESPACE",
	3: "DEPLOYMENT",
	4: "NODE",
}

var ComplianceStandardMetadata_Scope_value = map[string]int32{
	"UNSET":      0,
	"CLUSTER":    1,
	"NAMESPACE":  2,
	"DEPLOYMENT": 3,
	"NODE":       4,
}

func (x ComplianceStandardMetadata_Scope) String() string {
	return proto.EnumName(ComplianceStandardMetadata_Scope_name, int32(x))
}

func (ComplianceStandardMetadata_Scope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{1, 0}
}

// Next available tag: 4
type ComplianceAggregationRequest struct {
	GroupBy              []storage.ComplianceAggregation_Scope `protobuf:"varint,1,rep,packed,name=group_by,json=groupBy,proto3,enum=storage.ComplianceAggregation_Scope" json:"group_by,omitempty"`
	Unit                 storage.ComplianceAggregation_Scope   `protobuf:"varint,2,opt,name=unit,proto3,enum=storage.ComplianceAggregation_Scope" json:"unit,omitempty"`
	Where                *RawQuery                             `protobuf:"bytes,3,opt,name=where,proto3" json:"where,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *ComplianceAggregationRequest) Reset()         { *m = ComplianceAggregationRequest{} }
func (m *ComplianceAggregationRequest) String() string { return proto.CompactTextString(m) }
func (*ComplianceAggregationRequest) ProtoMessage()    {}
func (*ComplianceAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{0}
}
func (m *ComplianceAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceAggregationRequest.Merge(m, src)
}
func (m *ComplianceAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceAggregationRequest proto.InternalMessageInfo

func (m *ComplianceAggregationRequest) GetGroupBy() []storage.ComplianceAggregation_Scope {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *ComplianceAggregationRequest) GetUnit() storage.ComplianceAggregation_Scope {
	if m != nil {
		return m.Unit
	}
	return storage.ComplianceAggregation_UNKNOWN
}

func (m *ComplianceAggregationRequest) GetWhere() *RawQuery {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *ComplianceAggregationRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceAggregationRequest) Clone() *ComplianceAggregationRequest {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceAggregationRequest)
	*cloned = *m

	if m.GroupBy != nil {
		cloned.GroupBy = make([]storage.ComplianceAggregation_Scope, len(m.GroupBy))
		copy(cloned.GroupBy, m.GroupBy)
	}
	cloned.Where = m.Where.Clone()
	return cloned
}

type ComplianceStandardMetadata struct {
	Id                   string                             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Standard ID,hidden"`
	Name                 string                             `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" search:"Standard,store,hidden"`
	Description          string                             `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	NumImplementedChecks int32                              `protobuf:"varint,4,opt,name=num_implemented_checks,json=numImplementedChecks,proto3" json:"num_implemented_checks,omitempty"`
	Scopes               []ComplianceStandardMetadata_Scope `protobuf:"varint,5,rep,packed,name=scopes,proto3,enum=v1.ComplianceStandardMetadata_Scope" json:"scopes,omitempty"`
	Dynamic              bool                               `protobuf:"varint,6,opt,name=dynamic,proto3" json:"dynamic,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *ComplianceStandardMetadata) Reset()         { *m = ComplianceStandardMetadata{} }
func (m *ComplianceStandardMetadata) String() string { return proto.CompactTextString(m) }
func (*ComplianceStandardMetadata) ProtoMessage()    {}
func (*ComplianceStandardMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{1}
}
func (m *ComplianceStandardMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceStandardMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceStandardMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceStandardMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceStandardMetadata.Merge(m, src)
}
func (m *ComplianceStandardMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceStandardMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceStandardMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceStandardMetadata proto.InternalMessageInfo

func (m *ComplianceStandardMetadata) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ComplianceStandardMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ComplianceStandardMetadata) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ComplianceStandardMetadata) GetNumImplementedChecks() int32 {
	if m != nil {
		return m.NumImplementedChecks
	}
	return 0
}

func (m *ComplianceStandardMetadata) GetScopes() []ComplianceStandardMetadata_Scope {
	if m != nil {
		return m.Scopes
	}
	return nil
}

func (m *ComplianceStandardMetadata) GetDynamic() bool {
	if m != nil {
		return m.Dynamic
	}
	return false
}

func (m *ComplianceStandardMetadata) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceStandardMetadata) Clone() *ComplianceStandardMetadata {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceStandardMetadata)
	*cloned = *m

	if m.Scopes != nil {
		cloned.Scopes = make([]ComplianceStandardMetadata_Scope, len(m.Scopes))
		copy(cloned.Scopes, m.Scopes)
	}
	return cloned
}

type ComplianceControlGroup struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Control Group ID"`
	StandardId           string   `protobuf:"bytes,2,opt,name=standard_id,json=standardId,proto3" json:"standard_id,omitempty" search:"Standard ID,store"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" search:"Control Group,store"`
	Description          string   `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	NumImplementedChecks int32    `protobuf:"varint,5,opt,name=num_implemented_checks,json=numImplementedChecks,proto3" json:"num_implemented_checks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ComplianceControlGroup) Reset()         { *m = ComplianceControlGroup{} }
func (m *ComplianceControlGroup) String() string { return proto.CompactTextString(m) }
func (*ComplianceControlGroup) ProtoMessage()    {}
func (*ComplianceControlGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{2}
}
func (m *ComplianceControlGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceControlGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceControlGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceControlGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceControlGroup.Merge(m, src)
}
func (m *ComplianceControlGroup) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceControlGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceControlGroup.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceControlGroup proto.InternalMessageInfo

func (m *ComplianceControlGroup) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ComplianceControlGroup) GetStandardId() string {
	if m != nil {
		return m.StandardId
	}
	return ""
}

func (m *ComplianceControlGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ComplianceControlGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ComplianceControlGroup) GetNumImplementedChecks() int32 {
	if m != nil {
		return m.NumImplementedChecks
	}
	return 0
}

func (m *ComplianceControlGroup) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceControlGroup) Clone() *ComplianceControlGroup {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceControlGroup)
	*cloned = *m

	return cloned
}

type ComplianceControl struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Control ID,hidden"`
	StandardId           string   `protobuf:"bytes,2,opt,name=standard_id,json=standardId,proto3" json:"standard_id,omitempty" search:"Standard ID,hidden"`
	GroupId              string   `protobuf:"bytes,3,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty" search:"Control Group ID,hidden"`
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty" search:"Control,store"`
	Description          string   `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Implemented          bool     `protobuf:"varint,6,opt,name=implemented,proto3" json:"implemented,omitempty"`
	InterpretationText   string   `protobuf:"bytes,7,opt,name=interpretation_text,json=interpretationText,proto3" json:"interpretation_text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ComplianceControl) Reset()         { *m = ComplianceControl{} }
func (m *ComplianceControl) String() string { return proto.CompactTextString(m) }
func (*ComplianceControl) ProtoMessage()    {}
func (*ComplianceControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{3}
}
func (m *ComplianceControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceControl.Merge(m, src)
}
func (m *ComplianceControl) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceControl) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceControl.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceControl proto.InternalMessageInfo

func (m *ComplianceControl) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ComplianceControl) GetStandardId() string {
	if m != nil {
		return m.StandardId
	}
	return ""
}

func (m *ComplianceControl) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *ComplianceControl) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ComplianceControl) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ComplianceControl) GetImplemented() bool {
	if m != nil {
		return m.Implemented
	}
	return false
}

func (m *ComplianceControl) GetInterpretationText() string {
	if m != nil {
		return m.InterpretationText
	}
	return ""
}

func (m *ComplianceControl) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceControl) Clone() *ComplianceControl {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceControl)
	*cloned = *m

	return cloned
}

type ComplianceStandard struct {
	Metadata             *ComplianceStandardMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Groups               []*ComplianceControlGroup   `protobuf:"bytes,2,rep,name=groups,proto3" json:"groups,omitempty" search:"-"`
	Controls             []*ComplianceControl        `protobuf:"bytes,3,rep,name=controls,proto3" json:"controls,omitempty" search:"-"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ComplianceStandard) Reset()         { *m = ComplianceStandard{} }
func (m *ComplianceStandard) String() string { return proto.CompactTextString(m) }
func (*ComplianceStandard) ProtoMessage()    {}
func (*ComplianceStandard) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{4}
}
func (m *ComplianceStandard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceStandard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceStandard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceStandard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceStandard.Merge(m, src)
}
func (m *ComplianceStandard) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceStandard) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceStandard.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceStandard proto.InternalMessageInfo

func (m *ComplianceStandard) GetMetadata() *ComplianceStandardMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ComplianceStandard) GetGroups() []*ComplianceControlGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ComplianceStandard) GetControls() []*ComplianceControl {
	if m != nil {
		return m.Controls
	}
	return nil
}

func (m *ComplianceStandard) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceStandard) Clone() *ComplianceStandard {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceStandard)
	*cloned = *m

	cloned.Metadata = m.Metadata.Clone()
	if m.Groups != nil {
		cloned.Groups = make([]*ComplianceControlGroup, len(m.Groups))
		for idx, v := range m.Groups {
			cloned.Groups[idx] = v.Clone()
		}
	}
	if m.Controls != nil {
		cloned.Controls = make([]*ComplianceControl, len(m.Controls))
		for idx, v := range m.Controls {
			cloned.Controls[idx] = v.Clone()
		}
	}
	return cloned
}

type GetComplianceStandardResponse struct {
	Standard             *ComplianceStandard `protobuf:"bytes,1,opt,name=standard,proto3" json:"standard,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetComplianceStandardResponse) Reset()         { *m = GetComplianceStandardResponse{} }
func (m *GetComplianceStandardResponse) String() string { return proto.CompactTextString(m) }
func (*GetComplianceStandardResponse) ProtoMessage()    {}
func (*GetComplianceStandardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{5}
}
func (m *GetComplianceStandardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetComplianceStandardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetComplianceStandardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetComplianceStandardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetComplianceStandardResponse.Merge(m, src)
}
func (m *GetComplianceStandardResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetComplianceStandardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetComplianceStandardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetComplianceStandardResponse proto.InternalMessageInfo

func (m *GetComplianceStandardResponse) GetStandard() *ComplianceStandard {
	if m != nil {
		return m.Standard
	}
	return nil
}

func (m *GetComplianceStandardResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetComplianceStandardResponse) Clone() *GetComplianceStandardResponse {
	if m == nil {
		return nil
	}
	cloned := new(GetComplianceStandardResponse)
	*cloned = *m

	cloned.Standard = m.Standard.Clone()
	return cloned
}

type GetComplianceStandardsResponse struct {
	Standards            []*ComplianceStandardMetadata `protobuf:"bytes,1,rep,name=standards,proto3" json:"standards,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *GetComplianceStandardsResponse) Reset()         { *m = GetComplianceStandardsResponse{} }
func (m *GetComplianceStandardsResponse) String() string { return proto.CompactTextString(m) }
func (*GetComplianceStandardsResponse) ProtoMessage()    {}
func (*GetComplianceStandardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{6}
}
func (m *GetComplianceStandardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetComplianceStandardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetComplianceStandardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetComplianceStandardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetComplianceStandardsResponse.Merge(m, src)
}
func (m *GetComplianceStandardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetComplianceStandardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetComplianceStandardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetComplianceStandardsResponse proto.InternalMessageInfo

func (m *GetComplianceStandardsResponse) GetStandards() []*ComplianceStandardMetadata {
	if m != nil {
		return m.Standards
	}
	return nil
}

func (m *GetComplianceStandardsResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetComplianceStandardsResponse) Clone() *GetComplianceStandardsResponse {
	if m == nil {
		return nil
	}
	cloned := new(GetComplianceStandardsResponse)
	*cloned = *m

	if m.Standards != nil {
		cloned.Standards = make([]*ComplianceStandardMetadata, len(m.Standards))
		for idx, v := range m.Standards {
			cloned.Standards[idx] = v.Clone()
		}
	}
	return cloned
}

type GetComplianceRunResultsRequest struct {
	ClusterId  string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	StandardId string `protobuf:"bytes,2,opt,name=standard_id,json=standardId,proto3" json:"standard_id,omitempty"`
	// Specifies the run ID for which to return results. If empty, the most recent run is returned.
	// CAVEAT: Setting this field circumvents the results cache on the server-side, which may lead to significantly
	//         increased memory pressure and decreased performance.
	RunId                string   `protobuf:"bytes,3,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetComplianceRunResultsRequest) Reset()         { *m = GetComplianceRunResultsRequest{} }
func (m *GetComplianceRunResultsRequest) String() string { return proto.CompactTextString(m) }
func (*GetComplianceRunResultsRequest) ProtoMessage()    {}
func (*GetComplianceRunResultsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{7}
}
func (m *GetComplianceRunResultsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetComplianceRunResultsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetComplianceRunResultsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetComplianceRunResultsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetComplianceRunResultsRequest.Merge(m, src)
}
func (m *GetComplianceRunResultsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetComplianceRunResultsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetComplianceRunResultsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetComplianceRunResultsRequest proto.InternalMessageInfo

func (m *GetComplianceRunResultsRequest) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *GetComplianceRunResultsRequest) GetStandardId() string {
	if m != nil {
		return m.StandardId
	}
	return ""
}

func (m *GetComplianceRunResultsRequest) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *GetComplianceRunResultsRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetComplianceRunResultsRequest) Clone() *GetComplianceRunResultsRequest {
	if m == nil {
		return nil
	}
	cloned := new(GetComplianceRunResultsRequest)
	*cloned = *m

	return cloned
}

type GetComplianceRunResultsResponse struct {
	Results              *storage.ComplianceRunResults    `protobuf:"bytes,1,opt,name=results,proto3" json:"results,omitempty"`
	FailedRuns           []*storage.ComplianceRunMetadata `protobuf:"bytes,2,rep,name=failed_runs,json=failedRuns,proto3" json:"failed_runs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *GetComplianceRunResultsResponse) Reset()         { *m = GetComplianceRunResultsResponse{} }
func (m *GetComplianceRunResultsResponse) String() string { return proto.CompactTextString(m) }
func (*GetComplianceRunResultsResponse) ProtoMessage()    {}
func (*GetComplianceRunResultsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{8}
}
func (m *GetComplianceRunResultsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetComplianceRunResultsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetComplianceRunResultsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetComplianceRunResultsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetComplianceRunResultsResponse.Merge(m, src)
}
func (m *GetComplianceRunResultsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetComplianceRunResultsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetComplianceRunResultsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetComplianceRunResultsResponse proto.InternalMessageInfo

func (m *GetComplianceRunResultsResponse) GetResults() *storage.ComplianceRunResults {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *GetComplianceRunResultsResponse) GetFailedRuns() []*storage.ComplianceRunMetadata {
	if m != nil {
		return m.FailedRuns
	}
	return nil
}

func (m *GetComplianceRunResultsResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetComplianceRunResultsResponse) Clone() *GetComplianceRunResultsResponse {
	if m == nil {
		return nil
	}
	cloned := new(GetComplianceRunResultsResponse)
	*cloned = *m

	cloned.Results = m.Results.Clone()
	if m.FailedRuns != nil {
		cloned.FailedRuns = make([]*storage.ComplianceRunMetadata, len(m.FailedRuns))
		for idx, v := range m.FailedRuns {
			cloned.FailedRuns[idx] = v.Clone()
		}
	}
	return cloned
}

func init() {
	proto.RegisterEnum("v1.ComplianceStandardMetadata_Scope", ComplianceStandardMetadata_Scope_name, ComplianceStandardMetadata_Scope_value)
	proto.RegisterType((*ComplianceAggregationRequest)(nil), "v1.ComplianceAggregationRequest")
	proto.RegisterType((*ComplianceStandardMetadata)(nil), "v1.ComplianceStandardMetadata")
	proto.RegisterType((*ComplianceControlGroup)(nil), "v1.ComplianceControlGroup")
	proto.RegisterType((*ComplianceControl)(nil), "v1.ComplianceControl")
	proto.RegisterType((*ComplianceStandard)(nil), "v1.ComplianceStandard")
	proto.RegisterType((*GetComplianceStandardResponse)(nil), "v1.GetComplianceStandardResponse")
	proto.RegisterType((*GetComplianceStandardsResponse)(nil), "v1.GetComplianceStandardsResponse")
	proto.RegisterType((*GetComplianceRunResultsRequest)(nil), "v1.GetComplianceRunResultsRequest")
	proto.RegisterType((*GetComplianceRunResultsResponse)(nil), "v1.GetComplianceRunResultsResponse")
}

func init() { proto.RegisterFile("api/v1/compliance_service.proto", fileDescriptor_99d119a672c13dfb) }

var fileDescriptor_99d119a672c13dfb = []byte{
	// 1093 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcf, 0x8f, 0xdb, 0x44,
	0x14, 0xae, 0xf3, 0x63, 0x37, 0x79, 0x69, 0xab, 0x30, 0x6d, 0x57, 0xae, 0x77, 0x37, 0x76, 0x4d,
	0x11, 0x39, 0xb4, 0x8e, 0x12, 0x2a, 0x40, 0x55, 0xa5, 0xb2, 0xd9, 0x8d, 0x96, 0x48, 0xdd, 0x6d,
	0x71, 0xb6, 0x12, 0x70, 0x20, 0x72, 0xed, 0x21, 0x6b, 0x35, 0x19, 0x07, 0xcf, 0x38, 0xbb, 0x51,
	0xc5, 0x85, 0x2b, 0x47, 0x24, 0x84, 0xc4, 0xdf, 0xc2, 0x9d, 0x23, 0x12, 0x07, 0x6e, 0x11, 0x5a,
	0x38, 0xc1, 0x2d, 0xff, 0x00, 0x28, 0xe3, 0xb1, 0xe3, 0x24, 0xce, 0x2e, 0xdc, 0xec, 0x37, 0xef,
	0x7b, 0xef, 0x7b, 0xdf, 0x7b, 0xf3, 0x03, 0x54, 0x6b, 0xe8, 0xd6, 0x46, 0xf5, 0x9a, 0xed, 0x0d,
	0x86, 0x7d, 0xd7, 0x22, 0x36, 0xee, 0x52, 0xec, 0x8f, 0x5c, 0x1b, 0x1b, 0x43, 0xdf, 0x63, 0x1e,
	0xca, 0x8c, 0xea, 0xca, 0x4e, 0xcf, 0xf3, 0x7a, 0x7d, 0x5c, 0x9b, 0xf9, 0x5a, 0x84, 0x78, 0xcc,
	0x62, 0xae, 0x47, 0x68, 0xe8, 0xa1, 0xdc, 0xee, 0x79, 0x3d, 0x8f, 0x7f, 0xd6, 0x66, 0x5f, 0xc2,
	0x2a, 0x53, 0xe6, 0xf9, 0x56, 0x0f, 0x27, 0x22, 0x8b, 0x95, 0x6d, 0x91, 0x92, 0x62, 0xcb, 0xb7,
	0x4f, 0x17, 0xd3, 0x29, 0xb7, 0xe6, 0x7c, 0x06, 0x1e, 0x11, 0x46, 0x24, 0x8c, 0x78, 0x30, 0x64,
	0xe3, 0xd0, 0xa6, 0xff, 0x24, 0xc1, 0xce, 0x7e, 0x1c, 0x7a, 0xaf, 0xd7, 0xf3, 0x71, 0x8f, 0xd3,
	0x32, 0xf1, 0x57, 0x01, 0xa6, 0x0c, 0x3d, 0x85, 0x42, 0xcf, 0xf7, 0x82, 0x61, 0xf7, 0xd5, 0x58,
	0x96, 0xb4, 0x6c, 0xf5, 0x66, 0xe3, 0xbe, 0x21, 0x38, 0x19, 0xa9, 0x40, 0xa3, 0x63, 0x7b, 0x43,
	0x6c, 0x6e, 0x72, 0x54, 0x73, 0x8c, 0x3e, 0x84, 0x5c, 0x40, 0x5c, 0x26, 0x67, 0x34, 0xe9, 0x3f,
	0x83, 0x39, 0x02, 0xe9, 0x90, 0x3f, 0x3b, 0xc5, 0x3e, 0x96, 0xb3, 0x9a, 0x54, 0x2d, 0x35, 0xae,
	0x1b, 0xa3, 0xba, 0x61, 0x5a, 0x67, 0x9f, 0x04, 0xd8, 0x1f, 0x9b, 0xe1, 0x92, 0xfe, 0x4f, 0x06,
	0x94, 0x79, 0xa4, 0x0e, 0xb3, 0x88, 0x63, 0xf9, 0xce, 0x11, 0x66, 0x96, 0x63, 0x31, 0x0b, 0xd5,
	0x20, 0xe3, 0x3a, 0xb2, 0xa4, 0x49, 0xd5, 0x62, 0x53, 0x9d, 0x4e, 0xd4, 0xed, 0x50, 0xad, 0xc7,
	0x7a, 0xe4, 0xa9, 0xb5, 0x0f, 0x1e, 0x9c, 0xba, 0x8e, 0x83, 0x89, 0x6e, 0x66, 0x5c, 0x07, 0xbd,
	0x0f, 0x39, 0x62, 0x0d, 0x30, 0x67, 0x5b, 0x6c, 0xea, 0xd3, 0x89, 0x5a, 0x59, 0x86, 0x3c, 0x98,
	0x55, 0x80, 0x63, 0x14, 0xf7, 0x47, 0x1a, 0x94, 0x1c, 0x4c, 0x6d, 0xdf, 0x1d, 0xce, 0xca, 0xe0,
	0x8c, 0x8b, 0x66, 0xd2, 0x84, 0x1e, 0xc1, 0x16, 0x09, 0x06, 0x5d, 0x77, 0x30, 0xec, 0xe3, 0x01,
	0x26, 0x0c, 0x3b, 0x5d, 0xfb, 0x14, 0xdb, 0xaf, 0xa9, 0x9c, 0xd3, 0xa4, 0x6a, 0xde, 0xbc, 0x4d,
	0x82, 0x41, 0x7b, 0xbe, 0xb8, 0xcf, 0xd7, 0xd0, 0x13, 0xd8, 0xa0, 0x33, 0x49, 0xa8, 0x9c, 0x17,
	0xe2, 0x8f, 0xea, 0xc6, 0xfa, 0x82, 0x85, 0x7e, 0x02, 0x83, 0x64, 0xd8, 0x74, 0xc6, 0xc4, 0x1a,
	0xb8, 0xb6, 0xbc, 0xa1, 0x49, 0xd5, 0x82, 0x19, 0xfd, 0xea, 0x1f, 0x43, 0x9e, 0xbb, 0xa2, 0x22,
	0xe4, 0x5f, 0x1e, 0x77, 0x5a, 0x27, 0xe5, 0x6b, 0xa8, 0x04, 0x9b, 0xfb, 0xcf, 0x5e, 0x76, 0x4e,
	0x5a, 0x66, 0x59, 0x42, 0x37, 0xa0, 0x78, 0xbc, 0x77, 0xd4, 0xea, 0xbc, 0xd8, 0xdb, 0x6f, 0x95,
	0x33, 0xe8, 0x26, 0xc0, 0x41, 0xeb, 0xc5, 0xb3, 0xe7, 0x9f, 0x1d, 0xb5, 0x8e, 0x4f, 0xca, 0x59,
	0x54, 0x80, 0xdc, 0xf1, 0xf3, 0x83, 0x56, 0x39, 0xa7, 0x7f, 0x9f, 0x81, 0xad, 0x39, 0xa1, 0x7d,
	0x8f, 0x30, 0xdf, 0xeb, 0x1f, 0xce, 0x9a, 0x8f, 0x1e, 0x26, 0xd4, 0xdf, 0x9d, 0x4e, 0xd4, 0xbb,
	0x91, 0x94, 0xc2, 0x4b, 0xe3, 0x6e, 0x5a, 0xfb, 0x20, 0xd4, 0xfe, 0x29, 0x94, 0xa8, 0xa8, 0xa7,
	0xeb, 0x3a, 0xa2, 0x05, 0x95, 0xe9, 0x44, 0x55, 0xd2, 0xba, 0xc6, 0xbb, 0xa0, 0x9b, 0x10, 0x41,
	0xda, 0x0e, 0x7a, 0x24, 0x9a, 0xc7, 0xd5, 0x6f, 0x6a, 0xd3, 0x89, 0xba, 0x93, 0x9a, 0x31, 0xc2,
	0xa6, 0xb6, 0x2e, 0xf7, 0x7f, 0x5a, 0x97, 0x5f, 0xdf, 0x3a, 0xfd, 0xef, 0x0c, 0xbc, 0xb5, 0x22,
	0x0c, 0x32, 0x12, 0x9a, 0x2c, 0xd4, 0x16, 0x31, 0x5c, 0x1a, 0xc8, 0x8f, 0xd2, 0x44, 0xb9, 0x72,
	0x94, 0x93, 0xaa, 0xc4, 0x3b, 0xd8, 0x75, 0x84, 0x32, 0xf7, 0xa7, 0x13, 0x55, 0x5b, 0xd7, 0x8b,
	0x38, 0x46, 0xb8, 0x83, 0xdb, 0x0e, 0x32, 0x84, 0xac, 0x5c, 0x99, 0xa6, 0x32, 0x9d, 0xa8, 0x5b,
	0x4b, 0xe0, 0x4b, 0x05, 0xcd, 0xaf, 0x0a, 0xaa, 0x41, 0x29, 0x21, 0xa6, 0x98, 0xcd, 0xa4, 0x09,
	0xd5, 0xe0, 0x96, 0x4b, 0x18, 0xf6, 0x87, 0x3e, 0x0e, 0x8f, 0xc9, 0x2e, 0xc3, 0xe7, 0x4c, 0xde,
	0xe4, 0xb1, 0xd0, 0xe2, 0xd2, 0x09, 0x3e, 0x67, 0xfa, 0x6f, 0x12, 0xa0, 0xd5, 0x7d, 0x81, 0x1e,
	0x43, 0x61, 0x20, 0xf6, 0x06, 0x17, 0xbd, 0xd4, 0xa8, 0x5c, 0xbe, 0x83, 0xcc, 0xd8, 0x1f, 0x35,
	0x61, 0x83, 0x4b, 0x40, 0xe5, 0x8c, 0x96, 0xad, 0x96, 0x1a, 0xca, 0x22, 0x32, 0x39, 0xea, 0xcd,
	0x9b, 0xd3, 0x89, 0x0a, 0x91, 0x2a, 0x0f, 0x75, 0x53, 0x20, 0xd1, 0x1e, 0x14, 0xec, 0xd0, 0x8f,
	0xca, 0x59, 0x1e, 0xe5, 0x4e, 0x6a, 0x94, 0x95, 0x00, 0x31, 0x4c, 0xef, 0xc0, 0xee, 0x21, 0x66,
	0xab, 0x8c, 0x4d, 0x4c, 0x87, 0x1e, 0xa1, 0x18, 0x35, 0xa0, 0x10, 0xb5, 0x5b, 0xd4, 0xb8, 0x95,
	0x5e, 0xa3, 0x19, 0xfb, 0xe9, 0x5f, 0x40, 0x25, 0x35, 0x28, 0x8d, 0xa3, 0x3e, 0x81, 0x62, 0xe4,
	0x4d, 0xf9, 0xc9, 0x7f, 0xb5, 0x74, 0x73, 0x80, 0x7e, 0xb6, 0x14, 0xdf, 0x0c, 0x88, 0x89, 0x69,
	0xd0, 0x67, 0x34, 0xba, 0x58, 0x76, 0x01, 0xec, 0x7e, 0x40, 0x19, 0xf6, 0xbb, 0xd1, 0x86, 0x30,
	0x8b, 0xc2, 0xd2, 0x76, 0x90, 0x9a, 0x32, 0xf7, 0x0b, 0x63, 0x7d, 0x07, 0x36, 0xfc, 0x80, 0xc4,
	0x43, 0x6d, 0xe6, 0xfd, 0x80, 0xb4, 0x1d, 0xfd, 0x47, 0x09, 0xd4, 0xb5, 0x99, 0x45, 0x69, 0x1f,
	0xc0, 0xa6, 0x1f, 0x9a, 0x84, 0x5e, 0xbb, 0x29, 0xb7, 0x52, 0x02, 0x17, 0x79, 0xcf, 0x4e, 0xa8,
	0x2f, 0x2d, 0xb7, 0x8f, 0x9d, 0xae, 0x1f, 0x90, 0x68, 0x2c, 0x2a, 0xe9, 0xe0, 0x58, 0x15, 0x08,
	0x21, 0x66, 0x40, 0x68, 0xe3, 0xaf, 0x6c, 0xf2, 0x4c, 0xe8, 0x84, 0x77, 0x36, 0xea, 0xc2, 0xf5,
	0x43, 0xcc, 0xe2, 0x16, 0xa0, 0xe2, 0x4c, 0xe7, 0xd6, 0xec, 0x96, 0x56, 0xf4, 0xd9, 0xe7, 0xe5,
	0x9d, 0xd2, 0xb5, 0x6f, 0x7e, 0xfd, 0xf3, 0xbb, 0x8c, 0x82, 0xe4, 0xc5, 0x17, 0x48, 0x2d, 0xee,
	0x06, 0x72, 0xa1, 0x94, 0x48, 0x80, 0xca, 0xfc, 0x26, 0xc5, 0xd4, 0x0b, 0x7c, 0x1b, 0x37, 0xc7,
	0xed, 0x03, 0xe5, 0xde, 0xda, 0x34, 0x71, 0x96, 0x77, 0x78, 0x16, 0x15, 0xed, 0xae, 0xcb, 0x52,
	0x7b, 0xe3, 0x3a, 0x5f, 0xa3, 0x37, 0x70, 0xe3, 0x10, 0xb3, 0xb9, 0x78, 0x68, 0xb5, 0x82, 0x95,
	0x59, 0x50, 0xde, 0xbe, 0xd4, 0x47, 0x10, 0xb8, 0xc7, 0x09, 0x6c, 0xa3, 0xbb, 0x4b, 0x04, 0xfc,
	0x80, 0x44, 0xfd, 0xf9, 0x56, 0x82, 0xdb, 0x87, 0x98, 0x45, 0x0f, 0x0a, 0xec, 0x44, 0x24, 0xb4,
	0xc5, 0xc9, 0x5d, 0x7d, 0xe7, 0x28, 0xef, 0x5e, 0xf1, 0x30, 0x89, 0x69, 0x54, 0x39, 0x0d, 0x1d,
	0x69, 0x4b, 0x34, 0xac, 0x38, 0xa9, 0x60, 0xd3, 0x34, 0x7e, 0xbe, 0xa8, 0x48, 0xbf, 0x5c, 0x54,
	0xa4, 0xdf, 0x2f, 0x2a, 0xd2, 0x0f, 0x7f, 0x54, 0xae, 0x81, 0xec, 0x7a, 0x06, 0x65, 0x96, 0xfd,
	0xda, 0xf7, 0xce, 0xc3, 0x07, 0x98, 0x61, 0x0d, 0x5d, 0x63, 0x54, 0xff, 0x3c, 0x33, 0xaa, 0x7f,
	0x7a, 0xed, 0xd5, 0x06, 0xb7, 0xbd, 0xf7, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x37, 0x26, 0x8d,
	0x23, 0x4f, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ComplianceServiceClient is the client API for ComplianceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConnInterface.NewStream.
type ComplianceServiceClient interface {
	GetStandards(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetComplianceStandardsResponse, error)
	GetStandard(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*GetComplianceStandardResponse, error)
	GetRunResults(ctx context.Context, in *GetComplianceRunResultsRequest, opts ...grpc.CallOption) (*GetComplianceRunResultsResponse, error)
	GetAggregatedResults(ctx context.Context, in *ComplianceAggregationRequest, opts ...grpc.CallOption) (*storage.ComplianceAggregation_Response, error)
}

type complianceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewComplianceServiceClient(cc grpc.ClientConnInterface) ComplianceServiceClient {
	return &complianceServiceClient{cc}
}

func (c *complianceServiceClient) GetStandards(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetComplianceStandardsResponse, error) {
	out := new(GetComplianceStandardsResponse)
	err := c.cc.Invoke(ctx, "/v1.ComplianceService/GetStandards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *complianceServiceClient) GetStandard(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*GetComplianceStandardResponse, error) {
	out := new(GetComplianceStandardResponse)
	err := c.cc.Invoke(ctx, "/v1.ComplianceService/GetStandard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *complianceServiceClient) GetRunResults(ctx context.Context, in *GetComplianceRunResultsRequest, opts ...grpc.CallOption) (*GetComplianceRunResultsResponse, error) {
	out := new(GetComplianceRunResultsResponse)
	err := c.cc.Invoke(ctx, "/v1.ComplianceService/GetRunResults", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *complianceServiceClient) GetAggregatedResults(ctx context.Context, in *ComplianceAggregationRequest, opts ...grpc.CallOption) (*storage.ComplianceAggregation_Response, error) {
	out := new(storage.ComplianceAggregation_Response)
	err := c.cc.Invoke(ctx, "/v1.ComplianceService/GetAggregatedResults", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ComplianceServiceServer is the server API for ComplianceService service.
type ComplianceServiceServer interface {
	GetStandards(context.Context, *Empty) (*GetComplianceStandardsResponse, error)
	GetStandard(context.Context, *ResourceByID) (*GetComplianceStandardResponse, error)
	GetRunResults(context.Context, *GetComplianceRunResultsRequest) (*GetComplianceRunResultsResponse, error)
	GetAggregatedResults(context.Context, *ComplianceAggregationRequest) (*storage.ComplianceAggregation_Response, error)
}

// UnimplementedComplianceServiceServer can be embedded to have forward compatible implementations.
type UnimplementedComplianceServiceServer struct {
}

func (*UnimplementedComplianceServiceServer) GetStandards(ctx context.Context, req *Empty) (*GetComplianceStandardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStandards not implemented")
}
func (*UnimplementedComplianceServiceServer) GetStandard(ctx context.Context, req *ResourceByID) (*GetComplianceStandardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStandard not implemented")
}
func (*UnimplementedComplianceServiceServer) GetRunResults(ctx context.Context, req *GetComplianceRunResultsRequest) (*GetComplianceRunResultsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRunResults not implemented")
}
func (*UnimplementedComplianceServiceServer) GetAggregatedResults(ctx context.Context, req *ComplianceAggregationRequest) (*storage.ComplianceAggregation_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAggregatedResults not implemented")
}

func RegisterComplianceServiceServer(s *grpc.Server, srv ComplianceServiceServer) {
	s.RegisterService(&_ComplianceService_serviceDesc, srv)
}

func _ComplianceService_GetStandards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComplianceServiceServer).GetStandards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.ComplianceService/GetStandards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComplianceServiceServer).GetStandards(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComplianceService_GetStandard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComplianceServiceServer).GetStandard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.ComplianceService/GetStandard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComplianceServiceServer).GetStandard(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComplianceService_GetRunResults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetComplianceRunResultsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComplianceServiceServer).GetRunResults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.ComplianceService/GetRunResults",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComplianceServiceServer).GetRunResults(ctx, req.(*GetComplianceRunResultsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComplianceService_GetAggregatedResults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComplianceAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComplianceServiceServer).GetAggregatedResults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.ComplianceService/GetAggregatedResults",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComplianceServiceServer).GetAggregatedResults(ctx, req.(*ComplianceAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ComplianceService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1.ComplianceService",
	HandlerType: (*ComplianceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStandards",
			Handler:    _ComplianceService_GetStandards_Handler,
		},
		{
			MethodName: "GetStandard",
			Handler:    _ComplianceService_GetStandard_Handler,
		},
		{
			MethodName: "GetRunResults",
			Handler:    _ComplianceService_GetRunResults_Handler,
		},
		{
			MethodName: "GetAggregatedResults",
			Handler:    _ComplianceService_GetAggregatedResults_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/compliance_service.proto",
}

func (m *ComplianceAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Unit != 0 {
		i = encodeVarintComplianceService(dAtA, i, uint64(m.Unit))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GroupBy) > 0 {
		dAtA3 := make([]byte, len(m.GroupBy)*10)
		var j2 int
		for _, num := range m.GroupBy {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintComplianceService(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceStandardMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceStandardMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceStandardMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Dynamic {
		i--
		if m.Dynamic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Scopes) > 0 {
		dAtA5 := make([]byte, len(m.Scopes)*10)
		var j4 int
		for _, num := range m.Scopes {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintComplianceService(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x2a
	}
	if m.NumImplementedChecks != 0 {
		i = encodeVarintComplianceService(dAtA, i, uint64(m.NumImplementedChecks))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceControlGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceControlGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceControlGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumImplementedChecks != 0 {
		i = encodeVarintComplianceService(dAtA, i, uint64(m.NumImplementedChecks))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StandardId) > 0 {
		i -= len(m.StandardId)
		copy(dAtA[i:], m.StandardId)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.StandardId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InterpretationText) > 0 {
		i -= len(m.InterpretationText)
		copy(dAtA[i:], m.InterpretationText)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.InterpretationText)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Implemented {
		i--
		if m.Implemented {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StandardId) > 0 {
		i -= len(m.StandardId)
		copy(dAtA[i:], m.StandardId)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.StandardId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceStandard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceStandard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceStandard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Controls) > 0 {
		for iNdEx := len(m.Controls) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Controls[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComplianceService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComplianceService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetComplianceStandardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetComplianceStandardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetComplianceStandardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Standard != nil {
		{
			size, err := m.Standard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetComplianceStandardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetComplianceStandardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetComplianceStandardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Standards) > 0 {
		for iNdEx := len(m.Standards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Standards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComplianceService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetComplianceRunResultsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetComplianceRunResultsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetComplianceRunResultsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StandardId) > 0 {
		i -= len(m.StandardId)
		copy(dAtA[i:], m.StandardId)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.StandardId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetComplianceRunResultsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetComplianceRunResultsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetComplianceRunResultsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FailedRuns) > 0 {
		for iNdEx := len(m.FailedRuns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FailedRuns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComplianceService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Results != nil {
		{
			size, err := m.Results.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintComplianceService(dAtA []byte, offset int, v uint64) int {
	offset -= sovComplianceService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ComplianceAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupBy) > 0 {
		l = 0
		for _, e := range m.GroupBy {
			l += sovComplianceService(uint64(e))
		}
		n += 1 + sovComplianceService(uint64(l)) + l
	}
	if m.Unit != 0 {
		n += 1 + sovComplianceService(uint64(m.Unit))
	}
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceStandardMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.NumImplementedChecks != 0 {
		n += 1 + sovComplianceService(uint64(m.NumImplementedChecks))
	}
	if len(m.Scopes) > 0 {
		l = 0
		for _, e := range m.Scopes {
			l += sovComplianceService(uint64(e))
		}
		n += 1 + sovComplianceService(uint64(l)) + l
	}
	if m.Dynamic {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceControlGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.StandardId)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.NumImplementedChecks != 0 {
		n += 1 + sovComplianceService(uint64(m.NumImplementedChecks))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.StandardId)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.Implemented {
		n += 2
	}
	l = len(m.InterpretationText)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceStandard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovComplianceService(uint64(l))
		}
	}
	if len(m.Controls) > 0 {
		for _, e := range m.Controls {
			l = e.Size()
			n += 1 + l + sovComplianceService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetComplianceStandardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Standard != nil {
		l = m.Standard.Size()
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetComplianceStandardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Standards) > 0 {
		for _, e := range m.Standards {
			l = e.Size()
			n += 1 + l + sovComplianceService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetComplianceRunResultsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.StandardId)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetComplianceRunResultsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Results != nil {
		l = m.Results.Size()
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if len(m.FailedRuns) > 0 {
		for _, e := range m.FailedRuns {
			l = e.Size()
			n += 1 + l + sovComplianceService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovComplianceService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozComplianceService(x uint64) (n int) {
	return sovComplianceService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ComplianceAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v storage.ComplianceAggregation_Scope
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= storage.ComplianceAggregation_Scope(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupBy = append(m.GroupBy, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthComplianceService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthComplianceService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.GroupBy) == 0 {
					m.GroupBy = make([]storage.ComplianceAggregation_Scope, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v storage.ComplianceAggregation_Scope
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= storage.ComplianceAggregation_Scope(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupBy = append(m.GroupBy, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= storage.ComplianceAggregation_Scope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &RawQuery{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceStandardMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceStandardMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceStandardMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumImplementedChecks", wireType)
			}
			m.NumImplementedChecks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumImplementedChecks |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v ComplianceStandardMetadata_Scope
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ComplianceStandardMetadata_Scope(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Scopes = append(m.Scopes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthComplianceService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthComplianceService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Scopes) == 0 {
					m.Scopes = make([]ComplianceStandardMetadata_Scope, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ComplianceStandardMetadata_Scope
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ComplianceStandardMetadata_Scope(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Scopes = append(m.Scopes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dynamic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dynamic = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceControlGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceControlGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceControlGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumImplementedChecks", wireType)
			}
			m.NumImplementedChecks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumImplementedChecks |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implemented", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Implemented = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterpretationText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterpretationText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceStandard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceStandard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceStandard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &ComplianceStandardMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &ComplianceControlGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controls = append(m.Controls, &ComplianceControl{})
			if err := m.Controls[len(m.Controls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetComplianceStandardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetComplianceStandardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetComplianceStandardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Standard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Standard == nil {
				m.Standard = &ComplianceStandard{}
			}
			if err := m.Standard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetComplianceStandardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetComplianceStandardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetComplianceStandardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Standards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Standards = append(m.Standards, &ComplianceStandardMetadata{})
			if err := m.Standards[len(m.Standards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetComplianceRunResultsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetComplianceRunResultsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetComplianceRunResultsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetComplianceRunResultsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetComplianceRunResultsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetComplianceRunResultsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Results == nil {
				m.Results = &storage.ComplianceRunResults{}
			}
			if err := m.Results.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedRuns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedRuns = append(m.FailedRuns, &storage.ComplianceRunMetadata{})
			if err := m.FailedRuns[len(m.FailedRuns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipComplianceService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthComplianceService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupComplianceService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthComplianceService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthComplianceService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowComplianceService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupComplianceService = fmt.Errorf("proto: unexpected end of group")
)
