// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/v1/compliance_service.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	storage "github.com/stackrox/rox/generated/storage"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ComplianceStandardMetadata_Scope int32

const (
	ComplianceStandardMetadata_UNSET      ComplianceStandardMetadata_Scope = 0
	ComplianceStandardMetadata_CLUSTER    ComplianceStandardMetadata_Scope = 1
	ComplianceStandardMetadata_NAMESPACE  ComplianceStandardMetadata_Scope = 2
	ComplianceStandardMetadata_DEPLOYMENT ComplianceStandardMetadata_Scope = 3
	ComplianceStandardMetadata_NODE       ComplianceStandardMetadata_Scope = 4
)

var ComplianceStandardMetadata_Scope_name = map[int32]string{
	0: "UNSET",
	1: "CLUSTER",
	2: "NAMESPACE",
	3: "DEPLOYMENT",
	4: "NODE",
}

var ComplianceStandardMetadata_Scope_value = map[string]int32{
	"UNSET":      0,
	"CLUSTER":    1,
	"NAMESPACE":  2,
	"DEPLOYMENT": 3,
	"NODE":       4,
}

func (x ComplianceStandardMetadata_Scope) String() string {
	return proto.EnumName(ComplianceStandardMetadata_Scope_name, int32(x))
}

func (ComplianceStandardMetadata_Scope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{1, 0}
}

// Next available tag: 4
type ComplianceAggregationRequest struct {
	GroupBy              []storage.ComplianceAggregation_Scope `protobuf:"varint,1,rep,packed,name=group_by,json=groupBy,proto3,enum=storage.ComplianceAggregation_Scope" json:"group_by,omitempty"`
	Unit                 storage.ComplianceAggregation_Scope   `protobuf:"varint,2,opt,name=unit,proto3,enum=storage.ComplianceAggregation_Scope" json:"unit,omitempty"`
	Where                *RawQuery                             `protobuf:"bytes,3,opt,name=where,proto3" json:"where,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *ComplianceAggregationRequest) Reset()         { *m = ComplianceAggregationRequest{} }
func (m *ComplianceAggregationRequest) String() string { return proto.CompactTextString(m) }
func (*ComplianceAggregationRequest) ProtoMessage()    {}
func (*ComplianceAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{0}
}
func (m *ComplianceAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceAggregationRequest.Merge(m, src)
}
func (m *ComplianceAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceAggregationRequest proto.InternalMessageInfo

func (m *ComplianceAggregationRequest) GetGroupBy() []storage.ComplianceAggregation_Scope {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *ComplianceAggregationRequest) GetUnit() storage.ComplianceAggregation_Scope {
	if m != nil {
		return m.Unit
	}
	return storage.ComplianceAggregation_UNKNOWN
}

func (m *ComplianceAggregationRequest) GetWhere() *RawQuery {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *ComplianceAggregationRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceAggregationRequest) Clone() *ComplianceAggregationRequest {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceAggregationRequest)
	*cloned = *m

	if m.GroupBy != nil {
		cloned.GroupBy = make([]storage.ComplianceAggregation_Scope, len(m.GroupBy))
		copy(cloned.GroupBy, m.GroupBy)
	}
	cloned.Where = m.Where.Clone()
	return cloned
}

type ComplianceStandardMetadata struct {
	Id                   string                             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Standard ID,hidden"`     // @gotags: search:"Standard ID,hidden"
	Name                 string                             `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" search:"Standard,store,hidden"` // @gotags: search:"Standard,store,hidden"
	Description          string                             `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	NumImplementedChecks int32                              `protobuf:"varint,4,opt,name=num_implemented_checks,json=numImplementedChecks,proto3" json:"num_implemented_checks,omitempty"`
	Scopes               []ComplianceStandardMetadata_Scope `protobuf:"varint,5,rep,packed,name=scopes,proto3,enum=v1.ComplianceStandardMetadata_Scope" json:"scopes,omitempty"`
	Dynamic              bool                               `protobuf:"varint,6,opt,name=dynamic,proto3" json:"dynamic,omitempty"`
	HideScanResults      bool                               `protobuf:"varint,7,opt,name=hideScanResults,proto3" json:"hideScanResults,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *ComplianceStandardMetadata) Reset()         { *m = ComplianceStandardMetadata{} }
func (m *ComplianceStandardMetadata) String() string { return proto.CompactTextString(m) }
func (*ComplianceStandardMetadata) ProtoMessage()    {}
func (*ComplianceStandardMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{1}
}
func (m *ComplianceStandardMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceStandardMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceStandardMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceStandardMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceStandardMetadata.Merge(m, src)
}
func (m *ComplianceStandardMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceStandardMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceStandardMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceStandardMetadata proto.InternalMessageInfo

func (m *ComplianceStandardMetadata) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ComplianceStandardMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ComplianceStandardMetadata) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ComplianceStandardMetadata) GetNumImplementedChecks() int32 {
	if m != nil {
		return m.NumImplementedChecks
	}
	return 0
}

func (m *ComplianceStandardMetadata) GetScopes() []ComplianceStandardMetadata_Scope {
	if m != nil {
		return m.Scopes
	}
	return nil
}

func (m *ComplianceStandardMetadata) GetDynamic() bool {
	if m != nil {
		return m.Dynamic
	}
	return false
}

func (m *ComplianceStandardMetadata) GetHideScanResults() bool {
	if m != nil {
		return m.HideScanResults
	}
	return false
}

func (m *ComplianceStandardMetadata) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceStandardMetadata) Clone() *ComplianceStandardMetadata {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceStandardMetadata)
	*cloned = *m

	if m.Scopes != nil {
		cloned.Scopes = make([]ComplianceStandardMetadata_Scope, len(m.Scopes))
		copy(cloned.Scopes, m.Scopes)
	}
	return cloned
}

type ComplianceControlGroup struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Control Group ID"`                                   // @gotags: search:"Control Group ID"
	StandardId           string   `protobuf:"bytes,2,opt,name=standard_id,json=standardId,proto3" json:"standard_id,omitempty" search:"Standard ID,store"` // @gotags: search:"Standard ID,store"
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" search:"Control Group,store"`                               // @gotags: search:"Control Group,store"
	Description          string   `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	NumImplementedChecks int32    `protobuf:"varint,5,opt,name=num_implemented_checks,json=numImplementedChecks,proto3" json:"num_implemented_checks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ComplianceControlGroup) Reset()         { *m = ComplianceControlGroup{} }
func (m *ComplianceControlGroup) String() string { return proto.CompactTextString(m) }
func (*ComplianceControlGroup) ProtoMessage()    {}
func (*ComplianceControlGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{2}
}
func (m *ComplianceControlGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceControlGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceControlGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceControlGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceControlGroup.Merge(m, src)
}
func (m *ComplianceControlGroup) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceControlGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceControlGroup.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceControlGroup proto.InternalMessageInfo

func (m *ComplianceControlGroup) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ComplianceControlGroup) GetStandardId() string {
	if m != nil {
		return m.StandardId
	}
	return ""
}

func (m *ComplianceControlGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ComplianceControlGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ComplianceControlGroup) GetNumImplementedChecks() int32 {
	if m != nil {
		return m.NumImplementedChecks
	}
	return 0
}

func (m *ComplianceControlGroup) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceControlGroup) Clone() *ComplianceControlGroup {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceControlGroup)
	*cloned = *m

	return cloned
}

type ComplianceControl struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Control ID,hidden"`                                   // @gotags: search:"Control ID,hidden"
	StandardId           string   `protobuf:"bytes,2,opt,name=standard_id,json=standardId,proto3" json:"standard_id,omitempty" search:"Standard ID,hidden"` // @gotags: search:"Standard ID,hidden"
	GroupId              string   `protobuf:"bytes,3,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty" search:"Control Group ID,hidden"`          // @gotags: search:"Control Group ID,hidden"
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty" search:"Control,store"`                               // @gotags: search:"Control,store"
	Description          string   `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Implemented          bool     `protobuf:"varint,6,opt,name=implemented,proto3" json:"implemented,omitempty"`
	InterpretationText   string   `protobuf:"bytes,7,opt,name=interpretation_text,json=interpretationText,proto3" json:"interpretation_text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ComplianceControl) Reset()         { *m = ComplianceControl{} }
func (m *ComplianceControl) String() string { return proto.CompactTextString(m) }
func (*ComplianceControl) ProtoMessage()    {}
func (*ComplianceControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{3}
}
func (m *ComplianceControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceControl.Merge(m, src)
}
func (m *ComplianceControl) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceControl) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceControl.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceControl proto.InternalMessageInfo

func (m *ComplianceControl) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ComplianceControl) GetStandardId() string {
	if m != nil {
		return m.StandardId
	}
	return ""
}

func (m *ComplianceControl) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *ComplianceControl) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ComplianceControl) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ComplianceControl) GetImplemented() bool {
	if m != nil {
		return m.Implemented
	}
	return false
}

func (m *ComplianceControl) GetInterpretationText() string {
	if m != nil {
		return m.InterpretationText
	}
	return ""
}

func (m *ComplianceControl) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceControl) Clone() *ComplianceControl {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceControl)
	*cloned = *m

	return cloned
}

type ComplianceStandard struct {
	Metadata             *ComplianceStandardMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Groups               []*ComplianceControlGroup   `protobuf:"bytes,2,rep,name=groups,proto3" json:"groups,omitempty" search:"-"`     // @gotags: search:"-"
	Controls             []*ComplianceControl        `protobuf:"bytes,3,rep,name=controls,proto3" json:"controls,omitempty" search:"-"` // @gotags: search:"-"
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ComplianceStandard) Reset()         { *m = ComplianceStandard{} }
func (m *ComplianceStandard) String() string { return proto.CompactTextString(m) }
func (*ComplianceStandard) ProtoMessage()    {}
func (*ComplianceStandard) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{4}
}
func (m *ComplianceStandard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceStandard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceStandard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceStandard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceStandard.Merge(m, src)
}
func (m *ComplianceStandard) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceStandard) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceStandard.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceStandard proto.InternalMessageInfo

func (m *ComplianceStandard) GetMetadata() *ComplianceStandardMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ComplianceStandard) GetGroups() []*ComplianceControlGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ComplianceStandard) GetControls() []*ComplianceControl {
	if m != nil {
		return m.Controls
	}
	return nil
}

func (m *ComplianceStandard) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceStandard) Clone() *ComplianceStandard {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceStandard)
	*cloned = *m

	cloned.Metadata = m.Metadata.Clone()
	if m.Groups != nil {
		cloned.Groups = make([]*ComplianceControlGroup, len(m.Groups))
		for idx, v := range m.Groups {
			cloned.Groups[idx] = v.Clone()
		}
	}
	if m.Controls != nil {
		cloned.Controls = make([]*ComplianceControl, len(m.Controls))
		for idx, v := range m.Controls {
			cloned.Controls[idx] = v.Clone()
		}
	}
	return cloned
}

type GetComplianceStandardResponse struct {
	Standard             *ComplianceStandard `protobuf:"bytes,1,opt,name=standard,proto3" json:"standard,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetComplianceStandardResponse) Reset()         { *m = GetComplianceStandardResponse{} }
func (m *GetComplianceStandardResponse) String() string { return proto.CompactTextString(m) }
func (*GetComplianceStandardResponse) ProtoMessage()    {}
func (*GetComplianceStandardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{5}
}
func (m *GetComplianceStandardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetComplianceStandardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetComplianceStandardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetComplianceStandardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetComplianceStandardResponse.Merge(m, src)
}
func (m *GetComplianceStandardResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetComplianceStandardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetComplianceStandardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetComplianceStandardResponse proto.InternalMessageInfo

func (m *GetComplianceStandardResponse) GetStandard() *ComplianceStandard {
	if m != nil {
		return m.Standard
	}
	return nil
}

func (m *GetComplianceStandardResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetComplianceStandardResponse) Clone() *GetComplianceStandardResponse {
	if m == nil {
		return nil
	}
	cloned := new(GetComplianceStandardResponse)
	*cloned = *m

	cloned.Standard = m.Standard.Clone()
	return cloned
}

type GetComplianceStandardsResponse struct {
	Standards            []*ComplianceStandardMetadata `protobuf:"bytes,1,rep,name=standards,proto3" json:"standards,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *GetComplianceStandardsResponse) Reset()         { *m = GetComplianceStandardsResponse{} }
func (m *GetComplianceStandardsResponse) String() string { return proto.CompactTextString(m) }
func (*GetComplianceStandardsResponse) ProtoMessage()    {}
func (*GetComplianceStandardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{6}
}
func (m *GetComplianceStandardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetComplianceStandardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetComplianceStandardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetComplianceStandardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetComplianceStandardsResponse.Merge(m, src)
}
func (m *GetComplianceStandardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetComplianceStandardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetComplianceStandardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetComplianceStandardsResponse proto.InternalMessageInfo

func (m *GetComplianceStandardsResponse) GetStandards() []*ComplianceStandardMetadata {
	if m != nil {
		return m.Standards
	}
	return nil
}

func (m *GetComplianceStandardsResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetComplianceStandardsResponse) Clone() *GetComplianceStandardsResponse {
	if m == nil {
		return nil
	}
	cloned := new(GetComplianceStandardsResponse)
	*cloned = *m

	if m.Standards != nil {
		cloned.Standards = make([]*ComplianceStandardMetadata, len(m.Standards))
		for idx, v := range m.Standards {
			cloned.Standards[idx] = v.Clone()
		}
	}
	return cloned
}

type UpdateComplianceRequest struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	HideScanResults      bool     `protobuf:"varint,2,opt,name=hideScanResults,proto3" json:"hideScanResults,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateComplianceRequest) Reset()         { *m = UpdateComplianceRequest{} }
func (m *UpdateComplianceRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateComplianceRequest) ProtoMessage()    {}
func (*UpdateComplianceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{7}
}
func (m *UpdateComplianceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateComplianceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateComplianceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateComplianceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateComplianceRequest.Merge(m, src)
}
func (m *UpdateComplianceRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateComplianceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateComplianceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateComplianceRequest proto.InternalMessageInfo

func (m *UpdateComplianceRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UpdateComplianceRequest) GetHideScanResults() bool {
	if m != nil {
		return m.HideScanResults
	}
	return false
}

func (m *UpdateComplianceRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *UpdateComplianceRequest) Clone() *UpdateComplianceRequest {
	if m == nil {
		return nil
	}
	cloned := new(UpdateComplianceRequest)
	*cloned = *m

	return cloned
}

type GetComplianceRunResultsRequest struct {
	ClusterId  string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	StandardId string `protobuf:"bytes,2,opt,name=standard_id,json=standardId,proto3" json:"standard_id,omitempty"`
	// Specifies the run ID for which to return results. If empty, the most recent run is returned.
	// CAVEAT: Setting this field circumvents the results cache on the server-side, which may lead to significantly
	//         increased memory pressure and decreased performance.
	RunId                string   `protobuf:"bytes,3,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetComplianceRunResultsRequest) Reset()         { *m = GetComplianceRunResultsRequest{} }
func (m *GetComplianceRunResultsRequest) String() string { return proto.CompactTextString(m) }
func (*GetComplianceRunResultsRequest) ProtoMessage()    {}
func (*GetComplianceRunResultsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{8}
}
func (m *GetComplianceRunResultsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetComplianceRunResultsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetComplianceRunResultsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetComplianceRunResultsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetComplianceRunResultsRequest.Merge(m, src)
}
func (m *GetComplianceRunResultsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetComplianceRunResultsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetComplianceRunResultsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetComplianceRunResultsRequest proto.InternalMessageInfo

func (m *GetComplianceRunResultsRequest) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *GetComplianceRunResultsRequest) GetStandardId() string {
	if m != nil {
		return m.StandardId
	}
	return ""
}

func (m *GetComplianceRunResultsRequest) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *GetComplianceRunResultsRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetComplianceRunResultsRequest) Clone() *GetComplianceRunResultsRequest {
	if m == nil {
		return nil
	}
	cloned := new(GetComplianceRunResultsRequest)
	*cloned = *m

	return cloned
}

type GetComplianceRunResultsResponse struct {
	Results              *storage.ComplianceRunResults    `protobuf:"bytes,1,opt,name=results,proto3" json:"results,omitempty"`
	FailedRuns           []*storage.ComplianceRunMetadata `protobuf:"bytes,2,rep,name=failed_runs,json=failedRuns,proto3" json:"failed_runs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *GetComplianceRunResultsResponse) Reset()         { *m = GetComplianceRunResultsResponse{} }
func (m *GetComplianceRunResultsResponse) String() string { return proto.CompactTextString(m) }
func (*GetComplianceRunResultsResponse) ProtoMessage()    {}
func (*GetComplianceRunResultsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_99d119a672c13dfb, []int{9}
}
func (m *GetComplianceRunResultsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetComplianceRunResultsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetComplianceRunResultsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetComplianceRunResultsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetComplianceRunResultsResponse.Merge(m, src)
}
func (m *GetComplianceRunResultsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetComplianceRunResultsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetComplianceRunResultsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetComplianceRunResultsResponse proto.InternalMessageInfo

func (m *GetComplianceRunResultsResponse) GetResults() *storage.ComplianceRunResults {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *GetComplianceRunResultsResponse) GetFailedRuns() []*storage.ComplianceRunMetadata {
	if m != nil {
		return m.FailedRuns
	}
	return nil
}

func (m *GetComplianceRunResultsResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetComplianceRunResultsResponse) Clone() *GetComplianceRunResultsResponse {
	if m == nil {
		return nil
	}
	cloned := new(GetComplianceRunResultsResponse)
	*cloned = *m

	cloned.Results = m.Results.Clone()
	if m.FailedRuns != nil {
		cloned.FailedRuns = make([]*storage.ComplianceRunMetadata, len(m.FailedRuns))
		for idx, v := range m.FailedRuns {
			cloned.FailedRuns[idx] = v.Clone()
		}
	}
	return cloned
}

func init() {
	proto.RegisterEnum("v1.ComplianceStandardMetadata_Scope", ComplianceStandardMetadata_Scope_name, ComplianceStandardMetadata_Scope_value)
	proto.RegisterType((*ComplianceAggregationRequest)(nil), "v1.ComplianceAggregationRequest")
	proto.RegisterType((*ComplianceStandardMetadata)(nil), "v1.ComplianceStandardMetadata")
	proto.RegisterType((*ComplianceControlGroup)(nil), "v1.ComplianceControlGroup")
	proto.RegisterType((*ComplianceControl)(nil), "v1.ComplianceControl")
	proto.RegisterType((*ComplianceStandard)(nil), "v1.ComplianceStandard")
	proto.RegisterType((*GetComplianceStandardResponse)(nil), "v1.GetComplianceStandardResponse")
	proto.RegisterType((*GetComplianceStandardsResponse)(nil), "v1.GetComplianceStandardsResponse")
	proto.RegisterType((*UpdateComplianceRequest)(nil), "v1.UpdateComplianceRequest")
	proto.RegisterType((*GetComplianceRunResultsRequest)(nil), "v1.GetComplianceRunResultsRequest")
	proto.RegisterType((*GetComplianceRunResultsResponse)(nil), "v1.GetComplianceRunResultsResponse")
}

func init() { proto.RegisterFile("api/v1/compliance_service.proto", fileDescriptor_99d119a672c13dfb) }

var fileDescriptor_99d119a672c13dfb = []byte{
	// 1014 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xee, 0xae, 0xed, 0xc4, 0x7e, 0x6e, 0x8b, 0x99, 0xb6, 0x61, 0xbb, 0x69, 0x9c, 0xed, 0x02,
	0xc2, 0xe2, 0xb0, 0x96, 0x0d, 0x12, 0xa8, 0xaa, 0x54, 0x25, 0x8e, 0x15, 0x2c, 0x35, 0x69, 0x59,
	0x27, 0x12, 0x70, 0xc0, 0x9a, 0xee, 0x4e, 0x9d, 0x51, 0xbd, 0xb3, 0xcb, 0xcc, 0xac, 0x13, 0xab,
	0xe2, 0xc2, 0x95, 0x23, 0x17, 0x24, 0xfe, 0x0e, 0xc4, 0x89, 0x3b, 0x47, 0x24, 0xee, 0x08, 0x85,
	0x1e, 0xf8, 0x33, 0x90, 0xf7, 0xa7, 0x7f, 0xa6, 0xed, 0xcd, 0x7e, 0xef, 0x7d, 0xf3, 0xbe, 0xf7,
	0xbe, 0xf7, 0x66, 0x16, 0x76, 0x71, 0x40, 0x9b, 0xe3, 0x56, 0xd3, 0xf1, 0xbd, 0x60, 0x44, 0x31,
	0x73, 0xc8, 0x40, 0x10, 0x3e, 0xa6, 0x0e, 0xb1, 0x02, 0xee, 0x4b, 0x1f, 0xa9, 0xe3, 0x96, 0x7e,
	0x2b, 0x0f, 0xf2, 0x7c, 0x16, 0x3b, 0x74, 0x94, 0x18, 0x89, 0x17, 0xc8, 0x49, 0x62, 0xdb, 0x4e,
	0x6c, 0x82, 0x60, 0xee, 0x9c, 0xcd, 0x9f, 0xa4, 0xdf, 0x1b, 0xfa, 0xfe, 0x70, 0x44, 0x9a, 0xd3,
	0x18, 0xcc, 0x98, 0x2f, 0xb1, 0xa4, 0x3e, 0x13, 0x89, 0x57, 0x13, 0xd2, 0xe7, 0x78, 0x48, 0x66,
	0x98, 0xc4, 0x1e, 0xf3, 0x77, 0x05, 0xee, 0x75, 0x32, 0xe3, 0xde, 0x70, 0xc8, 0xc9, 0x30, 0x82,
	0xda, 0xe4, 0xbb, 0x90, 0x08, 0x89, 0x1e, 0x41, 0x79, 0xc8, 0xfd, 0x30, 0x18, 0x3c, 0x9b, 0x68,
	0x8a, 0x51, 0x68, 0xdc, 0x6c, 0x7f, 0x60, 0x25, 0xa7, 0x59, 0x2b, 0x81, 0x56, 0xdf, 0xf1, 0x03,
	0x62, 0x6f, 0x46, 0xa8, 0xfd, 0x09, 0xfa, 0x1c, 0x8a, 0x21, 0xa3, 0x52, 0x53, 0x0d, 0xe5, 0x8d,
	0xc1, 0x11, 0x02, 0x99, 0x50, 0x3a, 0x3f, 0x23, 0x9c, 0x68, 0x05, 0x43, 0x69, 0x54, 0xdb, 0xd7,
	0xad, 0x71, 0xcb, 0xb2, 0xf1, 0xf9, 0x97, 0x21, 0xe1, 0x13, 0x3b, 0x76, 0x99, 0xaf, 0x54, 0xd0,
	0xf3, 0x93, 0xfa, 0x12, 0x33, 0x17, 0x73, 0xf7, 0x88, 0x48, 0xec, 0x62, 0x89, 0xd1, 0x4d, 0x50,
	0xa9, 0xab, 0x29, 0x86, 0xd2, 0xa8, 0xd8, 0x2a, 0x75, 0x11, 0x82, 0x22, 0xc3, 0x1e, 0x89, 0xc8,
	0x54, 0xec, 0xe8, 0x37, 0x32, 0xa0, 0xea, 0x12, 0xe1, 0x70, 0x1a, 0x4c, 0x19, 0x44, 0xc9, 0x2a,
	0xf6, 0xac, 0x09, 0x7d, 0x0a, 0x5b, 0x2c, 0xf4, 0x06, 0xd4, 0x0b, 0x46, 0xc4, 0x23, 0x4c, 0x12,
	0x77, 0xe0, 0x9c, 0x11, 0xe7, 0x85, 0xd0, 0x8a, 0x86, 0xd2, 0x28, 0xd9, 0xb7, 0x59, 0xe8, 0xf5,
	0x72, 0x67, 0x27, 0xf2, 0xa1, 0x87, 0xb0, 0x21, 0xa6, 0xd5, 0x08, 0xad, 0x94, 0xf4, 0x6d, 0xdc,
	0xb2, 0xd6, 0x73, 0x4d, 0x4a, 0x4f, 0x30, 0x48, 0x83, 0x4d, 0x77, 0xc2, 0xb0, 0x47, 0x1d, 0x6d,
	0xc3, 0x50, 0x1a, 0x65, 0x3b, 0xfd, 0x8b, 0x1a, 0xf0, 0xce, 0x19, 0x75, 0x49, 0xdf, 0xc1, 0xcc,
	0x26, 0x22, 0x1c, 0x49, 0xa1, 0x6d, 0x46, 0x11, 0x8b, 0x66, 0xf3, 0x0b, 0x28, 0x45, 0x87, 0xa2,
	0x0a, 0x94, 0x4e, 0x8f, 0xfb, 0xdd, 0x93, 0xda, 0x35, 0x54, 0x85, 0xcd, 0xce, 0xe3, 0xd3, 0xfe,
	0x49, 0xd7, 0xae, 0x29, 0xe8, 0x06, 0x54, 0x8e, 0xf7, 0x8e, 0xba, 0xfd, 0xa7, 0x7b, 0x9d, 0x6e,
	0x4d, 0x45, 0x37, 0x01, 0x0e, 0xba, 0x4f, 0x1f, 0x3f, 0xf9, 0xfa, 0xa8, 0x7b, 0x7c, 0x52, 0x2b,
	0xa0, 0x32, 0x14, 0x8f, 0x9f, 0x1c, 0x74, 0x6b, 0x45, 0xf3, 0x57, 0x05, 0xb6, 0x72, 0xea, 0x1d,
	0x9f, 0x49, 0xee, 0x8f, 0x0e, 0xa7, 0x0a, 0x2f, 0xb5, 0x78, 0x17, 0xaa, 0x22, 0x29, 0x6d, 0x40,
	0xdd, 0xa4, 0xd3, 0x90, 0x9a, 0x7a, 0xb9, 0x06, 0x85, 0xf5, 0x1a, 0x14, 0xdf, 0x46, 0x83, 0xd2,
	0x7a, 0x0d, 0xcc, 0xff, 0x14, 0x78, 0x77, 0x89, 0xf7, 0xdb, 0x53, 0xbe, 0x9b, 0x2e, 0x01, 0x75,
	0x13, 0xda, 0xf1, 0x78, 0xcf, 0x54, 0x53, 0x5c, 0x5f, 0x4d, 0x69, 0xb9, 0x1a, 0x03, 0xaa, 0x33,
	0x95, 0x24, 0x0a, 0xcf, 0x9a, 0x50, 0x13, 0x6e, 0x51, 0x26, 0x09, 0x0f, 0x38, 0x89, 0x77, 0x79,
	0x20, 0xc9, 0x85, 0x8c, 0x94, 0xae, 0xd8, 0x68, 0xde, 0x75, 0x42, 0x2e, 0xa4, 0xf9, 0x9b, 0x02,
	0x68, 0x79, 0xba, 0xd0, 0x03, 0x28, 0x7b, 0xc9, 0x84, 0x45, 0x15, 0x57, 0xdb, 0xf5, 0xab, 0xe7,
	0xd0, 0xce, 0xe2, 0x51, 0x1b, 0x36, 0xa2, 0x32, 0x85, 0xa6, 0x1a, 0x85, 0x46, 0xb5, 0xad, 0xcf,
	0x23, 0x67, 0xc7, 0xc0, 0x4e, 0x22, 0x51, 0x0b, 0xca, 0x4e, 0x6c, 0x17, 0x5a, 0x21, 0x42, 0xdd,
	0x59, 0x89, 0xb2, 0xb3, 0x30, 0xb3, 0x0f, 0x3b, 0x87, 0x44, 0x2e, 0x33, 0xb2, 0x89, 0x08, 0x7c,
	0x26, 0x08, 0x6a, 0x43, 0x39, 0x15, 0x23, 0xa9, 0x61, 0x6b, 0x75, 0x0d, 0x76, 0x16, 0x67, 0x7e,
	0x0b, 0xf5, 0x95, 0x87, 0x8a, 0xec, 0xd4, 0x87, 0x50, 0x49, 0xa3, 0x45, 0x74, 0xb5, 0xbd, 0xbe,
	0x35, 0x39, 0xc0, 0xec, 0xc3, 0x7b, 0xa7, 0x81, 0x8b, 0x25, 0xc9, 0xc3, 0xd3, 0x2b, 0x73, 0x71,
	0xbc, 0x56, 0x2c, 0xac, 0xba, 0x7a, 0x61, 0xcf, 0x17, 0x48, 0xdb, 0x61, 0xea, 0x4a, 0xcf, 0xde,
	0x01, 0x70, 0x46, 0xa1, 0x90, 0x84, 0x0f, 0xb2, 0x1c, 0x95, 0xc4, 0xd2, 0x7b, 0x83, 0x49, 0xbe,
	0x03, 0x1b, 0x3c, 0x64, 0xf9, 0x1c, 0x97, 0x78, 0xc8, 0x7a, 0xae, 0xf9, 0x8b, 0x02, 0xbb, 0x6b,
	0x33, 0x27, 0xfd, 0xfa, 0x0c, 0x36, 0x79, 0x42, 0x3f, 0x16, 0x61, 0x67, 0xc5, 0x5d, 0x3e, 0x83,
	0x4b, 0xa3, 0xd1, 0x23, 0xa8, 0x3e, 0xc7, 0x74, 0x44, 0xdc, 0x01, 0x0f, 0x59, 0x3a, 0x4b, 0xf5,
	0xd5, 0xe0, 0xac, 0xd5, 0x10, 0x43, 0xec, 0x90, 0x89, 0xf6, 0xdf, 0xc5, 0xd9, 0x2d, 0xee, 0xc7,
	0x0f, 0x1f, 0x1a, 0xc0, 0xf5, 0x43, 0x22, 0x33, 0x5d, 0x51, 0x65, 0x2a, 0x5e, 0x77, 0xfa, 0x60,
	0xea, 0xe6, 0xf4, 0xe7, 0xd5, 0xf2, 0x9b, 0xc6, 0x0f, 0x7f, 0xbd, 0xfa, 0x49, 0xd5, 0x91, 0x36,
	0xff, 0x42, 0x37, 0x33, 0x89, 0x11, 0x85, 0xea, 0x4c, 0x02, 0x54, 0x8b, 0xde, 0x1f, 0x22, 0xfc,
	0x90, 0x3b, 0x64, 0x7f, 0xd2, 0x3b, 0xd0, 0xef, 0xaf, 0x4d, 0x93, 0x65, 0xf9, 0x30, 0xca, 0xb2,
	0x8b, 0x76, 0xd6, 0x65, 0x69, 0xbe, 0xa4, 0xee, 0xf7, 0xe8, 0x25, 0xdc, 0x38, 0x24, 0x32, 0x6f,
	0x1e, 0x5a, 0xae, 0x60, 0x69, 0x16, 0xf4, 0xf7, 0xaf, 0x8c, 0x49, 0x08, 0xdc, 0x8f, 0x08, 0x6c,
	0xa3, 0xbb, 0x0b, 0x04, 0x78, 0xc8, 0x52, 0x7d, 0x7e, 0x54, 0xe0, 0xf6, 0x21, 0x91, 0xe9, 0x33,
	0x4c, 0xdc, 0x94, 0x84, 0x31, 0xbf, 0x0e, 0xcb, 0x5f, 0x07, 0xfa, 0x47, 0xaf, 0x79, 0xce, 0x33,
	0x1a, 0x8d, 0x88, 0x86, 0x89, 0x8c, 0x05, 0x1a, 0x38, 0x4b, 0x9a, 0xb2, 0xe1, 0x50, 0x5f, 0x5c,
	0xac, 0xb4, 0xab, 0x1d, 0x9f, 0x3d, 0xa7, 0x43, 0xb4, 0x3d, 0xa5, 0xb5, 0x66, 0xf9, 0xf4, 0x7c,
	0x0a, 0xd2, 0x9c, 0xed, 0xab, 0x7b, 0xff, 0x40, 0xf9, 0x78, 0xdf, 0xfa, 0xe3, 0xb2, 0xae, 0xfc,
	0x79, 0x59, 0x57, 0xfe, 0xb9, 0xac, 0x2b, 0x3f, 0xff, 0x5b, 0xbf, 0x06, 0x1a, 0xf5, 0x2d, 0x21,
	0xb1, 0xf3, 0x82, 0xfb, 0x17, 0xf1, 0xa7, 0x92, 0x85, 0x03, 0x6a, 0x8d, 0x5b, 0xdf, 0xa8, 0xe3,
	0xd6, 0x57, 0x85, 0x67, 0x1b, 0x91, 0xed, 0x93, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0xdd, 0x3b,
	0x4b, 0xf7, 0xe3, 0x09, 0x00, 0x00,
}

func (m *ComplianceAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Unit != 0 {
		i = encodeVarintComplianceService(dAtA, i, uint64(m.Unit))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GroupBy) > 0 {
		dAtA3 := make([]byte, len(m.GroupBy)*10)
		var j2 int
		for _, num := range m.GroupBy {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintComplianceService(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceStandardMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceStandardMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceStandardMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HideScanResults {
		i--
		if m.HideScanResults {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Dynamic {
		i--
		if m.Dynamic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Scopes) > 0 {
		dAtA5 := make([]byte, len(m.Scopes)*10)
		var j4 int
		for _, num := range m.Scopes {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintComplianceService(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x2a
	}
	if m.NumImplementedChecks != 0 {
		i = encodeVarintComplianceService(dAtA, i, uint64(m.NumImplementedChecks))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceControlGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceControlGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceControlGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumImplementedChecks != 0 {
		i = encodeVarintComplianceService(dAtA, i, uint64(m.NumImplementedChecks))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StandardId) > 0 {
		i -= len(m.StandardId)
		copy(dAtA[i:], m.StandardId)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.StandardId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InterpretationText) > 0 {
		i -= len(m.InterpretationText)
		copy(dAtA[i:], m.InterpretationText)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.InterpretationText)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Implemented {
		i--
		if m.Implemented {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StandardId) > 0 {
		i -= len(m.StandardId)
		copy(dAtA[i:], m.StandardId)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.StandardId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceStandard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceStandard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceStandard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Controls) > 0 {
		for iNdEx := len(m.Controls) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Controls[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComplianceService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComplianceService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetComplianceStandardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetComplianceStandardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetComplianceStandardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Standard != nil {
		{
			size, err := m.Standard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetComplianceStandardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetComplianceStandardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetComplianceStandardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Standards) > 0 {
		for iNdEx := len(m.Standards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Standards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComplianceService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateComplianceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateComplianceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateComplianceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HideScanResults {
		i--
		if m.HideScanResults {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetComplianceRunResultsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetComplianceRunResultsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetComplianceRunResultsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StandardId) > 0 {
		i -= len(m.StandardId)
		copy(dAtA[i:], m.StandardId)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.StandardId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintComplianceService(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetComplianceRunResultsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetComplianceRunResultsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetComplianceRunResultsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FailedRuns) > 0 {
		for iNdEx := len(m.FailedRuns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FailedRuns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComplianceService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Results != nil {
		{
			size, err := m.Results.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintComplianceService(dAtA []byte, offset int, v uint64) int {
	offset -= sovComplianceService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ComplianceAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupBy) > 0 {
		l = 0
		for _, e := range m.GroupBy {
			l += sovComplianceService(uint64(e))
		}
		n += 1 + sovComplianceService(uint64(l)) + l
	}
	if m.Unit != 0 {
		n += 1 + sovComplianceService(uint64(m.Unit))
	}
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceStandardMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.NumImplementedChecks != 0 {
		n += 1 + sovComplianceService(uint64(m.NumImplementedChecks))
	}
	if len(m.Scopes) > 0 {
		l = 0
		for _, e := range m.Scopes {
			l += sovComplianceService(uint64(e))
		}
		n += 1 + sovComplianceService(uint64(l)) + l
	}
	if m.Dynamic {
		n += 2
	}
	if m.HideScanResults {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceControlGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.StandardId)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.NumImplementedChecks != 0 {
		n += 1 + sovComplianceService(uint64(m.NumImplementedChecks))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.StandardId)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.Implemented {
		n += 2
	}
	l = len(m.InterpretationText)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceStandard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovComplianceService(uint64(l))
		}
	}
	if len(m.Controls) > 0 {
		for _, e := range m.Controls {
			l = e.Size()
			n += 1 + l + sovComplianceService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetComplianceStandardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Standard != nil {
		l = m.Standard.Size()
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetComplianceStandardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Standards) > 0 {
		for _, e := range m.Standards {
			l = e.Size()
			n += 1 + l + sovComplianceService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateComplianceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.HideScanResults {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetComplianceRunResultsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.StandardId)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetComplianceRunResultsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Results != nil {
		l = m.Results.Size()
		n += 1 + l + sovComplianceService(uint64(l))
	}
	if len(m.FailedRuns) > 0 {
		for _, e := range m.FailedRuns {
			l = e.Size()
			n += 1 + l + sovComplianceService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovComplianceService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozComplianceService(x uint64) (n int) {
	return sovComplianceService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ComplianceAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v storage.ComplianceAggregation_Scope
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= storage.ComplianceAggregation_Scope(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupBy = append(m.GroupBy, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthComplianceService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthComplianceService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.GroupBy) == 0 {
					m.GroupBy = make([]storage.ComplianceAggregation_Scope, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v storage.ComplianceAggregation_Scope
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= storage.ComplianceAggregation_Scope(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupBy = append(m.GroupBy, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= storage.ComplianceAggregation_Scope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &RawQuery{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceStandardMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceStandardMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceStandardMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumImplementedChecks", wireType)
			}
			m.NumImplementedChecks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumImplementedChecks |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v ComplianceStandardMetadata_Scope
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ComplianceStandardMetadata_Scope(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Scopes = append(m.Scopes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthComplianceService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthComplianceService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Scopes) == 0 {
					m.Scopes = make([]ComplianceStandardMetadata_Scope, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ComplianceStandardMetadata_Scope
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ComplianceStandardMetadata_Scope(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Scopes = append(m.Scopes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dynamic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dynamic = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HideScanResults", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HideScanResults = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceControlGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceControlGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceControlGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumImplementedChecks", wireType)
			}
			m.NumImplementedChecks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumImplementedChecks |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implemented", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Implemented = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterpretationText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterpretationText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceStandard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceStandard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceStandard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &ComplianceStandardMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &ComplianceControlGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controls = append(m.Controls, &ComplianceControl{})
			if err := m.Controls[len(m.Controls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetComplianceStandardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetComplianceStandardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetComplianceStandardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Standard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Standard == nil {
				m.Standard = &ComplianceStandard{}
			}
			if err := m.Standard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetComplianceStandardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetComplianceStandardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetComplianceStandardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Standards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Standards = append(m.Standards, &ComplianceStandardMetadata{})
			if err := m.Standards[len(m.Standards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateComplianceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateComplianceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateComplianceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HideScanResults", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HideScanResults = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetComplianceRunResultsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetComplianceRunResultsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetComplianceRunResultsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetComplianceRunResultsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetComplianceRunResultsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetComplianceRunResultsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Results == nil {
				m.Results = &storage.ComplianceRunResults{}
			}
			if err := m.Results.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedRuns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedRuns = append(m.FailedRuns, &storage.ComplianceRunMetadata{})
			if err := m.FailedRuns[len(m.FailedRuns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipComplianceService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowComplianceService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowComplianceService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthComplianceService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupComplianceService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthComplianceService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthComplianceService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowComplianceService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupComplianceService = fmt.Errorf("proto: unexpected end of group")
)
