{
  "swagger": "2.0",
  "info": {
    "title": "api/v1/alert_service.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "AlertService"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v1/alerts": {
      "get": {
        "summary": "ListAlerts returns the slim list version of the alerts.",
        "description": "**Pagination Behavior:**\n- Default limit: 1000 alerts per request\n- Maximum limit: 1000 alerts per request\n- Default sorting: By violation time (newest first)\n- Supports custom pagination and sorting\n\n**Response Format:**\n- Returns ListAlert objects (slimmed down version)\n- Includes essential fields for list views\n- Optimized for UI display and bulk operations\n\n**Query Examples:**\n- \"Severity:HIGH_SEVERITY\" - High severity alerts\n- \"Cluster:production\" - Production cluster alerts\n- \"Violation State:ACTIVE\" - Active alerts only",
        "operationId": "AlertService_ListAlerts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListAlertsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "query",
            "description": "Search query string using StackRox search syntax.\nIf empty, returns all alerts (subject to pagination limits).\nSee https://docs.stackrox.com/docs/use-roxctl/#search for query syntax.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pagination.sortOption.field",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.sortOption.reversed",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.sortOption.aggregateBy.aggrFunc",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "UNSET",
              "COUNT",
              "MIN",
              "MAX"
            ],
            "default": "UNSET"
          },
          {
            "name": "pagination.sortOption.aggregateBy.distinct",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "AlertService"
        ]
      },
      "delete": {
        "summary": "DeleteAlerts is a maintenance function that deletes alerts from the store.",
        "description": "**Deletion Constraints:**\n- Only RESOLVED alerts can be deleted\n- Query MUST explicitly specify \"Violation State:RESOLVED\"\n- Confirmation required for actual deletion (dry-run mode by default)\n- Deletion is permanent and cannot be undone\n\n**Safety Features:**\n- Dry-run mode shows how many alerts would be deleted\n- Explicit confirmation required for actual deletion\n- Query must specifically target RESOLVED alerts\n\n**Error Cases:**\n- 400: Query does not specify RESOLVED state or specifies invalid state\n- 400: No query provided\n- 403: Insufficient permissions to delete alerts\n\n**Example Query:**\n- \"Violation State:RESOLVED+Cluster:production\" - Delete resolved alerts from production cluster",
        "operationId": "AlertService_DeleteAlerts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteAlertsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "query.query",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "query.pagination.limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "query.pagination.offset",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "query.pagination.sortOption.field",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "query.pagination.sortOption.reversed",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "query.pagination.sortOption.aggregateBy.aggrFunc",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "UNSET",
              "COUNT",
              "MIN",
              "MAX"
            ],
            "default": "UNSET"
          },
          {
            "name": "query.pagination.sortOption.aggregateBy.distinct",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "confirm",
            "description": "When false (default), performs a dry-run showing how many alerts would be deleted.\nWhen true, actually deletes the matching RESOLVED alerts.\nDeletion is permanent and cannot be undone.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "AlertService"
        ]
      }
    },
    "/v1/alerts/resolve": {
      "patch": {
        "summary": "ResolveAlertsByQuery marks alerts matching search query as resolved.",
        "description": "**Resolution Rules:**\n- Only resolves RUNTIME lifecycle alerts matching the query\n- All matching alerts are resolved in batches of 100\n- Permission checks are performed for each alert\n- Resolution triggers notification processing\n\n**Query Requirements:**\n- Must be a valid search query string\n- Only RUNTIME alerts are considered for resolution\n- Non-RUNTIME alerts in the query are ignored\n\n**Error Cases:**\n- 400: Invalid search query\n- 403: Insufficient permissions for some alerts\n- 500: Database errors during batch processing",
        "operationId": "AlertService_ResolveAlerts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1Empty"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "ResolveAlertsRequest contains parameters for resolving multiple alerts by query.\n\n**Resolution Rules:**\n- Only resolves RUNTIME lifecycle alerts matching the query\n- All matching alerts are resolved in batches of 100\n- Permission checks are performed for each alert\n- Resolution triggers notification processing\n\n**Query Requirements:**\n- Must be a valid search query string\n- Only RUNTIME alerts are considered for resolution\n- Non-RUNTIME alerts in the query are ignored",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1ResolveAlertsRequest"
            }
          }
        ],
        "tags": [
          "AlertService"
        ]
      }
    },
    "/v1/alerts/summary/counts": {
      "get": {
        "summary": "GetAlertsCounts returns the number of alerts grouped by category or cluster.",
        "description": "**Grouping Options:**\n- CATEGORY: Group by policy category\n- CLUSTER: Group by cluster\n- UNSET: No grouping (single count)\n\n**Response Format:**\n- Each group contains severity-based counts\n- Includes all severity levels (LOW, MEDIUM, HIGH, CRITICAL)\n- Optimized for dashboard metrics\n\n**Use Cases:**\n- Dashboard widgets\n- Cluster risk assessment\n- Category-based reporting",
        "operationId": "AlertService_GetAlertsCounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetAlertsCountsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "request.query",
            "description": "Search query string using StackRox search syntax.\nIf empty, returns all alerts (subject to pagination limits).\nSee https://docs.stackrox.com/docs/use-roxctl/#search for query syntax.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "request.pagination.limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "request.pagination.offset",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "request.pagination.sortOption.field",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "request.pagination.sortOption.reversed",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "request.pagination.sortOption.aggregateBy.aggrFunc",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "UNSET",
              "COUNT",
              "MIN",
              "MAX"
            ],
            "default": "UNSET"
          },
          {
            "name": "request.pagination.sortOption.aggregateBy.distinct",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "groupBy",
            "description": "Grouping method for the alert counts.\n\n - UNSET: No grouping - single count\n - CATEGORY: Group by policy category\n - CLUSTER: Group by cluster",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "UNSET",
              "CATEGORY",
              "CLUSTER"
            ],
            "default": "UNSET"
          }
        ],
        "tags": [
          "AlertService"
        ]
      }
    },
    "/v1/alerts/summary/groups": {
      "get": {
        "summary": "GetAlertsGroup returns alerts grouped by policy.",
        "description": "**Grouping Behavior:**\n- Groups alerts by policy ID\n- Returns policy information and alert counts\n- Fetches all matching alerts (no pagination limits)\n- Useful for policy-based analysis\n\n**Use Cases:**\n- Policy effectiveness analysis\n- Risk assessment by policy\n- Compliance reporting",
        "operationId": "AlertService_GetAlertsGroup",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetAlertsGroupResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "query",
            "description": "Search query string using StackRox search syntax.\nIf empty, returns all alerts (subject to pagination limits).\nSee https://docs.stackrox.com/docs/use-roxctl/#search for query syntax.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pagination.sortOption.field",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.sortOption.reversed",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.sortOption.aggregateBy.aggrFunc",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "UNSET",
              "COUNT",
              "MIN",
              "MAX"
            ],
            "default": "UNSET"
          },
          {
            "name": "pagination.sortOption.aggregateBy.distinct",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "AlertService"
        ]
      }
    },
    "/v1/alerts/summary/timeseries": {
      "get": {
        "summary": "GetAlertTimeseries returns the alerts sorted by time for trend analysis.",
        "description": "**Timeseries Behavior:**\n- Events organized by cluster and severity\n- Includes both alert creation and resolution events\n- Each severity level has its own timeline\n- Useful for trend analysis and monitoring\n\n**Use Cases:**\n- Alert trend visualization\n- Security posture monitoring\n- Incident response analysis",
        "operationId": "AlertService_GetAlertTimeseries",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetAlertTimeseriesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "query",
            "description": "Search query string using StackRox search syntax.\nIf empty, returns all alerts (subject to pagination limits).\nSee https://docs.stackrox.com/docs/use-roxctl/#search for query syntax.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pagination.sortOption.field",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.sortOption.reversed",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.sortOption.aggregateBy.aggrFunc",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "UNSET",
              "COUNT",
              "MIN",
              "MAX"
            ],
            "default": "UNSET"
          },
          {
            "name": "pagination.sortOption.aggregateBy.distinct",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "AlertService"
        ]
      }
    },
    "/v1/alerts/{id}": {
      "get": {
        "summary": "GetAlert returns the alert given its id.",
        "description": "Returns the full alert details including violations, enforcement actions,\nand entity information (deployment, image, or resource).\n\n**Error Cases:**\n- 404: Alert with specified ID does not exist\n- 403: Insufficient permissions to view the alert",
        "operationId": "AlertService_GetAlert",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/storageAlert"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "AlertService"
        ]
      }
    },
    "/v1/alerts/{id}/resolve": {
      "patch": {
        "summary": "ResolveAlert marks the given alert (by ID) as resolved.",
        "description": "**Resolution Rules:**\n- Only alerts with state ATTEMPTED or lifecycle stage RUNTIME can be resolved\n- Process violations can be added to baselines for future reference\n- Resolved alerts can be deleted (but only RESOLVED alerts can be deleted)\n- Resolution triggers notification processing\n\n**Baseline Integration:**\n- When add_to_baseline=true, process violations are added to deployment baselines\n- Baseline updates are synchronized with sensor clusters\n- Only applies to alerts with process violations\n\n**Error Cases:**\n- 404: Alert with specified ID does not exist\n- 403: Insufficient permissions to modify the alert\n- 400: Alert cannot be resolved (wrong state or lifecycle stage)",
        "operationId": "AlertService_ResolveAlert",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1Empty"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Unique identifier of the alert to resolve.\nMust reference an existing alert.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/AlertServiceResolveAlertBody"
            }
          }
        ],
        "tags": [
          "AlertService"
        ]
      }
    },
    "/v1/alertscount": {
      "get": {
        "summary": "CountAlerts counts how many alerts match the search query.",
        "description": "**Query Behavior:**\n- If query is empty, counts all alerts\n- Supports full StackRox search syntax\n- Returns total count of matching alerts\n\n**Use Cases:**\n- Dashboard metrics\n- Alert trend analysis\n- Policy effectiveness monitoring",
        "operationId": "AlertService_CountAlerts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CountAlertsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pagination.sortOption.field",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.sortOption.reversed",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.sortOption.aggregateBy.aggrFunc",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "UNSET",
              "COUNT",
              "MIN",
              "MAX"
            ],
            "default": "UNSET"
          },
          {
            "name": "pagination.sortOption.aggregateBy.distinct",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "AlertService"
        ]
      }
    }
  },
  "definitions": {
    "AlertDeploymentContainer": {
      "type": "object",
      "properties": {
        "image": {
          "$ref": "#/definitions/storageContainerImage",
          "description": "Container image information."
        },
        "name": {
          "type": "string",
          "description": "Name of the container within the deployment."
        }
      }
    },
    "AlertEnforcement": {
      "type": "object",
      "properties": {
        "action": {
          "$ref": "#/definitions/storageEnforcementAction",
          "description": "Enforcement action taken or attempted."
        },
        "message": {
          "type": "string",
          "description": "Human-readable message describing the enforcement result."
        }
      }
    },
    "AlertEntityType": {
      "type": "string",
      "enum": [
        "UNSET",
        "DEPLOYMENT",
        "CONTAINER_IMAGE",
        "RESOURCE"
      ],
      "default": "UNSET",
      "title": "- DEPLOYMENT: Alert on a deployment\n - CONTAINER_IMAGE: Alert on a container image\n - RESOURCE: Alert on a Kubernetes resource"
    },
    "AlertGroupAlertCounts": {
      "type": "object",
      "properties": {
        "severity": {
          "$ref": "#/definitions/storageSeverity",
          "description": "Severity level for this count."
        },
        "count": {
          "type": "string",
          "format": "int64",
          "description": "Number of alerts with this severity in this group."
        }
      }
    },
    "AlertProcessViolation": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string",
          "description": "Human-readable message describing the process violation."
        },
        "processes": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/storageProcessIndicator"
          },
          "description": "List of processes that violated the policy.\nLimited to maximum 40 processes per runtime alert."
        }
      }
    },
    "AlertResourceResourceType": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "SECRETS",
        "CONFIGMAPS",
        "CLUSTER_ROLES",
        "CLUSTER_ROLE_BINDINGS",
        "NETWORK_POLICIES",
        "SECURITY_CONTEXT_CONSTRAINTS",
        "EGRESS_FIREWALLS"
      ],
      "default": "UNKNOWN"
    },
    "AlertServiceResolveAlertBody": {
      "type": "object",
      "properties": {
        "whitelist": {
          "type": "boolean",
          "description": "Deprecated: Use add_to_baseline instead.\nWhen true, adds process violations to deployment baseline."
        },
        "addToBaseline": {
          "type": "boolean",
          "description": "When true, adds process violations from this alert to the deployment baseline.\nThis prevents future alerts for the same processes in the same deployment.\nOnly applies to alerts with process violations."
        }
      },
      "description": "ResolveAlertRequest contains parameters for resolving a single alert.\n\n**Alert Resolution Rules:**\n- Only alerts with state ATTEMPTED or lifecycle stage RUNTIME can be resolved\n- Process violations can be added to baselines for future reference\n- Resolved alerts can be deleted (but only RESOLVED alerts can be deleted)\n- Resolution triggers notification processing\n\n**Baseline Integration:**\n- When add_to_baseline=true, process violations are added to deployment baselines\n- Baseline updates are synchronized with sensor clusters\n- Only applies to alerts with process violations"
    },
    "AlertViolation": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string",
          "description": "Human-readable message describing the violation."
        },
        "keyValueAttrs": {
          "$ref": "#/definitions/ViolationKeyValueAttrs",
          "description": "Key-value attributes for the violation."
        },
        "networkFlowInfo": {
          "$ref": "#/definitions/ViolationNetworkFlowInfo",
          "description": "Network flow information for network-related violations."
        },
        "type": {
          "$ref": "#/definitions/AlertViolationType",
          "description": "Type of violation (for internal use only)."
        },
        "time": {
          "type": "string",
          "format": "date-time",
          "description": "Indicates violation time. This field differs from top-level field 'time' which represents last time the alert\noccurred in case of multiple occurrences of the policy alert. As of 55.0, this field is set only for kubernetes\nevent violations, but may not be limited to it in future."
        }
      }
    },
    "AlertViolationType": {
      "type": "string",
      "enum": [
        "GENERIC",
        "K8S_EVENT",
        "NETWORK_FLOW",
        "NETWORK_POLICY"
      ],
      "default": "GENERIC",
      "title": "- GENERIC: Generic policy violation\n - K8S_EVENT: Kubernetes event violation\n - NETWORK_FLOW: Network flow violation\n - NETWORK_POLICY: Network policy violation"
    },
    "ClusterAlertsAlertEvents": {
      "type": "object",
      "properties": {
        "severity": {
          "$ref": "#/definitions/storageSeverity",
          "description": "Severity level for these events."
        },
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1AlertEvent"
          },
          "description": "Timeline of alert events for this severity level."
        }
      }
    },
    "GetAlertTimeseriesResponseClusterAlerts": {
      "type": "object",
      "properties": {
        "cluster": {
          "type": "string",
          "description": "Cluster name for this group of alerts."
        },
        "severities": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/ClusterAlertsAlertEvents"
          },
          "description": "Alert events grouped by severity level."
        }
      }
    },
    "GetAlertsCountsRequestRequestGroup": {
      "type": "string",
      "enum": [
        "UNSET",
        "CATEGORY",
        "CLUSTER"
      ],
      "default": "UNSET",
      "description": "How to group the alert counts.\n\n - UNSET: No grouping - single count\n - CATEGORY: Group by policy category\n - CLUSTER: Group by cluster"
    },
    "GetAlertsCountsResponseAlertGroup": {
      "type": "object",
      "properties": {
        "group": {
          "type": "string",
          "description": "Group identifier (category name or cluster name)."
        },
        "counts": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/AlertGroupAlertCounts"
          },
          "description": "Counts by severity level for this group."
        }
      }
    },
    "KeyValueAttrsKeyValueAttr": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "ListAlertCommonEntityInfo": {
      "type": "object",
      "properties": {
        "clusterName": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "clusterId": {
          "type": "string"
        },
        "namespaceId": {
          "type": "string"
        },
        "resourceType": {
          "$ref": "#/definitions/storageListAlertResourceType"
        }
      },
      "description": "Fields common to all entities that an alert might belong to."
    },
    "ListAlertPolicyDevFields": {
      "type": "object",
      "properties": {
        "SORTName": {
          "type": "string"
        }
      }
    },
    "ListAlertResourceEntity": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      }
    },
    "NetworkFlowInfoEntity": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "entityType": {
          "$ref": "#/definitions/storageNetworkEntityInfoType"
        },
        "deploymentNamespace": {
          "type": "string"
        },
        "deploymentType": {
          "type": "string"
        },
        "port": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "PolicyMitreAttackVectors": {
      "type": "object",
      "properties": {
        "tactic": {
          "type": "string"
        },
        "techniques": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "ProcessSignalLineageInfo": {
      "type": "object",
      "properties": {
        "parentUid": {
          "type": "integer",
          "format": "int64"
        },
        "parentExecFilePath": {
          "type": "string"
        }
      }
    },
    "ViolationKeyValueAttrs": {
      "type": "object",
      "properties": {
        "attrs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/KeyValueAttrsKeyValueAttr"
          }
        }
      }
    },
    "ViolationNetworkFlowInfo": {
      "type": "object",
      "properties": {
        "protocol": {
          "$ref": "#/definitions/storageL4Protocol"
        },
        "source": {
          "$ref": "#/definitions/NetworkFlowInfoEntity"
        },
        "destination": {
          "$ref": "#/definitions/NetworkFlowInfoEntity"
        }
      }
    },
    "googlerpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "storageAlert": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the alert."
        },
        "policy": {
          "$ref": "#/definitions/storagePolicy",
          "description": "Policy that triggered this alert."
        },
        "lifecycleStage": {
          "$ref": "#/definitions/storageLifecycleStage",
          "description": "Lifecycle stage when the violation occurred."
        },
        "clusterId": {
          "type": "string",
          "description": "Unique identifier for the cluster containing the alert."
        },
        "clusterName": {
          "type": "string",
          "description": "Human-readable name of the cluster containing the alert."
        },
        "namespace": {
          "type": "string",
          "description": "Kubernetes namespace containing the alert."
        },
        "namespaceId": {
          "type": "string",
          "description": "Unique identifier for the namespace containing the alert."
        },
        "deployment": {
          "$ref": "#/definitions/storageAlertDeployment",
          "title": "Represents an alert on a deployment\nAn alert cannot be on more than one entity (deployment, container image, resource, etc.)"
        },
        "image": {
          "$ref": "#/definitions/storageContainerImage",
          "title": "Represents an alert on a container image.\nAn alert cannot be on more than one entity (deployment, container image, resource, etc.)"
        },
        "resource": {
          "$ref": "#/definitions/storageAlertResource",
          "title": "Represents an alert on a kubernetes resource (configmaps, secrets, etc.)\nAn alert cannot be on more than one entity (deployment, container image, resource, etc.)"
        },
        "violations": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/AlertViolation"
          },
          "description": "For run-time phase alert, a maximum of 40 violations are retained."
        },
        "processViolation": {
          "$ref": "#/definitions/AlertProcessViolation",
          "description": "Process violation details (if applicable)."
        },
        "enforcement": {
          "$ref": "#/definitions/AlertEnforcement",
          "description": "Enforcement action taken or attempted."
        },
        "time": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of the last occurrence of this alert.\nFor alerts with multiple violations, this represents the most recent occurrence."
        },
        "firstOccurred": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of the first occurrence of this alert."
        },
        "resolvedAt": {
          "type": "string",
          "format": "date-time",
          "description": "The time at which the alert was resolved. Only set if ViolationState is RESOLVED."
        },
        "state": {
          "$ref": "#/definitions/storageViolationState",
          "description": "Current state of the alert."
        },
        "platformComponent": {
          "type": "boolean",
          "description": "Whether this alert is related to a platform component."
        },
        "entityType": {
          "$ref": "#/definitions/AlertEntityType",
          "description": "Type of entity that triggered this alert."
        }
      },
      "title": "Next available tag: 24"
    },
    "storageAlertDeployment": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the deployment."
        },
        "name": {
          "type": "string",
          "description": "Human-readable name of the deployment."
        },
        "type": {
          "type": "string",
          "description": "Type of deployment (e.g., \"Deployment\", \"DaemonSet\", \"StatefulSet\")."
        },
        "namespace": {
          "type": "string",
          "description": "Kubernetes namespace containing the deployment.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Kubernetes labels applied to the deployment."
        },
        "clusterId": {
          "type": "string",
          "description": "Unique identifier for the cluster containing the deployment.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
        },
        "clusterName": {
          "type": "string",
          "description": "Human-readable name of the cluster containing the deployment.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
        },
        "containers": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/AlertDeploymentContainer"
          },
          "description": "List of containers in the deployment."
        },
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Kubernetes annotations applied to the deployment."
        },
        "inactive": {
          "type": "boolean",
          "description": "Whether the deployment is currently inactive."
        }
      }
    },
    "storageAlertResource": {
      "type": "object",
      "properties": {
        "resourceType": {
          "$ref": "#/definitions/AlertResourceResourceType",
          "description": "Type of Kubernetes resource that triggered the alert."
        },
        "name": {
          "type": "string",
          "description": "Name of the resource that triggered the alert."
        },
        "clusterId": {
          "type": "string",
          "description": "Unique identifier for the cluster containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
        },
        "clusterName": {
          "type": "string",
          "description": "Human-readable name of the cluster containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
        },
        "namespace": {
          "type": "string",
          "description": "Kubernetes namespace containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
        },
        "namespaceId": {
          "type": "string",
          "description": "Unique identifier for the namespace containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
        }
      },
      "title": "Represents an alert on a kubernetes resource other than a deployment (configmaps, secrets, etc.)"
    },
    "storageBooleanOperator": {
      "type": "string",
      "enum": [
        "OR",
        "AND"
      ],
      "default": "OR"
    },
    "storageContainerImage": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "name": {
          "$ref": "#/definitions/storageImageName"
        },
        "notPullable": {
          "type": "boolean"
        },
        "isClusterLocal": {
          "type": "boolean"
        },
        "idV2": {
          "type": "string"
        }
      },
      "title": "Next tag: 13"
    },
    "storageEnforcementAction": {
      "type": "string",
      "enum": [
        "UNSET_ENFORCEMENT",
        "SCALE_TO_ZERO_ENFORCEMENT",
        "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
        "KILL_POD_ENFORCEMENT",
        "FAIL_BUILD_ENFORCEMENT",
        "FAIL_KUBE_REQUEST_ENFORCEMENT",
        "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
        "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
      ],
      "default": "UNSET_ENFORCEMENT",
      "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates."
    },
    "storageEventSource": {
      "type": "string",
      "enum": [
        "NOT_APPLICABLE",
        "DEPLOYMENT_EVENT",
        "AUDIT_LOG_EVENT"
      ],
      "default": "NOT_APPLICABLE"
    },
    "storageExclusion": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the exclusion. Used for identification and documentation."
        },
        "deployment": {
          "$ref": "#/definitions/storageExclusionDeployment"
        },
        "image": {
          "$ref": "#/definitions/storageExclusionImage"
        },
        "expiration": {
          "type": "string",
          "format": "date-time",
          "description": "Expiration timestamp for this exclusion.\nWhen expired, the exclusion is automatically removed."
        }
      }
    },
    "storageExclusionDeployment": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "Name of the deployment to exclude. Optional if scope is provided.\nValidation: Must be provided if scope is not specified"
        },
        "scope": {
          "$ref": "#/definitions/storageScope",
          "title": "Scope-based exclusion criteria. Optional if name is provided.\nValidation: Must be provided if name is not specified\n- Must have at least one field populated (cluster, namespace, or label)\n- For audit log policies: Labels are not permitted"
        }
      }
    },
    "storageExclusionImage": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "Name of the image to exclude.\nValidation: Must be non-empty"
        }
      }
    },
    "storageImageName": {
      "type": "object",
      "properties": {
        "registry": {
          "type": "string"
        },
        "remote": {
          "type": "string"
        },
        "tag": {
          "type": "string"
        },
        "fullName": {
          "type": "string"
        }
      }
    },
    "storageL4Protocol": {
      "type": "string",
      "enum": [
        "L4_PROTOCOL_UNKNOWN",
        "L4_PROTOCOL_TCP",
        "L4_PROTOCOL_UDP",
        "L4_PROTOCOL_ICMP",
        "L4_PROTOCOL_RAW",
        "L4_PROTOCOL_SCTP",
        "L4_PROTOCOL_ANY"
      ],
      "default": "L4_PROTOCOL_UNKNOWN"
    },
    "storageLifecycleStage": {
      "type": "string",
      "enum": [
        "DEPLOY",
        "BUILD",
        "RUNTIME"
      ],
      "default": "DEPLOY"
    },
    "storageListAlert": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "lifecycleStage": {
          "$ref": "#/definitions/storageLifecycleStage"
        },
        "time": {
          "type": "string",
          "format": "date-time"
        },
        "policy": {
          "$ref": "#/definitions/storageListAlertPolicy"
        },
        "state": {
          "$ref": "#/definitions/storageViolationState"
        },
        "enforcementCount": {
          "type": "integer",
          "format": "int32"
        },
        "enforcementAction": {
          "$ref": "#/definitions/storageEnforcementAction"
        },
        "commonEntityInfo": {
          "$ref": "#/definitions/ListAlertCommonEntityInfo"
        },
        "deployment": {
          "$ref": "#/definitions/storageListAlertDeployment",
          "title": "Represents an alert on a deployment\nAn alert cannot be on more than one entity (deployment, container image, resource, etc.)"
        },
        "resource": {
          "$ref": "#/definitions/ListAlertResourceEntity",
          "title": "Represents an alert on a kubernetes resource (configmaps, secrets, etc.)\nAn alert cannot be on more than one entity (deployment, container image, resource, etc.)"
        }
      }
    },
    "storageListAlertDeployment": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "clusterName": {
          "type": "string",
          "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
        },
        "namespace": {
          "type": "string",
          "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
        },
        "clusterId": {
          "type": "string",
          "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
        },
        "inactive": {
          "type": "boolean"
        },
        "namespaceId": {
          "type": "string",
          "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
        },
        "deploymentType": {
          "type": "string"
        }
      }
    },
    "storageListAlertPolicy": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "severity": {
          "$ref": "#/definitions/storageSeverity"
        },
        "description": {
          "type": "string"
        },
        "categories": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "developerInternalFields": {
          "$ref": "#/definitions/ListAlertPolicyDevFields",
          "description": "For internal use only."
        }
      }
    },
    "storageListAlertResourceType": {
      "type": "string",
      "enum": [
        "DEPLOYMENT",
        "SECRETS",
        "CONFIGMAPS",
        "CLUSTER_ROLES",
        "CLUSTER_ROLE_BINDINGS",
        "NETWORK_POLICIES",
        "SECURITY_CONTEXT_CONSTRAINTS",
        "EGRESS_FIREWALLS"
      ],
      "default": "DEPLOYMENT",
      "title": "A special ListAlert-only enumeration of all resource types. Unlike Alert.Resource.ResourceType this also includes deployment as a type\nThis must be kept in sync with Alert.Resource.ResourceType (excluding the deployment value)"
    },
    "storageNetworkEntityInfoType": {
      "type": "string",
      "enum": [
        "UNKNOWN_TYPE",
        "DEPLOYMENT",
        "INTERNET",
        "LISTEN_ENDPOINT",
        "EXTERNAL_SOURCE",
        "INTERNAL_ENTITIES"
      ],
      "default": "UNKNOWN_TYPE",
      "title": "- INTERNAL_ENTITIES: INTERNAL_ENTITIES is for grouping all internal entities under a single network graph node"
    },
    "storagePolicy": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "title": "Unique identifier generated by the system. Must be empty for new policies.\nFormat: UUID v4, auto-generated during creation"
        },
        "name": {
          "type": "string",
          "title": "Name of the policy. Must be unique across all policies.\nValidation: 5-128 characters, no newlines or dollar signs\nPattern: ^[^\\n\\r\\$]{5,128}$"
        },
        "description": {
          "type": "string",
          "title": "Free-form text description of this policy.\nValidation: Max 800 characters, no dollar signs\nPattern: ^[^\\$]{0,800}$"
        },
        "rationale": {
          "type": "string",
          "description": "Business justification for why this policy exists.\nUsed for compliance and audit purposes."
        },
        "remediation": {
          "type": "string",
          "description": "Describes how to remediate a violation of this policy.\nShould be actionable and specific to the policy type."
        },
        "disabled": {
          "type": "boolean",
          "title": "Toggles whether or not this policy will be executing and actively firing alerts.\nDefault: false"
        },
        "categories": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "List of categories that this policy falls under. Category names must already exist in Central.\nValidation: At least one category required, no duplicates"
        },
        "lifecycleStages": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/storageLifecycleStage"
          },
          "title": "Describes which policy lifecycle stages this policy applies to. Choices are DEPLOY, BUILD, and RUNTIME.\nValidation: At least one stage required\n- BUILD: Must contain image-related criteria only\n- DEPLOY: Cannot contain runtime criteria\n- RUNTIME: Must contain at least one runtime criterion"
        },
        "eventSource": {
          "$ref": "#/definitions/storageEventSource",
          "title": "Describes which events should trigger execution of this policy\nValidation Rules:\n- Runtime policies: Cannot be NOT_APPLICABLE\n- Build/Deploy policies: Must be NOT_APPLICABLE\n- Audit log policies: No enforcement actions, no label scopes"
        },
        "exclusions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/storageExclusion"
          },
          "title": "Define deployments or images that should be excluded from this policy.\nValidation:\n- Deployment exclusions: Only valid for DEPLOY and RUNTIME lifecycles\n- Image exclusions: Only valid for BUILD lifecycle\n- Must have at least one criteria (name, scope, or image)"
        },
        "scope": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/storageScope"
          },
          "title": "Defines clusters, namespaces, and deployments that should be included in this policy.\nNo scopes defined includes everything.\nValidation: Must have at least one field populated (cluster, namespace, or label)"
        },
        "severity": {
          "$ref": "#/definitions/storageSeverity",
          "description": "Defines how severe a violation from this policy is.\nValidation: Must be set (not UNSET_SEVERITY)\nPossible values are UNSET_SEVERITY, LOW_SEVERITY, MEDIUM_SEVERITY, HIGH_SEVERITY, and CRITICAL_SEVERITY."
        },
        "enforcementActions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/storageEnforcementAction"
          },
          "title": "Lists the enforcement actions to take when a violation from this policy is identified.\nValidation: Must be compatible with lifecycle stages\n- FAIL_BUILD_ENFORCEMENT: BUILD lifecycle only\n- SCALE_TO_ZERO_ENFORCEMENT: DEPLOY lifecycle only\n- UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT: DEPLOY lifecycle only\n- KILL_POD_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_KUBE_REQUEST_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: DEPLOY lifecycle only\n- FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: DEPLOY lifecycle only\n- Audit log policies: No enforcement actions allowed"
        },
        "notifiers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "List of IDs of the notifiers that should be triggered when a violation from this policy is identified.\nIDs should be in the form of a UUID and are found through the Central API.\nValidation: All notifier IDs must reference existing notifiers"
        },
        "lastUpdated": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the policy was last updated. Auto-generated during creation/update."
        },
        "SORTName": {
          "type": "string",
          "description": "For internal use only."
        },
        "SORTLifecycleStage": {
          "type": "string",
          "description": "For internal use only."
        },
        "SORTEnforcement": {
          "type": "boolean",
          "description": "For internal use only."
        },
        "policyVersion": {
          "type": "string",
          "title": "Policy version. Must be \"1.1\" (current supported version).\nValidation: Only version 1.1 is supported"
        },
        "policySections": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/storagePolicySection"
          },
          "title": "PolicySections define the violation criteria for this policy.\nValidation Requirements:\n- Each section must have a unique sectionName\n- Each policy group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime policies must contain at least one runtime criterion\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria"
        },
        "mitreAttackVectors": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/PolicyMitreAttackVectors"
          },
          "description": "MITRE ATT&CK framework mappings for this policy.\nUsed for threat intelligence and compliance reporting."
        },
        "criteriaLocked": {
          "type": "boolean",
          "description": "Read-only field. If true, the policy's criteria fields are rendered read-only."
        },
        "mitreVectorsLocked": {
          "type": "boolean",
          "description": "Read-only field. If true, the policy's MITRE ATT&CK fields are rendered read-only."
        },
        "isDefault": {
          "type": "boolean",
          "description": "Read-only field. Indicates the policy is a default policy if true and a custom policy if false."
        },
        "source": {
          "$ref": "#/definitions/storagePolicySource"
        }
      },
      "title": "Next tag: 28"
    },
    "storagePolicyGroup": {
      "type": "object",
      "properties": {
        "fieldName": {
          "type": "string",
          "title": "Defines which field on a deployment or image this PolicyGroup evaluates.\nSee https://docs.openshift.com/acs/operating/manage-security-policies.html#policy-criteria_manage-security-policies for a complete list of possible values.\nValidation Requirements:\n- Must be a valid field name for the specified lifecycle stages\n- Field must support the specified boolean operator\n- Field must allow negation if negate=true\n- Field must support multiple values if more than one value is provided\n- Some fields have special restrictions (e.g., ImageSignatureVerifiedBy cannot use AND operator)"
        },
        "booleanOperator": {
          "$ref": "#/definitions/storageBooleanOperator",
          "title": "Determines if the values are combined with an OR or an AND. Defaults to OR.\nValidation: Must be compatible with the field type\n- Some fields only support OR (e.g., ImageSignatureVerifiedBy)\n- Some fields only support single values (operatorsForbidden=true)"
        },
        "negate": {
          "type": "boolean",
          "title": "Determines if the evaluation of this PolicyGroup is negated. Default to false.\nValidation: Must be allowed for the field type\n- Some fields cannot be negated (negationForbidden=true)"
        },
        "values": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/storagePolicyValue"
          },
          "title": "List of values for the specified field.\nValidation Requirements:\n- Must have at least one value\n- Values must match the expected regex pattern for the field type\n- Some fields only support single values\n- Values must be valid for the field's data type and constraints\n- Environment variable values have special format requirements\n- Dockerfile line values have special restrictions (e.g., no FROM with strict validation)"
        }
      }
    },
    "storagePolicySection": {
      "type": "object",
      "properties": {
        "sectionName": {
          "type": "string",
          "description": "Name of the policy section. Must be unique within the policy.\nUsed for organizing policy criteria into logical groups."
        },
        "policyGroups": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/storagePolicyGroup"
          },
          "title": "The set of policy groups that make up this section. Each group can be considered an individual criterion.\nValidation Requirements:\n- Each group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria"
        }
      }
    },
    "storagePolicySource": {
      "type": "string",
      "enum": [
        "IMPERATIVE",
        "DECLARATIVE"
      ],
      "default": "IMPERATIVE"
    },
    "storagePolicyValue": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "title": "The actual value for the policy criterion.\nValidation: Must match the expected format for the field type\nExamples:\n- CVE: \"CVE-2021-1234\"\n- Image Tag: \"latest\"\n- Environment Variable: \"UNSET=key=value\" or \"SECRET_KEY=key=\"\n- Dockerfile Line: \"ADD=.\" or \"RUN=apt-get update\"\n- Process Name: \"nginx\"\n- Network Flow: \"tcp:80\""
        }
      }
    },
    "storageProcessIndicator": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "title": "A unique UUID for the Indicator message"
        },
        "deploymentId": {
          "type": "string"
        },
        "containerName": {
          "type": "string"
        },
        "podId": {
          "type": "string",
          "title": "Pod name"
        },
        "podUid": {
          "type": "string"
        },
        "signal": {
          "$ref": "#/definitions/storageProcessSignal",
          "title": "A process signal message passed from Collector to Sensor"
        },
        "clusterId": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "containerStartTime": {
          "type": "string",
          "format": "date-time"
        },
        "imageId": {
          "type": "string"
        }
      },
      "title": "Next available tag: 13"
    },
    "storageProcessSignal": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "A unique UUID for identifying the message\nWe have this here instead of at the top level\nbecause we want to have each message to be\nself contained."
        },
        "containerId": {
          "type": "string",
          "title": "ID of container associated with this process"
        },
        "time": {
          "type": "string",
          "format": "date-time",
          "title": "Process creation time"
        },
        "name": {
          "type": "string",
          "title": "Process name"
        },
        "args": {
          "type": "string",
          "title": "Process arguments"
        },
        "execFilePath": {
          "type": "string",
          "title": "Process executable file path"
        },
        "pid": {
          "type": "integer",
          "format": "int64",
          "title": "Host process ID"
        },
        "uid": {
          "type": "integer",
          "format": "int64",
          "title": "Real user ID"
        },
        "gid": {
          "type": "integer",
          "format": "int64",
          "title": "Real group ID"
        },
        "lineage": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Process Lineage"
        },
        "scraped": {
          "type": "boolean",
          "title": "Signal origin"
        },
        "lineageInfo": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/ProcessSignalLineageInfo"
          },
          "title": "Process LineageInfo"
        }
      }
    },
    "storageScope": {
      "type": "object",
      "properties": {
        "cluster": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "label": {
          "$ref": "#/definitions/storageScopeLabel"
        }
      }
    },
    "storageScopeLabel": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "storageSeverity": {
      "type": "string",
      "enum": [
        "UNSET_SEVERITY",
        "LOW_SEVERITY",
        "MEDIUM_SEVERITY",
        "HIGH_SEVERITY",
        "CRITICAL_SEVERITY"
      ],
      "default": "UNSET_SEVERITY"
    },
    "storageViolationState": {
      "type": "string",
      "enum": [
        "ACTIVE",
        "RESOLVED",
        "ATTEMPTED"
      ],
      "default": "ACTIVE",
      "description": " - ACTIVE: Alert is currently active and requires attention.\nThis is the default state for new alerts.\nActive alerts can be resolved but cannot be deleted.\n - RESOLVED: Alert has been resolved (manually or automatically).\nResolved alerts can be deleted for maintenance purposes.\nOnly RESOLVED alerts can be deleted via DeleteAlerts API.\n - ATTEMPTED: Enforcement action was attempted but failed.\nThese alerts can be resolved to acknowledge the failed enforcement.\nCommon for alerts where enforcement actions are not fully configured."
    },
    "v1AggregateBy": {
      "type": "object",
      "properties": {
        "aggrFunc": {
          "$ref": "#/definitions/v1Aggregation"
        },
        "distinct": {
          "type": "boolean"
        }
      }
    },
    "v1Aggregation": {
      "type": "string",
      "enum": [
        "UNSET",
        "COUNT",
        "MIN",
        "MAX"
      ],
      "default": "UNSET"
    },
    "v1AlertEvent": {
      "type": "object",
      "properties": {
        "time": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp of the event (Unix timestamp in seconds)."
        },
        "type": {
          "$ref": "#/definitions/v1Type",
          "description": "Type of event (created or removed)."
        },
        "id": {
          "type": "string",
          "description": "Alert ID associated with this event."
        }
      },
      "description": "AlertEvent represents a single alert event in the timeseries."
    },
    "v1CountAlertsResponse": {
      "type": "object",
      "properties": {
        "count": {
          "type": "integer",
          "format": "int32",
          "description": "Number of alerts matching the search criteria."
        }
      },
      "description": "CountAlertsResponse contains the count of alerts matching the query."
    },
    "v1DeleteAlertsResponse": {
      "type": "object",
      "properties": {
        "numDeleted": {
          "type": "integer",
          "format": "int64",
          "description": "Number of alerts that were (or would be) deleted."
        },
        "dryRun": {
          "type": "boolean",
          "description": "True if this was a dry-run (no actual deletion occurred).\nFalse if alerts were actually deleted."
        }
      },
      "description": "DeleteAlertsResponse contains the result of a delete operation."
    },
    "v1Empty": {
      "type": "object"
    },
    "v1GetAlertTimeseriesResponse": {
      "type": "object",
      "properties": {
        "clusters": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/GetAlertTimeseriesResponseClusterAlerts"
          },
          "description": "Alert events organized by cluster."
        }
      },
      "description": "GetAlertTimeseriesResponse contains alert events organized by time and cluster.\n\n**Timeseries Behavior:**\n- Events are organized by cluster and severity\n- Each severity level has its own event timeline\n- Events include both alert creation and resolution\n- Useful for trend analysis and monitoring"
    },
    "v1GetAlertsCountsResponse": {
      "type": "object",
      "properties": {
        "groups": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/GetAlertsCountsResponseAlertGroup"
          },
          "description": "Alert counts grouped by the requested criteria."
        }
      },
      "description": "GetAlertsCountsResponse contains alert counts grouped by the specified criteria."
    },
    "v1GetAlertsGroupResponse": {
      "type": "object",
      "properties": {
        "alertsByPolicies": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1GetAlertsGroupResponsePolicyGroup"
          },
          "description": "Alerts grouped by policy, with counts per policy."
        }
      },
      "description": "GetAlertsGroupResponse contains alerts grouped by policy.\n\n**Grouping Behavior:**\n- Alerts are grouped by policy ID\n- Each group contains policy info and alert count\n- All alerts are fetched (no pagination limits)\n- Useful for policy-based alert analysis"
    },
    "v1GetAlertsGroupResponsePolicyGroup": {
      "type": "object",
      "properties": {
        "policy": {
          "$ref": "#/definitions/storageListAlertPolicy",
          "description": "Policy information for this group."
        },
        "numAlerts": {
          "type": "string",
          "format": "int64",
          "description": "Number of alerts for this policy."
        }
      }
    },
    "v1ListAlertsRequest": {
      "type": "object",
      "properties": {
        "query": {
          "type": "string",
          "description": "Search query string using StackRox search syntax.\nIf empty, returns all alerts (subject to pagination limits).\nSee https://docs.stackrox.com/docs/use-roxctl/#search for query syntax."
        },
        "pagination": {
          "$ref": "#/definitions/v1Pagination",
          "description": "Pagination parameters for controlling result set size and ordering.\nIf not specified, defaults to limit=1000 with violation time sorting."
        }
      },
      "description": "ListAlertsRequest contains parameters for listing alerts.\n\n**Query Parameters:**\n- query: Search query string using StackRox search syntax\n- pagination: Pagination parameters (limit, offset, sort options)\n\n**Pagination Limits:**\n- Maximum alerts returned: 1000 per request\n- Default limit: 1000 if pagination not specified\n- Default sorting: By violation time (newest first)\n\n**Search Query Examples:**\n- \"Severity:HIGH_SEVERITY\" - High severity alerts\n- \"Cluster:production\" - Alerts from production cluster\n- \"Violation State:ACTIVE\" - Active alerts only\n- \"Policy:Disallow Root Containers\" - Alerts from specific policy"
    },
    "v1ListAlertsResponse": {
      "type": "object",
      "properties": {
        "alerts": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/storageListAlert"
          },
          "description": "List of alerts matching the search criteria.\nLimited to maximum 1000 alerts per request."
        }
      },
      "description": "ListAlertsResponse contains the list of alerts matching the request criteria."
    },
    "v1Pagination": {
      "type": "object",
      "properties": {
        "limit": {
          "type": "integer",
          "format": "int32"
        },
        "offset": {
          "type": "integer",
          "format": "int32"
        },
        "sortOption": {
          "$ref": "#/definitions/v1SortOption"
        },
        "sortOptions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1SortOption"
          },
          "description": "This field is under development. It is not supported on any REST APIs."
        }
      }
    },
    "v1RawQuery": {
      "type": "object",
      "properties": {
        "query": {
          "type": "string"
        },
        "pagination": {
          "$ref": "#/definitions/v1Pagination"
        }
      },
      "description": "RawQuery represents the search query string.\nThe format of the query string is \"<field name>:<value,value,...>+<field name>:<value, value,...>+...\"\nFor example:\nTo search for deployments named \"central\" and \"sensor\" in the namespace \"stackrox\", the query string would be\n\"Deployment:central,sensor+Namespace:stackrox\"\nRawQuery is used in ListAPIs to search for a particular object."
    },
    "v1ResolveAlertsRequest": {
      "type": "object",
      "properties": {
        "query": {
          "type": "string",
          "description": "Search query to identify alerts to resolve.\nOnly RUNTIME lifecycle alerts matching this query will be resolved.\nMust be a valid StackRox search query string."
        }
      },
      "description": "ResolveAlertsRequest contains parameters for resolving multiple alerts by query.\n\n**Resolution Rules:**\n- Only resolves RUNTIME lifecycle alerts matching the query\n- All matching alerts are resolved in batches of 100\n- Permission checks are performed for each alert\n- Resolution triggers notification processing\n\n**Query Requirements:**\n- Must be a valid search query string\n- Only RUNTIME alerts are considered for resolution\n- Non-RUNTIME alerts in the query are ignored"
    },
    "v1SortOption": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        },
        "reversed": {
          "type": "boolean"
        },
        "aggregateBy": {
          "$ref": "#/definitions/v1AggregateBy",
          "description": "This field is under development. It is not supported on any REST APIs."
        }
      }
    },
    "v1Type": {
      "type": "string",
      "enum": [
        "CREATED",
        "REMOVED"
      ],
      "default": "CREATED",
      "description": "Type indicates the type of alert event in the timeseries.\n\n - CREATED: Alert was created\n - REMOVED: Alert was removed/resolved"
    }
  }
}
