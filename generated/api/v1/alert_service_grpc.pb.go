// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.25.3
// source: api/v1/alert_service.proto

package v1

import (
	context "context"
	storage "github.com/stackrox/rox/generated/storage"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AlertService_GetAlert_FullMethodName           = "/v1.AlertService/GetAlert"
	AlertService_CountAlerts_FullMethodName        = "/v1.AlertService/CountAlerts"
	AlertService_ListAlerts_FullMethodName         = "/v1.AlertService/ListAlerts"
	AlertService_GetAlertsGroup_FullMethodName     = "/v1.AlertService/GetAlertsGroup"
	AlertService_GetAlertsCounts_FullMethodName    = "/v1.AlertService/GetAlertsCounts"
	AlertService_GetAlertTimeseries_FullMethodName = "/v1.AlertService/GetAlertTimeseries"
	AlertService_ResolveAlert_FullMethodName       = "/v1.AlertService/ResolveAlert"
	AlertService_ResolveAlerts_FullMethodName      = "/v1.AlertService/ResolveAlerts"
	AlertService_DeleteAlerts_FullMethodName       = "/v1.AlertService/DeleteAlerts"
)

// AlertServiceClient is the client API for AlertService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// AlertService provides comprehensive alert management capabilities for StackRox Central.
//
// **Key Features:**
// - Query and filter alerts using StackRox search syntax
// - Resolve individual alerts or bulk resolve by query
// - Delete resolved alerts with safety confirmations
// - Group and count alerts by various criteria
// - Generate alert timeseries for trend analysis
// - Integrate with process baselines for violation management
//
// **Access Control:**
// - View operations require Alert View permissions
// - Modify operations require Alert Modify permissions
// - SAC (Service Access Control) checks are performed for all operations
//
// **Performance Considerations:**
// - Maximum 1000 alerts returned per list request
// - Bulk operations process alerts in batches of 100
// - Grouping operations may fetch all alerts (no pagination)
// - Default sorting by violation time (newest first)
//
// **Alert States:**
// - ACTIVE: Currently active violations
// - ATTEMPTED: Enforcement was attempted but failed
// - RESOLVED: Alert has been resolved (can be deleted)
//
// **Lifecycle Stages:**
// - BUILD: Alerts from build-time policy violations
// - DEPLOY: Alerts from deployment-time policy violations
// - RUNTIME: Alerts from runtime policy violations
type AlertServiceClient interface {
	// GetAlert returns the alert given its id.
	//
	// Returns the full alert details including violations, enforcement actions,
	// and entity information (deployment, image, or resource).
	//
	// **Error Cases:**
	// - 404: Alert with specified ID does not exist
	// - 403: Insufficient permissions to view the alert
	GetAlert(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*storage.Alert, error)
	// CountAlerts counts how many alerts match the search query.
	//
	// **Query Behavior:**
	// - If query is empty, counts all alerts
	// - Supports full StackRox search syntax
	// - Returns total count of matching alerts
	//
	// **Use Cases:**
	// - Dashboard metrics
	// - Alert trend analysis
	// - Policy effectiveness monitoring
	CountAlerts(ctx context.Context, in *RawQuery, opts ...grpc.CallOption) (*CountAlertsResponse, error)
	// ListAlerts returns the slim list version of the alerts.
	//
	// **Pagination Behavior:**
	// - Default limit: 1000 alerts per request
	// - Maximum limit: 1000 alerts per request
	// - Default sorting: By violation time (newest first)
	// - Supports custom pagination and sorting
	//
	// **Response Format:**
	// - Returns ListAlert objects (slimmed down version)
	// - Includes essential fields for list views
	// - Optimized for UI display and bulk operations
	//
	// **Query Examples:**
	// - "Severity:HIGH_SEVERITY" - High severity alerts
	// - "Cluster:production" - Production cluster alerts
	// - "Violation State:ACTIVE" - Active alerts only
	ListAlerts(ctx context.Context, in *ListAlertsRequest, opts ...grpc.CallOption) (*ListAlertsResponse, error)
	// GetAlertsGroup returns alerts grouped by policy.
	//
	// **Grouping Behavior:**
	// - Groups alerts by policy ID
	// - Returns policy information and alert counts
	// - Fetches all matching alerts (no pagination limits)
	// - Useful for policy-based analysis
	//
	// **Use Cases:**
	// - Policy effectiveness analysis
	// - Risk assessment by policy
	// - Compliance reporting
	GetAlertsGroup(ctx context.Context, in *ListAlertsRequest, opts ...grpc.CallOption) (*GetAlertsGroupResponse, error)
	// GetAlertsCounts returns the number of alerts grouped by category or cluster.
	//
	// **Grouping Options:**
	// - CATEGORY: Group by policy category
	// - CLUSTER: Group by cluster
	// - UNSET: No grouping (single count)
	//
	// **Response Format:**
	// - Each group contains severity-based counts
	// - Includes all severity levels (LOW, MEDIUM, HIGH, CRITICAL)
	// - Optimized for dashboard metrics
	//
	// **Use Cases:**
	// - Dashboard widgets
	// - Cluster risk assessment
	// - Category-based reporting
	GetAlertsCounts(ctx context.Context, in *GetAlertsCountsRequest, opts ...grpc.CallOption) (*GetAlertsCountsResponse, error)
	// GetAlertTimeseries returns the alerts sorted by time for trend analysis.
	//
	// **Timeseries Behavior:**
	// - Events organized by cluster and severity
	// - Includes both alert creation and resolution events
	// - Each severity level has its own timeline
	// - Useful for trend analysis and monitoring
	//
	// **Use Cases:**
	// - Alert trend visualization
	// - Security posture monitoring
	// - Incident response analysis
	GetAlertTimeseries(ctx context.Context, in *ListAlertsRequest, opts ...grpc.CallOption) (*GetAlertTimeseriesResponse, error)
	// ResolveAlert marks the given alert (by ID) as resolved.
	//
	// **Resolution Rules:**
	// - Only alerts with state ATTEMPTED or lifecycle stage RUNTIME can be resolved
	// - Process violations can be added to baselines for future reference
	// - Resolved alerts can be deleted (but only RESOLVED alerts can be deleted)
	// - Resolution triggers notification processing
	//
	// **Baseline Integration:**
	// - When add_to_baseline=true, process violations are added to deployment baselines
	// - Baseline updates are synchronized with sensor clusters
	// - Only applies to alerts with process violations
	//
	// **Error Cases:**
	// - 404: Alert with specified ID does not exist
	// - 403: Insufficient permissions to modify the alert
	// - 400: Alert cannot be resolved (wrong state or lifecycle stage)
	ResolveAlert(ctx context.Context, in *ResolveAlertRequest, opts ...grpc.CallOption) (*Empty, error)
	// ResolveAlertsByQuery marks alerts matching search query as resolved.
	//
	// **Resolution Rules:**
	// - Only resolves RUNTIME lifecycle alerts matching the query
	// - All matching alerts are resolved in batches of 100
	// - Permission checks are performed for each alert
	// - Resolution triggers notification processing
	//
	// **Query Requirements:**
	// - Must be a valid search query string
	// - Only RUNTIME alerts are considered for resolution
	// - Non-RUNTIME alerts in the query are ignored
	//
	// **Error Cases:**
	// - 400: Invalid search query
	// - 403: Insufficient permissions for some alerts
	// - 500: Database errors during batch processing
	ResolveAlerts(ctx context.Context, in *ResolveAlertsRequest, opts ...grpc.CallOption) (*Empty, error)
	// DeleteAlerts is a maintenance function that deletes alerts from the store.
	//
	// **Deletion Constraints:**
	// - Only RESOLVED alerts can be deleted
	// - Query MUST explicitly specify "Violation State:RESOLVED"
	// - Confirmation required for actual deletion (dry-run mode by default)
	// - Deletion is permanent and cannot be undone
	//
	// **Safety Features:**
	// - Dry-run mode shows how many alerts would be deleted
	// - Explicit confirmation required for actual deletion
	// - Query must specifically target RESOLVED alerts
	//
	// **Error Cases:**
	// - 400: Query does not specify RESOLVED state or specifies invalid state
	// - 400: No query provided
	// - 403: Insufficient permissions to delete alerts
	//
	// **Example Query:**
	// - "Violation State:RESOLVED+Cluster:production" - Delete resolved alerts from production cluster
	DeleteAlerts(ctx context.Context, in *DeleteAlertsRequest, opts ...grpc.CallOption) (*DeleteAlertsResponse, error)
}

type alertServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAlertServiceClient(cc grpc.ClientConnInterface) AlertServiceClient {
	return &alertServiceClient{cc}
}

func (c *alertServiceClient) GetAlert(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*storage.Alert, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(storage.Alert)
	err := c.cc.Invoke(ctx, AlertService_GetAlert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertServiceClient) CountAlerts(ctx context.Context, in *RawQuery, opts ...grpc.CallOption) (*CountAlertsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CountAlertsResponse)
	err := c.cc.Invoke(ctx, AlertService_CountAlerts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertServiceClient) ListAlerts(ctx context.Context, in *ListAlertsRequest, opts ...grpc.CallOption) (*ListAlertsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAlertsResponse)
	err := c.cc.Invoke(ctx, AlertService_ListAlerts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertServiceClient) GetAlertsGroup(ctx context.Context, in *ListAlertsRequest, opts ...grpc.CallOption) (*GetAlertsGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAlertsGroupResponse)
	err := c.cc.Invoke(ctx, AlertService_GetAlertsGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertServiceClient) GetAlertsCounts(ctx context.Context, in *GetAlertsCountsRequest, opts ...grpc.CallOption) (*GetAlertsCountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAlertsCountsResponse)
	err := c.cc.Invoke(ctx, AlertService_GetAlertsCounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertServiceClient) GetAlertTimeseries(ctx context.Context, in *ListAlertsRequest, opts ...grpc.CallOption) (*GetAlertTimeseriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAlertTimeseriesResponse)
	err := c.cc.Invoke(ctx, AlertService_GetAlertTimeseries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertServiceClient) ResolveAlert(ctx context.Context, in *ResolveAlertRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AlertService_ResolveAlert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertServiceClient) ResolveAlerts(ctx context.Context, in *ResolveAlertsRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AlertService_ResolveAlerts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertServiceClient) DeleteAlerts(ctx context.Context, in *DeleteAlertsRequest, opts ...grpc.CallOption) (*DeleteAlertsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAlertsResponse)
	err := c.cc.Invoke(ctx, AlertService_DeleteAlerts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AlertServiceServer is the server API for AlertService service.
// All implementations should embed UnimplementedAlertServiceServer
// for forward compatibility.
//
// AlertService provides comprehensive alert management capabilities for StackRox Central.
//
// **Key Features:**
// - Query and filter alerts using StackRox search syntax
// - Resolve individual alerts or bulk resolve by query
// - Delete resolved alerts with safety confirmations
// - Group and count alerts by various criteria
// - Generate alert timeseries for trend analysis
// - Integrate with process baselines for violation management
//
// **Access Control:**
// - View operations require Alert View permissions
// - Modify operations require Alert Modify permissions
// - SAC (Service Access Control) checks are performed for all operations
//
// **Performance Considerations:**
// - Maximum 1000 alerts returned per list request
// - Bulk operations process alerts in batches of 100
// - Grouping operations may fetch all alerts (no pagination)
// - Default sorting by violation time (newest first)
//
// **Alert States:**
// - ACTIVE: Currently active violations
// - ATTEMPTED: Enforcement was attempted but failed
// - RESOLVED: Alert has been resolved (can be deleted)
//
// **Lifecycle Stages:**
// - BUILD: Alerts from build-time policy violations
// - DEPLOY: Alerts from deployment-time policy violations
// - RUNTIME: Alerts from runtime policy violations
type AlertServiceServer interface {
	// GetAlert returns the alert given its id.
	//
	// Returns the full alert details including violations, enforcement actions,
	// and entity information (deployment, image, or resource).
	//
	// **Error Cases:**
	// - 404: Alert with specified ID does not exist
	// - 403: Insufficient permissions to view the alert
	GetAlert(context.Context, *ResourceByID) (*storage.Alert, error)
	// CountAlerts counts how many alerts match the search query.
	//
	// **Query Behavior:**
	// - If query is empty, counts all alerts
	// - Supports full StackRox search syntax
	// - Returns total count of matching alerts
	//
	// **Use Cases:**
	// - Dashboard metrics
	// - Alert trend analysis
	// - Policy effectiveness monitoring
	CountAlerts(context.Context, *RawQuery) (*CountAlertsResponse, error)
	// ListAlerts returns the slim list version of the alerts.
	//
	// **Pagination Behavior:**
	// - Default limit: 1000 alerts per request
	// - Maximum limit: 1000 alerts per request
	// - Default sorting: By violation time (newest first)
	// - Supports custom pagination and sorting
	//
	// **Response Format:**
	// - Returns ListAlert objects (slimmed down version)
	// - Includes essential fields for list views
	// - Optimized for UI display and bulk operations
	//
	// **Query Examples:**
	// - "Severity:HIGH_SEVERITY" - High severity alerts
	// - "Cluster:production" - Production cluster alerts
	// - "Violation State:ACTIVE" - Active alerts only
	ListAlerts(context.Context, *ListAlertsRequest) (*ListAlertsResponse, error)
	// GetAlertsGroup returns alerts grouped by policy.
	//
	// **Grouping Behavior:**
	// - Groups alerts by policy ID
	// - Returns policy information and alert counts
	// - Fetches all matching alerts (no pagination limits)
	// - Useful for policy-based analysis
	//
	// **Use Cases:**
	// - Policy effectiveness analysis
	// - Risk assessment by policy
	// - Compliance reporting
	GetAlertsGroup(context.Context, *ListAlertsRequest) (*GetAlertsGroupResponse, error)
	// GetAlertsCounts returns the number of alerts grouped by category or cluster.
	//
	// **Grouping Options:**
	// - CATEGORY: Group by policy category
	// - CLUSTER: Group by cluster
	// - UNSET: No grouping (single count)
	//
	// **Response Format:**
	// - Each group contains severity-based counts
	// - Includes all severity levels (LOW, MEDIUM, HIGH, CRITICAL)
	// - Optimized for dashboard metrics
	//
	// **Use Cases:**
	// - Dashboard widgets
	// - Cluster risk assessment
	// - Category-based reporting
	GetAlertsCounts(context.Context, *GetAlertsCountsRequest) (*GetAlertsCountsResponse, error)
	// GetAlertTimeseries returns the alerts sorted by time for trend analysis.
	//
	// **Timeseries Behavior:**
	// - Events organized by cluster and severity
	// - Includes both alert creation and resolution events
	// - Each severity level has its own timeline
	// - Useful for trend analysis and monitoring
	//
	// **Use Cases:**
	// - Alert trend visualization
	// - Security posture monitoring
	// - Incident response analysis
	GetAlertTimeseries(context.Context, *ListAlertsRequest) (*GetAlertTimeseriesResponse, error)
	// ResolveAlert marks the given alert (by ID) as resolved.
	//
	// **Resolution Rules:**
	// - Only alerts with state ATTEMPTED or lifecycle stage RUNTIME can be resolved
	// - Process violations can be added to baselines for future reference
	// - Resolved alerts can be deleted (but only RESOLVED alerts can be deleted)
	// - Resolution triggers notification processing
	//
	// **Baseline Integration:**
	// - When add_to_baseline=true, process violations are added to deployment baselines
	// - Baseline updates are synchronized with sensor clusters
	// - Only applies to alerts with process violations
	//
	// **Error Cases:**
	// - 404: Alert with specified ID does not exist
	// - 403: Insufficient permissions to modify the alert
	// - 400: Alert cannot be resolved (wrong state or lifecycle stage)
	ResolveAlert(context.Context, *ResolveAlertRequest) (*Empty, error)
	// ResolveAlertsByQuery marks alerts matching search query as resolved.
	//
	// **Resolution Rules:**
	// - Only resolves RUNTIME lifecycle alerts matching the query
	// - All matching alerts are resolved in batches of 100
	// - Permission checks are performed for each alert
	// - Resolution triggers notification processing
	//
	// **Query Requirements:**
	// - Must be a valid search query string
	// - Only RUNTIME alerts are considered for resolution
	// - Non-RUNTIME alerts in the query are ignored
	//
	// **Error Cases:**
	// - 400: Invalid search query
	// - 403: Insufficient permissions for some alerts
	// - 500: Database errors during batch processing
	ResolveAlerts(context.Context, *ResolveAlertsRequest) (*Empty, error)
	// DeleteAlerts is a maintenance function that deletes alerts from the store.
	//
	// **Deletion Constraints:**
	// - Only RESOLVED alerts can be deleted
	// - Query MUST explicitly specify "Violation State:RESOLVED"
	// - Confirmation required for actual deletion (dry-run mode by default)
	// - Deletion is permanent and cannot be undone
	//
	// **Safety Features:**
	// - Dry-run mode shows how many alerts would be deleted
	// - Explicit confirmation required for actual deletion
	// - Query must specifically target RESOLVED alerts
	//
	// **Error Cases:**
	// - 400: Query does not specify RESOLVED state or specifies invalid state
	// - 400: No query provided
	// - 403: Insufficient permissions to delete alerts
	//
	// **Example Query:**
	// - "Violation State:RESOLVED+Cluster:production" - Delete resolved alerts from production cluster
	DeleteAlerts(context.Context, *DeleteAlertsRequest) (*DeleteAlertsResponse, error)
}

// UnimplementedAlertServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAlertServiceServer struct{}

func (UnimplementedAlertServiceServer) GetAlert(context.Context, *ResourceByID) (*storage.Alert, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAlert not implemented")
}
func (UnimplementedAlertServiceServer) CountAlerts(context.Context, *RawQuery) (*CountAlertsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountAlerts not implemented")
}
func (UnimplementedAlertServiceServer) ListAlerts(context.Context, *ListAlertsRequest) (*ListAlertsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAlerts not implemented")
}
func (UnimplementedAlertServiceServer) GetAlertsGroup(context.Context, *ListAlertsRequest) (*GetAlertsGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAlertsGroup not implemented")
}
func (UnimplementedAlertServiceServer) GetAlertsCounts(context.Context, *GetAlertsCountsRequest) (*GetAlertsCountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAlertsCounts not implemented")
}
func (UnimplementedAlertServiceServer) GetAlertTimeseries(context.Context, *ListAlertsRequest) (*GetAlertTimeseriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAlertTimeseries not implemented")
}
func (UnimplementedAlertServiceServer) ResolveAlert(context.Context, *ResolveAlertRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveAlert not implemented")
}
func (UnimplementedAlertServiceServer) ResolveAlerts(context.Context, *ResolveAlertsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveAlerts not implemented")
}
func (UnimplementedAlertServiceServer) DeleteAlerts(context.Context, *DeleteAlertsRequest) (*DeleteAlertsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAlerts not implemented")
}
func (UnimplementedAlertServiceServer) testEmbeddedByValue() {}

// UnsafeAlertServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AlertServiceServer will
// result in compilation errors.
type UnsafeAlertServiceServer interface {
	mustEmbedUnimplementedAlertServiceServer()
}

func RegisterAlertServiceServer(s grpc.ServiceRegistrar, srv AlertServiceServer) {
	// If the following call pancis, it indicates UnimplementedAlertServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AlertService_ServiceDesc, srv)
}

func _AlertService_GetAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertServiceServer).GetAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AlertService_GetAlert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertServiceServer).GetAlert(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertService_CountAlerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertServiceServer).CountAlerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AlertService_CountAlerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertServiceServer).CountAlerts(ctx, req.(*RawQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertService_ListAlerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertServiceServer).ListAlerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AlertService_ListAlerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertServiceServer).ListAlerts(ctx, req.(*ListAlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertService_GetAlertsGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertServiceServer).GetAlertsGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AlertService_GetAlertsGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertServiceServer).GetAlertsGroup(ctx, req.(*ListAlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertService_GetAlertsCounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAlertsCountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertServiceServer).GetAlertsCounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AlertService_GetAlertsCounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertServiceServer).GetAlertsCounts(ctx, req.(*GetAlertsCountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertService_GetAlertTimeseries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertServiceServer).GetAlertTimeseries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AlertService_GetAlertTimeseries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertServiceServer).GetAlertTimeseries(ctx, req.(*ListAlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertService_ResolveAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveAlertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertServiceServer).ResolveAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AlertService_ResolveAlert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertServiceServer).ResolveAlert(ctx, req.(*ResolveAlertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertService_ResolveAlerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveAlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertServiceServer).ResolveAlerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AlertService_ResolveAlerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertServiceServer).ResolveAlerts(ctx, req.(*ResolveAlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertService_DeleteAlerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertServiceServer).DeleteAlerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AlertService_DeleteAlerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertServiceServer).DeleteAlerts(ctx, req.(*DeleteAlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AlertService_ServiceDesc is the grpc.ServiceDesc for AlertService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AlertService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.AlertService",
	HandlerType: (*AlertServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAlert",
			Handler:    _AlertService_GetAlert_Handler,
		},
		{
			MethodName: "CountAlerts",
			Handler:    _AlertService_CountAlerts_Handler,
		},
		{
			MethodName: "ListAlerts",
			Handler:    _AlertService_ListAlerts_Handler,
		},
		{
			MethodName: "GetAlertsGroup",
			Handler:    _AlertService_GetAlertsGroup_Handler,
		},
		{
			MethodName: "GetAlertsCounts",
			Handler:    _AlertService_GetAlertsCounts_Handler,
		},
		{
			MethodName: "GetAlertTimeseries",
			Handler:    _AlertService_GetAlertTimeseries_Handler,
		},
		{
			MethodName: "ResolveAlert",
			Handler:    _AlertService_ResolveAlert_Handler,
		},
		{
			MethodName: "ResolveAlerts",
			Handler:    _AlertService_ResolveAlerts_Handler,
		},
		{
			MethodName: "DeleteAlerts",
			Handler:    _AlertService_DeleteAlerts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/alert_service.proto",
}
