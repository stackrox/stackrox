// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/v1/image_service.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	v4 "github.com/stackrox/rox/generated/internalapi/scanner/v4"
	storage "github.com/stackrox/rox/generated/storage"
	v1 "github.com/stackrox/scanner/generated/scanner/api/v1"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type WatchImageResponse_ErrorType int32

const (
	WatchImageResponse_NO_ERROR             WatchImageResponse_ErrorType = 0
	WatchImageResponse_INVALID_IMAGE_NAME   WatchImageResponse_ErrorType = 1
	WatchImageResponse_NO_VALID_INTEGRATION WatchImageResponse_ErrorType = 2
	WatchImageResponse_SCAN_FAILED          WatchImageResponse_ErrorType = 3
)

var WatchImageResponse_ErrorType_name = map[int32]string{
	0: "NO_ERROR",
	1: "INVALID_IMAGE_NAME",
	2: "NO_VALID_INTEGRATION",
	3: "SCAN_FAILED",
}

var WatchImageResponse_ErrorType_value = map[string]int32{
	"NO_ERROR":             0,
	"INVALID_IMAGE_NAME":   1,
	"NO_VALID_INTEGRATION": 2,
	"SCAN_FAILED":          3,
}

func (x WatchImageResponse_ErrorType) String() string {
	return proto.EnumName(WatchImageResponse_ErrorType_name, int32(x))
}

func (WatchImageResponse_ErrorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{12, 0}
}

type GetImageRequest struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	IncludeSnoozed       bool     `protobuf:"varint,2,opt,name=include_snoozed,json=includeSnoozed,proto3" json:"include_snoozed,omitempty"`
	StripDescription     bool     `protobuf:"varint,3,opt,name=strip_description,json=stripDescription,proto3" json:"strip_description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetImageRequest) Reset()         { *m = GetImageRequest{} }
func (m *GetImageRequest) String() string { return proto.CompactTextString(m) }
func (*GetImageRequest) ProtoMessage()    {}
func (*GetImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{0}
}
func (m *GetImageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImageRequest.Merge(m, src)
}
func (m *GetImageRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetImageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetImageRequest proto.InternalMessageInfo

func (m *GetImageRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GetImageRequest) GetIncludeSnoozed() bool {
	if m != nil {
		return m.IncludeSnoozed
	}
	return false
}

func (m *GetImageRequest) GetStripDescription() bool {
	if m != nil {
		return m.StripDescription
	}
	return false
}

func (m *GetImageRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetImageRequest) Clone() *GetImageRequest {
	if m == nil {
		return nil
	}
	cloned := new(GetImageRequest)
	*cloned = *m

	return cloned
}

type ListImagesResponse struct {
	Images               []*storage.ListImage `protobuf:"bytes,1,rep,name=images,proto3" json:"images,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ListImagesResponse) Reset()         { *m = ListImagesResponse{} }
func (m *ListImagesResponse) String() string { return proto.CompactTextString(m) }
func (*ListImagesResponse) ProtoMessage()    {}
func (*ListImagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{1}
}
func (m *ListImagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListImagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListImagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListImagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListImagesResponse.Merge(m, src)
}
func (m *ListImagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListImagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListImagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListImagesResponse proto.InternalMessageInfo

func (m *ListImagesResponse) GetImages() []*storage.ListImage {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *ListImagesResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ListImagesResponse) Clone() *ListImagesResponse {
	if m == nil {
		return nil
	}
	cloned := new(ListImagesResponse)
	*cloned = *m

	if m.Images != nil {
		cloned.Images = make([]*storage.ListImage, len(m.Images))
		for idx, v := range m.Images {
			cloned.Images[idx] = v.Clone()
		}
	}
	return cloned
}

type CountImagesResponse struct {
	Count                int32    `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CountImagesResponse) Reset()         { *m = CountImagesResponse{} }
func (m *CountImagesResponse) String() string { return proto.CompactTextString(m) }
func (*CountImagesResponse) ProtoMessage()    {}
func (*CountImagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{2}
}
func (m *CountImagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CountImagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CountImagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CountImagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CountImagesResponse.Merge(m, src)
}
func (m *CountImagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *CountImagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CountImagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CountImagesResponse proto.InternalMessageInfo

func (m *CountImagesResponse) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *CountImagesResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CountImagesResponse) Clone() *CountImagesResponse {
	if m == nil {
		return nil
	}
	cloned := new(CountImagesResponse)
	*cloned = *m

	return cloned
}

type ScanImageRequest struct {
	ImageName      string `protobuf:"bytes,1,opt,name=image_name,json=imageName,proto3" json:"image_name,omitempty"`
	Force          bool   `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	IncludeSnoozed bool   `protobuf:"varint,3,opt,name=include_snoozed,json=includeSnoozed,proto3" json:"include_snoozed,omitempty"`
	// Cluster to delegate scan to, may be the cluster's name or ID.
	Cluster              string   `protobuf:"bytes,4,opt,name=cluster,proto3" json:"cluster,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScanImageRequest) Reset()         { *m = ScanImageRequest{} }
func (m *ScanImageRequest) String() string { return proto.CompactTextString(m) }
func (*ScanImageRequest) ProtoMessage()    {}
func (*ScanImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{3}
}
func (m *ScanImageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanImageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanImageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanImageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanImageRequest.Merge(m, src)
}
func (m *ScanImageRequest) XXX_Size() int {
	return m.Size()
}
func (m *ScanImageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanImageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ScanImageRequest proto.InternalMessageInfo

func (m *ScanImageRequest) GetImageName() string {
	if m != nil {
		return m.ImageName
	}
	return ""
}

func (m *ScanImageRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *ScanImageRequest) GetIncludeSnoozed() bool {
	if m != nil {
		return m.IncludeSnoozed
	}
	return false
}

func (m *ScanImageRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *ScanImageRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ScanImageRequest) Clone() *ScanImageRequest {
	if m == nil {
		return nil
	}
	cloned := new(ScanImageRequest)
	*cloned = *m

	return cloned
}

type ScanImageInternalRequest struct {
	Image                *storage.ContainerImage          `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	CachedOnly           bool                             `protobuf:"varint,3,opt,name=cached_only,json=cachedOnly,proto3" json:"cached_only,omitempty"`
	Source               *ScanImageInternalRequest_Source `protobuf:"bytes,4,opt,name=source,proto3" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *ScanImageInternalRequest) Reset()         { *m = ScanImageInternalRequest{} }
func (m *ScanImageInternalRequest) String() string { return proto.CompactTextString(m) }
func (*ScanImageInternalRequest) ProtoMessage()    {}
func (*ScanImageInternalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{4}
}
func (m *ScanImageInternalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanImageInternalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanImageInternalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanImageInternalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanImageInternalRequest.Merge(m, src)
}
func (m *ScanImageInternalRequest) XXX_Size() int {
	return m.Size()
}
func (m *ScanImageInternalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanImageInternalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ScanImageInternalRequest proto.InternalMessageInfo

func (m *ScanImageInternalRequest) GetImage() *storage.ContainerImage {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *ScanImageInternalRequest) GetCachedOnly() bool {
	if m != nil {
		return m.CachedOnly
	}
	return false
}

func (m *ScanImageInternalRequest) GetSource() *ScanImageInternalRequest_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *ScanImageInternalRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ScanImageInternalRequest) Clone() *ScanImageInternalRequest {
	if m == nil {
		return nil
	}
	cloned := new(ScanImageInternalRequest)
	*cloned = *m

	cloned.Image = m.Image.Clone()
	cloned.Source = m.Source.Clone()
	return cloned
}

type ScanImageInternalRequest_Source struct {
	ClusterId            string   `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	Namespace            string   `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	ImagePullSecrets     []string `protobuf:"bytes,3,rep,name=image_pull_secrets,json=imagePullSecrets,proto3" json:"image_pull_secrets,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScanImageInternalRequest_Source) Reset()         { *m = ScanImageInternalRequest_Source{} }
func (m *ScanImageInternalRequest_Source) String() string { return proto.CompactTextString(m) }
func (*ScanImageInternalRequest_Source) ProtoMessage()    {}
func (*ScanImageInternalRequest_Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{4, 0}
}
func (m *ScanImageInternalRequest_Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanImageInternalRequest_Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanImageInternalRequest_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanImageInternalRequest_Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanImageInternalRequest_Source.Merge(m, src)
}
func (m *ScanImageInternalRequest_Source) XXX_Size() int {
	return m.Size()
}
func (m *ScanImageInternalRequest_Source) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanImageInternalRequest_Source.DiscardUnknown(m)
}

var xxx_messageInfo_ScanImageInternalRequest_Source proto.InternalMessageInfo

func (m *ScanImageInternalRequest_Source) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *ScanImageInternalRequest_Source) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ScanImageInternalRequest_Source) GetImagePullSecrets() []string {
	if m != nil {
		return m.ImagePullSecrets
	}
	return nil
}

func (m *ScanImageInternalRequest_Source) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ScanImageInternalRequest_Source) Clone() *ScanImageInternalRequest_Source {
	if m == nil {
		return nil
	}
	cloned := new(ScanImageInternalRequest_Source)
	*cloned = *m

	if m.ImagePullSecrets != nil {
		cloned.ImagePullSecrets = make([]string, len(m.ImagePullSecrets))
		copy(cloned.ImagePullSecrets, m.ImagePullSecrets)
	}
	return cloned
}

type ScanImageInternalResponse struct {
	Image                *storage.Image `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ScanImageInternalResponse) Reset()         { *m = ScanImageInternalResponse{} }
func (m *ScanImageInternalResponse) String() string { return proto.CompactTextString(m) }
func (*ScanImageInternalResponse) ProtoMessage()    {}
func (*ScanImageInternalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{5}
}
func (m *ScanImageInternalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanImageInternalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanImageInternalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanImageInternalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanImageInternalResponse.Merge(m, src)
}
func (m *ScanImageInternalResponse) XXX_Size() int {
	return m.Size()
}
func (m *ScanImageInternalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanImageInternalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ScanImageInternalResponse proto.InternalMessageInfo

func (m *ScanImageInternalResponse) GetImage() *storage.Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *ScanImageInternalResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ScanImageInternalResponse) Clone() *ScanImageInternalResponse {
	if m == nil {
		return nil
	}
	cloned := new(ScanImageInternalResponse)
	*cloned = *m

	cloned.Image = m.Image.Clone()
	return cloned
}

type GetImageVulnerabilitiesInternalRequest struct {
	ImageId              string                 `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	ImageName            *storage.ImageName     `protobuf:"bytes,2,opt,name=image_name,json=imageName,proto3" json:"image_name,omitempty"`
	Metadata             *storage.ImageMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
	IsClusterLocal       bool                   `protobuf:"varint,6,opt,name=is_cluster_local,json=isClusterLocal,proto3" json:"is_cluster_local,omitempty"`
	Components           *v1.Components         `protobuf:"bytes,4,opt,name=components,proto3" json:"components,omitempty"`
	Notes                []v1.Note              `protobuf:"varint,5,rep,packed,name=notes,proto3,enum=scannerV1.Note" json:"notes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *GetImageVulnerabilitiesInternalRequest) Reset() {
	*m = GetImageVulnerabilitiesInternalRequest{}
}
func (m *GetImageVulnerabilitiesInternalRequest) String() string { return proto.CompactTextString(m) }
func (*GetImageVulnerabilitiesInternalRequest) ProtoMessage()    {}
func (*GetImageVulnerabilitiesInternalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{6}
}
func (m *GetImageVulnerabilitiesInternalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImageVulnerabilitiesInternalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImageVulnerabilitiesInternalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImageVulnerabilitiesInternalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImageVulnerabilitiesInternalRequest.Merge(m, src)
}
func (m *GetImageVulnerabilitiesInternalRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetImageVulnerabilitiesInternalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImageVulnerabilitiesInternalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetImageVulnerabilitiesInternalRequest proto.InternalMessageInfo

func (m *GetImageVulnerabilitiesInternalRequest) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

func (m *GetImageVulnerabilitiesInternalRequest) GetImageName() *storage.ImageName {
	if m != nil {
		return m.ImageName
	}
	return nil
}

func (m *GetImageVulnerabilitiesInternalRequest) GetMetadata() *storage.ImageMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *GetImageVulnerabilitiesInternalRequest) GetIsClusterLocal() bool {
	if m != nil {
		return m.IsClusterLocal
	}
	return false
}

func (m *GetImageVulnerabilitiesInternalRequest) GetComponents() *v1.Components {
	if m != nil {
		return m.Components
	}
	return nil
}

func (m *GetImageVulnerabilitiesInternalRequest) GetNotes() []v1.Note {
	if m != nil {
		return m.Notes
	}
	return nil
}

func (m *GetImageVulnerabilitiesInternalRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetImageVulnerabilitiesInternalRequest) Clone() *GetImageVulnerabilitiesInternalRequest {
	if m == nil {
		return nil
	}
	cloned := new(GetImageVulnerabilitiesInternalRequest)
	*cloned = *m

	cloned.ImageName = m.ImageName.Clone()
	cloned.Metadata = m.Metadata.Clone()
	cloned.Components = m.Components.Clone()
	if m.Notes != nil {
		cloned.Notes = make([]v1.Note, len(m.Notes))
		copy(cloned.Notes, m.Notes)
	}
	return cloned
}

type EnrichLocalImageInternalRequest struct {
	IndexerVersion       string                  `protobuf:"bytes,12,opt,name=indexer_version,json=indexerVersion,proto3" json:"indexer_version,omitempty"`
	ImageId              string                  `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	ImageName            *storage.ImageName      `protobuf:"bytes,2,opt,name=image_name,json=imageName,proto3" json:"image_name,omitempty"`
	Metadata             *storage.ImageMetadata  `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
	ImageSignature       *storage.ImageSignature `protobuf:"bytes,4,opt,name=image_signature,json=imageSignature,proto3" json:"image_signature,omitempty"`
	Components           *v1.Components          `protobuf:"bytes,5,opt,name=components,proto3" json:"components,omitempty"`
	Notes                []v1.Note               `protobuf:"varint,6,rep,packed,name=notes,proto3,enum=scannerV1.Note" json:"notes,omitempty"`
	ImageNotes           []storage.Image_Note    `protobuf:"varint,7,rep,packed,name=image_notes,json=imageNotes,proto3,enum=storage.Image_Note" json:"image_notes,omitempty"`
	Error                string                  `protobuf:"bytes,8,opt,name=error,proto3" json:"error,omitempty"`
	RequestId            string                  `protobuf:"bytes,9,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Force                bool                    `protobuf:"varint,10,opt,name=force,proto3" json:"force,omitempty"`
	V4Contents           *v4.Contents            `protobuf:"bytes,11,opt,name=v4_contents,json=v4Contents,proto3" json:"v4_contents,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *EnrichLocalImageInternalRequest) Reset()         { *m = EnrichLocalImageInternalRequest{} }
func (m *EnrichLocalImageInternalRequest) String() string { return proto.CompactTextString(m) }
func (*EnrichLocalImageInternalRequest) ProtoMessage()    {}
func (*EnrichLocalImageInternalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{7}
}
func (m *EnrichLocalImageInternalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnrichLocalImageInternalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnrichLocalImageInternalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnrichLocalImageInternalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnrichLocalImageInternalRequest.Merge(m, src)
}
func (m *EnrichLocalImageInternalRequest) XXX_Size() int {
	return m.Size()
}
func (m *EnrichLocalImageInternalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EnrichLocalImageInternalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EnrichLocalImageInternalRequest proto.InternalMessageInfo

func (m *EnrichLocalImageInternalRequest) GetIndexerVersion() string {
	if m != nil {
		return m.IndexerVersion
	}
	return ""
}

func (m *EnrichLocalImageInternalRequest) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

func (m *EnrichLocalImageInternalRequest) GetImageName() *storage.ImageName {
	if m != nil {
		return m.ImageName
	}
	return nil
}

func (m *EnrichLocalImageInternalRequest) GetMetadata() *storage.ImageMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *EnrichLocalImageInternalRequest) GetImageSignature() *storage.ImageSignature {
	if m != nil {
		return m.ImageSignature
	}
	return nil
}

func (m *EnrichLocalImageInternalRequest) GetComponents() *v1.Components {
	if m != nil {
		return m.Components
	}
	return nil
}

func (m *EnrichLocalImageInternalRequest) GetNotes() []v1.Note {
	if m != nil {
		return m.Notes
	}
	return nil
}

func (m *EnrichLocalImageInternalRequest) GetImageNotes() []storage.Image_Note {
	if m != nil {
		return m.ImageNotes
	}
	return nil
}

func (m *EnrichLocalImageInternalRequest) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *EnrichLocalImageInternalRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *EnrichLocalImageInternalRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *EnrichLocalImageInternalRequest) GetV4Contents() *v4.Contents {
	if m != nil {
		return m.V4Contents
	}
	return nil
}

func (m *EnrichLocalImageInternalRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *EnrichLocalImageInternalRequest) Clone() *EnrichLocalImageInternalRequest {
	if m == nil {
		return nil
	}
	cloned := new(EnrichLocalImageInternalRequest)
	*cloned = *m

	cloned.ImageName = m.ImageName.Clone()
	cloned.Metadata = m.Metadata.Clone()
	cloned.ImageSignature = m.ImageSignature.Clone()
	cloned.Components = m.Components.Clone()
	if m.Notes != nil {
		cloned.Notes = make([]v1.Note, len(m.Notes))
		copy(cloned.Notes, m.Notes)
	}
	if m.ImageNotes != nil {
		cloned.ImageNotes = make([]storage.Image_Note, len(m.ImageNotes))
		copy(cloned.ImageNotes, m.ImageNotes)
	}
	cloned.V4Contents = m.V4Contents.Clone()
	return cloned
}

type UpdateLocalScanStatusInternalRequest struct {
	RequestId            string   `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Error                string   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateLocalScanStatusInternalRequest) Reset()         { *m = UpdateLocalScanStatusInternalRequest{} }
func (m *UpdateLocalScanStatusInternalRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateLocalScanStatusInternalRequest) ProtoMessage()    {}
func (*UpdateLocalScanStatusInternalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{8}
}
func (m *UpdateLocalScanStatusInternalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLocalScanStatusInternalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLocalScanStatusInternalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLocalScanStatusInternalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLocalScanStatusInternalRequest.Merge(m, src)
}
func (m *UpdateLocalScanStatusInternalRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateLocalScanStatusInternalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLocalScanStatusInternalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLocalScanStatusInternalRequest proto.InternalMessageInfo

func (m *UpdateLocalScanStatusInternalRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *UpdateLocalScanStatusInternalRequest) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *UpdateLocalScanStatusInternalRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *UpdateLocalScanStatusInternalRequest) Clone() *UpdateLocalScanStatusInternalRequest {
	if m == nil {
		return nil
	}
	cloned := new(UpdateLocalScanStatusInternalRequest)
	*cloned = *m

	return cloned
}

type DeleteImagesRequest struct {
	Query                *RawQuery `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Confirm              bool      `protobuf:"varint,2,opt,name=confirm,proto3" json:"confirm,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DeleteImagesRequest) Reset()         { *m = DeleteImagesRequest{} }
func (m *DeleteImagesRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteImagesRequest) ProtoMessage()    {}
func (*DeleteImagesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{9}
}
func (m *DeleteImagesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteImagesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteImagesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteImagesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteImagesRequest.Merge(m, src)
}
func (m *DeleteImagesRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteImagesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteImagesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteImagesRequest proto.InternalMessageInfo

func (m *DeleteImagesRequest) GetQuery() *RawQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *DeleteImagesRequest) GetConfirm() bool {
	if m != nil {
		return m.Confirm
	}
	return false
}

func (m *DeleteImagesRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *DeleteImagesRequest) Clone() *DeleteImagesRequest {
	if m == nil {
		return nil
	}
	cloned := new(DeleteImagesRequest)
	*cloned = *m

	cloned.Query = m.Query.Clone()
	return cloned
}

type DeleteImagesResponse struct {
	NumDeleted           uint32   `protobuf:"varint,1,opt,name=num_deleted,json=numDeleted,proto3" json:"num_deleted,omitempty"`
	DryRun               bool     `protobuf:"varint,2,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteImagesResponse) Reset()         { *m = DeleteImagesResponse{} }
func (m *DeleteImagesResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteImagesResponse) ProtoMessage()    {}
func (*DeleteImagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{10}
}
func (m *DeleteImagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteImagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteImagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteImagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteImagesResponse.Merge(m, src)
}
func (m *DeleteImagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteImagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteImagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteImagesResponse proto.InternalMessageInfo

func (m *DeleteImagesResponse) GetNumDeleted() uint32 {
	if m != nil {
		return m.NumDeleted
	}
	return 0
}

func (m *DeleteImagesResponse) GetDryRun() bool {
	if m != nil {
		return m.DryRun
	}
	return false
}

func (m *DeleteImagesResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *DeleteImagesResponse) Clone() *DeleteImagesResponse {
	if m == nil {
		return nil
	}
	cloned := new(DeleteImagesResponse)
	*cloned = *m

	return cloned
}

type WatchImageRequest struct {
	// The name of the image.
	// This must be fully qualified, including a tag,
	// but must NOT include a SHA.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WatchImageRequest) Reset()         { *m = WatchImageRequest{} }
func (m *WatchImageRequest) String() string { return proto.CompactTextString(m) }
func (*WatchImageRequest) ProtoMessage()    {}
func (*WatchImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{11}
}
func (m *WatchImageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchImageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchImageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchImageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchImageRequest.Merge(m, src)
}
func (m *WatchImageRequest) XXX_Size() int {
	return m.Size()
}
func (m *WatchImageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchImageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WatchImageRequest proto.InternalMessageInfo

func (m *WatchImageRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WatchImageRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *WatchImageRequest) Clone() *WatchImageRequest {
	if m == nil {
		return nil
	}
	cloned := new(WatchImageRequest)
	*cloned = *m

	return cloned
}

type WatchImageResponse struct {
	// If the image was scanned successfully, this returns the normalized name of the image.
	// This depends on what we get from the registry.
	// For example, "docker.io/wordpress:latest" -> "docker.io/library/wordpress:latest"
	NormalizedName string                       `protobuf:"bytes,1,opt,name=normalized_name,json=normalizedName,proto3" json:"normalized_name,omitempty"`
	ErrorType      WatchImageResponse_ErrorType `protobuf:"varint,2,opt,name=error_type,json=errorType,proto3,enum=v1.WatchImageResponse_ErrorType" json:"error_type,omitempty"`
	// Only set if error_type is NOT equal to "NO_ERROR".
	ErrorMessage         string   `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WatchImageResponse) Reset()         { *m = WatchImageResponse{} }
func (m *WatchImageResponse) String() string { return proto.CompactTextString(m) }
func (*WatchImageResponse) ProtoMessage()    {}
func (*WatchImageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{12}
}
func (m *WatchImageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchImageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchImageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchImageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchImageResponse.Merge(m, src)
}
func (m *WatchImageResponse) XXX_Size() int {
	return m.Size()
}
func (m *WatchImageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchImageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WatchImageResponse proto.InternalMessageInfo

func (m *WatchImageResponse) GetNormalizedName() string {
	if m != nil {
		return m.NormalizedName
	}
	return ""
}

func (m *WatchImageResponse) GetErrorType() WatchImageResponse_ErrorType {
	if m != nil {
		return m.ErrorType
	}
	return WatchImageResponse_NO_ERROR
}

func (m *WatchImageResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *WatchImageResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *WatchImageResponse) Clone() *WatchImageResponse {
	if m == nil {
		return nil
	}
	cloned := new(WatchImageResponse)
	*cloned = *m

	return cloned
}

type UnwatchImageRequest struct {
	// The name of the image to unwatch.
	// Should match the name of a previously watched image.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnwatchImageRequest) Reset()         { *m = UnwatchImageRequest{} }
func (m *UnwatchImageRequest) String() string { return proto.CompactTextString(m) }
func (*UnwatchImageRequest) ProtoMessage()    {}
func (*UnwatchImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{13}
}
func (m *UnwatchImageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnwatchImageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnwatchImageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnwatchImageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnwatchImageRequest.Merge(m, src)
}
func (m *UnwatchImageRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnwatchImageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnwatchImageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnwatchImageRequest proto.InternalMessageInfo

func (m *UnwatchImageRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UnwatchImageRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *UnwatchImageRequest) Clone() *UnwatchImageRequest {
	if m == nil {
		return nil
	}
	cloned := new(UnwatchImageRequest)
	*cloned = *m

	return cloned
}

type GetWatchedImagesResponse struct {
	WatchedImages        []*storage.WatchedImage `protobuf:"bytes,1,rep,name=watched_images,json=watchedImages,proto3" json:"watched_images,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *GetWatchedImagesResponse) Reset()         { *m = GetWatchedImagesResponse{} }
func (m *GetWatchedImagesResponse) String() string { return proto.CompactTextString(m) }
func (*GetWatchedImagesResponse) ProtoMessage()    {}
func (*GetWatchedImagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{14}
}
func (m *GetWatchedImagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWatchedImagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWatchedImagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWatchedImagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWatchedImagesResponse.Merge(m, src)
}
func (m *GetWatchedImagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWatchedImagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWatchedImagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWatchedImagesResponse proto.InternalMessageInfo

func (m *GetWatchedImagesResponse) GetWatchedImages() []*storage.WatchedImage {
	if m != nil {
		return m.WatchedImages
	}
	return nil
}

func (m *GetWatchedImagesResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetWatchedImagesResponse) Clone() *GetWatchedImagesResponse {
	if m == nil {
		return nil
	}
	cloned := new(GetWatchedImagesResponse)
	*cloned = *m

	if m.WatchedImages != nil {
		cloned.WatchedImages = make([]*storage.WatchedImage, len(m.WatchedImages))
		for idx, v := range m.WatchedImages {
			cloned.WatchedImages[idx] = v.Clone()
		}
	}
	return cloned
}

// ScanImageInternalResponseDetails contains proto messages that are added to details
// when returning errors from the ScanImageInternal endpoint.
type ScanImageInternalResponseDetails struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScanImageInternalResponseDetails) Reset()         { *m = ScanImageInternalResponseDetails{} }
func (m *ScanImageInternalResponseDetails) String() string { return proto.CompactTextString(m) }
func (*ScanImageInternalResponseDetails) ProtoMessage()    {}
func (*ScanImageInternalResponseDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{15}
}
func (m *ScanImageInternalResponseDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanImageInternalResponseDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanImageInternalResponseDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanImageInternalResponseDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanImageInternalResponseDetails.Merge(m, src)
}
func (m *ScanImageInternalResponseDetails) XXX_Size() int {
	return m.Size()
}
func (m *ScanImageInternalResponseDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanImageInternalResponseDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ScanImageInternalResponseDetails proto.InternalMessageInfo

func (m *ScanImageInternalResponseDetails) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ScanImageInternalResponseDetails) Clone() *ScanImageInternalResponseDetails {
	if m == nil {
		return nil
	}
	cloned := new(ScanImageInternalResponseDetails)
	*cloned = *m

	return cloned
}

// TooManyParallelScans tells sensor that there are too many parallel scans, and that it will need to
// retry later.
type ScanImageInternalResponseDetails_TooManyParallelScans struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScanImageInternalResponseDetails_TooManyParallelScans) Reset() {
	*m = ScanImageInternalResponseDetails_TooManyParallelScans{}
}
func (m *ScanImageInternalResponseDetails_TooManyParallelScans) String() string {
	return proto.CompactTextString(m)
}
func (*ScanImageInternalResponseDetails_TooManyParallelScans) ProtoMessage() {}
func (*ScanImageInternalResponseDetails_TooManyParallelScans) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{15, 0}
}
func (m *ScanImageInternalResponseDetails_TooManyParallelScans) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanImageInternalResponseDetails_TooManyParallelScans) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanImageInternalResponseDetails_TooManyParallelScans.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanImageInternalResponseDetails_TooManyParallelScans) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanImageInternalResponseDetails_TooManyParallelScans.Merge(m, src)
}
func (m *ScanImageInternalResponseDetails_TooManyParallelScans) XXX_Size() int {
	return m.Size()
}
func (m *ScanImageInternalResponseDetails_TooManyParallelScans) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanImageInternalResponseDetails_TooManyParallelScans.DiscardUnknown(m)
}

var xxx_messageInfo_ScanImageInternalResponseDetails_TooManyParallelScans proto.InternalMessageInfo

func (m *ScanImageInternalResponseDetails_TooManyParallelScans) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ScanImageInternalResponseDetails_TooManyParallelScans) Clone() *ScanImageInternalResponseDetails_TooManyParallelScans {
	if m == nil {
		return nil
	}
	cloned := new(ScanImageInternalResponseDetails_TooManyParallelScans)
	*cloned = *m

	return cloned
}

type ExportImageRequest struct {
	Timeout              int32    `protobuf:"varint,1,opt,name=timeout,proto3" json:"timeout,omitempty"`
	Query                string   `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExportImageRequest) Reset()         { *m = ExportImageRequest{} }
func (m *ExportImageRequest) String() string { return proto.CompactTextString(m) }
func (*ExportImageRequest) ProtoMessage()    {}
func (*ExportImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{16}
}
func (m *ExportImageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportImageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportImageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportImageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportImageRequest.Merge(m, src)
}
func (m *ExportImageRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExportImageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportImageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExportImageRequest proto.InternalMessageInfo

func (m *ExportImageRequest) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *ExportImageRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *ExportImageRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ExportImageRequest) Clone() *ExportImageRequest {
	if m == nil {
		return nil
	}
	cloned := new(ExportImageRequest)
	*cloned = *m

	return cloned
}

type ExportImageResponse struct {
	Image                *storage.Image `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ExportImageResponse) Reset()         { *m = ExportImageResponse{} }
func (m *ExportImageResponse) String() string { return proto.CompactTextString(m) }
func (*ExportImageResponse) ProtoMessage()    {}
func (*ExportImageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4306cfe43028263, []int{17}
}
func (m *ExportImageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportImageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportImageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportImageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportImageResponse.Merge(m, src)
}
func (m *ExportImageResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExportImageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportImageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExportImageResponse proto.InternalMessageInfo

func (m *ExportImageResponse) GetImage() *storage.Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *ExportImageResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ExportImageResponse) Clone() *ExportImageResponse {
	if m == nil {
		return nil
	}
	cloned := new(ExportImageResponse)
	*cloned = *m

	cloned.Image = m.Image.Clone()
	return cloned
}

func init() {
	proto.RegisterEnum("v1.WatchImageResponse_ErrorType", WatchImageResponse_ErrorType_name, WatchImageResponse_ErrorType_value)
	proto.RegisterType((*GetImageRequest)(nil), "v1.GetImageRequest")
	proto.RegisterType((*ListImagesResponse)(nil), "v1.ListImagesResponse")
	proto.RegisterType((*CountImagesResponse)(nil), "v1.CountImagesResponse")
	proto.RegisterType((*ScanImageRequest)(nil), "v1.ScanImageRequest")
	proto.RegisterType((*ScanImageInternalRequest)(nil), "v1.ScanImageInternalRequest")
	proto.RegisterType((*ScanImageInternalRequest_Source)(nil), "v1.ScanImageInternalRequest.Source")
	proto.RegisterType((*ScanImageInternalResponse)(nil), "v1.ScanImageInternalResponse")
	proto.RegisterType((*GetImageVulnerabilitiesInternalRequest)(nil), "v1.GetImageVulnerabilitiesInternalRequest")
	proto.RegisterType((*EnrichLocalImageInternalRequest)(nil), "v1.EnrichLocalImageInternalRequest")
	proto.RegisterType((*UpdateLocalScanStatusInternalRequest)(nil), "v1.UpdateLocalScanStatusInternalRequest")
	proto.RegisterType((*DeleteImagesRequest)(nil), "v1.DeleteImagesRequest")
	proto.RegisterType((*DeleteImagesResponse)(nil), "v1.DeleteImagesResponse")
	proto.RegisterType((*WatchImageRequest)(nil), "v1.WatchImageRequest")
	proto.RegisterType((*WatchImageResponse)(nil), "v1.WatchImageResponse")
	proto.RegisterType((*UnwatchImageRequest)(nil), "v1.UnwatchImageRequest")
	proto.RegisterType((*GetWatchedImagesResponse)(nil), "v1.GetWatchedImagesResponse")
	proto.RegisterType((*ScanImageInternalResponseDetails)(nil), "v1.ScanImageInternalResponseDetails")
	proto.RegisterType((*ScanImageInternalResponseDetails_TooManyParallelScans)(nil), "v1.ScanImageInternalResponseDetails.TooManyParallelScans")
	proto.RegisterType((*ExportImageRequest)(nil), "v1.ExportImageRequest")
	proto.RegisterType((*ExportImageResponse)(nil), "v1.ExportImageResponse")
}

func init() { proto.RegisterFile("api/v1/image_service.proto", fileDescriptor_b4306cfe43028263) }

var fileDescriptor_b4306cfe43028263 = []byte{
	// 1585 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x4f, 0x73, 0xe3, 0x48,
	0x15, 0x5f, 0xdb, 0x71, 0x12, 0x3f, 0x7b, 0x1c, 0xa7, 0xed, 0x49, 0x14, 0x6f, 0xfe, 0x95, 0xb2,
	0x30, 0x21, 0x0b, 0x36, 0x09, 0xd9, 0xcb, 0x2e, 0x55, 0xac, 0x49, 0xbc, 0xc1, 0x54, 0xec, 0x04,
	0x39, 0x13, 0x16, 0x98, 0x42, 0xd5, 0x2b, 0xf5, 0x26, 0x2a, 0xe4, 0x6e, 0x8f, 0x5a, 0x72, 0xc6,
	0x4b, 0x71, 0x80, 0x13, 0xc5, 0x95, 0x0b, 0x67, 0x8a, 0x4f, 0xc0, 0xa7, 0xe0, 0x44, 0x51, 0xc5,
	0x17, 0xa0, 0x06, 0x3e, 0x08, 0xd5, 0x7f, 0x64, 0x4b, 0x8e, 0x93, 0xec, 0xdc, 0xf6, 0xa6, 0x7e,
	0x7f, 0x7e, 0xfd, 0xde, 0xeb, 0xd7, 0xbf, 0x7e, 0x82, 0x3a, 0x1e, 0x7a, 0xcd, 0xd1, 0x61, 0xd3,
	0x1b, 0xe0, 0x1b, 0x62, 0x73, 0x12, 0x8c, 0x3c, 0x87, 0x34, 0x86, 0x01, 0x0b, 0x19, 0xca, 0x8e,
	0x0e, 0xeb, 0x48, 0xeb, 0xc9, 0x60, 0x18, 0x8e, 0x95, 0xbc, 0xfe, 0xbe, 0x96, 0x71, 0x82, 0x03,
	0xe7, 0x36, 0xed, 0x54, 0xdf, 0xbc, 0x61, 0xec, 0xc6, 0x27, 0x4d, 0x61, 0x83, 0x29, 0x65, 0x21,
	0x0e, 0x3d, 0x46, 0xb9, 0xd6, 0xee, 0x79, 0x34, 0x24, 0x01, 0xc5, 0xbe, 0x50, 0x73, 0x07, 0x53,
	0x4a, 0x82, 0xe6, 0xe8, 0xb8, 0xe9, 0xb0, 0xc1, 0x80, 0x51, 0x6d, 0xb4, 0x1d, 0x2b, 0xf4, 0x3e,
	0x0e, 0x1b, 0x0c, 0x19, 0x25, 0x34, 0xd4, 0xfa, 0x8d, 0x19, 0x3d, 0x65, 0x61, 0xbc, 0xbb, 0xc1,
	0x43, 0x16, 0xe0, 0x1b, 0xd2, 0x74, 0xc9, 0xd0, 0x67, 0xe3, 0xc1, 0xd4, 0xa9, 0x1a, 0x6b, 0x64,
	0xa6, 0x4a, 0x68, 0xde, 0xc1, 0xca, 0x19, 0x09, 0x3b, 0x42, 0x62, 0x91, 0xd7, 0x11, 0xe1, 0x21,
	0x2a, 0x43, 0xd6, 0x73, 0x8d, 0xcc, 0x6e, 0x66, 0xbf, 0x60, 0x65, 0x3d, 0x17, 0xbd, 0x80, 0x15,
	0x8f, 0x3a, 0x7e, 0xe4, 0x12, 0x9b, 0x53, 0xc6, 0xbe, 0x22, 0xae, 0x91, 0xdd, 0xcd, 0xec, 0x2f,
	0x5b, 0x65, 0x2d, 0xee, 0x2b, 0x29, 0xfa, 0x10, 0x56, 0x79, 0x18, 0x78, 0x43, 0xdb, 0x25, 0xdc,
	0x09, 0xbc, 0xa1, 0x48, 0xdb, 0xc8, 0x49, 0xd3, 0x8a, 0x54, 0x9c, 0x4e, 0xe5, 0xe6, 0xa7, 0x80,
	0xce, 0x3d, 0xae, 0x76, 0xe6, 0x16, 0xe1, 0x43, 0x46, 0x39, 0x41, 0x07, 0xb0, 0x28, 0xa3, 0xe3,
	0x46, 0x66, 0x37, 0xb7, 0x5f, 0x3c, 0x42, 0x0d, 0x1d, 0x74, 0x63, 0x62, 0x6c, 0x69, 0x0b, 0xf3,
	0x43, 0xa8, 0x9e, 0xb0, 0x88, 0xce, 0x42, 0xd4, 0x20, 0xef, 0x08, 0xb1, 0xcc, 0x20, 0x6f, 0xa9,
	0x85, 0xf9, 0xa7, 0x0c, 0x54, 0xfa, 0x0e, 0xa6, 0xa9, 0x4c, 0xb7, 0x00, 0xd4, 0xa9, 0x53, 0x3c,
	0x20, 0x3a, 0xe3, 0x82, 0x94, 0xf4, 0xf0, 0x40, 0x22, 0x7d, 0xc9, 0x02, 0x87, 0xe8, 0x74, 0xd5,
	0x62, 0x5e, 0x39, 0x72, 0x73, 0xcb, 0x61, 0xc0, 0x92, 0xe3, 0x47, 0x3c, 0x24, 0x81, 0xb1, 0x20,
	0xa1, 0xe3, 0xa5, 0xf9, 0xd7, 0x2c, 0x18, 0x93, 0x60, 0x3a, 0xba, 0x1f, 0xe2, 0xa0, 0xbe, 0x07,
	0x79, 0x19, 0x82, 0x8c, 0xa7, 0x78, 0xb4, 0x3e, 0xa9, 0xc0, 0x09, 0xa3, 0x21, 0xf6, 0x28, 0x09,
	0x54, 0x0e, 0xca, 0x0a, 0xed, 0x40, 0xd1, 0xc1, 0xce, 0x2d, 0x71, 0x6d, 0x46, 0xfd, 0xb1, 0x0e,
	0x05, 0x94, 0xe8, 0x82, 0xfa, 0x63, 0xf4, 0x09, 0x2c, 0x72, 0x16, 0x89, 0x34, 0x16, 0x24, 0xe0,
	0x5e, 0x63, 0x74, 0xd8, 0x78, 0x68, 0xf7, 0x46, 0x5f, 0x9a, 0x5a, 0xda, 0xa5, 0xce, 0x61, 0x51,
	0x49, 0x44, 0xad, 0x74, 0xf8, 0xf6, 0xa4, 0x3b, 0x0a, 0x5a, 0xd2, 0x71, 0xd1, 0x26, 0x14, 0x44,
	0x11, 0xf9, 0x10, 0xeb, 0x7a, 0x15, 0xac, 0xa9, 0x00, 0x7d, 0x17, 0x90, 0x2a, 0xf4, 0x30, 0xf2,
	0x7d, 0x9b, 0x13, 0x27, 0x20, 0x21, 0x37, 0x72, 0xbb, 0xb9, 0xfd, 0x82, 0x55, 0x91, 0x9a, 0xcb,
	0xc8, 0xf7, 0xfb, 0x4a, 0xfe, 0xd3, 0x85, 0xe5, 0x6c, 0x25, 0x67, 0xb6, 0x60, 0x63, 0x4e, 0x94,
	0xfa, 0x90, 0x3f, 0x48, 0x17, 0xa9, 0x3c, 0x29, 0x52, 0xb2, 0x36, 0xe6, 0xdf, 0xb3, 0xf0, 0xed,
	0xb8, 0xbb, 0xaf, 0x23, 0x9f, 0x92, 0x00, 0x7f, 0xe1, 0xf9, 0x5e, 0xe8, 0x11, 0x3e, 0x5b, 0xf5,
	0x0d, 0x58, 0x56, 0x11, 0x4e, 0x92, 0x5b, 0x92, 0xeb, 0x8e, 0x8b, 0x0e, 0x53, 0x5d, 0x92, 0x95,
	0x1b, 0xa2, 0xf4, 0x86, 0xa2, 0x5d, 0x92, 0x9d, 0x73, 0x04, 0xcb, 0x03, 0x12, 0x62, 0x17, 0x87,
	0x58, 0x9e, 0x48, 0xf1, 0x68, 0x2d, 0xed, 0xd0, 0xd5, 0x5a, 0x6b, 0x62, 0x87, 0xf6, 0xa1, 0xe2,
	0x71, 0x3b, 0xae, 0xb1, 0xcf, 0x1c, 0xec, 0x1b, 0x8b, 0xba, 0xb1, 0xf8, 0x89, 0x12, 0x9f, 0x0b,
	0x29, 0xfa, 0x08, 0x60, 0x42, 0x08, 0x5c, 0x9f, 0xea, 0xf3, 0x86, 0xa6, 0x84, 0xeb, 0xc3, 0xc6,
	0xc9, 0x44, 0x69, 0x25, 0x0c, 0xd1, 0xb7, 0x20, 0x2f, 0x78, 0x82, 0x1b, 0xf9, 0xdd, 0xdc, 0x7e,
	0xf9, 0x68, 0x25, 0xe1, 0xd1, 0x63, 0x21, 0xb1, 0x94, 0xd6, 0xfc, 0xdb, 0x02, 0xec, 0xb4, 0x69,
	0xe0, 0x39, 0xb7, 0x72, 0xb7, 0xb9, 0x3d, 0x2a, 0xef, 0x80, 0x4b, 0xde, 0x90, 0xc0, 0x1e, 0x91,
	0x80, 0x8b, 0x7b, 0x5e, 0x92, 0x45, 0x2b, 0x6b, 0xf1, 0xb5, 0x92, 0x7e, 0x03, 0xca, 0xfa, 0x29,
	0xac, 0x68, 0x66, 0xf7, 0x6e, 0x28, 0x0e, 0xa3, 0x20, 0xbe, 0x07, 0xeb, 0x69, 0xd7, 0x7e, 0xac,
	0xb6, 0xca, 0x5e, 0x6a, 0x3d, 0x53, 0xee, 0xfc, 0x3b, 0x97, 0x7b, 0xf1, 0xb1, 0x72, 0xa3, 0x63,
	0x28, 0xea, 0x32, 0x48, 0xe3, 0x25, 0x69, 0x5c, 0x4d, 0xc7, 0xa6, 0x1c, 0x54, 0xb9, 0x7a, 0xd2,
	0xab, 0x06, 0x79, 0x12, 0x04, 0x2c, 0x30, 0x96, 0x65, 0x51, 0xd5, 0x42, 0xdc, 0xd1, 0x40, 0x9d,
	0x90, 0xa8, 0x77, 0x41, 0xdd, 0x42, 0x2d, 0xe9, 0xb8, 0x53, 0x3e, 0x83, 0x24, 0x9f, 0x7d, 0x04,
	0xc5, 0xd1, 0xb1, 0xed, 0x30, 0x1a, 0xca, 0xfc, 0x8a, 0x32, 0xbf, 0x5a, 0x1c, 0x6d, 0x63, 0x74,
	0x2c, 0x89, 0x47, 0xa5, 0x37, 0x3a, 0x8e, 0xbf, 0xcd, 0x5f, 0xc1, 0x07, 0x2f, 0x87, 0x2e, 0x0e,
	0x89, 0xec, 0x12, 0x71, 0x53, 0xfb, 0x21, 0x0e, 0xa3, 0x7b, 0x17, 0x2b, 0x1d, 0x53, 0x66, 0x4e,
	0x4c, 0x2a, 0x91, 0x6c, 0x22, 0x11, 0xb3, 0x0f, 0xd5, 0x53, 0xe2, 0x93, 0x90, 0xc4, 0xdc, 0xae,
	0xb0, 0x4c, 0xc8, 0xbf, 0x8e, 0x48, 0x30, 0xd6, 0xb7, 0xbe, 0x24, 0x98, 0xcc, 0xc2, 0x77, 0x3f,
	0x13, 0x32, 0x4b, 0xa9, 0x24, 0xeb, 0x32, 0xfa, 0xa5, 0x17, 0x0c, 0x34, 0x6d, 0xc7, 0x4b, 0xf3,
	0x12, 0x6a, 0x69, 0x50, 0xcd, 0x25, 0x3b, 0x50, 0xa4, 0xd1, 0xc0, 0x76, 0xa5, 0x4e, 0x85, 0xf8,
	0xcc, 0x02, 0x1a, 0x0d, 0x94, 0xb5, 0x8b, 0xd6, 0x61, 0xc9, 0x0d, 0xc6, 0x76, 0x10, 0x51, 0x0d,
	0xb9, 0xe8, 0x06, 0x63, 0x2b, 0xa2, 0xe6, 0x0b, 0x58, 0xfd, 0x39, 0x0e, 0x9d, 0xdb, 0xd4, 0xa3,
	0x82, 0x60, 0x21, 0xf1, 0x9c, 0xc8, 0x6f, 0xf3, 0xf7, 0x59, 0x40, 0x49, 0x4b, 0xbd, 0xf3, 0x0b,
	0x58, 0xa1, 0x2c, 0x18, 0x60, 0xdf, 0xfb, 0x8a, 0xb8, 0xc9, 0x47, 0xa8, 0x3c, 0x15, 0xcb, 0xc6,
	0xff, 0x11, 0x80, 0x2c, 0x8c, 0x1d, 0x8e, 0x87, 0xea, 0xae, 0x94, 0x8f, 0x76, 0x45, 0xf6, 0xf7,
	0x41, 0x1b, 0x6d, 0x61, 0x78, 0x35, 0x1e, 0x12, 0xab, 0x40, 0xe2, 0x4f, 0xb4, 0x07, 0xcf, 0x14,
	0xc0, 0x80, 0x70, 0x2e, 0x78, 0x33, 0x27, 0xf7, 0x29, 0x49, 0x61, 0x57, 0xc9, 0xcc, 0x57, 0x50,
	0x98, 0x38, 0xa3, 0x12, 0x2c, 0xf7, 0x2e, 0xec, 0xb6, 0x65, 0x5d, 0x58, 0x95, 0xf7, 0xd0, 0x1a,
	0xa0, 0x4e, 0xef, 0xba, 0x75, 0xde, 0x39, 0xb5, 0x3b, 0xdd, 0xd6, 0x59, 0xdb, 0xee, 0xb5, 0xba,
	0xed, 0x4a, 0x06, 0x19, 0x50, 0xeb, 0x5d, 0xd8, 0x5a, 0xd1, 0xbb, 0x6a, 0x9f, 0x59, 0xad, 0xab,
	0xce, 0x45, 0xaf, 0x92, 0x45, 0x2b, 0x50, 0xec, 0x9f, 0xb4, 0x7a, 0xf6, 0x67, 0xad, 0xce, 0x79,
	0xfb, 0xb4, 0x92, 0x33, 0xbf, 0x03, 0xd5, 0x97, 0xf4, 0xee, 0x6b, 0x95, 0xeb, 0x73, 0x30, 0xce,
	0x48, 0x28, 0x73, 0x23, 0xee, 0xcc, 0x69, 0xfd, 0x10, 0xca, 0x77, 0x4a, 0x61, 0xa7, 0x26, 0x85,
	0xe7, 0x93, 0x2b, 0x93, 0xf4, 0xb3, 0x9e, 0xdd, 0x25, 0x51, 0xcc, 0x8f, 0x61, 0xf7, 0xc1, 0x47,
	0xe5, 0x94, 0x84, 0xd8, 0xf3, 0x79, 0x7d, 0x0d, 0x6a, 0x57, 0x8c, 0x75, 0x31, 0x1d, 0x5f, 0xe2,
	0x00, 0xfb, 0x3e, 0x91, 0xdd, 0xcd, 0xcd, 0x53, 0x40, 0xed, 0x37, 0x43, 0x16, 0xa4, 0xa7, 0x25,
	0x03, 0x96, 0x42, 0x6f, 0x40, 0x58, 0x14, 0x0f, 0x1c, 0xf1, 0x52, 0xb4, 0xb6, 0xea, 0x56, 0xdd,
	0xda, 0x72, 0x61, 0x7e, 0x02, 0xd5, 0x14, 0xca, 0xbb, 0x3c, 0x68, 0x47, 0xff, 0x2c, 0x40, 0x49,
	0xb1, 0x95, 0x9a, 0x38, 0xd1, 0x4f, 0x60, 0x39, 0x7e, 0xe0, 0x50, 0x55, 0x34, 0xc4, 0xcc, 0x30,
	0x57, 0x9f, 0x01, 0x32, 0xd7, 0xff, 0xf0, 0xef, 0xff, 0xfd, 0x39, 0xbb, 0x8a, 0x56, 0x26, 0x23,
	0x2f, 0x6f, 0xfe, 0xd6, 0x73, 0x7f, 0x87, 0xba, 0x50, 0x4c, 0x4c, 0x53, 0x28, 0x75, 0xb7, 0xea,
	0xeb, 0x62, 0x35, 0x67, 0xd8, 0x9a, 0x07, 0x27, 0xe7, 0x2d, 0xf4, 0x19, 0xc0, 0x74, 0xbc, 0x9b,
	0x41, 0x5b, 0x13, 0xab, 0xfb, 0xc3, 0x9f, 0x89, 0x24, 0x58, 0x09, 0xc1, 0x14, 0x0c, 0x75, 0xa1,
	0x30, 0x39, 0x30, 0x54, 0x4b, 0x8d, 0x2e, 0x0f, 0xa5, 0x58, 0x97, 0x30, 0x35, 0x33, 0x99, 0xa2,
	0x60, 0xb3, 0x8f, 0x33, 0x07, 0xe8, 0x12, 0x56, 0xef, 0x9d, 0x3f, 0xda, 0x7c, 0x6c, 0x22, 0xaa,
	0x6f, 0x3d, 0xa0, 0xd5, 0x07, 0xf7, 0x1a, 0x76, 0x9e, 0x18, 0x31, 0xd0, 0x41, 0xf2, 0x60, 0x1e,
	0x9f, 0x43, 0x9e, 0xd8, 0xcd, 0xcc, 0xfd, 0x31, 0x9b, 0x41, 0xbf, 0x06, 0xe3, 0xa1, 0x07, 0x1a,
	0xc9, 0xe9, 0xee, 0x89, 0xe7, 0xfb, 0xa9, 0x94, 0xae, 0x60, 0xeb, 0x51, 0x6a, 0x47, 0xfb, 0xc2,
	0xff, 0xeb, 0xb0, 0x7f, 0xbd, 0x20, 0xc3, 0x11, 0x7f, 0x4e, 0xe8, 0x15, 0xec, 0x74, 0xe8, 0x08,
	0xfb, 0x9e, 0x70, 0x13, 0x1e, 0x2d, 0xea, 0x5a, 0xe4, 0xc6, 0xe3, 0x61, 0x30, 0x3e, 0x11, 0xe3,
	0x2a, 0x47, 0x53, 0xeb, 0x84, 0xa3, 0xb9, 0x27, 0xcf, 0x73, 0x0b, 0xbd, 0x9f, 0x38, 0x4f, 0x39,
	0xdf, 0x36, 0xbd, 0x09, 0x1e, 0x7a, 0x09, 0xa5, 0x24, 0xb9, 0x23, 0xd9, 0xb1, 0x73, 0xde, 0x90,
	0xba, 0x71, 0x5f, 0x91, 0x6e, 0xbf, 0x83, 0x64, 0xfb, 0xfd, 0x02, 0x60, 0x4a, 0xb1, 0xe8, 0xf9,
	0x2c, 0xe5, 0x2a, 0xc8, 0xb5, 0xf9, 0x4c, 0x6c, 0x6e, 0x4a, 0xc0, 0x35, 0x73, 0x55, 0x00, 0x6a,
	0x1e, 0x52, 0xb8, 0xa2, 0x15, 0xbb, 0x50, 0x4a, 0xf2, 0xa1, 0x8a, 0x78, 0x0e, 0x43, 0x26, 0x4b,
	0xb1, 0x21, 0x11, 0xab, 0x07, 0xf7, 0x11, 0xd1, 0x35, 0x54, 0x66, 0x39, 0x33, 0x59, 0xcf, 0x4d,
	0xdd, 0x83, 0x73, 0x49, 0x35, 0xc6, 0x45, 0x73, 0x70, 0x5f, 0x41, 0x29, 0xc1, 0x57, 0x1c, 0xc9,
	0x64, 0xef, 0xf3, 0xa0, 0xa2, 0x88, 0x39, 0xcc, 0x96, 0xc6, 0x26, 0xd2, 0x40, 0x57, 0xf7, 0xfb,
	0x99, 0x1f, 0x37, 0xfe, 0xf1, 0x76, 0x3b, 0xf3, 0xaf, 0xb7, 0xdb, 0x99, 0xff, 0xbc, 0xdd, 0xce,
	0xfc, 0xe5, 0xbf, 0xdb, 0xef, 0x81, 0xe1, 0xb1, 0x06, 0x0f, 0xb1, 0xf3, 0x9b, 0x80, 0xbd, 0x51,
	0xff, 0xa8, 0x0d, 0x3c, 0xf4, 0x1a, 0xa3, 0xc3, 0x5f, 0x66, 0x47, 0x87, 0x9f, 0x67, 0xbf, 0x58,
	0x94, 0xb2, 0x1f, 0xfc, 0x3f, 0x00, 0x00, 0xff, 0xff, 0x65, 0x20, 0x5c, 0x92, 0xb7, 0x0f, 0x00,
	0x00,
}

func (m *GetImageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StripDescription {
		i--
		if m.StripDescription {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IncludeSnoozed {
		i--
		if m.IncludeSnoozed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListImagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListImagesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListImagesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Images) > 0 {
		for iNdEx := len(m.Images) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Images[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintImageService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CountImagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountImagesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CountImagesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintImageService(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ScanImageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanImageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanImageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cluster) > 0 {
		i -= len(m.Cluster)
		copy(dAtA[i:], m.Cluster)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.Cluster)))
		i--
		dAtA[i] = 0x22
	}
	if m.IncludeSnoozed {
		i--
		if m.IncludeSnoozed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ImageName) > 0 {
		i -= len(m.ImageName)
		copy(dAtA[i:], m.ImageName)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.ImageName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScanImageInternalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanImageInternalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanImageInternalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Source != nil {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CachedOnly {
		i--
		if m.CachedOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScanImageInternalRequest_Source) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanImageInternalRequest_Source) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanImageInternalRequest_Source) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ImagePullSecrets) > 0 {
		for iNdEx := len(m.ImagePullSecrets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ImagePullSecrets[iNdEx])
			copy(dAtA[i:], m.ImagePullSecrets[iNdEx])
			i = encodeVarintImageService(dAtA, i, uint64(len(m.ImagePullSecrets[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScanImageInternalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanImageInternalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanImageInternalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetImageVulnerabilitiesInternalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImageVulnerabilitiesInternalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImageVulnerabilitiesInternalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsClusterLocal {
		i--
		if m.IsClusterLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Notes) > 0 {
		dAtA5 := make([]byte, len(m.Notes)*10)
		var j4 int
		for _, num := range m.Notes {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintImageService(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x2a
	}
	if m.Components != nil {
		{
			size, err := m.Components.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ImageName != nil {
		{
			size, err := m.ImageName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ImageId) > 0 {
		i -= len(m.ImageId)
		copy(dAtA[i:], m.ImageId)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.ImageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnrichLocalImageInternalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnrichLocalImageInternalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnrichLocalImageInternalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexerVersion) > 0 {
		i -= len(m.IndexerVersion)
		copy(dAtA[i:], m.IndexerVersion)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.IndexerVersion)))
		i--
		dAtA[i] = 0x62
	}
	if m.V4Contents != nil {
		{
			size, err := m.V4Contents.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ImageNotes) > 0 {
		dAtA11 := make([]byte, len(m.ImageNotes)*10)
		var j10 int
		for _, num := range m.ImageNotes {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintImageService(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Notes) > 0 {
		dAtA13 := make([]byte, len(m.Notes)*10)
		var j12 int
		for _, num := range m.Notes {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintImageService(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x32
	}
	if m.Components != nil {
		{
			size, err := m.Components.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ImageSignature != nil {
		{
			size, err := m.ImageSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ImageName != nil {
		{
			size, err := m.ImageName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ImageId) > 0 {
		i -= len(m.ImageId)
		copy(dAtA[i:], m.ImageId)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.ImageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateLocalScanStatusInternalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLocalScanStatusInternalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLocalScanStatusInternalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteImagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteImagesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteImagesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Confirm {
		i--
		if m.Confirm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteImagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteImagesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteImagesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DryRun {
		i--
		if m.DryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.NumDeleted != 0 {
		i = encodeVarintImageService(dAtA, i, uint64(m.NumDeleted))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WatchImageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchImageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchImageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WatchImageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchImageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchImageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorType != 0 {
		i = encodeVarintImageService(dAtA, i, uint64(m.ErrorType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NormalizedName) > 0 {
		i -= len(m.NormalizedName)
		copy(dAtA[i:], m.NormalizedName)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.NormalizedName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnwatchImageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnwatchImageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnwatchImageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWatchedImagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWatchedImagesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWatchedImagesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.WatchedImages) > 0 {
		for iNdEx := len(m.WatchedImages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WatchedImages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintImageService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ScanImageInternalResponseDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanImageInternalResponseDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanImageInternalResponseDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ScanImageInternalResponseDetails_TooManyParallelScans) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanImageInternalResponseDetails_TooManyParallelScans) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanImageInternalResponseDetails_TooManyParallelScans) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ExportImageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportImageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportImageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintImageService(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timeout != 0 {
		i = encodeVarintImageService(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExportImageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportImageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportImageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintImageService(dAtA []byte, offset int, v uint64) int {
	offset -= sovImageService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetImageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.IncludeSnoozed {
		n += 2
	}
	if m.StripDescription {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListImagesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Images) > 0 {
		for _, e := range m.Images {
			l = e.Size()
			n += 1 + l + sovImageService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CountImagesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovImageService(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanImageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ImageName)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.IncludeSnoozed {
		n += 2
	}
	l = len(m.Cluster)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanImageInternalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.CachedOnly {
		n += 2
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanImageInternalRequest_Source) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if len(m.ImagePullSecrets) > 0 {
		for _, s := range m.ImagePullSecrets {
			l = len(s)
			n += 1 + l + sovImageService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanImageInternalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetImageVulnerabilitiesInternalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.ImageName != nil {
		l = m.ImageName.Size()
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.Components != nil {
		l = m.Components.Size()
		n += 1 + l + sovImageService(uint64(l))
	}
	if len(m.Notes) > 0 {
		l = 0
		for _, e := range m.Notes {
			l += sovImageService(uint64(e))
		}
		n += 1 + sovImageService(uint64(l)) + l
	}
	if m.IsClusterLocal {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnrichLocalImageInternalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.ImageName != nil {
		l = m.ImageName.Size()
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.ImageSignature != nil {
		l = m.ImageSignature.Size()
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.Components != nil {
		l = m.Components.Size()
		n += 1 + l + sovImageService(uint64(l))
	}
	if len(m.Notes) > 0 {
		l = 0
		for _, e := range m.Notes {
			l += sovImageService(uint64(e))
		}
		n += 1 + sovImageService(uint64(l)) + l
	}
	if len(m.ImageNotes) > 0 {
		l = 0
		for _, e := range m.ImageNotes {
			l += sovImageService(uint64(e))
		}
		n += 1 + sovImageService(uint64(l)) + l
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.V4Contents != nil {
		l = m.V4Contents.Size()
		n += 1 + l + sovImageService(uint64(l))
	}
	l = len(m.IndexerVersion)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateLocalScanStatusInternalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteImagesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.Confirm {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteImagesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumDeleted != 0 {
		n += 1 + sovImageService(uint64(m.NumDeleted))
	}
	if m.DryRun {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WatchImageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WatchImageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NormalizedName)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.ErrorType != 0 {
		n += 1 + sovImageService(uint64(m.ErrorType))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnwatchImageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWatchedImagesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.WatchedImages) > 0 {
		for _, e := range m.WatchedImages {
			l = e.Size()
			n += 1 + l + sovImageService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanImageInternalResponseDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanImageInternalResponseDetails_TooManyParallelScans) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExportImageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timeout != 0 {
		n += 1 + sovImageService(uint64(m.Timeout))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExportImageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovImageService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovImageService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozImageService(x uint64) (n int) {
	return sovImageService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetImageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeSnoozed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeSnoozed = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StripDescription", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StripDescription = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListImagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListImagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListImagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Images = append(m.Images, &storage.ListImage{})
			if err := m.Images[len(m.Images)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountImagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountImagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountImagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanImageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanImageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanImageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeSnoozed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeSnoozed = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanImageInternalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanImageInternalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanImageInternalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &storage.ContainerImage{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CachedOnly = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &ScanImageInternalRequest_Source{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanImageInternalRequest_Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullSecrets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullSecrets = append(m.ImagePullSecrets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanImageInternalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanImageInternalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanImageInternalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &storage.Image{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetImageVulnerabilitiesInternalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImageVulnerabilitiesInternalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImageVulnerabilitiesInternalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageName == nil {
				m.ImageName = &storage.ImageName{}
			}
			if err := m.ImageName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &storage.ImageMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Components == nil {
				m.Components = &v1.Components{}
			}
			if err := m.Components.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v v1.Note
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImageService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= v1.Note(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Notes = append(m.Notes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImageService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImageService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthImageService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Notes) == 0 {
					m.Notes = make([]v1.Note, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v v1.Note
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImageService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= v1.Note(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Notes = append(m.Notes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterLocal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnrichLocalImageInternalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnrichLocalImageInternalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnrichLocalImageInternalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageName == nil {
				m.ImageName = &storage.ImageName{}
			}
			if err := m.ImageName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &storage.ImageMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageSignature == nil {
				m.ImageSignature = &storage.ImageSignature{}
			}
			if err := m.ImageSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Components == nil {
				m.Components = &v1.Components{}
			}
			if err := m.Components.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v v1.Note
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImageService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= v1.Note(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Notes = append(m.Notes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImageService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImageService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthImageService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Notes) == 0 {
					m.Notes = make([]v1.Note, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v v1.Note
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImageService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= v1.Note(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Notes = append(m.Notes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
		case 7:
			if wireType == 0 {
				var v storage.Image_Note
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImageService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= storage.Image_Note(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ImageNotes = append(m.ImageNotes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImageService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImageService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthImageService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ImageNotes) == 0 {
					m.ImageNotes = make([]storage.Image_Note, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v storage.Image_Note
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImageService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= storage.Image_Note(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ImageNotes = append(m.ImageNotes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageNotes", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4Contents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.V4Contents == nil {
				m.V4Contents = &v4.Contents{}
			}
			if err := m.V4Contents.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLocalScanStatusInternalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLocalScanStatusInternalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLocalScanStatusInternalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteImagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteImagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteImagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &RawQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Confirm = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteImagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteImagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteImagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumDeleted", wireType)
			}
			m.NumDeleted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumDeleted |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DryRun = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchImageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchImageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchImageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchImageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchImageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchImageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalizedName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NormalizedName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorType", wireType)
			}
			m.ErrorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorType |= WatchImageResponse_ErrorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnwatchImageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnwatchImageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnwatchImageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWatchedImagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWatchedImagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWatchedImagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WatchedImages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WatchedImages = append(m.WatchedImages, &storage.WatchedImage{})
			if err := m.WatchedImages[len(m.WatchedImages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanImageInternalResponseDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanImageInternalResponseDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanImageInternalResponseDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanImageInternalResponseDetails_TooManyParallelScans) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TooManyParallelScans: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TooManyParallelScans: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportImageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportImageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportImageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportImageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportImageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportImageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &storage.Image{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImageService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImageService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImageService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthImageService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupImageService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthImageService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthImageService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImageService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupImageService = fmt.Errorf("proto: unexpected end of group")
)
