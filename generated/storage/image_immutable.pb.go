// Code generated by protoc-gen-go-immutable. DO NOT EDIT.

package storage

import (
	"iter"
	"time"
)

// ImmutableImage is an immutable interface for Image
type ImmutableImage interface {
	GetId() string
	GetImmutableName() ImmutableImageName
	// This should deprecate the ImageName field long-term, allowing images with the same digest to be associated with
	// different locations.
	// TODO(dhaus): For now, this message will be without search tags due to duplicated search tags otherwise.
	GetImmutableNames() iter.Seq[ImmutableImageName]
	GetImmutableMetadata() ImmutableImageMetadata
	GetImmutableScan() ImmutableImageScan
	GetImmutableSignatureVerificationData() ImmutableImageSignatureVerificationData
	GetImmutableSignature() ImmutableImageSignature
	GetComponents() int32
	GetCves() int32
	GetFixableCves() int32
	GetImmutableLastUpdated() time.Time
	GetNotPullable() bool
	GetIsClusterLocal() bool
	GetPriority() int64
	GetRiskScore() float32
	GetTopCvss() float32
	GetImmutableNotes() iter.Seq[Image_Note]
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *Image
}

// GetImmutableName implements ImmutableImage
func (m *Image) GetImmutableName() ImmutableImageName {
	return m.GetName()
}

// GetImmutableNames implements ImmutableImage
func (m *Image) GetImmutableNames() iter.Seq[ImmutableImageName] {
	return func(yield func(ImmutableImageName) bool) {
		if m == nil || m.Names == nil {
			return
		}
		for _, v := range m.Names {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableMetadata implements ImmutableImage
func (m *Image) GetImmutableMetadata() ImmutableImageMetadata {
	return m.GetMetadata()
}

// GetImmutableScan implements ImmutableImage
func (m *Image) GetImmutableScan() ImmutableImageScan {
	return m.GetScan()
}

// GetImmutableSignatureVerificationData implements ImmutableImage
func (m *Image) GetImmutableSignatureVerificationData() ImmutableImageSignatureVerificationData {
	return m.GetSignatureVerificationData()
}

// GetImmutableSignature implements ImmutableImage
func (m *Image) GetImmutableSignature() ImmutableImageSignature {
	return m.GetSignature()
}

// GetImmutableLastUpdated implements ImmutableImage
func (m *Image) GetImmutableLastUpdated() time.Time {
	if m == nil || m.LastUpdated == nil {
		return time.Time{}
	}
	return m.LastUpdated.AsTime()
}

// GetImmutableNotes implements ImmutableImage
func (m *Image) GetImmutableNotes() iter.Seq[Image_Note] {
	return func(yield func(Image_Note) bool) {
		if m == nil || m.Notes == nil {
			return
		}
		for _, v := range m.Notes {
			if !yield(v) {
				return
			}
		}
	}
}

// Verify that Image implements ImmutableImage
var _ ImmutableImage = (*Image)(nil)

// ImmutableDataSource is an immutable interface for DataSource
type ImmutableDataSource interface {
	GetId() string
	GetName() string
	GetMirror() string
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *DataSource
}

// Verify that DataSource implements ImmutableDataSource
var _ ImmutableDataSource = (*DataSource)(nil)

// ImmutableImageScan is an immutable interface for ImageScan
type ImmutableImageScan interface {
	GetScannerVersion() string
	GetImmutableScanTime() time.Time
	GetImmutableComponents() iter.Seq[ImmutableEmbeddedImageScanComponent]
	GetOperatingSystem() string
	// DataSource contains information about which integration was used to scan the image
	GetImmutableDataSource() ImmutableDataSource
	GetImmutableNotes() iter.Seq[ImageScan_Note]
	GetHash() uint64
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *ImageScan
}

// GetImmutableScanTime implements ImmutableImageScan
func (m *ImageScan) GetImmutableScanTime() time.Time {
	if m == nil || m.ScanTime == nil {
		return time.Time{}
	}
	return m.ScanTime.AsTime()
}

// GetImmutableComponents implements ImmutableImageScan
func (m *ImageScan) GetImmutableComponents() iter.Seq[ImmutableEmbeddedImageScanComponent] {
	return func(yield func(ImmutableEmbeddedImageScanComponent) bool) {
		if m == nil || m.Components == nil {
			return
		}
		for _, v := range m.Components {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableDataSource implements ImmutableImageScan
func (m *ImageScan) GetImmutableDataSource() ImmutableDataSource {
	return m.GetDataSource()
}

// GetImmutableNotes implements ImmutableImageScan
func (m *ImageScan) GetImmutableNotes() iter.Seq[ImageScan_Note] {
	return func(yield func(ImageScan_Note) bool) {
		if m == nil || m.Notes == nil {
			return
		}
		for _, v := range m.Notes {
			if !yield(v) {
				return
			}
		}
	}
}

// Verify that ImageScan implements ImmutableImageScan
var _ ImmutableImageScan = (*ImageScan)(nil)

// ImmutableImageSignatureVerificationData is an immutable interface for ImageSignatureVerificationData
type ImmutableImageSignatureVerificationData interface {
	GetImmutableResults() iter.Seq[ImmutableImageSignatureVerificationResult]
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *ImageSignatureVerificationData
}

// GetImmutableResults implements ImmutableImageSignatureVerificationData
func (m *ImageSignatureVerificationData) GetImmutableResults() iter.Seq[ImmutableImageSignatureVerificationResult] {
	return func(yield func(ImmutableImageSignatureVerificationResult) bool) {
		if m == nil || m.Results == nil {
			return
		}
		for _, v := range m.Results {
			if !yield(v) {
				return
			}
		}
	}
}

// Verify that ImageSignatureVerificationData implements ImmutableImageSignatureVerificationData
var _ ImmutableImageSignatureVerificationData = (*ImageSignatureVerificationData)(nil)

// ImmutableImageSignatureVerificationResult is an immutable interface for ImageSignatureVerificationResult
type ImmutableImageSignatureVerificationResult interface {
	GetImmutableVerificationTime() time.Time
	// verifier_id correlates to the ID of the signature integration used to verify the signature.
	GetVerifierId() string
	GetStatus() ImageSignatureVerificationResult_Status
	// description is set in the case of an error with the specific error's message. Otherwise, this will not be set.
	GetDescription() string
	// The full image names that are verified by this specific signature integration ID.
	GetImmutableVerifiedImageReferences() iter.Seq[string]
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *ImageSignatureVerificationResult
}

// GetImmutableVerificationTime implements ImmutableImageSignatureVerificationResult
func (m *ImageSignatureVerificationResult) GetImmutableVerificationTime() time.Time {
	if m == nil || m.VerificationTime == nil {
		return time.Time{}
	}
	return m.VerificationTime.AsTime()
}

// GetImmutableVerifiedImageReferences implements ImmutableImageSignatureVerificationResult
func (m *ImageSignatureVerificationResult) GetImmutableVerifiedImageReferences() iter.Seq[string] {
	return func(yield func(string) bool) {
		if m == nil || m.VerifiedImageReferences == nil {
			return
		}
		for _, v := range m.VerifiedImageReferences {
			if !yield(v) {
				return
			}
		}
	}
}

// Verify that ImageSignatureVerificationResult implements ImmutableImageSignatureVerificationResult
var _ ImmutableImageSignatureVerificationResult = (*ImageSignatureVerificationResult)(nil)

// ImmutableEmbeddedImageScanComponent is an immutable interface for EmbeddedImageScanComponent
type ImmutableEmbeddedImageScanComponent interface {
	GetName() string
	GetVersion() string
	GetImmutableLicense() ImmutableLicense
	GetImmutableVulns() iter.Seq[ImmutableEmbeddedVulnerability]
	GetLayerIndex() int32
	GetPriority() int64
	GetSource() SourceType
	GetLocation() string
	GetTopCvss() float32
	GetRiskScore() float32
	// Component version that fixes all the fixable vulnerabilities in this component.
	GetFixedBy() string
	// Values are cleared after moving to cache, remove them from the grpc return as well
	GetImmutableExecutables() iter.Seq[ImmutableEmbeddedImageScanComponent_Executable]
	GetArchitecture() string
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *EmbeddedImageScanComponent
}

// GetImmutableLicense implements ImmutableEmbeddedImageScanComponent
func (m *EmbeddedImageScanComponent) GetImmutableLicense() ImmutableLicense {
	return m.GetLicense()
}

// GetImmutableVulns implements ImmutableEmbeddedImageScanComponent
func (m *EmbeddedImageScanComponent) GetImmutableVulns() iter.Seq[ImmutableEmbeddedVulnerability] {
	return func(yield func(ImmutableEmbeddedVulnerability) bool) {
		if m == nil || m.Vulns == nil {
			return
		}
		for _, v := range m.Vulns {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableExecutables implements ImmutableEmbeddedImageScanComponent
func (m *EmbeddedImageScanComponent) GetImmutableExecutables() iter.Seq[ImmutableEmbeddedImageScanComponent_Executable] {
	return func(yield func(ImmutableEmbeddedImageScanComponent_Executable) bool) {
		if m == nil || m.Executables == nil {
			return
		}
		for _, v := range m.Executables {
			if !yield(v) {
				return
			}
		}
	}
}

// Verify that EmbeddedImageScanComponent implements ImmutableEmbeddedImageScanComponent
var _ ImmutableEmbeddedImageScanComponent = (*EmbeddedImageScanComponent)(nil)

// ImmutableEmbeddedImageScanComponent_Executable is an immutable interface for EmbeddedImageScanComponent_Executable
type ImmutableEmbeddedImageScanComponent_Executable interface {
	GetPath() string
	GetImmutableDependencies() iter.Seq[string]
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *EmbeddedImageScanComponent_Executable
}

// GetImmutableDependencies implements ImmutableEmbeddedImageScanComponent_Executable
func (m *EmbeddedImageScanComponent_Executable) GetImmutableDependencies() iter.Seq[string] {
	return func(yield func(string) bool) {
		if m == nil || m.Dependencies == nil {
			return
		}
		for _, v := range m.Dependencies {
			if !yield(v) {
				return
			}
		}
	}
}

// Verify that EmbeddedImageScanComponent_Executable implements ImmutableEmbeddedImageScanComponent_Executable
var _ ImmutableEmbeddedImageScanComponent_Executable = (*EmbeddedImageScanComponent_Executable)(nil)

// ImmutableLicense is an immutable interface for License
type ImmutableLicense interface {
	GetName() string
	GetType() string
	GetUrl() string
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *License
}

// Verify that License implements ImmutableLicense
var _ ImmutableLicense = (*License)(nil)

// ImmutableImageMetadata is an immutable interface for ImageMetadata
type ImmutableImageMetadata interface {
	// V1Metadata contains all of the V1 docker data. In the normal case we will get this because the image is a
	// V1 image OR because the v2 manifest has a link to it in it's config.
	// See https://docs.docker.com/registry/spec/manifest-v2-2/#image-manifest-field-descriptions
	// The only time we will not get it is in the rare caseof a strictly V2 image schema
	GetImmutableV1() ImmutableV1Metadata
	// We should always get V2 metadata unless the registry is old or the image is strictly V1
	GetImmutableV2() ImmutableV2Metadata
	// We never need both sets of layers so consolidate them. They will be ordered by oldest->newest
	GetImmutableLayerShas() iter.Seq[string]
	// DataSource contains information about which integration was used to pull the metadata
	GetImmutableDataSource() ImmutableDataSource
	// Version is used to determine if the metadata needs to be re-pulled
	GetVersion() uint64
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *ImageMetadata
}

// GetImmutableV1 implements ImmutableImageMetadata
func (m *ImageMetadata) GetImmutableV1() ImmutableV1Metadata {
	return m.GetV1()
}

// GetImmutableV2 implements ImmutableImageMetadata
func (m *ImageMetadata) GetImmutableV2() ImmutableV2Metadata {
	return m.GetV2()
}

// GetImmutableLayerShas implements ImmutableImageMetadata
func (m *ImageMetadata) GetImmutableLayerShas() iter.Seq[string] {
	return func(yield func(string) bool) {
		if m == nil || m.LayerShas == nil {
			return
		}
		for _, v := range m.LayerShas {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableDataSource implements ImmutableImageMetadata
func (m *ImageMetadata) GetImmutableDataSource() ImmutableDataSource {
	return m.GetDataSource()
}

// Verify that ImageMetadata implements ImmutableImageMetadata
var _ ImmutableImageMetadata = (*ImageMetadata)(nil)

// ImmutableImageSignature is an immutable interface for ImageSignature
type ImmutableImageSignature interface {
	GetImmutableSignatures() iter.Seq[ImmutableSignature]
	GetImmutableFetched() time.Time
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *ImageSignature
}

// GetImmutableSignatures implements ImmutableImageSignature
func (m *ImageSignature) GetImmutableSignatures() iter.Seq[ImmutableSignature] {
	return func(yield func(ImmutableSignature) bool) {
		if m == nil || m.Signatures == nil {
			return
		}
		for _, v := range m.Signatures {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableFetched implements ImmutableImageSignature
func (m *ImageSignature) GetImmutableFetched() time.Time {
	if m == nil || m.Fetched == nil {
		return time.Time{}
	}
	return m.Fetched.AsTime()
}

// Verify that ImageSignature implements ImmutableImageSignature
var _ ImmutableImageSignature = (*ImageSignature)(nil)

// ImmutableSignature is an immutable interface for Signature
type ImmutableSignature interface {
	GetImmutableCosign() ImmutableCosignSignature
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *Signature
}

// GetImmutableCosign implements ImmutableSignature
func (m *Signature) GetImmutableCosign() ImmutableCosignSignature {
	return m.GetCosign()
}

// Verify that Signature implements ImmutableSignature
var _ ImmutableSignature = (*Signature)(nil)

// ImmutableCosignSignature is an immutable interface for CosignSignature
type ImmutableCosignSignature interface {
	GetRawSignature() []byte
	GetSignaturePayload() []byte
	GetCertPem() []byte
	GetCertChainPem() []byte
	GetRekorBundle() []byte
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *CosignSignature
}

// Verify that CosignSignature implements ImmutableCosignSignature
var _ ImmutableCosignSignature = (*CosignSignature)(nil)

// ImmutableV2Metadata is an immutable interface for V2Metadata
type ImmutableV2Metadata interface {
	GetDigest() string
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *V2Metadata
}

// Verify that V2Metadata implements ImmutableV2Metadata
var _ ImmutableV2Metadata = (*V2Metadata)(nil)

// ImmutableV1Metadata is an immutable interface for V1Metadata
type ImmutableV1Metadata interface {
	GetDigest() string
	GetImmutableCreated() time.Time
	GetAuthor() string
	GetImmutableLayers() iter.Seq[ImmutableImageLayer]
	GetUser() string
	GetImmutableCommand() iter.Seq[string]
	GetImmutableEntrypoint() iter.Seq[string]
	GetImmutableVolumes() iter.Seq[string]
	GetImmutableLabels() iter.Seq2[string, string]
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *V1Metadata
}

// GetImmutableCreated implements ImmutableV1Metadata
func (m *V1Metadata) GetImmutableCreated() time.Time {
	if m == nil || m.Created == nil {
		return time.Time{}
	}
	return m.Created.AsTime()
}

// GetImmutableLayers implements ImmutableV1Metadata
func (m *V1Metadata) GetImmutableLayers() iter.Seq[ImmutableImageLayer] {
	return func(yield func(ImmutableImageLayer) bool) {
		if m == nil || m.Layers == nil {
			return
		}
		for _, v := range m.Layers {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableCommand implements ImmutableV1Metadata
func (m *V1Metadata) GetImmutableCommand() iter.Seq[string] {
	return func(yield func(string) bool) {
		if m == nil || m.Command == nil {
			return
		}
		for _, v := range m.Command {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableEntrypoint implements ImmutableV1Metadata
func (m *V1Metadata) GetImmutableEntrypoint() iter.Seq[string] {
	return func(yield func(string) bool) {
		if m == nil || m.Entrypoint == nil {
			return
		}
		for _, v := range m.Entrypoint {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableVolumes implements ImmutableV1Metadata
func (m *V1Metadata) GetImmutableVolumes() iter.Seq[string] {
	return func(yield func(string) bool) {
		if m == nil || m.Volumes == nil {
			return
		}
		for _, v := range m.Volumes {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableLabels implements ImmutableV1Metadata
func (m *V1Metadata) GetImmutableLabels() iter.Seq2[string, string] {
	return func(yield func(string, string) bool) {
		if m == nil || m.Labels == nil {
			return
		}
		for k, v := range m.Labels {
			if !yield(k, v) {
				return
			}
		}
	}
}

// Verify that V1Metadata implements ImmutableV1Metadata
var _ ImmutableV1Metadata = (*V1Metadata)(nil)

// ImmutableImageLayer is an immutable interface for ImageLayer
type ImmutableImageLayer interface {
	GetInstruction() string
	GetValue() string
	GetImmutableCreated() time.Time
	GetAuthor() string
	GetEmpty() bool
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *ImageLayer
}

// GetImmutableCreated implements ImmutableImageLayer
func (m *ImageLayer) GetImmutableCreated() time.Time {
	if m == nil || m.Created == nil {
		return time.Time{}
	}
	return m.Created.AsTime()
}

// Verify that ImageLayer implements ImmutableImageLayer
var _ ImmutableImageLayer = (*ImageLayer)(nil)

// ImmutableImageName is an immutable interface for ImageName
type ImmutableImageName interface {
	GetRegistry() string
	GetRemote() string
	GetTag() string
	GetFullName() string
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *ImageName
}

// Verify that ImageName implements ImmutableImageName
var _ ImmutableImageName = (*ImageName)(nil)

// ImmutableListImage is an immutable interface for ListImage
type ImmutableListImage interface {
	GetId() string
	GetName() string
	GetComponents() int32
	GetCves() int32
	GetFixableCves() int32
	GetImmutableCreated() time.Time
	GetImmutableLastUpdated() time.Time
	GetPriority() int64
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *ListImage
}

// GetImmutableCreated implements ImmutableListImage
func (m *ListImage) GetImmutableCreated() time.Time {
	if m == nil || m.Created == nil {
		return time.Time{}
	}
	return m.Created.AsTime()
}

// GetImmutableLastUpdated implements ImmutableListImage
func (m *ListImage) GetImmutableLastUpdated() time.Time {
	if m == nil || m.LastUpdated == nil {
		return time.Time{}
	}
	return m.LastUpdated.AsTime()
}

// Verify that ListImage implements ImmutableListImage
var _ ImmutableListImage = (*ListImage)(nil)

// ImmutableWatchedImage is an immutable interface for WatchedImage
type ImmutableWatchedImage interface {
	GetName() string
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *WatchedImage
}

// Verify that WatchedImage implements ImmutableWatchedImage
var _ ImmutableWatchedImage = (*WatchedImage)(nil)
