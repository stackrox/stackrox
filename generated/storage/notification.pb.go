// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/notification.proto

package storage

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Notification type is the storage representation of the Notification type.
//
// Refer to v1.NotificationType for a more detailed doc.
type NotificationType int32

const (
	NotificationType_NOTIFICATION_TYPE_GENERIC     NotificationType = 0
	NotificationType_NOTIFICATION_TYPE_LOG_MESSAGE NotificationType = 1
)

var NotificationType_name = map[int32]string{
	0: "NOTIFICATION_TYPE_GENERIC",
	1: "NOTIFICATION_TYPE_LOG_MESSAGE",
}

var NotificationType_value = map[string]int32{
	"NOTIFICATION_TYPE_GENERIC":     0,
	"NOTIFICATION_TYPE_LOG_MESSAGE": 1,
}

func (x NotificationType) String() string {
	return proto.EnumName(NotificationType_name, int32(x))
}

func (NotificationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0e013aafbf5d2e7a, []int{0}
}

// Notification level is the storage representation of the Notification level.
//
// Refer to v1.NotificationLevel for a more detailed doc.
type NotificationLevel int32

const (
	NotificationLevel_NOTIFICATION_LEVEL_UNKNOWN NotificationLevel = 0
	NotificationLevel_NOTIFICATION_LEVEL_INFO    NotificationLevel = 1
	NotificationLevel_NOTIFICATION_LEVEL_SUCCESS NotificationLevel = 2
	NotificationLevel_NOTIFICATION_LEVEL_WARN    NotificationLevel = 3
	NotificationLevel_NOTIFICATION_LEVEL_DANGER  NotificationLevel = 4
)

var NotificationLevel_name = map[int32]string{
	0: "NOTIFICATION_LEVEL_UNKNOWN",
	1: "NOTIFICATION_LEVEL_INFO",
	2: "NOTIFICATION_LEVEL_SUCCESS",
	3: "NOTIFICATION_LEVEL_WARN",
	4: "NOTIFICATION_LEVEL_DANGER",
}

var NotificationLevel_value = map[string]int32{
	"NOTIFICATION_LEVEL_UNKNOWN": 0,
	"NOTIFICATION_LEVEL_INFO":    1,
	"NOTIFICATION_LEVEL_SUCCESS": 2,
	"NOTIFICATION_LEVEL_WARN":    3,
	"NOTIFICATION_LEVEL_DANGER":  4,
}

func (x NotificationLevel) String() string {
	return proto.EnumName(NotificationLevel_name, int32(x))
}

func (NotificationLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0e013aafbf5d2e7a, []int{1}
}

// Notification is the storage representation of the Notification.
//
// Refer to v1.Notification for a more detailed doc.
type Notification struct {
	// This is a UUIDv5 where the tuple of domain, resource_type, resource_id, message is used to generate it
	// deterministically. This can be then used for deduping purposes.
	Id                   string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" sql:"pk,type(uuid)"`
	Type                 NotificationType  `protobuf:"varint,2,opt,name=type,proto3,enum=storage.NotificationType" json:"type,omitempty" search:"Notification Type,hidden"`
	Level                NotificationLevel `protobuf:"varint,3,opt,name=level,proto3,enum=storage.NotificationLevel" json:"level,omitempty" search:"Notification Level,hidden"`
	Message              string            `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	Hint                 string            `protobuf:"bytes,5,opt,name=hint,proto3" json:"hint,omitempty"`
	Domain               string            `protobuf:"bytes,6,opt,name=domain,proto3" json:"domain,omitempty" search:"Notification Domain,hidden"`
	ResourceType         string            `protobuf:"bytes,7,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty" search:"Resource,hidden"`
	ResourceId           string            `protobuf:"bytes,8,opt,name=resource_id,json=resourceId,proto3" json:"resource_id,omitempty"`
	Occurrences          int64             `protobuf:"varint,9,opt,name=occurrences,proto3" json:"occurrences,omitempty"`
	LastOccurred         *types.Timestamp  `protobuf:"bytes,10,opt,name=last_occurred,json=lastOccurred,proto3" json:"last_occurred,omitempty"`
	CreatedAt            *types.Timestamp  `protobuf:"bytes,11,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty" search:"Created Time,hidden"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Notification) Reset()         { *m = Notification{} }
func (m *Notification) String() string { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()    {}
func (*Notification) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e013aafbf5d2e7a, []int{0}
}
func (m *Notification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Notification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Notification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Notification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notification.Merge(m, src)
}
func (m *Notification) XXX_Size() int {
	return m.Size()
}
func (m *Notification) XXX_DiscardUnknown() {
	xxx_messageInfo_Notification.DiscardUnknown(m)
}

var xxx_messageInfo_Notification proto.InternalMessageInfo

func (m *Notification) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Notification) GetType() NotificationType {
	if m != nil {
		return m.Type
	}
	return NotificationType_NOTIFICATION_TYPE_GENERIC
}

func (m *Notification) GetLevel() NotificationLevel {
	if m != nil {
		return m.Level
	}
	return NotificationLevel_NOTIFICATION_LEVEL_UNKNOWN
}

func (m *Notification) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Notification) GetHint() string {
	if m != nil {
		return m.Hint
	}
	return ""
}

func (m *Notification) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Notification) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *Notification) GetResourceId() string {
	if m != nil {
		return m.ResourceId
	}
	return ""
}

func (m *Notification) GetOccurrences() int64 {
	if m != nil {
		return m.Occurrences
	}
	return 0
}

func (m *Notification) GetLastOccurred() *types.Timestamp {
	if m != nil {
		return m.LastOccurred
	}
	return nil
}

func (m *Notification) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Notification) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Notification) Clone() *Notification {
	if m == nil {
		return nil
	}
	cloned := new(Notification)
	*cloned = *m

	cloned.LastOccurred = m.LastOccurred.Clone()
	cloned.CreatedAt = m.CreatedAt.Clone()
	return cloned
}

func init() {
	proto.RegisterEnum("storage.NotificationType", NotificationType_name, NotificationType_value)
	proto.RegisterEnum("storage.NotificationLevel", NotificationLevel_name, NotificationLevel_value)
	proto.RegisterType((*Notification)(nil), "storage.Notification")
}

func init() { proto.RegisterFile("storage/notification.proto", fileDescriptor_0e013aafbf5d2e7a) }

var fileDescriptor_0e013aafbf5d2e7a = []byte{
	// 591 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x93, 0x4f, 0x6e, 0xd3, 0x40,
	0x14, 0xc6, 0xeb, 0x34, 0x6d, 0xe9, 0xa4, 0x45, 0x66, 0x40, 0xea, 0x34, 0xb4, 0xb1, 0x1b, 0x04,
	0x0d, 0x55, 0xe5, 0x48, 0x85, 0x55, 0x37, 0x95, 0x93, 0xba, 0x91, 0x45, 0xb0, 0x91, 0xe3, 0x52,
	0xfe, 0x2c, 0x2c, 0xd7, 0x9e, 0xba, 0xa3, 0x26, 0x9e, 0x60, 0x4f, 0x10, 0xbd, 0x09, 0x87, 0xe0,
	0x20, 0x2c, 0x39, 0x81, 0x85, 0xca, 0x0d, 0xbc, 0x64, 0x85, 0x3c, 0xb6, 0xa3, 0x40, 0x53, 0xb1,
	0x1b, 0x7f, 0xdf, 0xfb, 0x7e, 0x9e, 0xf7, 0xf4, 0x06, 0xd4, 0x63, 0x46, 0x23, 0x37, 0xc0, 0xed,
	0x90, 0x32, 0x72, 0x41, 0x3c, 0x97, 0x11, 0x1a, 0x2a, 0xe3, 0x88, 0x32, 0x0a, 0x57, 0x0a, 0xaf,
	0x2e, 0x05, 0x94, 0x06, 0x43, 0xdc, 0xe6, 0xf2, 0xf9, 0xe4, 0xa2, 0xcd, 0xc8, 0x08, 0xc7, 0xcc,
	0x1d, 0x8d, 0xf3, 0xca, 0xfa, 0xa3, 0x80, 0x06, 0x94, 0x1f, 0xdb, 0xd9, 0x29, 0x57, 0x9b, 0xbf,
	0xab, 0x60, 0xcd, 0x98, 0xc1, 0xc2, 0x5d, 0x50, 0x21, 0x3e, 0x12, 0x64, 0xa1, 0xb5, 0xda, 0xd9,
	0x48, 0x13, 0xe9, 0x61, 0xfc, 0x69, 0x78, 0xd8, 0x1c, 0x5f, 0xed, 0xb3, 0xeb, 0x31, 0x6e, 0x4d,
	0x26, 0xc4, 0x7f, 0xde, 0xb4, 0x2a, 0xc4, 0x87, 0x36, 0xa8, 0x66, 0x12, 0xaa, 0xc8, 0x42, 0xeb,
	0xfe, 0xc1, 0xa6, 0x52, 0x5c, 0x44, 0x99, 0xa5, 0xd9, 0xd7, 0x63, 0xdc, 0x79, 0x9a, 0x26, 0xd2,
	0x4e, 0x8c, 0xdd, 0xc8, 0xbb, 0x3c, 0x6c, 0xce, 0xba, 0x72, 0x66, 0xef, 0x5f, 0x12, 0xdf, 0xc7,
	0x61, 0xd3, 0xe2, 0x34, 0xf8, 0x0e, 0x2c, 0x0d, 0xf1, 0x67, 0x3c, 0x44, 0x8b, 0x1c, 0x5b, 0x9f,
	0x8b, 0xed, 0x67, 0x15, 0x9d, 0x67, 0x69, 0x22, 0x35, 0xe7, 0x72, 0xb9, 0x3f, 0x05, 0xe7, 0x40,
	0x88, 0xc0, 0xca, 0x08, 0xc7, 0xb1, 0x1b, 0x60, 0x54, 0xcd, 0xba, 0xb3, 0xca, 0x4f, 0x08, 0x41,
	0xf5, 0x92, 0x84, 0x0c, 0x2d, 0x71, 0x99, 0x9f, 0xe1, 0x11, 0x58, 0xf6, 0xe9, 0xc8, 0x25, 0x21,
	0x5a, 0xe6, 0xa3, 0xd8, 0x4d, 0x13, 0xe9, 0xc9, 0xdc, 0x9f, 0x1d, 0xf3, 0xb2, 0xe9, 0xdf, 0x8a,
	0x18, 0x54, 0xc1, 0x7a, 0x84, 0x63, 0x3a, 0x89, 0x3c, 0xec, 0xf0, 0x39, 0xad, 0x70, 0xce, 0x56,
	0x9a, 0x48, 0xa8, 0xe4, 0x58, 0x45, 0xc1, 0x34, 0xbc, 0x56, 0x46, 0xb2, 0xc9, 0x40, 0x09, 0xd4,
	0xa6, 0x08, 0xe2, 0xa3, 0x7b, 0xfc, 0x7a, 0xa0, 0x94, 0x74, 0x1f, 0xca, 0xa0, 0x46, 0x3d, 0x6f,
	0x12, 0x45, 0x38, 0xf4, 0x70, 0x8c, 0x56, 0x65, 0xa1, 0xb5, 0x68, 0xcd, 0x4a, 0xf0, 0x08, 0xac,
	0x0f, 0xdd, 0x98, 0x39, 0x85, 0xe6, 0x23, 0x20, 0x0b, 0xad, 0xda, 0x41, 0x5d, 0xc9, 0xb7, 0x45,
	0x29, 0xb7, 0x45, 0xb1, 0xcb, 0x6d, 0xb1, 0xd6, 0xb2, 0x80, 0x59, 0xd4, 0xc3, 0x8f, 0x00, 0x78,
	0x11, 0x76, 0x19, 0xf6, 0x1d, 0x97, 0xa1, 0xda, 0xff, 0xd2, 0x1d, 0x39, 0x4d, 0xa4, 0xad, 0xb2,
	0xbf, 0x6e, 0x9e, 0x94, 0x33, 0x7b, 0xda, 0xe3, 0x6a, 0xc1, 0x53, 0xd9, 0x9e, 0x0d, 0xc4, 0x7f,
	0xb7, 0x05, 0x6e, 0x83, 0x4d, 0xc3, 0xb4, 0xf5, 0x13, 0xbd, 0xab, 0xda, 0xba, 0x69, 0x38, 0xf6,
	0xfb, 0x37, 0x9a, 0xd3, 0xd3, 0x0c, 0xcd, 0xd2, 0xbb, 0xe2, 0x02, 0xdc, 0x01, 0xdb, 0xb7, 0xed,
	0xbe, 0xd9, 0x73, 0x5e, 0x6b, 0x83, 0x81, 0xda, 0xd3, 0x44, 0x61, 0xef, 0x9b, 0x00, 0x1e, 0xdc,
	0xda, 0x16, 0xd8, 0x00, 0xf5, 0xbf, 0x82, 0x7d, 0xed, 0xad, 0xd6, 0x77, 0x4e, 0x8d, 0x57, 0x86,
	0x79, 0x66, 0x88, 0x0b, 0xf0, 0x31, 0xd8, 0x98, 0xe3, 0xeb, 0xc6, 0x89, 0x29, 0x0a, 0x77, 0x84,
	0x07, 0xa7, 0xdd, 0xae, 0x36, 0x18, 0x88, 0x95, 0x3b, 0xc2, 0x67, 0xaa, 0x65, 0x88, 0x8b, 0xb7,
	0x3a, 0xca, 0xcd, 0x63, 0xd5, 0xe8, 0x69, 0x96, 0x58, 0xed, 0xbc, 0xfc, 0x7e, 0xd3, 0x10, 0x7e,
	0xdc, 0x34, 0x84, 0x9f, 0x37, 0x0d, 0xe1, 0xeb, 0xaf, 0xc6, 0x02, 0xd8, 0x24, 0x54, 0x89, 0x99,
	0xeb, 0x5d, 0x45, 0xf4, 0x4b, 0x3e, 0xe3, 0xf2, 0x15, 0x7c, 0x28, 0x9f, 0xfb, 0xf9, 0x32, 0xd7,
	0x5f, 0xfc, 0x09, 0x00, 0x00, 0xff, 0xff, 0x6b, 0x7f, 0x8a, 0xff, 0x1c, 0x04, 0x00, 0x00,
}

func (m *Notification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotification(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.LastOccurred != nil {
		{
			size, err := m.LastOccurred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotification(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Occurrences != 0 {
		i = encodeVarintNotification(dAtA, i, uint64(m.Occurrences))
		i--
		dAtA[i] = 0x48
	}
	if len(m.ResourceId) > 0 {
		i -= len(m.ResourceId)
		copy(dAtA[i:], m.ResourceId)
		i = encodeVarintNotification(dAtA, i, uint64(len(m.ResourceId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ResourceType) > 0 {
		i -= len(m.ResourceType)
		copy(dAtA[i:], m.ResourceType)
		i = encodeVarintNotification(dAtA, i, uint64(len(m.ResourceType)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintNotification(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Hint) > 0 {
		i -= len(m.Hint)
		copy(dAtA[i:], m.Hint)
		i = encodeVarintNotification(dAtA, i, uint64(len(m.Hint)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintNotification(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if m.Level != 0 {
		i = encodeVarintNotification(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintNotification(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNotification(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintNotification(dAtA []byte, offset int, v uint64) int {
	offset -= sovNotification(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Notification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNotification(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovNotification(uint64(m.Type))
	}
	if m.Level != 0 {
		n += 1 + sovNotification(uint64(m.Level))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovNotification(uint64(l))
	}
	l = len(m.Hint)
	if l > 0 {
		n += 1 + l + sovNotification(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovNotification(uint64(l))
	}
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovNotification(uint64(l))
	}
	l = len(m.ResourceId)
	if l > 0 {
		n += 1 + l + sovNotification(uint64(l))
	}
	if m.Occurrences != 0 {
		n += 1 + sovNotification(uint64(m.Occurrences))
	}
	if m.LastOccurred != nil {
		l = m.LastOccurred.Size()
		n += 1 + l + sovNotification(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovNotification(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNotification(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNotification(x uint64) (n int) {
	return sovNotification(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Notification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotification
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NotificationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= NotificationLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotification
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Occurrences", wireType)
			}
			m.Occurrences = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Occurrences |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastOccurred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastOccurred == nil {
				m.LastOccurred = &types.Timestamp{}
			}
			if err := m.LastOccurred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotification
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotification
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotification
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotification(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotification
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNotification(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNotification
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNotification
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNotification
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNotification
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNotification
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNotification
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNotification        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNotification          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNotification = fmt.Errorf("proto: unexpected end of group")
)
