// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/deployment.proto

package storage

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Volume_MountPropagation int32

const (
	Volume_NONE              Volume_MountPropagation = 0
	Volume_HOST_TO_CONTAINER Volume_MountPropagation = 1
	Volume_BIDIRECTIONAL     Volume_MountPropagation = 2
)

var Volume_MountPropagation_name = map[int32]string{
	0: "NONE",
	1: "HOST_TO_CONTAINER",
	2: "BIDIRECTIONAL",
}

var Volume_MountPropagation_value = map[string]int32{
	"NONE":              0,
	"HOST_TO_CONTAINER": 1,
	"BIDIRECTIONAL":     2,
}

func (x Volume_MountPropagation) String() string {
	return proto.EnumName(Volume_MountPropagation_name, int32(x))
}

func (Volume_MountPropagation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{4, 0}
}

type PortConfig_ExposureLevel int32

const (
	PortConfig_UNSET    PortConfig_ExposureLevel = 0
	PortConfig_EXTERNAL PortConfig_ExposureLevel = 1
	PortConfig_NODE     PortConfig_ExposureLevel = 2
	PortConfig_INTERNAL PortConfig_ExposureLevel = 3
	PortConfig_HOST     PortConfig_ExposureLevel = 4
	PortConfig_ROUTE    PortConfig_ExposureLevel = 5
)

var PortConfig_ExposureLevel_name = map[int32]string{
	0: "UNSET",
	1: "EXTERNAL",
	2: "NODE",
	3: "INTERNAL",
	4: "HOST",
	5: "ROUTE",
}

var PortConfig_ExposureLevel_value = map[string]int32{
	"UNSET":    0,
	"EXTERNAL": 1,
	"NODE":     2,
	"INTERNAL": 3,
	"HOST":     4,
	"ROUTE":    5,
}

func (x PortConfig_ExposureLevel) String() string {
	return proto.EnumName(PortConfig_ExposureLevel_name, int32(x))
}

func (PortConfig_ExposureLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{11, 0}
}

// For any update to EnvVarSource, please also update 'ui/src/messages/common.js'
type ContainerConfig_EnvironmentConfig_EnvVarSource int32

const (
	ContainerConfig_EnvironmentConfig_UNSET          ContainerConfig_EnvironmentConfig_EnvVarSource = 0
	ContainerConfig_EnvironmentConfig_RAW            ContainerConfig_EnvironmentConfig_EnvVarSource = 1
	ContainerConfig_EnvironmentConfig_SECRET_KEY     ContainerConfig_EnvironmentConfig_EnvVarSource = 2
	ContainerConfig_EnvironmentConfig_CONFIG_MAP_KEY ContainerConfig_EnvironmentConfig_EnvVarSource = 3
	ContainerConfig_EnvironmentConfig_FIELD          ContainerConfig_EnvironmentConfig_EnvVarSource = 4
	ContainerConfig_EnvironmentConfig_RESOURCE_FIELD ContainerConfig_EnvironmentConfig_EnvVarSource = 5
	ContainerConfig_EnvironmentConfig_UNKNOWN        ContainerConfig_EnvironmentConfig_EnvVarSource = 6
)

var ContainerConfig_EnvironmentConfig_EnvVarSource_name = map[int32]string{
	0: "UNSET",
	1: "RAW",
	2: "SECRET_KEY",
	3: "CONFIG_MAP_KEY",
	4: "FIELD",
	5: "RESOURCE_FIELD",
	6: "UNKNOWN",
}

var ContainerConfig_EnvironmentConfig_EnvVarSource_value = map[string]int32{
	"UNSET":          0,
	"RAW":            1,
	"SECRET_KEY":     2,
	"CONFIG_MAP_KEY": 3,
	"FIELD":          4,
	"RESOURCE_FIELD": 5,
	"UNKNOWN":        6,
}

func (x ContainerConfig_EnvironmentConfig_EnvVarSource) String() string {
	return proto.EnumName(ContainerConfig_EnvironmentConfig_EnvVarSource_name, int32(x))
}

func (ContainerConfig_EnvironmentConfig_EnvVarSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{12, 0, 0}
}

type SecurityContext_SeccompProfile_ProfileType int32

const (
	SecurityContext_SeccompProfile_UNCONFINED      SecurityContext_SeccompProfile_ProfileType = 0
	SecurityContext_SeccompProfile_RUNTIME_DEFAULT SecurityContext_SeccompProfile_ProfileType = 1
	SecurityContext_SeccompProfile_LOCALHOST       SecurityContext_SeccompProfile_ProfileType = 2
)

var SecurityContext_SeccompProfile_ProfileType_name = map[int32]string{
	0: "UNCONFINED",
	1: "RUNTIME_DEFAULT",
	2: "LOCALHOST",
}

var SecurityContext_SeccompProfile_ProfileType_value = map[string]int32{
	"UNCONFINED":      0,
	"RUNTIME_DEFAULT": 1,
	"LOCALHOST":       2,
}

func (x SecurityContext_SeccompProfile_ProfileType) String() string {
	return proto.EnumName(SecurityContext_SeccompProfile_ProfileType_name, int32(x))
}

func (SecurityContext_SeccompProfile_ProfileType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{13, 1, 0}
}

// Next available tag: 35
type Deployment struct {
	Id                            string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Deployment ID,store,hidden" sql:"pk,type(uuid)"`
	Name                          string            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" search:"Deployment,store"`
	Hash                          uint64            `protobuf:"varint,26,opt,name=hash,proto3" json:"hash,omitempty" hash:"ignore" sensorhash:"ignore"`
	Type                          string            `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty" search:"Deployment Type"`
	Namespace                     string            `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace,omitempty" search:"Namespace,store"`
	NamespaceId                   string            `protobuf:"bytes,23,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty" search:"Namespace ID" sql:"fk(NamespaceMetadata:id),no-fk-constraint,type(uuid)"`
	OrchestratorComponent         bool              `protobuf:"varint,33,opt,name=orchestrator_component,json=orchestratorComponent,proto3" json:"orchestrator_component,omitempty" search:"Orchestrator Component"`
	Replicas                      int64             `protobuf:"varint,6,opt,name=replicas,proto3" json:"replicas,omitempty" policy:"Replicas"`
	Labels                        map[string]string `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels,omitempty" search:"Deployment Label,store" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	PodLabels                     map[string]string `protobuf:"bytes,19,rep,name=pod_labels,json=podLabels,proto3" json:"pod_labels,omitempty" search:"Pod Label,store" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	LabelSelector                 *LabelSelector    `protobuf:"bytes,20,opt,name=label_selector,json=labelSelector,proto3" json:"label_selector,omitempty"`
	Created                       *types.Timestamp  `protobuf:"bytes,8,opt,name=created,proto3" json:"created,omitempty" search:"Created,store,hidden" hash:"ignore"`
	ClusterId                     string            `protobuf:"bytes,9,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty" search:"Cluster ID,store,hidden" sql:"type(uuid)"`
	ClusterName                   string            `protobuf:"bytes,10,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty" search:"Cluster,store"`
	Containers                    []*Container      `protobuf:"bytes,11,rep,name=containers,proto3" json:"containers,omitempty"`
	Annotations                   map[string]string `protobuf:"bytes,14,rep,name=annotations,proto3" json:"annotations,omitempty" search:"Deployment Annotation" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Priority                      int64             `protobuf:"varint,15,opt,name=priority,proto3" json:"priority,omitempty" search:"Deployment Risk Priority,hidden" hash:"ignore"`
	Inactive                      bool              `protobuf:"varint,16,opt,name=inactive,proto3" json:"inactive,omitempty"`
	ImagePullSecrets              []string          `protobuf:"bytes,17,rep,name=image_pull_secrets,json=imagePullSecrets,proto3" json:"image_pull_secrets,omitempty" search:"Image Pull Secret"`
	ServiceAccount                string            `protobuf:"bytes,18,opt,name=service_account,json=serviceAccount,proto3" json:"service_account,omitempty" search:"Service Account"`
	ServiceAccountPermissionLevel PermissionLevel   `protobuf:"varint,28,opt,name=service_account_permission_level,json=serviceAccountPermissionLevel,proto3,enum=storage.PermissionLevel" json:"service_account_permission_level,omitempty" search:"Service Account Permission Level,store"`
	AutomountServiceAccountToken  bool              `protobuf:"varint,25,opt,name=automount_service_account_token,json=automountServiceAccountToken,proto3" json:"automount_service_account_token,omitempty" policy:"Automount Service Account Token"`
	HostNetwork                   bool              `protobuf:"varint,21,opt,name=host_network,json=hostNetwork,proto3" json:"host_network,omitempty" policy:"Host Network"`
	HostPid                       bool              `protobuf:"varint,31,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" policy:"Host PID"`
	HostIpc                       bool              `protobuf:"varint,32,opt,name=host_ipc,json=hostIpc,proto3" json:"host_ipc,omitempty" policy:"Host IPC"`
	RuntimeClass                  string            `protobuf:"bytes,34,opt,name=runtime_class,json=runtimeClass,proto3" json:"runtime_class,omitempty" policy:"Runtime Class"`
	Tolerations                   []*Toleration     `protobuf:"bytes,22,rep,name=tolerations,proto3" json:"tolerations,omitempty" search:"-"`
	Ports                         []*PortConfig     `protobuf:"bytes,24,rep,name=ports,proto3" json:"ports,omitempty" policy:"Ports"`
	StateTimestamp                int64             `protobuf:"varint,27,opt,name=state_timestamp,json=stateTimestamp,proto3" json:"state_timestamp,omitempty" hash:"ignore" sensorhash:"ignore"`
	RiskScore                     float32           `protobuf:"fixed32,29,opt,name=risk_score,json=riskScore,proto3" json:"risk_score,omitempty" search:"Deployment Risk Score,hidden" policy:",ignore"`
	XXX_NoUnkeyedLiteral          struct{}          `json:"-"`
	XXX_unrecognized              []byte            `json:"-"`
	XXX_sizecache                 int32             `json:"-"`
}

func (m *Deployment) Reset()         { *m = Deployment{} }
func (m *Deployment) String() string { return proto.CompactTextString(m) }
func (*Deployment) ProtoMessage()    {}
func (*Deployment) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{0}
}
func (m *Deployment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment.Merge(m, src)
}
func (m *Deployment) XXX_Size() int {
	return m.Size()
}
func (m *Deployment) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment proto.InternalMessageInfo

func (m *Deployment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Deployment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Deployment) GetHash() uint64 {
	if m != nil {
		return m.Hash
	}
	return 0
}

func (m *Deployment) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Deployment) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Deployment) GetNamespaceId() string {
	if m != nil {
		return m.NamespaceId
	}
	return ""
}

func (m *Deployment) GetOrchestratorComponent() bool {
	if m != nil {
		return m.OrchestratorComponent
	}
	return false
}

func (m *Deployment) GetReplicas() int64 {
	if m != nil {
		return m.Replicas
	}
	return 0
}

func (m *Deployment) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Deployment) GetPodLabels() map[string]string {
	if m != nil {
		return m.PodLabels
	}
	return nil
}

func (m *Deployment) GetLabelSelector() *LabelSelector {
	if m != nil {
		return m.LabelSelector
	}
	return nil
}

func (m *Deployment) GetCreated() *types.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *Deployment) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *Deployment) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *Deployment) GetContainers() []*Container {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *Deployment) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Deployment) GetPriority() int64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Deployment) GetInactive() bool {
	if m != nil {
		return m.Inactive
	}
	return false
}

func (m *Deployment) GetImagePullSecrets() []string {
	if m != nil {
		return m.ImagePullSecrets
	}
	return nil
}

func (m *Deployment) GetServiceAccount() string {
	if m != nil {
		return m.ServiceAccount
	}
	return ""
}

func (m *Deployment) GetServiceAccountPermissionLevel() PermissionLevel {
	if m != nil {
		return m.ServiceAccountPermissionLevel
	}
	return PermissionLevel_UNSET
}

func (m *Deployment) GetAutomountServiceAccountToken() bool {
	if m != nil {
		return m.AutomountServiceAccountToken
	}
	return false
}

func (m *Deployment) GetHostNetwork() bool {
	if m != nil {
		return m.HostNetwork
	}
	return false
}

func (m *Deployment) GetHostPid() bool {
	if m != nil {
		return m.HostPid
	}
	return false
}

func (m *Deployment) GetHostIpc() bool {
	if m != nil {
		return m.HostIpc
	}
	return false
}

func (m *Deployment) GetRuntimeClass() string {
	if m != nil {
		return m.RuntimeClass
	}
	return ""
}

func (m *Deployment) GetTolerations() []*Toleration {
	if m != nil {
		return m.Tolerations
	}
	return nil
}

func (m *Deployment) GetPorts() []*PortConfig {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *Deployment) GetStateTimestamp() int64 {
	if m != nil {
		return m.StateTimestamp
	}
	return 0
}

func (m *Deployment) GetRiskScore() float32 {
	if m != nil {
		return m.RiskScore
	}
	return 0
}

func (m *Deployment) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Deployment) Clone() *Deployment {
	if m == nil {
		return nil
	}
	cloned := new(Deployment)
	*cloned = *m

	if m.Labels != nil {
		cloned.Labels = make(map[string]string, len(m.Labels))
		for k, v := range m.Labels {
			cloned.Labels[k] = v
		}
	}
	if m.PodLabels != nil {
		cloned.PodLabels = make(map[string]string, len(m.PodLabels))
		for k, v := range m.PodLabels {
			cloned.PodLabels[k] = v
		}
	}
	cloned.LabelSelector = m.LabelSelector.Clone()
	cloned.Created = m.Created.Clone()
	if m.Containers != nil {
		cloned.Containers = make([]*Container, len(m.Containers))
		for idx, v := range m.Containers {
			cloned.Containers[idx] = v.Clone()
		}
	}
	if m.Annotations != nil {
		cloned.Annotations = make(map[string]string, len(m.Annotations))
		for k, v := range m.Annotations {
			cloned.Annotations[k] = v
		}
	}
	if m.ImagePullSecrets != nil {
		cloned.ImagePullSecrets = make([]string, len(m.ImagePullSecrets))
		copy(cloned.ImagePullSecrets, m.ImagePullSecrets)
	}
	if m.Tolerations != nil {
		cloned.Tolerations = make([]*Toleration, len(m.Tolerations))
		for idx, v := range m.Tolerations {
			cloned.Tolerations[idx] = v.Clone()
		}
	}
	if m.Ports != nil {
		cloned.Ports = make([]*PortConfig, len(m.Ports))
		for idx, v := range m.Ports {
			cloned.Ports[idx] = v.Clone()
		}
	}
	return cloned
}

// Next tag: 12
type ContainerImage struct {
	Id                   string     `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty" search:"Image Sha,store,hidden" sql:"fk(Image:id),no-fk-constraint,index=hash"`
	Name                 *ImageName `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	NotPullable          bool       `protobuf:"varint,10,opt,name=not_pullable,json=notPullable,proto3" json:"not_pullable,omitempty"`
	IsClusterLocal       bool       `protobuf:"varint,11,opt,name=is_cluster_local,json=isClusterLocal,proto3" json:"is_cluster_local,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ContainerImage) Reset()         { *m = ContainerImage{} }
func (m *ContainerImage) String() string { return proto.CompactTextString(m) }
func (*ContainerImage) ProtoMessage()    {}
func (*ContainerImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{1}
}
func (m *ContainerImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerImage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerImage.Merge(m, src)
}
func (m *ContainerImage) XXX_Size() int {
	return m.Size()
}
func (m *ContainerImage) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerImage.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerImage proto.InternalMessageInfo

func (m *ContainerImage) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ContainerImage) GetName() *ImageName {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *ContainerImage) GetNotPullable() bool {
	if m != nil {
		return m.NotPullable
	}
	return false
}

func (m *ContainerImage) GetIsClusterLocal() bool {
	if m != nil {
		return m.IsClusterLocal
	}
	return false
}

func (m *ContainerImage) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ContainerImage) Clone() *ContainerImage {
	if m == nil {
		return nil
	}
	cloned := new(ContainerImage)
	*cloned = *m

	cloned.Name = m.Name.Clone()
	return cloned
}

type Container struct {
	Id                   string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Config               *ContainerConfig  `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	Image                *ContainerImage   `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	SecurityContext      *SecurityContext  `protobuf:"bytes,4,opt,name=security_context,json=securityContext,proto3" json:"security_context,omitempty"`
	Volumes              []*Volume         `protobuf:"bytes,5,rep,name=volumes,proto3" json:"volumes,omitempty" sql:"flag=ROX_DEPLOYMENT_VOLUME_SEARCH" search:"flag=ROX_DEPLOYMENT_VOLUME_SEARCH"`
	Ports                []*PortConfig     `protobuf:"bytes,6,rep,name=ports,proto3" json:"ports,omitempty" policy:",ignore" search:"-"`
	Secrets              []*EmbeddedSecret `protobuf:"bytes,7,rep,name=secrets,proto3" json:"secrets,omitempty" sql:"flag=ROX_DEPLOYMENT_SECRET_SEARCH" search:"flag=ROX_DEPLOYMENT_SECRET_SEARCH"`
	Resources            *Resources        `protobuf:"bytes,8,opt,name=resources,proto3" json:"resources,omitempty"`
	Name                 string            `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty" policy:"Container Name"`
	LivenessProbe        *LivenessProbe    `protobuf:"bytes,11,opt,name=liveness_probe,json=livenessProbe,proto3" json:"liveness_probe,omitempty"`
	ReadinessProbe       *ReadinessProbe   `protobuf:"bytes,12,opt,name=readiness_probe,json=readinessProbe,proto3" json:"readiness_probe,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Container) Reset()         { *m = Container{} }
func (m *Container) String() string { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()    {}
func (*Container) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{2}
}
func (m *Container) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Container) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Container.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Container) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Container.Merge(m, src)
}
func (m *Container) XXX_Size() int {
	return m.Size()
}
func (m *Container) XXX_DiscardUnknown() {
	xxx_messageInfo_Container.DiscardUnknown(m)
}

var xxx_messageInfo_Container proto.InternalMessageInfo

func (m *Container) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Container) GetConfig() *ContainerConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Container) GetImage() *ContainerImage {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *Container) GetSecurityContext() *SecurityContext {
	if m != nil {
		return m.SecurityContext
	}
	return nil
}

func (m *Container) GetVolumes() []*Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *Container) GetPorts() []*PortConfig {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *Container) GetSecrets() []*EmbeddedSecret {
	if m != nil {
		return m.Secrets
	}
	return nil
}

func (m *Container) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Container) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Container) GetLivenessProbe() *LivenessProbe {
	if m != nil {
		return m.LivenessProbe
	}
	return nil
}

func (m *Container) GetReadinessProbe() *ReadinessProbe {
	if m != nil {
		return m.ReadinessProbe
	}
	return nil
}

func (m *Container) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Container) Clone() *Container {
	if m == nil {
		return nil
	}
	cloned := new(Container)
	*cloned = *m

	cloned.Config = m.Config.Clone()
	cloned.Image = m.Image.Clone()
	cloned.SecurityContext = m.SecurityContext.Clone()
	if m.Volumes != nil {
		cloned.Volumes = make([]*Volume, len(m.Volumes))
		for idx, v := range m.Volumes {
			cloned.Volumes[idx] = v.Clone()
		}
	}
	if m.Ports != nil {
		cloned.Ports = make([]*PortConfig, len(m.Ports))
		for idx, v := range m.Ports {
			cloned.Ports[idx] = v.Clone()
		}
	}
	if m.Secrets != nil {
		cloned.Secrets = make([]*EmbeddedSecret, len(m.Secrets))
		for idx, v := range m.Secrets {
			cloned.Secrets[idx] = v.Clone()
		}
	}
	cloned.Resources = m.Resources.Clone()
	cloned.LivenessProbe = m.LivenessProbe.Clone()
	cloned.ReadinessProbe = m.ReadinessProbe.Clone()
	return cloned
}

type Resources struct {
	CpuCoresRequest      float32  `protobuf:"fixed32,1,opt,name=cpu_cores_request,json=cpuCoresRequest,proto3" json:"cpu_cores_request,omitempty" search:"CPU Cores Request,store"`
	CpuCoresLimit        float32  `protobuf:"fixed32,2,opt,name=cpu_cores_limit,json=cpuCoresLimit,proto3" json:"cpu_cores_limit,omitempty" search:"CPU Cores Limit,store"`
	MemoryMbRequest      float32  `protobuf:"fixed32,3,opt,name=memory_mb_request,json=memoryMbRequest,proto3" json:"memory_mb_request,omitempty" search:"Memory Request (MB),store"`
	MemoryMbLimit        float32  `protobuf:"fixed32,4,opt,name=memory_mb_limit,json=memoryMbLimit,proto3" json:"memory_mb_limit,omitempty" search:"Memory Limit (MB),store"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Resources) Reset()         { *m = Resources{} }
func (m *Resources) String() string { return proto.CompactTextString(m) }
func (*Resources) ProtoMessage()    {}
func (*Resources) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{3}
}
func (m *Resources) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resources) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Resources.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Resources) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resources.Merge(m, src)
}
func (m *Resources) XXX_Size() int {
	return m.Size()
}
func (m *Resources) XXX_DiscardUnknown() {
	xxx_messageInfo_Resources.DiscardUnknown(m)
}

var xxx_messageInfo_Resources proto.InternalMessageInfo

func (m *Resources) GetCpuCoresRequest() float32 {
	if m != nil {
		return m.CpuCoresRequest
	}
	return 0
}

func (m *Resources) GetCpuCoresLimit() float32 {
	if m != nil {
		return m.CpuCoresLimit
	}
	return 0
}

func (m *Resources) GetMemoryMbRequest() float32 {
	if m != nil {
		return m.MemoryMbRequest
	}
	return 0
}

func (m *Resources) GetMemoryMbLimit() float32 {
	if m != nil {
		return m.MemoryMbLimit
	}
	return 0
}

func (m *Resources) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Resources) Clone() *Resources {
	if m == nil {
		return nil
	}
	cloned := new(Resources)
	*cloned = *m

	return cloned
}

type Volume struct {
	Name                 string                  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" search:"Volume Name,store"`
	Source               string                  `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty" search:"Volume Source,store"`
	Destination          string                  `protobuf:"bytes,3,opt,name=destination,proto3" json:"destination,omitempty" search:"Volume Destination,store"`
	ReadOnly             bool                    `protobuf:"varint,4,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty" search:"Volume ReadOnly,store"`
	Type                 string                  `protobuf:"bytes,5,opt,name=type,proto3" json:"type,omitempty" search:"Volume Type,store"`
	MountPropagation     Volume_MountPropagation `protobuf:"varint,6,opt,name=mount_propagation,json=mountPropagation,proto3,enum=storage.Volume_MountPropagation" json:"mount_propagation,omitempty" policy:"Mount Propagation"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Volume) Reset()         { *m = Volume{} }
func (m *Volume) String() string { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()    {}
func (*Volume) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{4}
}
func (m *Volume) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Volume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Volume.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Volume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Volume.Merge(m, src)
}
func (m *Volume) XXX_Size() int {
	return m.Size()
}
func (m *Volume) XXX_DiscardUnknown() {
	xxx_messageInfo_Volume.DiscardUnknown(m)
}

var xxx_messageInfo_Volume proto.InternalMessageInfo

func (m *Volume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Volume) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *Volume) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *Volume) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *Volume) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Volume) GetMountPropagation() Volume_MountPropagation {
	if m != nil {
		return m.MountPropagation
	}
	return Volume_NONE
}

func (m *Volume) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Volume) Clone() *Volume {
	if m == nil {
		return nil
	}
	cloned := new(Volume)
	*cloned = *m

	return cloned
}

type LivenessProbe struct {
	Defined              bool     `protobuf:"varint,1,opt,name=defined,proto3" json:"defined,omitempty" policy:"Liveness Probe Defined"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LivenessProbe) Reset()         { *m = LivenessProbe{} }
func (m *LivenessProbe) String() string { return proto.CompactTextString(m) }
func (*LivenessProbe) ProtoMessage()    {}
func (*LivenessProbe) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{5}
}
func (m *LivenessProbe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LivenessProbe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LivenessProbe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LivenessProbe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LivenessProbe.Merge(m, src)
}
func (m *LivenessProbe) XXX_Size() int {
	return m.Size()
}
func (m *LivenessProbe) XXX_DiscardUnknown() {
	xxx_messageInfo_LivenessProbe.DiscardUnknown(m)
}

var xxx_messageInfo_LivenessProbe proto.InternalMessageInfo

func (m *LivenessProbe) GetDefined() bool {
	if m != nil {
		return m.Defined
	}
	return false
}

func (m *LivenessProbe) MessageClone() proto.Message {
	return m.Clone()
}
func (m *LivenessProbe) Clone() *LivenessProbe {
	if m == nil {
		return nil
	}
	cloned := new(LivenessProbe)
	*cloned = *m

	return cloned
}

type ReadinessProbe struct {
	Defined              bool     `protobuf:"varint,1,opt,name=defined,proto3" json:"defined,omitempty" policy:"Readiness Probe Defined"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadinessProbe) Reset()         { *m = ReadinessProbe{} }
func (m *ReadinessProbe) String() string { return proto.CompactTextString(m) }
func (*ReadinessProbe) ProtoMessage()    {}
func (*ReadinessProbe) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{6}
}
func (m *ReadinessProbe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadinessProbe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadinessProbe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadinessProbe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadinessProbe.Merge(m, src)
}
func (m *ReadinessProbe) XXX_Size() int {
	return m.Size()
}
func (m *ReadinessProbe) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadinessProbe.DiscardUnknown(m)
}

var xxx_messageInfo_ReadinessProbe proto.InternalMessageInfo

func (m *ReadinessProbe) GetDefined() bool {
	if m != nil {
		return m.Defined
	}
	return false
}

func (m *ReadinessProbe) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ReadinessProbe) Clone() *ReadinessProbe {
	if m == nil {
		return nil
	}
	cloned := new(ReadinessProbe)
	*cloned = *m

	return cloned
}

// Pod represents information for a currently running pod or deleted pod in an active deployment.
type Pod struct {
	// Pod UID
	Id            string               `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Pod ID,hidden" sql:"pk,type(uuid)"`
	Name          string               `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" search:"Pod Name,hidden"`
	DeploymentId  string               `protobuf:"bytes,3,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty" search:"Deployment ID,hidden" sql:"fk(Deployment:id),no-fk-constraint,type(uuid)"`
	Namespace     string               `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty" search:"Namespace,store"`
	ClusterId     string               `protobuf:"bytes,5,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty" search:"Cluster ID,store,hidden" sql:"type(uuid)"`
	LiveInstances []*ContainerInstance `protobuf:"bytes,6,rep,name=live_instances,json=liveInstances,proto3" json:"live_instances,omitempty"`
	// Must be a list of lists, so we can perform search queries (does not work for maps that aren't <string, string>)
	// There is one bucket (list) per container name.
	TerminatedInstances []*Pod_ContainerInstanceList `protobuf:"bytes,7,rep,name=terminated_instances,json=terminatedInstances,proto3" json:"terminated_instances,omitempty" search:"-"`
	// Time Kubernetes reports the pod was created.
	Started              *types.Timestamp `protobuf:"bytes,8,opt,name=started,proto3" json:"started,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Pod) Reset()         { *m = Pod{} }
func (m *Pod) String() string { return proto.CompactTextString(m) }
func (*Pod) ProtoMessage()    {}
func (*Pod) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{7}
}
func (m *Pod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pod.Merge(m, src)
}
func (m *Pod) XXX_Size() int {
	return m.Size()
}
func (m *Pod) XXX_DiscardUnknown() {
	xxx_messageInfo_Pod.DiscardUnknown(m)
}

var xxx_messageInfo_Pod proto.InternalMessageInfo

func (m *Pod) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Pod) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Pod) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *Pod) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Pod) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *Pod) GetLiveInstances() []*ContainerInstance {
	if m != nil {
		return m.LiveInstances
	}
	return nil
}

func (m *Pod) GetTerminatedInstances() []*Pod_ContainerInstanceList {
	if m != nil {
		return m.TerminatedInstances
	}
	return nil
}

func (m *Pod) GetStarted() *types.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *Pod) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Pod) Clone() *Pod {
	if m == nil {
		return nil
	}
	cloned := new(Pod)
	*cloned = *m

	if m.LiveInstances != nil {
		cloned.LiveInstances = make([]*ContainerInstance, len(m.LiveInstances))
		for idx, v := range m.LiveInstances {
			cloned.LiveInstances[idx] = v.Clone()
		}
	}
	if m.TerminatedInstances != nil {
		cloned.TerminatedInstances = make([]*Pod_ContainerInstanceList, len(m.TerminatedInstances))
		for idx, v := range m.TerminatedInstances {
			cloned.TerminatedInstances[idx] = v.Clone()
		}
	}
	cloned.Started = m.Started.Clone()
	return cloned
}

type Pod_ContainerInstanceList struct {
	Instances            []*ContainerInstance `protobuf:"bytes,1,rep,name=instances,proto3" json:"instances,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Pod_ContainerInstanceList) Reset()         { *m = Pod_ContainerInstanceList{} }
func (m *Pod_ContainerInstanceList) String() string { return proto.CompactTextString(m) }
func (*Pod_ContainerInstanceList) ProtoMessage()    {}
func (*Pod_ContainerInstanceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{7, 0}
}
func (m *Pod_ContainerInstanceList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pod_ContainerInstanceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pod_ContainerInstanceList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pod_ContainerInstanceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pod_ContainerInstanceList.Merge(m, src)
}
func (m *Pod_ContainerInstanceList) XXX_Size() int {
	return m.Size()
}
func (m *Pod_ContainerInstanceList) XXX_DiscardUnknown() {
	xxx_messageInfo_Pod_ContainerInstanceList.DiscardUnknown(m)
}

var xxx_messageInfo_Pod_ContainerInstanceList proto.InternalMessageInfo

func (m *Pod_ContainerInstanceList) GetInstances() []*ContainerInstance {
	if m != nil {
		return m.Instances
	}
	return nil
}

func (m *Pod_ContainerInstanceList) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Pod_ContainerInstanceList) Clone() *Pod_ContainerInstanceList {
	if m == nil {
		return nil
	}
	cloned := new(Pod_ContainerInstanceList)
	*cloned = *m

	if m.Instances != nil {
		cloned.Instances = make([]*ContainerInstance, len(m.Instances))
		for idx, v := range m.Instances {
			cloned.Instances[idx] = v.Clone()
		}
	}
	return cloned
}

// ContainerInstanceID allows to uniquely identify a container within a cluster.
type ContainerInstance struct {
	// The instance ID of this container.
	InstanceId *ContainerInstanceID `protobuf:"bytes,1,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
	// The pod containing this container instance (kubernetes only).
	ContainingPodId string `protobuf:"bytes,2,opt,name=containing_pod_id,json=containingPodId,proto3" json:"containing_pod_id,omitempty"`
	// Container name.
	ContainerName string `protobuf:"bytes,6,opt,name=container_name,json=containerName,proto3" json:"container_name,omitempty"`
	// The IP addresses of this container.
	ContainerIps []string `protobuf:"bytes,3,rep,name=container_ips,json=containerIps,proto3" json:"container_ips,omitempty"`
	// The start time of the container
	Started *types.Timestamp `protobuf:"bytes,4,opt,name=started,proto3" json:"started,omitempty"`
	// Image ID
	ImageDigest string `protobuf:"bytes,5,opt,name=image_digest,json=imageDigest,proto3" json:"image_digest,omitempty" search:"Container Image Digest,hidden"`
	// The finish time of the container, if it finished.
	Finished *types.Timestamp `protobuf:"bytes,7,opt,name=finished,proto3" json:"finished,omitempty"`
	// The exit code of the container. Only valid when finished is populated.
	ExitCode int32 `protobuf:"varint,8,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	// The reason for the container's termination, if it finished.
	TerminationReason    string   `protobuf:"bytes,9,opt,name=termination_reason,json=terminationReason,proto3" json:"termination_reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContainerInstance) Reset()         { *m = ContainerInstance{} }
func (m *ContainerInstance) String() string { return proto.CompactTextString(m) }
func (*ContainerInstance) ProtoMessage()    {}
func (*ContainerInstance) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{8}
}
func (m *ContainerInstance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerInstance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerInstance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerInstance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerInstance.Merge(m, src)
}
func (m *ContainerInstance) XXX_Size() int {
	return m.Size()
}
func (m *ContainerInstance) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerInstance.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerInstance proto.InternalMessageInfo

func (m *ContainerInstance) GetInstanceId() *ContainerInstanceID {
	if m != nil {
		return m.InstanceId
	}
	return nil
}

func (m *ContainerInstance) GetContainingPodId() string {
	if m != nil {
		return m.ContainingPodId
	}
	return ""
}

func (m *ContainerInstance) GetContainerName() string {
	if m != nil {
		return m.ContainerName
	}
	return ""
}

func (m *ContainerInstance) GetContainerIps() []string {
	if m != nil {
		return m.ContainerIps
	}
	return nil
}

func (m *ContainerInstance) GetStarted() *types.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *ContainerInstance) GetImageDigest() string {
	if m != nil {
		return m.ImageDigest
	}
	return ""
}

func (m *ContainerInstance) GetFinished() *types.Timestamp {
	if m != nil {
		return m.Finished
	}
	return nil
}

func (m *ContainerInstance) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *ContainerInstance) GetTerminationReason() string {
	if m != nil {
		return m.TerminationReason
	}
	return ""
}

func (m *ContainerInstance) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ContainerInstance) Clone() *ContainerInstance {
	if m == nil {
		return nil
	}
	cloned := new(ContainerInstance)
	*cloned = *m

	cloned.InstanceId = m.InstanceId.Clone()
	if m.ContainerIps != nil {
		cloned.ContainerIps = make([]string, len(m.ContainerIps))
		copy(cloned.ContainerIps, m.ContainerIps)
	}
	cloned.Started = m.Started.Clone()
	cloned.Finished = m.Finished.Clone()
	return cloned
}

type ContainerInstanceID struct {
	// The runtime running this container.
	ContainerRuntime ContainerRuntime `protobuf:"varint,1,opt,name=container_runtime,json=containerRuntime,proto3,enum=storage.ContainerRuntime" json:"container_runtime,omitempty"`
	// The ID of the container, specific to the given runtime.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// The node on which this container runs.
	Node                 string   `protobuf:"bytes,3,opt,name=node,proto3" json:"node,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContainerInstanceID) Reset()         { *m = ContainerInstanceID{} }
func (m *ContainerInstanceID) String() string { return proto.CompactTextString(m) }
func (*ContainerInstanceID) ProtoMessage()    {}
func (*ContainerInstanceID) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{9}
}
func (m *ContainerInstanceID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerInstanceID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerInstanceID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerInstanceID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerInstanceID.Merge(m, src)
}
func (m *ContainerInstanceID) XXX_Size() int {
	return m.Size()
}
func (m *ContainerInstanceID) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerInstanceID.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerInstanceID proto.InternalMessageInfo

func (m *ContainerInstanceID) GetContainerRuntime() ContainerRuntime {
	if m != nil {
		return m.ContainerRuntime
	}
	return ContainerRuntime_UNKNOWN_CONTAINER_RUNTIME
}

func (m *ContainerInstanceID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ContainerInstanceID) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *ContainerInstanceID) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ContainerInstanceID) Clone() *ContainerInstanceID {
	if m == nil {
		return nil
	}
	cloned := new(ContainerInstanceID)
	*cloned = *m

	return cloned
}

type EmbeddedSecret struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" search:"Secret"`
	Path                 string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty" search:"Secret Path"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmbeddedSecret) Reset()         { *m = EmbeddedSecret{} }
func (m *EmbeddedSecret) String() string { return proto.CompactTextString(m) }
func (*EmbeddedSecret) ProtoMessage()    {}
func (*EmbeddedSecret) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{10}
}
func (m *EmbeddedSecret) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmbeddedSecret) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmbeddedSecret.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmbeddedSecret) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmbeddedSecret.Merge(m, src)
}
func (m *EmbeddedSecret) XXX_Size() int {
	return m.Size()
}
func (m *EmbeddedSecret) XXX_DiscardUnknown() {
	xxx_messageInfo_EmbeddedSecret.DiscardUnknown(m)
}

var xxx_messageInfo_EmbeddedSecret proto.InternalMessageInfo

func (m *EmbeddedSecret) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EmbeddedSecret) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *EmbeddedSecret) MessageClone() proto.Message {
	return m.Clone()
}
func (m *EmbeddedSecret) Clone() *EmbeddedSecret {
	if m == nil {
		return nil
	}
	cloned := new(EmbeddedSecret)
	*cloned = *m

	return cloned
}

// Next Available Tag: 6
type PortConfig struct {
	Name                 string                     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ContainerPort        int32                      `protobuf:"varint,2,opt,name=container_port,json=containerPort,proto3" json:"container_port,omitempty" search:"Port,store"`
	Protocol             string                     `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty" search:"Port Protocol,store"`
	Exposure             PortConfig_ExposureLevel   `protobuf:"varint,4,opt,name=exposure,proto3,enum=storage.PortConfig_ExposureLevel" json:"exposure,omitempty" search:"Max Exposure Level,store"`
	ExposedPort          int32                      `protobuf:"varint,5,opt,name=exposed_port,json=exposedPort,proto3" json:"exposed_port,omitempty"` // Deprecated: Do not use.
	ExposureInfos        []*PortConfig_ExposureInfo `protobuf:"bytes,6,rep,name=exposure_infos,json=exposureInfos,proto3" json:"exposure_infos,omitempty" policy:"Exposure Infos" sensorhash:"set"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *PortConfig) Reset()         { *m = PortConfig{} }
func (m *PortConfig) String() string { return proto.CompactTextString(m) }
func (*PortConfig) ProtoMessage()    {}
func (*PortConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{11}
}
func (m *PortConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortConfig.Merge(m, src)
}
func (m *PortConfig) XXX_Size() int {
	return m.Size()
}
func (m *PortConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PortConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PortConfig proto.InternalMessageInfo

func (m *PortConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PortConfig) GetContainerPort() int32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

func (m *PortConfig) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *PortConfig) GetExposure() PortConfig_ExposureLevel {
	if m != nil {
		return m.Exposure
	}
	return PortConfig_UNSET
}

// Deprecated: Do not use.
func (m *PortConfig) GetExposedPort() int32 {
	if m != nil {
		return m.ExposedPort
	}
	return 0
}

func (m *PortConfig) GetExposureInfos() []*PortConfig_ExposureInfo {
	if m != nil {
		return m.ExposureInfos
	}
	return nil
}

func (m *PortConfig) MessageClone() proto.Message {
	return m.Clone()
}
func (m *PortConfig) Clone() *PortConfig {
	if m == nil {
		return nil
	}
	cloned := new(PortConfig)
	*cloned = *m

	if m.ExposureInfos != nil {
		cloned.ExposureInfos = make([]*PortConfig_ExposureInfo, len(m.ExposureInfos))
		for idx, v := range m.ExposureInfos {
			cloned.ExposureInfos[idx] = v.Clone()
		}
	}
	return cloned
}

type PortConfig_ExposureInfo struct {
	Level PortConfig_ExposureLevel `protobuf:"varint,1,opt,name=level,proto3,enum=storage.PortConfig_ExposureLevel" json:"level,omitempty" search:"Exposure Level,store"`
	// only set if level is not HOST
	ServiceName      string `protobuf:"bytes,2,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty" search:"Exposing Service,store"`
	ServiceId        string `protobuf:"bytes,3,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	ServiceClusterIp string `protobuf:"bytes,4,opt,name=service_cluster_ip,json=serviceClusterIp,proto3" json:"service_cluster_ip,omitempty"`
	ServicePort      int32  `protobuf:"varint,5,opt,name=service_port,json=servicePort,proto3" json:"service_port,omitempty" search:"Exposing Service Port,store"`
	// only set if level is HOST, NODE, EXTERNAL or ROUTE
	NodePort int32 `protobuf:"varint,6,opt,name=node_port,json=nodePort,proto3" json:"node_port,omitempty" search:"Exposed Node Port,store"`
	// only set if level is EXTERNAL
	ExternalIps []string `protobuf:"bytes,7,rep,name=external_ips,json=externalIps,proto3" json:"external_ips,omitempty" search:"External IP,store"`
	// only set if level is EXTERNAL or ROUTE
	ExternalHostnames    []string `protobuf:"bytes,8,rep,name=external_hostnames,json=externalHostnames,proto3" json:"external_hostnames,omitempty" search:"External Hostname,store"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PortConfig_ExposureInfo) Reset()         { *m = PortConfig_ExposureInfo{} }
func (m *PortConfig_ExposureInfo) String() string { return proto.CompactTextString(m) }
func (*PortConfig_ExposureInfo) ProtoMessage()    {}
func (*PortConfig_ExposureInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{11, 0}
}
func (m *PortConfig_ExposureInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortConfig_ExposureInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortConfig_ExposureInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortConfig_ExposureInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortConfig_ExposureInfo.Merge(m, src)
}
func (m *PortConfig_ExposureInfo) XXX_Size() int {
	return m.Size()
}
func (m *PortConfig_ExposureInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PortConfig_ExposureInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PortConfig_ExposureInfo proto.InternalMessageInfo

func (m *PortConfig_ExposureInfo) GetLevel() PortConfig_ExposureLevel {
	if m != nil {
		return m.Level
	}
	return PortConfig_UNSET
}

func (m *PortConfig_ExposureInfo) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *PortConfig_ExposureInfo) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *PortConfig_ExposureInfo) GetServiceClusterIp() string {
	if m != nil {
		return m.ServiceClusterIp
	}
	return ""
}

func (m *PortConfig_ExposureInfo) GetServicePort() int32 {
	if m != nil {
		return m.ServicePort
	}
	return 0
}

func (m *PortConfig_ExposureInfo) GetNodePort() int32 {
	if m != nil {
		return m.NodePort
	}
	return 0
}

func (m *PortConfig_ExposureInfo) GetExternalIps() []string {
	if m != nil {
		return m.ExternalIps
	}
	return nil
}

func (m *PortConfig_ExposureInfo) GetExternalHostnames() []string {
	if m != nil {
		return m.ExternalHostnames
	}
	return nil
}

func (m *PortConfig_ExposureInfo) MessageClone() proto.Message {
	return m.Clone()
}
func (m *PortConfig_ExposureInfo) Clone() *PortConfig_ExposureInfo {
	if m == nil {
		return nil
	}
	cloned := new(PortConfig_ExposureInfo)
	*cloned = *m

	if m.ExternalIps != nil {
		cloned.ExternalIps = make([]string, len(m.ExternalIps))
		copy(cloned.ExternalIps, m.ExternalIps)
	}
	if m.ExternalHostnames != nil {
		cloned.ExternalHostnames = make([]string, len(m.ExternalHostnames))
		copy(cloned.ExternalHostnames, m.ExternalHostnames)
	}
	return cloned
}

type ContainerConfig struct {
	Env                  []*ContainerConfig_EnvironmentConfig `protobuf:"bytes,1,rep,name=env,proto3" json:"env,omitempty" sql:"flag=ROX_DEPLOYMENT_ENVVAR_SEARCH" search:"flag=ROX_DEPLOYMENT_ENVVAR_SEARCH"`
	Command              []string                             `protobuf:"bytes,2,rep,name=command,proto3" json:"command,omitempty"`
	Args                 []string                             `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
	Directory            string                               `protobuf:"bytes,4,opt,name=directory,proto3" json:"directory,omitempty"`
	User                 string                               `protobuf:"bytes,5,opt,name=user,proto3" json:"user,omitempty"`
	Uid                  int64                                `protobuf:"varint,6,opt,name=uid,proto3" json:"uid,omitempty"`
	AppArmorProfile      string                               `protobuf:"bytes,7,opt,name=app_armor_profile,json=appArmorProfile,proto3" json:"app_armor_profile,omitempty" policy:"AppArmor Profile"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *ContainerConfig) Reset()         { *m = ContainerConfig{} }
func (m *ContainerConfig) String() string { return proto.CompactTextString(m) }
func (*ContainerConfig) ProtoMessage()    {}
func (*ContainerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{12}
}
func (m *ContainerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerConfig.Merge(m, src)
}
func (m *ContainerConfig) XXX_Size() int {
	return m.Size()
}
func (m *ContainerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerConfig proto.InternalMessageInfo

func (m *ContainerConfig) GetEnv() []*ContainerConfig_EnvironmentConfig {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *ContainerConfig) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ContainerConfig) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *ContainerConfig) GetDirectory() string {
	if m != nil {
		return m.Directory
	}
	return ""
}

func (m *ContainerConfig) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *ContainerConfig) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ContainerConfig) GetAppArmorProfile() string {
	if m != nil {
		return m.AppArmorProfile
	}
	return ""
}

func (m *ContainerConfig) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ContainerConfig) Clone() *ContainerConfig {
	if m == nil {
		return nil
	}
	cloned := new(ContainerConfig)
	*cloned = *m

	if m.Env != nil {
		cloned.Env = make([]*ContainerConfig_EnvironmentConfig, len(m.Env))
		for idx, v := range m.Env {
			cloned.Env[idx] = v.Clone()
		}
	}
	if m.Command != nil {
		cloned.Command = make([]string, len(m.Command))
		copy(cloned.Command, m.Command)
	}
	if m.Args != nil {
		cloned.Args = make([]string, len(m.Args))
		copy(cloned.Args, m.Args)
	}
	return cloned
}

type ContainerConfig_EnvironmentConfig struct {
	Key                  string                                         `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" search:"Environment Key,store"`
	Value                string                                         `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" search:"Environment Value,store"`
	EnvVarSource         ContainerConfig_EnvironmentConfig_EnvVarSource `protobuf:"varint,3,opt,name=env_var_source,json=envVarSource,proto3,enum=storage.ContainerConfig_EnvironmentConfig_EnvVarSource" json:"env_var_source,omitempty" search:"Environment Variable Source,store"`
	XXX_NoUnkeyedLiteral struct{}                                       `json:"-"`
	XXX_unrecognized     []byte                                         `json:"-"`
	XXX_sizecache        int32                                          `json:"-"`
}

func (m *ContainerConfig_EnvironmentConfig) Reset()         { *m = ContainerConfig_EnvironmentConfig{} }
func (m *ContainerConfig_EnvironmentConfig) String() string { return proto.CompactTextString(m) }
func (*ContainerConfig_EnvironmentConfig) ProtoMessage()    {}
func (*ContainerConfig_EnvironmentConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{12, 0}
}
func (m *ContainerConfig_EnvironmentConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerConfig_EnvironmentConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerConfig_EnvironmentConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerConfig_EnvironmentConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerConfig_EnvironmentConfig.Merge(m, src)
}
func (m *ContainerConfig_EnvironmentConfig) XXX_Size() int {
	return m.Size()
}
func (m *ContainerConfig_EnvironmentConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerConfig_EnvironmentConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerConfig_EnvironmentConfig proto.InternalMessageInfo

func (m *ContainerConfig_EnvironmentConfig) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ContainerConfig_EnvironmentConfig) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *ContainerConfig_EnvironmentConfig) GetEnvVarSource() ContainerConfig_EnvironmentConfig_EnvVarSource {
	if m != nil {
		return m.EnvVarSource
	}
	return ContainerConfig_EnvironmentConfig_UNSET
}

func (m *ContainerConfig_EnvironmentConfig) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ContainerConfig_EnvironmentConfig) Clone() *ContainerConfig_EnvironmentConfig {
	if m == nil {
		return nil
	}
	cloned := new(ContainerConfig_EnvironmentConfig)
	*cloned = *m

	return cloned
}

type SecurityContext struct {
	Privileged               bool                            `protobuf:"varint,1,opt,name=privileged,proto3" json:"privileged,omitempty" search:"Privileged,store"`
	Selinux                  *SecurityContext_SELinux        `protobuf:"bytes,2,opt,name=selinux,proto3" json:"selinux,omitempty"`
	DropCapabilities         []string                        `protobuf:"bytes,3,rep,name=drop_capabilities,json=dropCapabilities,proto3" json:"drop_capabilities,omitempty" search:"Drop Capabilities,store"`
	AddCapabilities          []string                        `protobuf:"bytes,4,rep,name=add_capabilities,json=addCapabilities,proto3" json:"add_capabilities,omitempty" search:"Add Capabilities,store"`
	ReadOnlyRootFilesystem   bool                            `protobuf:"varint,5,opt,name=read_only_root_filesystem,json=readOnlyRootFilesystem,proto3" json:"read_only_root_filesystem,omitempty" search:"Read Only Root Filesystem,store"`
	SeccompProfile           *SecurityContext_SeccompProfile `protobuf:"bytes,6,opt,name=seccomp_profile,json=seccompProfile,proto3" json:"seccomp_profile,omitempty"`
	AllowPrivilegeEscalation bool                            `protobuf:"varint,7,opt,name=allow_privilege_escalation,json=allowPrivilegeEscalation,proto3" json:"allow_privilege_escalation,omitempty" policy:"Allow Privilege Escalation"`
	XXX_NoUnkeyedLiteral     struct{}                        `json:"-"`
	XXX_unrecognized         []byte                          `json:"-"`
	XXX_sizecache            int32                           `json:"-"`
}

func (m *SecurityContext) Reset()         { *m = SecurityContext{} }
func (m *SecurityContext) String() string { return proto.CompactTextString(m) }
func (*SecurityContext) ProtoMessage()    {}
func (*SecurityContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{13}
}
func (m *SecurityContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityContext.Merge(m, src)
}
func (m *SecurityContext) XXX_Size() int {
	return m.Size()
}
func (m *SecurityContext) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityContext.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityContext proto.InternalMessageInfo

func (m *SecurityContext) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *SecurityContext) GetSelinux() *SecurityContext_SELinux {
	if m != nil {
		return m.Selinux
	}
	return nil
}

func (m *SecurityContext) GetDropCapabilities() []string {
	if m != nil {
		return m.DropCapabilities
	}
	return nil
}

func (m *SecurityContext) GetAddCapabilities() []string {
	if m != nil {
		return m.AddCapabilities
	}
	return nil
}

func (m *SecurityContext) GetReadOnlyRootFilesystem() bool {
	if m != nil {
		return m.ReadOnlyRootFilesystem
	}
	return false
}

func (m *SecurityContext) GetSeccompProfile() *SecurityContext_SeccompProfile {
	if m != nil {
		return m.SeccompProfile
	}
	return nil
}

func (m *SecurityContext) GetAllowPrivilegeEscalation() bool {
	if m != nil {
		return m.AllowPrivilegeEscalation
	}
	return false
}

func (m *SecurityContext) MessageClone() proto.Message {
	return m.Clone()
}
func (m *SecurityContext) Clone() *SecurityContext {
	if m == nil {
		return nil
	}
	cloned := new(SecurityContext)
	*cloned = *m

	cloned.Selinux = m.Selinux.Clone()
	if m.DropCapabilities != nil {
		cloned.DropCapabilities = make([]string, len(m.DropCapabilities))
		copy(cloned.DropCapabilities, m.DropCapabilities)
	}
	if m.AddCapabilities != nil {
		cloned.AddCapabilities = make([]string, len(m.AddCapabilities))
		copy(cloned.AddCapabilities, m.AddCapabilities)
	}
	cloned.SeccompProfile = m.SeccompProfile.Clone()
	return cloned
}

type SecurityContext_SELinux struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	Role                 string   `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	Type                 string   `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Level                string   `protobuf:"bytes,4,opt,name=level,proto3" json:"level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityContext_SELinux) Reset()         { *m = SecurityContext_SELinux{} }
func (m *SecurityContext_SELinux) String() string { return proto.CompactTextString(m) }
func (*SecurityContext_SELinux) ProtoMessage()    {}
func (*SecurityContext_SELinux) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{13, 0}
}
func (m *SecurityContext_SELinux) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityContext_SELinux) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityContext_SELinux.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityContext_SELinux) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityContext_SELinux.Merge(m, src)
}
func (m *SecurityContext_SELinux) XXX_Size() int {
	return m.Size()
}
func (m *SecurityContext_SELinux) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityContext_SELinux.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityContext_SELinux proto.InternalMessageInfo

func (m *SecurityContext_SELinux) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SecurityContext_SELinux) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *SecurityContext_SELinux) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SecurityContext_SELinux) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

func (m *SecurityContext_SELinux) MessageClone() proto.Message {
	return m.Clone()
}
func (m *SecurityContext_SELinux) Clone() *SecurityContext_SELinux {
	if m == nil {
		return nil
	}
	cloned := new(SecurityContext_SELinux)
	*cloned = *m

	return cloned
}

type SecurityContext_SeccompProfile struct {
	Type                 SecurityContext_SeccompProfile_ProfileType `protobuf:"varint,1,opt,name=type,proto3,enum=storage.SecurityContext_SeccompProfile_ProfileType" json:"type,omitempty" policy:"Seccomp Profile Type"`
	LocalhostProfile     string                                     `protobuf:"bytes,2,opt,name=localhost_profile,json=localhostProfile,proto3" json:"localhost_profile,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *SecurityContext_SeccompProfile) Reset()         { *m = SecurityContext_SeccompProfile{} }
func (m *SecurityContext_SeccompProfile) String() string { return proto.CompactTextString(m) }
func (*SecurityContext_SeccompProfile) ProtoMessage()    {}
func (*SecurityContext_SeccompProfile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{13, 1}
}
func (m *SecurityContext_SeccompProfile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityContext_SeccompProfile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityContext_SeccompProfile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityContext_SeccompProfile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityContext_SeccompProfile.Merge(m, src)
}
func (m *SecurityContext_SeccompProfile) XXX_Size() int {
	return m.Size()
}
func (m *SecurityContext_SeccompProfile) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityContext_SeccompProfile.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityContext_SeccompProfile proto.InternalMessageInfo

func (m *SecurityContext_SeccompProfile) GetType() SecurityContext_SeccompProfile_ProfileType {
	if m != nil {
		return m.Type
	}
	return SecurityContext_SeccompProfile_UNCONFINED
}

func (m *SecurityContext_SeccompProfile) GetLocalhostProfile() string {
	if m != nil {
		return m.LocalhostProfile
	}
	return ""
}

func (m *SecurityContext_SeccompProfile) MessageClone() proto.Message {
	return m.Clone()
}
func (m *SecurityContext_SeccompProfile) Clone() *SecurityContext_SeccompProfile {
	if m == nil {
		return nil
	}
	cloned := new(SecurityContext_SeccompProfile)
	*cloned = *m

	return cloned
}

// Next available tag: 9
type ListDeployment struct {
	Id                   string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Hash                 uint64           `protobuf:"varint,8,opt,name=hash,proto3" json:"hash,omitempty"`
	Name                 string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Cluster              string           `protobuf:"bytes,3,opt,name=cluster,proto3" json:"cluster,omitempty"`
	ClusterId            string           `protobuf:"bytes,4,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	Namespace            string           `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Created              *types.Timestamp `protobuf:"bytes,6,opt,name=created,proto3" json:"created,omitempty"`
	Priority             int64            `protobuf:"varint,7,opt,name=priority,proto3" json:"priority,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ListDeployment) Reset()         { *m = ListDeployment{} }
func (m *ListDeployment) String() string { return proto.CompactTextString(m) }
func (*ListDeployment) ProtoMessage()    {}
func (*ListDeployment) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3884ae4621696a3, []int{14}
}
func (m *ListDeployment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDeployment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDeployment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDeployment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDeployment.Merge(m, src)
}
func (m *ListDeployment) XXX_Size() int {
	return m.Size()
}
func (m *ListDeployment) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDeployment.DiscardUnknown(m)
}

var xxx_messageInfo_ListDeployment proto.InternalMessageInfo

func (m *ListDeployment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ListDeployment) GetHash() uint64 {
	if m != nil {
		return m.Hash
	}
	return 0
}

func (m *ListDeployment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListDeployment) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *ListDeployment) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *ListDeployment) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListDeployment) GetCreated() *types.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *ListDeployment) GetPriority() int64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *ListDeployment) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ListDeployment) Clone() *ListDeployment {
	if m == nil {
		return nil
	}
	cloned := new(ListDeployment)
	*cloned = *m

	cloned.Created = m.Created.Clone()
	return cloned
}

func init() {
	proto.RegisterEnum("storage.Volume_MountPropagation", Volume_MountPropagation_name, Volume_MountPropagation_value)
	proto.RegisterEnum("storage.PortConfig_ExposureLevel", PortConfig_ExposureLevel_name, PortConfig_ExposureLevel_value)
	proto.RegisterEnum("storage.ContainerConfig_EnvironmentConfig_EnvVarSource", ContainerConfig_EnvironmentConfig_EnvVarSource_name, ContainerConfig_EnvironmentConfig_EnvVarSource_value)
	proto.RegisterEnum("storage.SecurityContext_SeccompProfile_ProfileType", SecurityContext_SeccompProfile_ProfileType_name, SecurityContext_SeccompProfile_ProfileType_value)
	proto.RegisterType((*Deployment)(nil), "storage.Deployment")
	proto.RegisterMapType((map[string]string)(nil), "storage.Deployment.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "storage.Deployment.LabelsEntry")
	proto.RegisterMapType((map[string]string)(nil), "storage.Deployment.PodLabelsEntry")
	proto.RegisterType((*ContainerImage)(nil), "storage.ContainerImage")
	proto.RegisterType((*Container)(nil), "storage.Container")
	proto.RegisterType((*Resources)(nil), "storage.Resources")
	proto.RegisterType((*Volume)(nil), "storage.Volume")
	proto.RegisterType((*LivenessProbe)(nil), "storage.LivenessProbe")
	proto.RegisterType((*ReadinessProbe)(nil), "storage.ReadinessProbe")
	proto.RegisterType((*Pod)(nil), "storage.Pod")
	proto.RegisterType((*Pod_ContainerInstanceList)(nil), "storage.Pod.ContainerInstanceList")
	proto.RegisterType((*ContainerInstance)(nil), "storage.ContainerInstance")
	proto.RegisterType((*ContainerInstanceID)(nil), "storage.ContainerInstanceID")
	proto.RegisterType((*EmbeddedSecret)(nil), "storage.EmbeddedSecret")
	proto.RegisterType((*PortConfig)(nil), "storage.PortConfig")
	proto.RegisterType((*PortConfig_ExposureInfo)(nil), "storage.PortConfig.ExposureInfo")
	proto.RegisterType((*ContainerConfig)(nil), "storage.ContainerConfig")
	proto.RegisterType((*ContainerConfig_EnvironmentConfig)(nil), "storage.ContainerConfig.EnvironmentConfig")
	proto.RegisterType((*SecurityContext)(nil), "storage.SecurityContext")
	proto.RegisterType((*SecurityContext_SELinux)(nil), "storage.SecurityContext.SELinux")
	proto.RegisterType((*SecurityContext_SeccompProfile)(nil), "storage.SecurityContext.SeccompProfile")
	proto.RegisterType((*ListDeployment)(nil), "storage.ListDeployment")
}

func init() { proto.RegisterFile("storage/deployment.proto", fileDescriptor_c3884ae4621696a3) }

var fileDescriptor_c3884ae4621696a3 = []byte{
	// 3601 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x5a, 0x4b, 0x73, 0xe3, 0x56,
	0x76, 0x36, 0x45, 0x4a, 0x24, 0x0f, 0x25, 0x0a, 0xba, 0xfd, 0x30, 0x5a, 0xee, 0x6e, 0xa0, 0xe1,
	0x97, 0xec, 0xe9, 0x56, 0xb7, 0xdb, 0xce, 0x8c, 0x47, 0x71, 0x7b, 0x22, 0x51, 0xec, 0x31, 0xd5,
	0x12, 0x45, 0x5f, 0x51, 0x3d, 0x63, 0x27, 0x55, 0x28, 0x08, 0xb8, 0x92, 0x30, 0x02, 0x71, 0x31,
	0x00, 0x28, 0xb7, 0xb2, 0x9b, 0x55, 0x6a, 0x16, 0xd9, 0xa5, 0x52, 0xc9, 0x22, 0x8b, 0x54, 0x16,
	0xf9, 0x0b, 0xf9, 0x09, 0xa9, 0x4a, 0xa5, 0x6a, 0xaa, 0xb2, 0x67, 0xa5, 0x9c, 0x65, 0xb2, 0x19,
	0xfe, 0x82, 0xd4, 0x7d, 0xe1, 0x41, 0x49, 0xee, 0x76, 0xd5, 0xac, 0x08, 0x9c, 0xf3, 0x9d, 0x73,
	0x5f, 0xe7, 0x9e, 0x17, 0x08, 0x7a, 0x92, 0xd2, 0xd8, 0x39, 0x21, 0x8f, 0x3d, 0x12, 0x05, 0xf4,
	0x62, 0x44, 0xc2, 0x74, 0x3d, 0x8a, 0x69, 0x4a, 0x51, 0x5d, 0x72, 0x56, 0x8d, 0x13, 0x4a, 0x4f,
	0x02, 0xf2, 0x98, 0x93, 0x8f, 0xc6, 0xc7, 0x8f, 0x53, 0x7f, 0x44, 0x92, 0xd4, 0x19, 0x45, 0x02,
	0xb9, 0x6a, 0x28, 0x1d, 0x2e, 0x0d, 0x53, 0xc7, 0x0f, 0x49, 0x6c, 0xc7, 0xe3, 0x90, 0xa1, 0x24,
	0xe0, 0xa6, 0x02, 0x04, 0xce, 0x11, 0x09, 0x12, 0x49, 0xbd, 0xa1, 0xa8, 0xfe, 0xc8, 0x39, 0xb9,
	0x04, 0x65, 0x8a, 0x52, 0x05, 0x45, 0x8a, 0x1a, 0x1f, 0x39, 0xae, 0x42, 0x9e, 0xd0, 0x13, 0xca,
	0x1f, 0x1f, 0xb3, 0x27, 0x41, 0xb5, 0xfe, 0xf3, 0x06, 0xc0, 0x76, 0xb6, 0x14, 0xf4, 0x02, 0xe6,
	0x7c, 0x4f, 0xaf, 0x98, 0x95, 0xb5, 0xe6, 0xd6, 0x9f, 0x4f, 0x27, 0xc6, 0xcf, 0x12, 0xe2, 0xc4,
	0xee, 0xe9, 0x86, 0x95, 0x63, 0xcc, 0xde, 0xf6, 0x43, 0xa6, 0x9e, 0x3c, 0x3c, 0xf5, 0x3d, 0x8f,
	0x84, 0x96, 0x99, 0xfc, 0x36, 0xd8, 0xb0, 0xa2, 0xb3, 0x87, 0xe9, 0x45, 0x44, 0xd6, 0xc6, 0x63,
	0xdf, 0xfb, 0xc8, 0xc2, 0x73, 0xbe, 0x87, 0x3e, 0x81, 0x5a, 0xe8, 0x8c, 0x88, 0x3e, 0xc7, 0xd5,
	0xdd, 0x9b, 0x4e, 0x8c, 0x3b, 0x97, 0xd5, 0x09, 0x5d, 0x16, 0xe6, 0x50, 0xf4, 0x73, 0xa8, 0x9d,
	0x3a, 0xc9, 0xa9, 0xbe, 0x6a, 0x56, 0xd6, 0x6a, 0x5b, 0xef, 0x4f, 0x27, 0xc6, 0x03, 0xf6, 0xbe,
	0x61, 0xf9, 0x27, 0x21, 0x83, 0x99, 0x09, 0x09, 0x13, 0x1a, 0x97, 0x68, 0x98, 0x8b, 0xa0, 0x27,
	0x50, 0x63, 0x13, 0xd0, 0x6b, 0x7c, 0xb4, 0xbb, 0xd3, 0x89, 0xa1, 0x5f, 0x31, 0xf9, 0xe1, 0x45,
	0xc4, 0x24, 0x18, 0x12, 0x6d, 0x40, 0x93, 0x0d, 0x9a, 0x44, 0x8e, 0x4b, 0xf4, 0xf9, 0xcb, 0x62,
	0x7d, 0xc5, 0x54, 0x73, 0xcc, 0xe1, 0xe8, 0x3b, 0x58, 0xcc, 0x5e, 0x6c, 0xdf, 0xd3, 0xdf, 0xe6,
	0xe2, 0xc3, 0xe9, 0xc4, 0x18, 0x5c, 0x12, 0x37, 0x7b, 0xdb, 0x72, 0x93, 0x8e, 0xcf, 0xd6, 0x32,
	0xea, 0x1e, 0x49, 0x1d, 0xcf, 0x49, 0x9d, 0x0d, 0xdf, 0xfb, 0xe8, 0x61, 0x48, 0x1f, 0x1d, 0x9f,
	0x3d, 0x72, 0x69, 0x98, 0xa4, 0x31, 0x3b, 0xc8, 0xd2, 0x5e, 0xb6, 0xb2, 0x91, 0x7a, 0x1e, 0xfa,
	0x16, 0x6e, 0xd3, 0xd8, 0x3d, 0x25, 0x0c, 0x98, 0xd2, 0xd8, 0x76, 0xe9, 0x28, 0xa2, 0x21, 0x09,
	0x53, 0xfd, 0x81, 0x59, 0x59, 0x6b, 0x6c, 0xbd, 0x3b, 0x9d, 0x18, 0x86, 0x9a, 0xc2, 0x7e, 0x01,
	0x69, 0x76, 0x14, 0xd2, 0xc2, 0xb7, 0x8a, 0x2a, 0x32, 0x3a, 0xfa, 0x04, 0x1a, 0x31, 0x89, 0x02,
	0xdf, 0x75, 0x12, 0x7d, 0xc1, 0xac, 0xac, 0x55, 0xb7, 0x6e, 0x4d, 0x27, 0xc6, 0x4a, 0x44, 0x03,
	0xdf, 0xbd, 0xd8, 0xb0, 0xb0, 0xe4, 0x59, 0x38, 0x83, 0xa1, 0xbf, 0x82, 0x05, 0x61, 0xa4, 0x7a,
	0xdd, 0xac, 0xae, 0xb5, 0x9e, 0x1a, 0xeb, 0xd2, 0xf4, 0xd6, 0xf3, 0x4d, 0x5f, 0xdf, 0xe5, 0x88,
	0x6e, 0x98, 0xc6, 0x17, 0xe5, 0xf9, 0x15, 0x0e, 0x86, 0x63, 0xd4, 0x46, 0x4b, 0x9d, 0xc8, 0x06,
	0x88, 0xa8, 0x67, 0xcb, 0x11, 0x6e, 0xf0, 0x11, 0xac, 0xab, 0x46, 0x18, 0x50, 0xaf, 0x38, 0x48,
	0xe9, 0x18, 0x07, 0xd4, 0x2b, 0x6b, 0x6f, 0x46, 0x0a, 0x8d, 0x9e, 0x41, 0x9b, 0x2b, 0xb7, 0x13,
	0x12, 0x10, 0x37, 0xa5, 0xb1, 0x7e, 0xd3, 0xac, 0xac, 0xb5, 0x9e, 0xde, 0xce, 0x06, 0xe1, 0xc0,
	0x03, 0xc9, 0xc5, 0x4b, 0x41, 0xf1, 0x15, 0x11, 0xa8, 0xbb, 0x31, 0x71, 0x52, 0xe2, 0xe9, 0x0d,
	0x2e, 0xb7, 0xba, 0x2e, 0x2e, 0xff, 0xba, 0xba, 0xfc, 0xeb, 0x43, 0x75, 0xf9, 0xb7, 0x1e, 0x4f,
	0x27, 0xc6, 0x4f, 0xd4, 0xa4, 0x3a, 0x42, 0x6c, 0xe6, 0x26, 0x95, 0xed, 0x5a, 0xe9, 0x46, 0x43,
	0x00, 0x37, 0x18, 0x27, 0x29, 0x89, 0x99, 0xa9, 0x35, 0xb9, 0xa9, 0xfd, 0xd9, 0x74, 0x62, 0x7c,
	0x92, 0x69, 0x13, 0xdc, 0x6b, 0xae, 0x66, 0xd1, 0x96, 0x9a, 0x52, 0x51, 0xcf, 0x43, 0xcf, 0x60,
	0x51, 0x69, 0xe5, 0xd7, 0x14, 0xb8, 0xde, 0xd5, 0xe9, 0xc4, 0xb8, 0x3d, 0xa3, 0x57, 0x6d, 0x5c,
	0x4b, 0xe2, 0x99, 0x0d, 0xa3, 0xa7, 0x00, 0x99, 0xff, 0x4a, 0xf4, 0x16, 0x3f, 0x1b, 0x94, 0x6d,
	0x5b, 0x47, 0xb1, 0x70, 0x01, 0x85, 0x7e, 0x03, 0x2d, 0x27, 0x0c, 0x69, 0xea, 0xa4, 0x3e, 0x0d,
	0x13, 0xbd, 0xcd, 0x85, 0xde, 0xbb, 0xea, 0x40, 0x37, 0x73, 0x98, 0x38, 0x52, 0x6b, 0x3a, 0x31,
	0xee, 0x5f, 0x61, 0x37, 0x39, 0xd0, 0xc2, 0x45, 0xe5, 0xe8, 0x25, 0x34, 0xa2, 0xd8, 0xa7, 0xb1,
	0x9f, 0x5e, 0xe8, 0xcb, 0xdc, 0x98, 0x37, 0xa6, 0x13, 0xe3, 0xa7, 0x57, 0xa8, 0xc0, 0x7e, 0x72,
	0x66, 0x0e, 0x24, 0xf6, 0x9a, 0xb3, 0xc8, 0x74, 0xa1, 0x55, 0x68, 0xf8, 0xa1, 0xe3, 0xa6, 0xfe,
	0x39, 0xd1, 0x35, 0x76, 0xe5, 0x70, 0xf6, 0x8e, 0x76, 0x01, 0x71, 0xe7, 0x6c, 0x47, 0xe3, 0x80,
	0xd9, 0x94, 0x1b, 0x93, 0x34, 0xd1, 0x57, 0xcc, 0xea, 0x5a, 0x73, 0xeb, 0xfe, 0x74, 0x62, 0xac,
	0xaa, 0xd1, 0x7b, 0x0c, 0x65, 0x0e, 0xc6, 0x41, 0x60, 0x1e, 0x70, 0x94, 0x85, 0x35, 0x2e, 0xc9,
	0x48, 0x82, 0x92, 0xa0, 0x2e, 0x2c, 0x27, 0x24, 0x3e, 0xf7, 0x5d, 0x62, 0x3b, 0xae, 0x4b, 0xc7,
	0x61, 0xaa, 0xa3, 0xcb, 0x5e, 0xea, 0x40, 0x40, 0xcc, 0x4d, 0x01, 0xb1, 0x70, 0x5b, 0x0a, 0x49,
	0x02, 0xfa, 0xfb, 0x0a, 0x98, 0x33, 0x7a, 0xec, 0x88, 0xc4, 0x23, 0x3f, 0x49, 0x7c, 0x1a, 0xda,
	0x01, 0x39, 0x27, 0x81, 0x7e, 0xd7, 0xac, 0xac, 0xb5, 0x9f, 0xea, 0xd9, 0x51, 0x0c, 0x32, 0xc0,
	0x2e, 0xe3, 0x6f, 0x7d, 0x3a, 0x9d, 0x18, 0x8f, 0xaf, 0x19, 0xd2, 0xcc, 0xc1, 0x26, 0x47, 0x2b,
	0x7b, 0xb9, 0x57, 0x9e, 0xc9, 0x8c, 0x4e, 0x94, 0x80, 0xe1, 0x8c, 0x53, 0x3a, 0xe2, 0x33, 0x9a,
	0x9d, 0x61, 0x4a, 0xcf, 0x48, 0xa8, 0xdf, 0xe1, 0x3e, 0xed, 0xe1, 0x74, 0x62, 0xac, 0x29, 0x2f,
	0xb4, 0xa9, 0x44, 0xcc, 0xd9, 0x69, 0x0c, 0x99, 0x88, 0x85, 0xef, 0x66, 0x4a, 0x0f, 0x4a, 0xc3,
	0x73, 0x36, 0xfa, 0x02, 0x16, 0x4f, 0x69, 0x92, 0xda, 0x21, 0x49, 0xbf, 0xa3, 0xf1, 0x99, 0x7e,
	0x8b, 0x8f, 0x70, 0x67, 0x3a, 0x31, 0x6e, 0xa9, 0x11, 0xbe, 0xa2, 0x49, 0x6a, 0xf6, 0x05, 0xdf,
	0xc2, 0x2d, 0x06, 0x97, 0x6f, 0xe8, 0x09, 0x34, 0xb8, 0x74, 0xe4, 0x7b, 0xba, 0xc1, 0x25, 0x4b,
	0x1e, 0x92, 0x4b, 0x0e, 0x7a, 0xdb, 0x16, 0xae, 0x33, 0xd8, 0xc0, 0xf7, 0x32, 0x09, 0x3f, 0x72,
	0x75, 0xf3, 0x1a, 0x89, 0xde, 0xa0, 0x23, 0x25, 0x7a, 0x91, 0x8b, 0x7e, 0x01, 0x4b, 0x32, 0x1d,
	0xb0, 0xdd, 0xc0, 0x49, 0x12, 0xdd, 0xca, 0x2f, 0x66, 0xe6, 0x8a, 0x05, 0xc0, 0xec, 0x30, 0x80,
	0x85, 0x17, 0xa5, 0x00, 0x7f, 0x45, 0x5d, 0x68, 0xa5, 0x34, 0x20, 0xb1, 0xbc, 0x65, 0xb7, 0xf9,
	0x2d, 0xbb, 0x91, 0x1d, 0xed, 0x30, 0xe3, 0x6d, 0xb5, 0xa7, 0x13, 0x03, 0xd4, 0xa9, 0x3e, 0xb2,
	0x70, 0x51, 0x0e, 0x3d, 0x83, 0xf9, 0x88, 0xc6, 0x69, 0xa2, 0xeb, 0x33, 0x0a, 0x06, 0x34, 0x4e,
	0x3b, 0x34, 0x3c, 0xf6, 0x4f, 0xb6, 0xd0, 0x74, 0x62, 0xb4, 0xd5, 0xa4, 0x18, 0x3d, 0xb1, 0xb0,
	0x90, 0x42, 0x7d, 0x58, 0x4e, 0x52, 0x27, 0x25, 0x76, 0x96, 0xfe, 0xe8, 0xef, 0xf0, 0x6b, 0xf8,
	0x86, 0x51, 0xbd, 0xcd, 0xa5, 0x33, 0xf7, 0x89, 0xbe, 0x01, 0x88, 0xfd, 0xe4, 0xcc, 0x4e, 0x5c,
	0x1a, 0x13, 0xfd, 0x9e, 0x59, 0x59, 0x9b, 0xfb, 0xe1, 0x1b, 0x7d, 0xe0, 0x16, 0x3d, 0xa1, 0x9a,
	0xe4, 0x43, 0xa5, 0xbf, 0xc9, 0xb4, 0x71, 0xcc, 0xea, 0xcf, 0xa1, 0x55, 0x88, 0x1e, 0x48, 0x83,
	0xea, 0x19, 0xb9, 0x10, 0x59, 0x10, 0x66, 0x8f, 0xe8, 0x26, 0xcc, 0x9f, 0x3b, 0xc1, 0x58, 0xa6,
	0x32, 0x58, 0xbc, 0x6c, 0xcc, 0x7d, 0x5e, 0x59, 0xfd, 0x02, 0xda, 0xe5, 0xd8, 0xf3, 0xa3, 0xa4,
	0xbf, 0x04, 0x6d, 0xd6, 0xd1, 0xfd, 0x18, 0xf9, 0x9d, 0x5a, 0xa3, 0xaa, 0xd5, 0x76, 0x6a, 0x8d,
	0x45, 0x6d, 0x69, 0xa7, 0xd6, 0xb8, 0xaf, 0x19, 0xd6, 0x3f, 0xce, 0x41, 0x3b, 0xf3, 0xbd, 0xdc,
	0xcb, 0xa0, 0x23, 0x9e, 0xd3, 0x89, 0xb4, 0x08, 0x4f, 0x27, 0x46, 0xbf, 0xec, 0x84, 0x0e, 0x4e,
	0x9d, 0xab, 0x82, 0xc6, 0xf1, 0xd9, 0x1a, 0xe7, 0x5f, 0x9d, 0x9e, 0xf8, 0xa1, 0x47, 0x5e, 0x3d,
	0x63, 0x07, 0x26, 0x52, 0xbd, 0x0f, 0x64, 0xaa, 0x57, 0xe1, 0x51, 0x30, 0x0f, 0x03, 0x5c, 0x05,
	0x0b, 0x17, 0x32, 0xbf, 0x7b, 0x00, 0x8b, 0x21, 0x4d, 0xb9, 0x7b, 0x74, 0x8e, 0x02, 0x11, 0x73,
	0x1a, 0xb8, 0x15, 0xd2, 0x74, 0x20, 0x49, 0x68, 0x0d, 0x34, 0x3f, 0xb1, 0x55, 0x64, 0x0a, 0xa8,
	0xeb, 0x04, 0x7a, 0x8b, 0xc3, 0xda, 0x7e, 0x22, 0x03, 0xd2, 0x2e, 0xa3, 0x6e, 0xd4, 0xfe, 0xf0,
	0xcf, 0xc6, 0x5b, 0x3b, 0xb5, 0xc6, 0x9c, 0x56, 0xcd, 0x76, 0x62, 0x5e, 0x5b, 0xd8, 0xa9, 0x35,
	0x16, 0xb4, 0xfa, 0x4e, 0xad, 0x51, 0xd7, 0x1a, 0x3b, 0xb5, 0x46, 0x43, 0x6b, 0xee, 0xd4, 0x1a,
	0x4d, 0x0d, 0xac, 0xbf, 0x59, 0x80, 0x66, 0xb6, 0x37, 0xa8, 0x9d, 0xa7, 0xba, 0x7c, 0x09, 0x4f,
	0x60, 0xc1, 0xe5, 0x46, 0xcd, 0xb7, 0xb9, 0x55, 0xf0, 0x85, 0x99, 0x8c, 0x30, 0x7a, 0x2c, 0x71,
	0xe8, 0x11, 0xcc, 0x73, 0x9f, 0xad, 0x57, 0xb9, 0xc0, 0xdb, 0x97, 0x05, 0xf8, 0xf2, 0xb1, 0x40,
	0xa1, 0x0e, 0x68, 0x09, 0x71, 0xc7, 0x2c, 0x88, 0xd8, 0x2c, 0x26, 0x92, 0x57, 0x29, 0x3f, 0x95,
	0xe2, 0x50, 0x07, 0x12, 0xd0, 0x11, 0x7c, 0xbc, 0x9c, 0x94, 0x09, 0xe8, 0x77, 0x15, 0xa8, 0x9f,
	0xd3, 0x60, 0x3c, 0x22, 0x89, 0x3e, 0xcf, 0xef, 0xe5, 0x72, 0x26, 0xfc, 0x92, 0xd3, 0xb7, 0x5e,
	0x4e, 0x27, 0x06, 0x16, 0x67, 0x18, 0x38, 0x27, 0xcf, 0xf0, 0xfe, 0xaf, 0xed, 0xed, 0xee, 0x60,
	0x77, 0xff, 0x9b, 0xbd, 0x6e, 0x7f, 0x68, 0xbf, 0xdc, 0xdf, 0x3d, 0xdc, 0xeb, 0xda, 0x07, 0xdd,
	0x4d, 0xdc, 0xf9, 0x8a, 0xdd, 0x3c, 0x61, 0x0b, 0xaf, 0x87, 0x62, 0x35, 0x2e, 0xda, 0x51, 0x8e,
	0x61, 0xe1, 0x7a, 0xc7, 0x60, 0x4c, 0x27, 0xc6, 0x3b, 0xb3, 0x77, 0xce, 0x2c, 0xb8, 0x1a, 0xe9,
	0x25, 0x7e, 0x5f, 0x81, 0xba, 0x8a, 0x93, 0x22, 0x83, 0xcc, 0xb7, 0xb1, 0x3b, 0x3a, 0x22, 0x9e,
	0x47, 0x3c, 0x11, 0x0f, 0x5f, 0xb3, 0xae, 0x83, 0x6e, 0x07, 0x77, 0x87, 0x6f, 0xb4, 0xae, 0x32,
	0x14, 0xab, 0xf1, 0xd1, 0x13, 0x68, 0xc6, 0x24, 0xa1, 0xe3, 0xd8, 0x25, 0x89, 0xcc, 0xe7, 0x72,
	0x4b, 0xc6, 0x8a, 0x83, 0x73, 0x10, 0x7a, 0x2c, 0xcd, 0x5e, 0xa4, 0x4e, 0xef, 0x4c, 0x27, 0xc6,
	0xdb, 0x6a, 0xcd, 0x99, 0x0d, 0x98, 0xcc, 0xfc, 0x55, 0x7d, 0xc3, 0xf2, 0x4d, 0xff, 0x9c, 0x84,
	0x24, 0x49, 0xec, 0x28, 0xa6, 0x47, 0x84, 0x9b, 0x76, 0x29, 0xdf, 0x94, 0xec, 0x01, 0xe3, 0xe2,
	0xa5, 0xa0, 0xf8, 0x8a, 0xfe, 0x02, 0x96, 0x63, 0xe2, 0x78, 0x7e, 0x41, 0x7e, 0x71, 0xc6, 0xf6,
	0xb0, 0xe2, 0x0b, 0x05, 0xed, 0xb8, 0xf4, 0x2e, 0x6f, 0xc2, 0x7f, 0xcc, 0x41, 0x33, 0x5b, 0x10,
	0x1a, 0xc0, 0x8a, 0x1b, 0x8d, 0x6d, 0xe6, 0x0a, 0x13, 0x3b, 0x26, 0xbf, 0x1d, 0x93, 0x24, 0xe5,
	0x17, 0x63, 0x6e, 0xeb, 0xbd, 0xe9, 0xc4, 0xc8, 0xf6, 0xb2, 0x33, 0x38, 0x34, 0x3b, 0x0c, 0x64,
	0x62, 0x01, 0x52, 0x71, 0x7e, 0xd9, 0x8d, 0xc6, 0x9c, 0x21, 0xe9, 0x68, 0x07, 0x96, 0x73, 0x8d,
	0x81, 0x3f, 0xf2, 0x53, 0x7e, 0xa9, 0xe6, 0xca, 0x59, 0x5c, 0xae, 0x6f, 0x97, 0x41, 0x94, 0xb6,
	0x25, 0xa5, 0x8d, 0x53, 0x11, 0x86, 0x95, 0x11, 0x19, 0xd1, 0xf8, 0xc2, 0x1e, 0x1d, 0x65, 0xb3,
	0xab, 0x72, 0x6d, 0x1f, 0x4c, 0x27, 0x86, 0xa5, 0xb4, 0xed, 0x71, 0x90, 0x9a, 0x9a, 0xb9, 0xb6,
	0xb7, 0xf5, 0x51, 0x36, 0x3f, 0xa1, 0x60, 0xef, 0x48, 0xcd, 0x6f, 0x17, 0x96, 0x73, 0x9d, 0x62,
	0x7e, 0xb5, 0xcb, 0xeb, 0x95, 0x1a, 0xf9, 0x34, 0x4a, 0xfa, 0x96, 0x94, 0x3e, 0xce, 0xb2, 0xfe,
	0xb7, 0x0a, 0x0b, 0xe2, 0xee, 0xa1, 0xa7, 0x05, 0x3f, 0x38, 0x93, 0xf2, 0x09, 0x04, 0xb7, 0x86,
	0x72, 0xcd, 0xfb, 0x39, 0x2c, 0x88, 0x93, 0x90, 0x85, 0xb2, 0x39, 0x9d, 0x18, 0x77, 0x67, 0xa4,
	0x0e, 0x38, 0x20, 0x2b, 0x8f, 0x04, 0x1e, 0xfd, 0x12, 0x5a, 0x1e, 0x49, 0x52, 0x3f, 0xe4, 0xf1,
	0x83, 0x6f, 0x4a, 0x53, 0x84, 0xd7, 0x19, 0xf1, 0xed, 0x1c, 0x95, 0xe5, 0xf2, 0x05, 0x49, 0xf4,
	0x0b, 0x66, 0xf9, 0x8e, 0x67, 0xd3, 0x30, 0xb8, 0xe0, 0x3b, 0xd1, 0x28, 0x9f, 0x94, 0x54, 0xc3,
	0x6c, 0x6b, 0x3f, 0x0c, 0x2e, 0x94, 0x8e, 0x46, 0x2c, 0x09, 0x6c, 0xdd, 0xbc, 0xf8, 0x9e, 0xbf,
	0x76, 0xdd, 0xac, 0xf0, 0xce, 0xd6, 0xcd, 0xcb, 0xef, 0x11, 0xac, 0x88, 0xd4, 0x2f, 0x8a, 0x69,
	0xe4, 0x9c, 0x88, 0x35, 0x2c, 0xf0, 0x3c, 0xd4, 0x9c, 0xf1, 0x69, 0xeb, 0x7b, 0x3c, 0x7f, 0xcc,
	0x71, 0x62, 0x08, 0x75, 0xd7, 0xf6, 0x44, 0x16, 0x9a, 0xb3, 0x2d, 0xac, 0x8d, 0x66, 0x24, 0xac,
	0xe7, 0xa0, 0xcd, 0x6a, 0x41, 0x0d, 0xa8, 0xf5, 0xf7, 0xfb, 0x5d, 0xed, 0x2d, 0x74, 0x0b, 0x56,
	0xbe, 0xda, 0x3f, 0x18, 0xda, 0xc3, 0x7d, 0xbb, 0xb3, 0xdf, 0x1f, 0x6e, 0xf6, 0xfa, 0x5d, 0xac,
	0x55, 0xd0, 0x0a, 0x2c, 0x6d, 0xf5, 0xb6, 0x7b, 0xb8, 0xdb, 0x19, 0xf6, 0xf6, 0xfb, 0x9b, 0xbb,
	0xda, 0x9c, 0xd5, 0x87, 0xa5, 0xd2, 0x1d, 0x45, 0xcf, 0xa0, 0xee, 0x91, 0x63, 0x3f, 0x24, 0x22,
	0x9a, 0xc8, 0x12, 0x5c, 0xcd, 0x4d, 0x61, 0x4d, 0x0e, 0x36, 0xb7, 0x05, 0xd2, 0xc2, 0x4a, 0xc6,
	0x1a, 0x40, 0xbb, 0x7c, 0x67, 0xd1, 0x97, 0xb3, 0x0a, 0xb9, 0x55, 0xe6, 0x55, 0xb8, 0x04, 0x5f,
	0xab, 0xf1, 0xdf, 0xe6, 0xa1, 0x3a, 0xa0, 0x1e, 0xfa, 0xb2, 0xd0, 0xcc, 0x59, 0x9f, 0x4e, 0x8c,
	0x8f, 0x8b, 0x15, 0x71, 0x6f, 0xfb, 0xb5, 0xfd, 0x9b, 0x27, 0xa5, 0xfe, 0xcd, 0xa5, 0x9a, 0x9a,
	0x5b, 0xb2, 0xd4, 0x21, 0x4d, 0xf9, 0xaf, 0x61, 0x29, 0xef, 0x8b, 0xb1, 0x5a, 0x55, 0x98, 0xe4,
	0xe1, 0x74, 0x62, 0x7c, 0x7d, 0x75, 0x27, 0x69, 0x36, 0xe7, 0xc8, 0xb9, 0xaf, 0xef, 0x8b, 0x2c,
	0xe6, 0x63, 0xf5, 0xbc, 0x72, 0x37, 0xa7, 0xf6, 0xe3, 0xba, 0x39, 0xe5, 0x02, 0x7b, 0xfe, 0x4f,
	0x54, 0x60, 0x6f, 0x0a, 0x67, 0x6f, 0xfb, 0x61, 0x92, 0x3a, 0x21, 0x0b, 0x2a, 0x22, 0x60, 0xae,
	0x5e, 0x91, 0x28, 0x48, 0x88, 0x70, 0xf8, 0xea, 0x2d, 0x41, 0x04, 0x6e, 0xa6, 0xac, 0x6a, 0x0a,
	0x9d, 0x94, 0x78, 0x05, 0x45, 0xf5, 0x99, 0x56, 0xc8, 0x80, 0x7a, 0x97, 0x95, 0xed, 0xfa, 0x49,
	0x7a, 0x29, 0xc5, 0xbf, 0x91, 0xeb, 0xcb, 0x87, 0xf9, 0x0c, 0xea, 0x49, 0xea, 0xc4, 0x6f, 0xd4,
	0xc7, 0xc0, 0x0a, 0xba, 0xfa, 0x35, 0xdc, 0xba, 0x72, 0x4c, 0xf4, 0x39, 0x34, 0xf3, 0xa9, 0x56,
	0x5e, 0xbb, 0xe6, 0x1c, 0x6c, 0xfd, 0x57, 0x15, 0x56, 0x2e, 0x01, 0xd0, 0x33, 0x68, 0x29, 0x88,
	0x2d, 0x2d, 0xba, 0xf5, 0xf4, 0xee, 0xf5, 0x1a, 0x7b, 0xdb, 0x18, 0x94, 0x40, 0xcf, 0x43, 0x1f,
	0xc3, 0x8a, 0xec, 0x41, 0xf8, 0xe1, 0x89, 0x1d, 0x51, 0x8f, 0x29, 0x11, 0xb9, 0xf4, 0x72, 0xce,
	0x18, 0x50, 0xaf, 0xe7, 0xa1, 0xf7, 0xa1, 0x9d, 0x77, 0x65, 0xb9, 0xf5, 0x2f, 0x70, 0xe0, 0x52,
	0x46, 0xe5, 0xcd, 0x8f, 0x77, 0x21, 0x27, 0xd8, 0x7e, 0x94, 0xe8, 0x55, 0x56, 0xe3, 0xe3, 0xc5,
	0x8c, 0xd8, 0x8b, 0x4a, 0xbb, 0x5a, 0x7b, 0xe3, 0x5d, 0x45, 0x7b, 0xb0, 0x28, 0x7a, 0x08, 0x9e,
	0x7f, 0xc2, 0x42, 0x9d, 0xb0, 0xc6, 0x8f, 0xa7, 0x13, 0xe3, 0x83, 0xcc, 0x1a, 0xb3, 0xdc, 0x42,
	0xa4, 0xf0, 0xdb, 0x1c, 0x99, 0xdd, 0xc5, 0x16, 0x97, 0x17, 0x44, 0xf4, 0x53, 0x68, 0x1c, 0xfb,
	0xa1, 0x9f, 0x9c, 0x12, 0x4f, 0xaf, 0xbf, 0x76, 0x16, 0x19, 0x16, 0xbd, 0x03, 0x4d, 0xf2, 0xca,
	0x4f, 0x6d, 0x97, 0x7a, 0x84, 0x1b, 0xc5, 0x3c, 0x6e, 0x30, 0x42, 0x87, 0x7a, 0x04, 0x3d, 0x02,
	0xa4, 0xcc, 0xc8, 0xa7, 0xa1, 0x1d, 0x13, 0x27, 0xa1, 0xa1, 0x68, 0x4c, 0xe1, 0x95, 0x02, 0x07,
	0x73, 0x86, 0xf5, 0xbb, 0x0a, 0xdc, 0xb8, 0xe2, 0x90, 0xd0, 0xf3, 0xec, 0x60, 0xf2, 0x16, 0x38,
	0x3f, 0xdd, 0xf6, 0xd3, 0x3b, 0x57, 0x74, 0x92, 0x04, 0x00, 0x6b, 0xee, 0x0c, 0x45, 0xa6, 0xf2,
	0x73, 0x59, 0x2a, 0x8f, 0xa0, 0x16, 0xb2, 0x69, 0x73, 0xef, 0x83, 0xf9, 0xb3, 0x75, 0x02, 0xed,
	0x72, 0x3e, 0x89, 0x3e, 0x2c, 0xc5, 0xea, 0x1b, 0xd3, 0x89, 0xb1, 0x9c, 0x37, 0x38, 0x44, 0x4f,
	0x46, 0x78, 0xb5, 0x87, 0x50, 0x8b, 0x9c, 0xf4, 0x54, 0xfa, 0x41, 0x7d, 0x3a, 0x31, 0x6e, 0x96,
	0x81, 0xe6, 0xc0, 0x49, 0x4f, 0x2d, 0xcc, 0x51, 0xd6, 0xbf, 0x34, 0x00, 0xf2, 0x44, 0x98, 0xcf,
	0x25, 0x1b, 0x45, 0x2a, 0xfc, 0xb2, 0x68, 0x64, 0x2c, 0x0f, 0xe6, 0xaa, 0xe7, 0xb7, 0xde, 0x9e,
	0x4e, 0x8c, 0x1b, 0xb9, 0x8b, 0x8d, 0x0b, 0x29, 0x91, 0x82, 0x33, 0x2a, 0xfa, 0x02, 0x1a, 0xfc,
	0xec, 0x5c, 0x1a, 0x48, 0x0f, 0x5b, 0xca, 0x19, 0x18, 0x86, 0x05, 0x07, 0x0e, 0xc8, 0x62, 0xb5,
	0x92, 0x40, 0x1e, 0x34, 0xc8, 0xab, 0x88, 0x26, 0xe3, 0x58, 0xf8, 0xc9, 0xf6, 0xd3, 0x07, 0x57,
	0x64, 0xf0, 0xeb, 0x5d, 0x89, 0x11, 0xfd, 0x9f, 0x52, 0x56, 0xb1, 0xe7, 0xbc, 0x32, 0x15, 0xbb,
	0xdc, 0xf1, 0xc9, 0x34, 0xa3, 0xf7, 0x61, 0x91, 0x3f, 0x13, 0x4f, 0xac, 0x70, 0x9e, 0xaf, 0x70,
	0x4e, 0xaf, 0xe0, 0x96, 0xa4, 0xf3, 0xa5, 0x8c, 0xa1, 0xad, 0x44, 0x6c, 0x3f, 0x3c, 0xa6, 0xca,
	0x47, 0x9a, 0x3f, 0x34, 0xa5, 0x5e, 0x78, 0x4c, 0xcb, 0x4d, 0xa1, 0x6c, 0x36, 0x8c, 0x95, 0x94,
	0x1b, 0x0a, 0x09, 0x3b, 0xc9, 0x25, 0x52, 0x90, 0x4d, 0x56, 0xff, 0xb5, 0x06, 0x8b, 0x45, 0x6d,
	0xe8, 0x5b, 0x98, 0x17, 0x8d, 0xb0, 0xca, 0x9b, 0xee, 0xc8, 0x83, 0xe9, 0xc4, 0xb8, 0xa7, 0x76,
	0xe4, 0xea, 0xdd, 0x10, 0x2a, 0xd1, 0x73, 0x58, 0x54, 0xdd, 0xad, 0x42, 0x3c, 0x2d, 0x35, 0xc2,
	0xb9, 0xbc, 0x1f, 0x9e, 0xa8, 0x9e, 0x56, 0x96, 0xa5, 0x49, 0x41, 0xee, 0x74, 0xee, 0x01, 0x28,
	0x3d, 0x2a, 0xb4, 0xe2, 0xa6, 0xa4, 0xf4, 0x3c, 0xf4, 0x10, 0x90, 0x62, 0x67, 0xc1, 0x2c, 0x12,
	0x91, 0x10, 0x6b, 0x92, 0x23, 0xe3, 0x58, 0x2f, 0x42, 0x2f, 0xf2, 0x49, 0x15, 0xce, 0x67, 0x6d,
	0x3a, 0x31, 0xde, 0xbb, 0x6e, 0x52, 0x66, 0xd1, 0x24, 0xd5, 0xcc, 0xf8, 0x29, 0x6e, 0x42, 0x93,
	0x5d, 0x32, 0xa1, 0x69, 0x81, 0x6b, 0x2a, 0x65, 0xd2, 0x5d, 0x71, 0xe2, 0x66, 0x9f, 0x7a, 0x65,
	0x2d, 0x0d, 0x26, 0x26, 0x55, 0x2c, 0x92, 0x57, 0x29, 0x89, 0x43, 0x27, 0xe0, 0x0e, 0xb5, 0x7e,
	0xb9, 0x69, 0xda, 0x95, 0x7c, 0xb3, 0x37, 0xc8, 0x66, 0xa1, 0x64, 0x98, 0xbf, 0x3d, 0x00, 0x94,
	0xa9, 0x38, 0xa5, 0x49, 0xca, 0xe3, 0xbb, 0xde, 0xe0, 0x8a, 0x66, 0xa6, 0x23, 0x15, 0x7d, 0x25,
	0x51, 0x4a, 0xdd, 0x8a, 0x92, 0x57, 0x8c, 0xc4, 0x3a, 0x84, 0xa5, 0xd2, 0xb9, 0xa3, 0x26, 0xcc,
	0x1f, 0xf6, 0x0f, 0xba, 0x43, 0xed, 0x2d, 0xb4, 0x08, 0x8d, 0xee, 0xaf, 0x87, 0x5d, 0xcc, 0x12,
	0xc3, 0x8a, 0x48, 0x26, 0xb7, 0xbb, 0xda, 0x1c, 0xa3, 0xf7, 0xfa, 0x92, 0x5e, 0x65, 0x74, 0x96,
	0x5a, 0x6a, 0x35, 0x26, 0x8a, 0xf7, 0x0f, 0x87, 0x5d, 0x6d, 0xde, 0xfa, 0xe3, 0x3c, 0x2c, 0xcf,
	0xf4, 0x15, 0xd0, 0xdf, 0x55, 0xa0, 0x4a, 0xc2, 0x73, 0x19, 0x31, 0x3f, 0xbe, 0xae, 0xff, 0xb0,
	0xde, 0x0d, 0xcf, 0xfd, 0x98, 0x86, 0x2c, 0xef, 0x91, 0xd5, 0xf6, 0x0f, 0x97, 0xc6, 0xdd, 0xfe,
	0xcb, 0x97, 0x9b, 0xf8, 0x8d, 0x4a, 0xe3, 0x32, 0x14, 0xb3, 0xe9, 0x20, 0x1d, 0xea, 0x2e, 0x1d,
	0x8d, 0x9c, 0x90, 0xb9, 0x58, 0x16, 0xe5, 0xd4, 0x2b, 0xf3, 0x6d, 0x4e, 0x7c, 0xa2, 0x82, 0x1f,
	0x7f, 0x46, 0x77, 0xa1, 0xe9, 0xf9, 0x31, 0xff, 0x3c, 0x72, 0x21, 0x8d, 0x2f, 0x27, 0x30, 0x89,
	0x71, 0x42, 0x62, 0x11, 0xd4, 0x30, 0x7f, 0x46, 0x1a, 0x54, 0xc7, 0xbe, 0x27, 0x3e, 0x38, 0x61,
	0xf6, 0x88, 0x7a, 0xb0, 0xe2, 0x44, 0x91, 0xed, 0xc4, 0x23, 0x1a, 0xb3, 0xea, 0xe0, 0xd8, 0x0f,
	0x08, 0x0f, 0x5e, 0xf2, 0x2b, 0x62, 0xd6, 0x0a, 0x8e, 0xa2, 0x4d, 0x86, 0x61, 0xce, 0x8e, 0x61,
	0x2c, 0xbc, 0xec, 0x48, 0x92, 0xa4, 0xac, 0xfe, 0xbe, 0x0a, 0x2b, 0x97, 0xf6, 0x0b, 0x7d, 0x56,
	0xe8, 0xb1, 0x95, 0x2b, 0x9d, 0x02, 0xd6, 0x7c, 0x41, 0xb2, 0x4a, 0x87, 0xf7, 0xe1, 0x36, 0x4a,
	0x7d, 0xb8, 0x19, 0x93, 0x2a, 0xc8, 0xbd, 0x64, 0xa0, 0xcc, 0x07, 0x70, 0x11, 0xf4, 0xb7, 0x15,
	0x68, 0x93, 0xf0, 0xdc, 0x3e, 0x77, 0x62, 0x5b, 0x56, 0x7b, 0x55, 0xee, 0x69, 0x7e, 0xf6, 0xe6,
	0xc7, 0xcc, 0x28, 0x2f, 0x9d, 0x58, 0xd4, 0x82, 0xe5, 0x8c, 0xbe, 0x3c, 0x7c, 0xec, 0x3b, 0x47,
	0xc1, 0x6c, 0xd1, 0xb8, 0x48, 0x0a, 0xd2, 0x56, 0x0c, 0x8b, 0x45, 0x6d, 0x45, 0xab, 0xae, 0x43,
	0x15, 0x6f, 0xfe, 0x4a, 0xab, 0xa0, 0x36, 0x80, 0x6c, 0x95, 0xbc, 0xe8, 0x7e, 0xa3, 0xcd, 0x21,
	0x04, 0xed, 0xce, 0x7e, 0xff, 0x79, 0xef, 0x97, 0xf6, 0xde, 0xe6, 0x80, 0xd3, 0xaa, 0x4c, 0xee,
	0x79, 0xaf, 0xbb, 0xbb, 0xad, 0xd5, 0x18, 0x1b, 0x77, 0x0f, 0xf6, 0x0f, 0x71, 0xa7, 0x6b, 0x0b,
	0xda, 0x3c, 0x6a, 0x41, 0xfd, 0xb0, 0xff, 0xa2, 0xbf, 0xff, 0xab, 0xbe, 0xb6, 0x60, 0xfd, 0x53,
	0x1d, 0x96, 0x67, 0x1a, 0x5c, 0xe8, 0x19, 0x40, 0x14, 0xfb, 0xe7, 0x7e, 0x40, 0x4e, 0xb2, 0x72,
	0xa7, 0xf4, 0xa5, 0x78, 0x90, 0x71, 0xd5, 0x42, 0x0a, 0x02, 0x68, 0x03, 0xea, 0x09, 0x09, 0xfc,
	0x70, 0xfc, 0x4a, 0x76, 0xed, 0xcc, 0xeb, 0x5a, 0x69, 0xeb, 0x07, 0xdd, 0x5d, 0x86, 0xc3, 0x4a,
	0x00, 0x7d, 0x0d, 0x2b, 0x5e, 0x4c, 0x23, 0xdb, 0x75, 0x22, 0xe7, 0xc8, 0x0f, 0xfc, 0xd4, 0x27,
	0xd2, 0x94, 0xcb, 0x47, 0xbb, 0x1d, 0xd3, 0xc8, 0xec, 0x14, 0x40, 0x6a, 0x22, 0x1a, 0x13, 0x2f,
	0x32, 0x50, 0x1f, 0x34, 0xc7, 0xf3, 0xca, 0x1a, 0x6b, 0x5c, 0x63, 0xc9, 0xdb, 0x6f, 0x7a, 0xde,
	0x95, 0x0a, 0x97, 0x1d, 0xcf, 0x2b, 0xe9, 0x3b, 0x81, 0x3b, 0x59, 0x5d, 0x6e, 0xc7, 0x94, 0xa6,
	0x36, 0x33, 0xea, 0xe4, 0x22, 0x49, 0xc9, 0x88, 0xdf, 0x21, 0xf9, 0x6d, 0x44, 0x29, 0x66, 0xb5,
	0xa1, 0xc9, 0x0a, 0x72, 0x13, 0x53, 0x9a, 0x9a, 0xcf, 0x33, 0xb0, 0x1a, 0xe1, 0xb6, 0xaa, 0xd8,
	0x19, 0x3f, 0x67, 0xa3, 0x01, 0x2c, 0x27, 0xc4, 0x75, 0xe9, 0x28, 0xca, 0xee, 0xdb, 0x02, 0xdf,
	0xcf, 0x0f, 0xaf, 0xdf, 0x4f, 0x81, 0x97, 0x17, 0x0d, 0xb7, 0x93, 0xd2, 0x3b, 0x22, 0xb0, 0xea,
	0x04, 0x01, 0xfd, 0xce, 0xce, 0x4e, 0xcb, 0x26, 0x89, 0xeb, 0x04, 0xa2, 0xcc, 0xaf, 0xf3, 0xb9,
	0x7f, 0x38, 0x9d, 0x18, 0xef, 0x66, 0x97, 0x99, 0xa1, 0xcd, 0xec, 0xb8, 0xcd, 0x6e, 0x86, 0xb6,
	0xb0, 0xce, 0x55, 0x65, 0xbc, 0x9c, 0xb5, 0xfa, 0x97, 0x50, 0x97, 0x07, 0x9b, 0xf9, 0x96, 0x4a,
	0xc1, 0xb7, 0x20, 0xa8, 0xc5, 0x34, 0x50, 0x9d, 0x73, 0xfe, 0xcc, 0x68, 0xbc, 0x57, 0x21, 0xb3,
	0x43, 0xde, 0x8b, 0xb8, 0xa9, 0xc2, 0xbf, 0xf0, 0x58, 0xe2, 0x65, 0xf5, 0xff, 0x2a, 0xd0, 0x2e,
	0x2f, 0x13, 0xfd, 0x46, 0x0a, 0x8b, 0x34, 0xe1, 0xd3, 0x37, 0xdc, 0x9d, 0x75, 0xf9, 0x3b, 0xbc,
	0x88, 0x88, 0x48, 0x1c, 0xd4, 0xaa, 0x25, 0x4e, 0x79, 0xb0, 0xd2, 0xff, 0x13, 0x7e, 0x02, 0x2b,
	0xbc, 0xfd, 0x2d, 0xbe, 0x38, 0xc9, 0x63, 0x11, 0x2b, 0xd1, 0x32, 0x86, 0x72, 0x7d, 0x9b, 0xd0,
	0x2a, 0x0c, 0xc2, 0xee, 0xee, 0x61, 0x9f, 0xdf, 0xd6, 0x7e, 0x77, 0x5b, 0x7b, 0x0b, 0xdd, 0x80,
	0x65, 0x7c, 0xd8, 0x1f, 0xf6, 0xf6, 0xba, 0xf6, 0x76, 0xf7, 0xf9, 0xe6, 0xe1, 0xee, 0x50, 0xab,
	0xa0, 0x25, 0x68, 0xee, 0xee, 0x77, 0x36, 0x77, 0x79, 0x78, 0x9a, 0xb3, 0xfe, 0x58, 0x81, 0x36,
	0xab, 0xdf, 0x0a, 0xff, 0x07, 0x99, 0x6d, 0x92, 0x23, 0xf9, 0xff, 0x0c, 0x56, 0x10, 0xd4, 0xe4,
	0x1f, 0x2f, 0x50, 0xb1, 0x4d, 0x20, 0x33, 0x5c, 0x16, 0x33, 0x44, 0xaa, 0x21, 0xb7, 0x59, 0xbd,
	0xb2, 0x24, 0xa6, 0x50, 0x6a, 0xcb, 0x00, 0x91, 0xd7, 0xcc, 0x77, 0x2f, 0xfd, 0x27, 0xa3, 0x58,
	0xa7, 0x7f, 0x96, 0x7f, 0x6f, 0x5f, 0x78, 0x7d, 0x45, 0xa5, 0x3e, 0x9f, 0xaf, 0x16, 0xbe, 0x04,
	0xd7, 0x79, 0x94, 0xc9, 0xde, 0xb7, 0x3e, 0xfb, 0xf7, 0xef, 0xef, 0x57, 0xfe, 0xf0, 0xfd, 0xfd,
	0xca, 0x7f, 0x7f, 0x7f, 0xbf, 0xf2, 0x0f, 0xff, 0x73, 0xff, 0x2d, 0xb8, 0xe3, 0xd3, 0xf5, 0x24,
	0x75, 0xdc, 0xb3, 0x98, 0xbe, 0x12, 0x6a, 0xd5, 0x21, 0x7f, 0xab, 0xfe, 0xe2, 0x73, 0xb4, 0xc0,
	0xe9, 0x9f, 0xfe, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xab, 0xd3, 0x24, 0xc9, 0x0e, 0x24, 0x00,
	0x00,
}

func (m *Deployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RuntimeClass) > 0 {
		i -= len(m.RuntimeClass)
		copy(dAtA[i:], m.RuntimeClass)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.RuntimeClass)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.OrchestratorComponent {
		i--
		if m.OrchestratorComponent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.HostIpc {
		i--
		if m.HostIpc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.HostPid {
		i--
		if m.HostPid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.RiskScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RiskScore))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xed
	}
	if m.ServiceAccountPermissionLevel != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.ServiceAccountPermissionLevel))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.StateTimestamp != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.StateTimestamp))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.Hash != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.Hash))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.AutomountServiceAccountToken {
		i--
		if m.AutomountServiceAccountToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDeployment(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.NamespaceId) > 0 {
		i -= len(m.NamespaceId)
		copy(dAtA[i:], m.NamespaceId)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.NamespaceId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.Tolerations) > 0 {
		for iNdEx := len(m.Tolerations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tolerations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDeployment(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.HostNetwork {
		i--
		if m.HostNetwork {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.LabelSelector != nil {
		{
			size, err := m.LabelSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.PodLabels) > 0 {
		for k := range m.PodLabels {
			v := m.PodLabels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintDeployment(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDeployment(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDeployment(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.ServiceAccount) > 0 {
		i -= len(m.ServiceAccount)
		copy(dAtA[i:], m.ServiceAccount)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.ServiceAccount)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.ImagePullSecrets) > 0 {
		for iNdEx := len(m.ImagePullSecrets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ImagePullSecrets[iNdEx])
			copy(dAtA[i:], m.ImagePullSecrets[iNdEx])
			i = encodeVarintDeployment(dAtA, i, uint64(len(m.ImagePullSecrets[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.Inactive {
		i--
		if m.Inactive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Priority != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x78
	}
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintDeployment(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDeployment(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDeployment(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Containers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDeployment(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Created != nil {
		{
			size, err := m.Created.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintDeployment(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDeployment(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDeployment(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Replicas != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.Replicas))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsClusterLocal {
		i--
		if m.IsClusterLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.NotPullable {
		i--
		if m.NotPullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x22
	}
	if m.Name != nil {
		{
			size, err := m.Name.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Container) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Container) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Container) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReadinessProbe != nil {
		{
			size, err := m.ReadinessProbe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.LivenessProbe != nil {
		{
			size, err := m.LivenessProbe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x52
	}
	if m.Resources != nil {
		{
			size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Secrets) > 0 {
		for iNdEx := len(m.Secrets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Secrets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDeployment(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDeployment(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Volumes) > 0 {
		for iNdEx := len(m.Volumes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Volumes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDeployment(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.SecurityContext != nil {
		{
			size, err := m.SecurityContext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Resources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resources) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resources) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MemoryMbLimit != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MemoryMbLimit))))
		i--
		dAtA[i] = 0x25
	}
	if m.MemoryMbRequest != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MemoryMbRequest))))
		i--
		dAtA[i] = 0x1d
	}
	if m.CpuCoresLimit != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CpuCoresLimit))))
		i--
		dAtA[i] = 0x15
	}
	if m.CpuCoresRequest != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CpuCoresRequest))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *Volume) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Volume) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Volume) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MountPropagation != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.MountPropagation))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LivenessProbe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LivenessProbe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LivenessProbe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Defined {
		i--
		if m.Defined {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReadinessProbe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadinessProbe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadinessProbe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Defined {
		i--
		if m.Defined {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Pod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Started != nil {
		{
			size, err := m.Started.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.TerminatedInstances) > 0 {
		for iNdEx := len(m.TerminatedInstances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TerminatedInstances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDeployment(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.LiveInstances) > 0 {
		for iNdEx := len(m.LiveInstances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LiveInstances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDeployment(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pod_ContainerInstanceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pod_ContainerInstanceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pod_ContainerInstanceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Instances) > 0 {
		for iNdEx := len(m.Instances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Instances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDeployment(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContainerInstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerInstance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerInstance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TerminationReason) > 0 {
		i -= len(m.TerminationReason)
		copy(dAtA[i:], m.TerminationReason)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.TerminationReason)))
		i--
		dAtA[i] = 0x4a
	}
	if m.ExitCode != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.ExitCode))
		i--
		dAtA[i] = 0x40
	}
	if m.Finished != nil {
		{
			size, err := m.Finished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ContainerName) > 0 {
		i -= len(m.ContainerName)
		copy(dAtA[i:], m.ContainerName)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.ContainerName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ImageDigest) > 0 {
		i -= len(m.ImageDigest)
		copy(dAtA[i:], m.ImageDigest)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.ImageDigest)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Started != nil {
		{
			size, err := m.Started.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ContainerIps) > 0 {
		for iNdEx := len(m.ContainerIps) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ContainerIps[iNdEx])
			copy(dAtA[i:], m.ContainerIps[iNdEx])
			i = encodeVarintDeployment(dAtA, i, uint64(len(m.ContainerIps[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ContainingPodId) > 0 {
		i -= len(m.ContainingPodId)
		copy(dAtA[i:], m.ContainingPodId)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.ContainingPodId)))
		i--
		dAtA[i] = 0x12
	}
	if m.InstanceId != nil {
		{
			size, err := m.InstanceId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerInstanceID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerInstanceID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerInstanceID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Node) > 0 {
		i -= len(m.Node)
		copy(dAtA[i:], m.Node)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Node)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.ContainerRuntime != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.ContainerRuntime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EmbeddedSecret) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmbeddedSecret) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmbeddedSecret) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PortConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExposureInfos) > 0 {
		for iNdEx := len(m.ExposureInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExposureInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDeployment(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ExposedPort != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.ExposedPort))
		i--
		dAtA[i] = 0x28
	}
	if m.Exposure != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.Exposure))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ContainerPort != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.ContainerPort))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PortConfig_ExposureInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortConfig_ExposureInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortConfig_ExposureInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExternalHostnames) > 0 {
		for iNdEx := len(m.ExternalHostnames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExternalHostnames[iNdEx])
			copy(dAtA[i:], m.ExternalHostnames[iNdEx])
			i = encodeVarintDeployment(dAtA, i, uint64(len(m.ExternalHostnames[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ExternalIps) > 0 {
		for iNdEx := len(m.ExternalIps) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExternalIps[iNdEx])
			copy(dAtA[i:], m.ExternalIps[iNdEx])
			i = encodeVarintDeployment(dAtA, i, uint64(len(m.ExternalIps[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.NodePort != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.NodePort))
		i--
		dAtA[i] = 0x30
	}
	if m.ServicePort != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.ServicePort))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ServiceClusterIp) > 0 {
		i -= len(m.ServiceClusterIp)
		copy(dAtA[i:], m.ServiceClusterIp)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.ServiceClusterIp)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Level != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContainerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AppArmorProfile) > 0 {
		i -= len(m.AppArmorProfile)
		copy(dAtA[i:], m.AppArmorProfile)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.AppArmorProfile)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Uid != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x30
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Directory) > 0 {
		i -= len(m.Directory)
		copy(dAtA[i:], m.Directory)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Directory)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintDeployment(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Command) > 0 {
		for iNdEx := len(m.Command) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Command[iNdEx])
			copy(dAtA[i:], m.Command[iNdEx])
			i = encodeVarintDeployment(dAtA, i, uint64(len(m.Command[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Env) > 0 {
		for iNdEx := len(m.Env) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Env[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDeployment(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContainerConfig_EnvironmentConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerConfig_EnvironmentConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerConfig_EnvironmentConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EnvVarSource != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.EnvVarSource))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllowPrivilegeEscalation {
		i--
		if m.AllowPrivilegeEscalation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.SeccompProfile != nil {
		{
			size, err := m.SeccompProfile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ReadOnlyRootFilesystem {
		i--
		if m.ReadOnlyRootFilesystem {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.AddCapabilities) > 0 {
		for iNdEx := len(m.AddCapabilities) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AddCapabilities[iNdEx])
			copy(dAtA[i:], m.AddCapabilities[iNdEx])
			i = encodeVarintDeployment(dAtA, i, uint64(len(m.AddCapabilities[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DropCapabilities) > 0 {
		for iNdEx := len(m.DropCapabilities) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DropCapabilities[iNdEx])
			copy(dAtA[i:], m.DropCapabilities[iNdEx])
			i = encodeVarintDeployment(dAtA, i, uint64(len(m.DropCapabilities[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Selinux != nil {
		{
			size, err := m.Selinux.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Privileged {
		i--
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecurityContext_SELinux) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityContext_SELinux) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityContext_SELinux) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Level) > 0 {
		i -= len(m.Level)
		copy(dAtA[i:], m.Level)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Level)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityContext_SeccompProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityContext_SeccompProfile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityContext_SeccompProfile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LocalhostProfile) > 0 {
		i -= len(m.LocalhostProfile)
		copy(dAtA[i:], m.LocalhostProfile)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.LocalhostProfile)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListDeployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDeployment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDeployment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Hash != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.Hash))
		i--
		dAtA[i] = 0x40
	}
	if m.Priority != 0 {
		i = encodeVarintDeployment(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x38
	}
	if m.Created != nil {
		{
			size, err := m.Created.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDeployment(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Cluster) > 0 {
		i -= len(m.Cluster)
		copy(dAtA[i:], m.Cluster)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Cluster)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintDeployment(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDeployment(dAtA []byte, offset int, v uint64) int {
	offset -= sovDeployment(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Deployment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.Replicas != 0 {
		n += 1 + sovDeployment(uint64(m.Replicas))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDeployment(uint64(len(k))) + 1 + len(v) + sovDeployment(uint64(len(v)))
			n += mapEntrySize + 1 + sovDeployment(uint64(mapEntrySize))
		}
	}
	if m.Created != nil {
		l = m.Created.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDeployment(uint64(len(k))) + 1 + len(v) + sovDeployment(uint64(len(v)))
			n += mapEntrySize + 1 + sovDeployment(uint64(mapEntrySize))
		}
	}
	if m.Priority != 0 {
		n += 1 + sovDeployment(uint64(m.Priority))
	}
	if m.Inactive {
		n += 3
	}
	if len(m.ImagePullSecrets) > 0 {
		for _, s := range m.ImagePullSecrets {
			l = len(s)
			n += 2 + l + sovDeployment(uint64(l))
		}
	}
	l = len(m.ServiceAccount)
	if l > 0 {
		n += 2 + l + sovDeployment(uint64(l))
	}
	if len(m.PodLabels) > 0 {
		for k, v := range m.PodLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDeployment(uint64(len(k))) + 1 + len(v) + sovDeployment(uint64(len(v)))
			n += mapEntrySize + 2 + sovDeployment(uint64(mapEntrySize))
		}
	}
	if m.LabelSelector != nil {
		l = m.LabelSelector.Size()
		n += 2 + l + sovDeployment(uint64(l))
	}
	if m.HostNetwork {
		n += 3
	}
	if len(m.Tolerations) > 0 {
		for _, e := range m.Tolerations {
			l = e.Size()
			n += 2 + l + sovDeployment(uint64(l))
		}
	}
	l = len(m.NamespaceId)
	if l > 0 {
		n += 2 + l + sovDeployment(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 2 + l + sovDeployment(uint64(l))
		}
	}
	if m.AutomountServiceAccountToken {
		n += 3
	}
	if m.Hash != 0 {
		n += 2 + sovDeployment(uint64(m.Hash))
	}
	if m.StateTimestamp != 0 {
		n += 2 + sovDeployment(uint64(m.StateTimestamp))
	}
	if m.ServiceAccountPermissionLevel != 0 {
		n += 2 + sovDeployment(uint64(m.ServiceAccountPermissionLevel))
	}
	if m.RiskScore != 0 {
		n += 6
	}
	if m.HostPid {
		n += 3
	}
	if m.HostIpc {
		n += 3
	}
	if m.OrchestratorComponent {
		n += 3
	}
	l = len(m.RuntimeClass)
	if l > 0 {
		n += 2 + l + sovDeployment(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.NotPullable {
		n += 2
	}
	if m.IsClusterLocal {
		n += 2
	}
	return n
}

func (m *Container) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.SecurityContext != nil {
		l = m.SecurityContext.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.Size()
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if len(m.Secrets) > 0 {
		for _, e := range m.Secrets {
			l = e.Size()
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.LivenessProbe != nil {
		l = m.LivenessProbe.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.ReadinessProbe != nil {
		l = m.ReadinessProbe.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Resources) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuCoresRequest != 0 {
		n += 5
	}
	if m.CpuCoresLimit != 0 {
		n += 5
	}
	if m.MemoryMbRequest != 0 {
		n += 5
	}
	if m.MemoryMbLimit != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Volume) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.MountPropagation != 0 {
		n += 1 + sovDeployment(uint64(m.MountPropagation))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LivenessProbe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Defined {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadinessProbe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Defined {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if len(m.LiveInstances) > 0 {
		for _, e := range m.LiveInstances {
			l = e.Size()
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if len(m.TerminatedInstances) > 0 {
		for _, e := range m.TerminatedInstances {
			l = e.Size()
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pod_ContainerInstanceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Instances) > 0 {
		for _, e := range m.Instances {
			l = e.Size()
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerInstance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InstanceId != nil {
		l = m.InstanceId.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.ContainingPodId)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if len(m.ContainerIps) > 0 {
		for _, s := range m.ContainerIps {
			l = len(s)
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.ImageDigest)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.ContainerName)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.ExitCode != 0 {
		n += 1 + sovDeployment(uint64(m.ExitCode))
	}
	l = len(m.TerminationReason)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerInstanceID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerRuntime != 0 {
		n += 1 + sovDeployment(uint64(m.ContainerRuntime))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EmbeddedSecret) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PortConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.ContainerPort != 0 {
		n += 1 + sovDeployment(uint64(m.ContainerPort))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.Exposure != 0 {
		n += 1 + sovDeployment(uint64(m.Exposure))
	}
	if m.ExposedPort != 0 {
		n += 1 + sovDeployment(uint64(m.ExposedPort))
	}
	if len(m.ExposureInfos) > 0 {
		for _, e := range m.ExposureInfos {
			l = e.Size()
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PortConfig_ExposureInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovDeployment(uint64(m.Level))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.ServiceClusterIp)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.ServicePort != 0 {
		n += 1 + sovDeployment(uint64(m.ServicePort))
	}
	if m.NodePort != 0 {
		n += 1 + sovDeployment(uint64(m.NodePort))
	}
	if len(m.ExternalIps) > 0 {
		for _, s := range m.ExternalIps {
			l = len(s)
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if len(m.ExternalHostnames) > 0 {
		for _, s := range m.ExternalHostnames {
			l = len(s)
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Env) > 0 {
		for _, e := range m.Env {
			l = e.Size()
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	l = len(m.Directory)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovDeployment(uint64(m.Uid))
	}
	l = len(m.AppArmorProfile)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerConfig_EnvironmentConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.EnvVarSource != 0 {
		n += 1 + sovDeployment(uint64(m.EnvVarSource))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Privileged {
		n += 2
	}
	if m.Selinux != nil {
		l = m.Selinux.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	if len(m.DropCapabilities) > 0 {
		for _, s := range m.DropCapabilities {
			l = len(s)
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if len(m.AddCapabilities) > 0 {
		for _, s := range m.AddCapabilities {
			l = len(s)
			n += 1 + l + sovDeployment(uint64(l))
		}
	}
	if m.ReadOnlyRootFilesystem {
		n += 2
	}
	if m.SeccompProfile != nil {
		l = m.SeccompProfile.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.AllowPrivilegeEscalation {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityContext_SELinux) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityContext_SeccompProfile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovDeployment(uint64(m.Type))
	}
	l = len(m.LocalhostProfile)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDeployment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Cluster)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.Created != nil {
		l = m.Created.Size()
		n += 1 + l + sovDeployment(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovDeployment(uint64(m.Priority))
	}
	if m.Hash != 0 {
		n += 1 + sovDeployment(uint64(m.Hash))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDeployment(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDeployment(x uint64) (n int) {
	return sovDeployment(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Deployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			m.Replicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Replicas |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDeployment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDeployment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDeployment
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDeployment
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDeployment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDeployment
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDeployment
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDeployment(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDeployment
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Created == nil {
				m.Created = &types.Timestamp{}
			}
			if err := m.Created.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &Container{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDeployment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDeployment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDeployment
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDeployment
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDeployment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDeployment
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDeployment
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDeployment(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDeployment
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inactive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inactive = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullSecrets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullSecrets = append(m.ImagePullSecrets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodLabels == nil {
				m.PodLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDeployment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDeployment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDeployment
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDeployment
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDeployment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDeployment
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDeployment
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDeployment(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDeployment
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PodLabels[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelSelector == nil {
				m.LabelSelector = &LabelSelector{}
			}
			if err := m.LabelSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostNetwork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostNetwork = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tolerations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tolerations = append(m.Tolerations, &Toleration{})
			if err := m.Tolerations[len(m.Tolerations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortConfig{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomountServiceAccountToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutomountServiceAccountToken = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hash |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateTimestamp", wireType)
			}
			m.StateTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StateTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccountPermissionLevel", wireType)
			}
			m.ServiceAccountPermissionLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceAccountPermissionLevel |= PermissionLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RiskScore = float32(math.Float32frombits(v))
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostPid = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIpc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostIpc = bool(v != 0)
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorComponent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OrchestratorComponent = bool(v != 0)
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &ImageName{}
			}
			if err := m.Name.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotPullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotPullable = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterLocal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &ContainerConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &ContainerImage{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityContext == nil {
				m.SecurityContext = &SecurityContext{}
			}
			if err := m.SecurityContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, &Volume{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortConfig{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secrets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secrets = append(m.Secrets, &EmbeddedSecret{})
			if err := m.Secrets[len(m.Secrets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivenessProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LivenessProbe == nil {
				m.LivenessProbe = &LivenessProbe{}
			}
			if err := m.LivenessProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadinessProbe == nil {
				m.ReadinessProbe = &ReadinessProbe{}
			}
			if err := m.ReadinessProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCoresRequest", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CpuCoresRequest = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCoresLimit", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CpuCoresLimit = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryMbRequest", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MemoryMbRequest = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryMbLimit", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MemoryMbLimit = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Volume) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Volume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Volume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPropagation", wireType)
			}
			m.MountPropagation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MountPropagation |= Volume_MountPropagation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LivenessProbe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LivenessProbe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LivenessProbe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defined", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Defined = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadinessProbe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadinessProbe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadinessProbe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defined", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Defined = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveInstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveInstances = append(m.LiveInstances, &ContainerInstance{})
			if err := m.LiveInstances[len(m.LiveInstances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerminatedInstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TerminatedInstances = append(m.TerminatedInstances, &Pod_ContainerInstanceList{})
			if err := m.TerminatedInstances[len(m.TerminatedInstances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &types.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pod_ContainerInstanceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerInstanceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerInstanceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instances = append(m.Instances, &ContainerInstance{})
			if err := m.Instances[len(m.Instances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerInstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerInstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerInstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InstanceId == nil {
				m.InstanceId = &ContainerInstanceID{}
			}
			if err := m.InstanceId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainingPodId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainingPodId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerIps = append(m.ContainerIps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &types.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finished == nil {
				m.Finished = &types.Timestamp{}
			}
			if err := m.Finished.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerminationReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TerminationReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerInstanceID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerInstanceID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerInstanceID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRuntime", wireType)
			}
			m.ContainerRuntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerRuntime |= ContainerRuntime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmbeddedSecret) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmbeddedSecret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmbeddedSecret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			m.ContainerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exposure", wireType)
			}
			m.Exposure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exposure |= PortConfig_ExposureLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposedPort", wireType)
			}
			m.ExposedPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExposedPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposureInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExposureInfos = append(m.ExposureInfos, &PortConfig_ExposureInfo{})
			if err := m.ExposureInfos[len(m.ExposureInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortConfig_ExposureInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExposureInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExposureInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= PortConfig_ExposureLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceClusterIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceClusterIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePort", wireType)
			}
			m.ServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServicePort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePort", wireType)
			}
			m.NodePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodePort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalIps = append(m.ExternalIps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalHostnames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalHostnames = append(m.ExternalHostnames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, &ContainerConfig_EnvironmentConfig{})
			if err := m.Env[len(m.Env)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Directory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Directory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppArmorProfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppArmorProfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerConfig_EnvironmentConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvironmentConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvironmentConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVarSource", wireType)
			}
			m.EnvVarSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnvVarSource |= ContainerConfig_EnvironmentConfig_EnvVarSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selinux", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selinux == nil {
				m.Selinux = &SecurityContext_SELinux{}
			}
			if err := m.Selinux.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropCapabilities", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropCapabilities = append(m.DropCapabilities, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddCapabilities", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddCapabilities = append(m.AddCapabilities, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnlyRootFilesystem", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnlyRootFilesystem = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeccompProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SeccompProfile == nil {
				m.SeccompProfile = &SecurityContext_SeccompProfile{}
			}
			if err := m.SeccompProfile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPrivilegeEscalation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPrivilegeEscalation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityContext_SELinux) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SELinux: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SELinux: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityContext_SeccompProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeccompProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeccompProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SecurityContext_SeccompProfile_ProfileType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalhostProfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalhostProfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDeployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDeployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDeployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDeployment
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDeployment
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Created == nil {
				m.Created = &types.Timestamp{}
			}
			if err := m.Created.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hash |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDeployment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDeployment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDeployment(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDeployment
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDeployment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDeployment
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDeployment
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDeployment
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDeployment        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDeployment          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDeployment = fmt.Errorf("proto: unexpected end of group")
)
