// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/compliance.proto

package storage

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ComplianceState int32

const (
	ComplianceState_COMPLIANCE_STATE_UNKNOWN ComplianceState = 0
	ComplianceState_COMPLIANCE_STATE_SKIP    ComplianceState = 1
	ComplianceState_COMPLIANCE_STATE_NOTE    ComplianceState = 2
	ComplianceState_COMPLIANCE_STATE_SUCCESS ComplianceState = 3
	ComplianceState_COMPLIANCE_STATE_FAILURE ComplianceState = 4
	ComplianceState_COMPLIANCE_STATE_ERROR   ComplianceState = 5
)

var ComplianceState_name = map[int32]string{
	0: "COMPLIANCE_STATE_UNKNOWN",
	1: "COMPLIANCE_STATE_SKIP",
	2: "COMPLIANCE_STATE_NOTE",
	3: "COMPLIANCE_STATE_SUCCESS",
	4: "COMPLIANCE_STATE_FAILURE",
	5: "COMPLIANCE_STATE_ERROR",
}

var ComplianceState_value = map[string]int32{
	"COMPLIANCE_STATE_UNKNOWN": 0,
	"COMPLIANCE_STATE_SKIP":    1,
	"COMPLIANCE_STATE_NOTE":    2,
	"COMPLIANCE_STATE_SUCCESS": 3,
	"COMPLIANCE_STATE_FAILURE": 4,
	"COMPLIANCE_STATE_ERROR":   5,
}

func (x ComplianceState) String() string {
	return proto.EnumName(ComplianceState_name, int32(x))
}

func (ComplianceState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{0}
}

type ComplianceAggregation_Scope int32

const (
	ComplianceAggregation_UNKNOWN    ComplianceAggregation_Scope = 0
	ComplianceAggregation_STANDARD   ComplianceAggregation_Scope = 1
	ComplianceAggregation_CLUSTER    ComplianceAggregation_Scope = 2
	ComplianceAggregation_CATEGORY   ComplianceAggregation_Scope = 3
	ComplianceAggregation_CONTROL    ComplianceAggregation_Scope = 4
	ComplianceAggregation_NAMESPACE  ComplianceAggregation_Scope = 5
	ComplianceAggregation_NODE       ComplianceAggregation_Scope = 6
	ComplianceAggregation_DEPLOYMENT ComplianceAggregation_Scope = 7
	ComplianceAggregation_CHECK      ComplianceAggregation_Scope = 8
)

var ComplianceAggregation_Scope_name = map[int32]string{
	0: "UNKNOWN",
	1: "STANDARD",
	2: "CLUSTER",
	3: "CATEGORY",
	4: "CONTROL",
	5: "NAMESPACE",
	6: "NODE",
	7: "DEPLOYMENT",
	8: "CHECK",
}

var ComplianceAggregation_Scope_value = map[string]int32{
	"UNKNOWN":    0,
	"STANDARD":   1,
	"CLUSTER":    2,
	"CATEGORY":   3,
	"CONTROL":    4,
	"NAMESPACE":  5,
	"NODE":       6,
	"DEPLOYMENT": 7,
	"CHECK":      8,
}

func (x ComplianceAggregation_Scope) String() string {
	return proto.EnumName(ComplianceAggregation_Scope_name, int32(x))
}

func (ComplianceAggregation_Scope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{7, 0}
}

type ComplianceResource struct {
	// Types that are valid to be assigned to Resource:
	//	*ComplianceResource_Cluster
	//	*ComplianceResource_Deployment
	//	*ComplianceResource_Node
	//	*ComplianceResource_Image
	Resource             isComplianceResource_Resource `protobuf_oneof:"resource"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *ComplianceResource) Reset()         { *m = ComplianceResource{} }
func (m *ComplianceResource) String() string { return proto.CompactTextString(m) }
func (*ComplianceResource) ProtoMessage()    {}
func (*ComplianceResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{0}
}
func (m *ComplianceResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceResource.Merge(m, src)
}
func (m *ComplianceResource) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceResource) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceResource.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceResource proto.InternalMessageInfo

type isComplianceResource_Resource interface {
	isComplianceResource_Resource()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isComplianceResource_Resource
}

type ComplianceResource_Cluster struct {
	Cluster *ComplianceResource_ClusterName `protobuf:"bytes,1,opt,name=cluster,proto3,oneof" json:"cluster,omitempty"`
}
type ComplianceResource_Deployment struct {
	Deployment *ComplianceResource_DeploymentName `protobuf:"bytes,2,opt,name=deployment,proto3,oneof" json:"deployment,omitempty"`
}
type ComplianceResource_Node struct {
	Node *ComplianceResource_NodeName `protobuf:"bytes,3,opt,name=node,proto3,oneof" json:"node,omitempty"`
}
type ComplianceResource_Image struct {
	Image *ImageName `protobuf:"bytes,4,opt,name=image,proto3,oneof" json:"image,omitempty"`
}

func (*ComplianceResource_Cluster) isComplianceResource_Resource() {}
func (m *ComplianceResource_Cluster) Clone() isComplianceResource_Resource {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceResource_Cluster)
	*cloned = *m

	cloned.Cluster = m.Cluster.Clone()
	return cloned
}
func (*ComplianceResource_Deployment) isComplianceResource_Resource() {}
func (m *ComplianceResource_Deployment) Clone() isComplianceResource_Resource {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceResource_Deployment)
	*cloned = *m

	cloned.Deployment = m.Deployment.Clone()
	return cloned
}
func (*ComplianceResource_Node) isComplianceResource_Resource() {}
func (m *ComplianceResource_Node) Clone() isComplianceResource_Resource {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceResource_Node)
	*cloned = *m

	cloned.Node = m.Node.Clone()
	return cloned
}
func (*ComplianceResource_Image) isComplianceResource_Resource() {}
func (m *ComplianceResource_Image) Clone() isComplianceResource_Resource {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceResource_Image)
	*cloned = *m

	cloned.Image = m.Image.Clone()
	return cloned
}

func (m *ComplianceResource) GetResource() isComplianceResource_Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *ComplianceResource) GetCluster() *ComplianceResource_ClusterName {
	if x, ok := m.GetResource().(*ComplianceResource_Cluster); ok {
		return x.Cluster
	}
	return nil
}

func (m *ComplianceResource) GetDeployment() *ComplianceResource_DeploymentName {
	if x, ok := m.GetResource().(*ComplianceResource_Deployment); ok {
		return x.Deployment
	}
	return nil
}

func (m *ComplianceResource) GetNode() *ComplianceResource_NodeName {
	if x, ok := m.GetResource().(*ComplianceResource_Node); ok {
		return x.Node
	}
	return nil
}

func (m *ComplianceResource) GetImage() *ImageName {
	if x, ok := m.GetResource().(*ComplianceResource_Image); ok {
		return x.Image
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ComplianceResource) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ComplianceResource_Cluster)(nil),
		(*ComplianceResource_Deployment)(nil),
		(*ComplianceResource_Node)(nil),
		(*ComplianceResource_Image)(nil),
	}
}

func (m *ComplianceResource) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceResource) Clone() *ComplianceResource {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceResource)
	*cloned = *m

	if m.Resource != nil {
		cloned.Resource = m.Resource.Clone()
	}
	return cloned
}

type ComplianceResource_ClusterName struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ComplianceResource_ClusterName) Reset()         { *m = ComplianceResource_ClusterName{} }
func (m *ComplianceResource_ClusterName) String() string { return proto.CompactTextString(m) }
func (*ComplianceResource_ClusterName) ProtoMessage()    {}
func (*ComplianceResource_ClusterName) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{0, 0}
}
func (m *ComplianceResource_ClusterName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceResource_ClusterName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceResource_ClusterName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceResource_ClusterName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceResource_ClusterName.Merge(m, src)
}
func (m *ComplianceResource_ClusterName) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceResource_ClusterName) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceResource_ClusterName.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceResource_ClusterName proto.InternalMessageInfo

func (m *ComplianceResource_ClusterName) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ComplianceResource_ClusterName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ComplianceResource_ClusterName) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceResource_ClusterName) Clone() *ComplianceResource_ClusterName {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceResource_ClusterName)
	*cloned = *m

	return cloned
}

type ComplianceResource_DeploymentName struct {
	Cluster              *ComplianceResource_ClusterName `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	Id                   string                          `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string                          `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Namespace            string                          `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *ComplianceResource_DeploymentName) Reset()         { *m = ComplianceResource_DeploymentName{} }
func (m *ComplianceResource_DeploymentName) String() string { return proto.CompactTextString(m) }
func (*ComplianceResource_DeploymentName) ProtoMessage()    {}
func (*ComplianceResource_DeploymentName) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{0, 1}
}
func (m *ComplianceResource_DeploymentName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceResource_DeploymentName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceResource_DeploymentName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceResource_DeploymentName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceResource_DeploymentName.Merge(m, src)
}
func (m *ComplianceResource_DeploymentName) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceResource_DeploymentName) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceResource_DeploymentName.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceResource_DeploymentName proto.InternalMessageInfo

func (m *ComplianceResource_DeploymentName) GetCluster() *ComplianceResource_ClusterName {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *ComplianceResource_DeploymentName) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ComplianceResource_DeploymentName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ComplianceResource_DeploymentName) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ComplianceResource_DeploymentName) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceResource_DeploymentName) Clone() *ComplianceResource_DeploymentName {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceResource_DeploymentName)
	*cloned = *m

	cloned.Cluster = m.Cluster.Clone()
	return cloned
}

type ComplianceResource_NodeName struct {
	Cluster              *ComplianceResource_ClusterName `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	Id                   string                          `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string                          `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *ComplianceResource_NodeName) Reset()         { *m = ComplianceResource_NodeName{} }
func (m *ComplianceResource_NodeName) String() string { return proto.CompactTextString(m) }
func (*ComplianceResource_NodeName) ProtoMessage()    {}
func (*ComplianceResource_NodeName) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{0, 2}
}
func (m *ComplianceResource_NodeName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceResource_NodeName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceResource_NodeName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceResource_NodeName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceResource_NodeName.Merge(m, src)
}
func (m *ComplianceResource_NodeName) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceResource_NodeName) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceResource_NodeName.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceResource_NodeName proto.InternalMessageInfo

func (m *ComplianceResource_NodeName) GetCluster() *ComplianceResource_ClusterName {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *ComplianceResource_NodeName) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ComplianceResource_NodeName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ComplianceResource_NodeName) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceResource_NodeName) Clone() *ComplianceResource_NodeName {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceResource_NodeName)
	*cloned = *m

	cloned.Cluster = m.Cluster.Clone()
	return cloned
}

type ComplianceResultValue struct {
	Evidence             []*ComplianceResultValue_Evidence `protobuf:"bytes,1,rep,name=evidence,proto3" json:"evidence,omitempty"`
	OverallState         ComplianceState                   `protobuf:"varint,2,opt,name=overall_state,json=overallState,proto3,enum=storage.ComplianceState" json:"overall_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *ComplianceResultValue) Reset()         { *m = ComplianceResultValue{} }
func (m *ComplianceResultValue) String() string { return proto.CompactTextString(m) }
func (*ComplianceResultValue) ProtoMessage()    {}
func (*ComplianceResultValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{1}
}
func (m *ComplianceResultValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceResultValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceResultValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceResultValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceResultValue.Merge(m, src)
}
func (m *ComplianceResultValue) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceResultValue) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceResultValue.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceResultValue proto.InternalMessageInfo

func (m *ComplianceResultValue) GetEvidence() []*ComplianceResultValue_Evidence {
	if m != nil {
		return m.Evidence
	}
	return nil
}

func (m *ComplianceResultValue) GetOverallState() ComplianceState {
	if m != nil {
		return m.OverallState
	}
	return ComplianceState_COMPLIANCE_STATE_UNKNOWN
}

func (m *ComplianceResultValue) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceResultValue) Clone() *ComplianceResultValue {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceResultValue)
	*cloned = *m

	if m.Evidence != nil {
		cloned.Evidence = make([]*ComplianceResultValue_Evidence, len(m.Evidence))
		for idx, v := range m.Evidence {
			cloned.Evidence[idx] = v.Clone()
		}
	}
	return cloned
}

type ComplianceResultValue_Evidence struct {
	State                ComplianceState `protobuf:"varint,1,opt,name=state,proto3,enum=storage.ComplianceState" json:"state,omitempty"`
	Message              string          `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	MessageId            int32           `protobuf:"varint,3,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ComplianceResultValue_Evidence) Reset()         { *m = ComplianceResultValue_Evidence{} }
func (m *ComplianceResultValue_Evidence) String() string { return proto.CompactTextString(m) }
func (*ComplianceResultValue_Evidence) ProtoMessage()    {}
func (*ComplianceResultValue_Evidence) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{1, 0}
}
func (m *ComplianceResultValue_Evidence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceResultValue_Evidence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceResultValue_Evidence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceResultValue_Evidence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceResultValue_Evidence.Merge(m, src)
}
func (m *ComplianceResultValue_Evidence) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceResultValue_Evidence) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceResultValue_Evidence.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceResultValue_Evidence proto.InternalMessageInfo

func (m *ComplianceResultValue_Evidence) GetState() ComplianceState {
	if m != nil {
		return m.State
	}
	return ComplianceState_COMPLIANCE_STATE_UNKNOWN
}

func (m *ComplianceResultValue_Evidence) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ComplianceResultValue_Evidence) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *ComplianceResultValue_Evidence) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceResultValue_Evidence) Clone() *ComplianceResultValue_Evidence {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceResultValue_Evidence)
	*cloned = *m

	return cloned
}

type ComplianceControlResult struct {
	Resource             *ComplianceResource    `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
	ControlId            string                 `protobuf:"bytes,2,opt,name=control_id,json=controlId,proto3" json:"control_id,omitempty"`
	Value                *ComplianceResultValue `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ComplianceControlResult) Reset()         { *m = ComplianceControlResult{} }
func (m *ComplianceControlResult) String() string { return proto.CompactTextString(m) }
func (*ComplianceControlResult) ProtoMessage()    {}
func (*ComplianceControlResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{2}
}
func (m *ComplianceControlResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceControlResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceControlResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceControlResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceControlResult.Merge(m, src)
}
func (m *ComplianceControlResult) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceControlResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceControlResult.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceControlResult proto.InternalMessageInfo

func (m *ComplianceControlResult) GetResource() *ComplianceResource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *ComplianceControlResult) GetControlId() string {
	if m != nil {
		return m.ControlId
	}
	return ""
}

func (m *ComplianceControlResult) GetValue() *ComplianceResultValue {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ComplianceControlResult) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceControlResult) Clone() *ComplianceControlResult {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceControlResult)
	*cloned = *m

	cloned.Resource = m.Resource.Clone()
	cloned.Value = m.Value.Clone()
	return cloned
}

// Next available tag: 5
type ComplianceDomain struct {
	Id                   string                 `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty" sql:"pk" search:"Compliance Domain ID,hidden"`
	Cluster              *Cluster               `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty" sql:"ignore_pk,ignore_unique"`
	Nodes                map[string]*Node       `protobuf:"bytes,2,rep,name=nodes,proto3" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Deployments          map[string]*Deployment `protobuf:"bytes,3,rep,name=deployments,proto3" json:"deployments,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ComplianceDomain) Reset()         { *m = ComplianceDomain{} }
func (m *ComplianceDomain) String() string { return proto.CompactTextString(m) }
func (*ComplianceDomain) ProtoMessage()    {}
func (*ComplianceDomain) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{3}
}
func (m *ComplianceDomain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceDomain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceDomain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceDomain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceDomain.Merge(m, src)
}
func (m *ComplianceDomain) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceDomain) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceDomain.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceDomain proto.InternalMessageInfo

func (m *ComplianceDomain) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ComplianceDomain) GetCluster() *Cluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *ComplianceDomain) GetNodes() map[string]*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *ComplianceDomain) GetDeployments() map[string]*Deployment {
	if m != nil {
		return m.Deployments
	}
	return nil
}

func (m *ComplianceDomain) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceDomain) Clone() *ComplianceDomain {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceDomain)
	*cloned = *m

	cloned.Cluster = m.Cluster.Clone()
	if m.Nodes != nil {
		cloned.Nodes = make(map[string]*Node, len(m.Nodes))
		for k, v := range m.Nodes {
			cloned.Nodes[k] = v.Clone()
		}
	}
	if m.Deployments != nil {
		cloned.Deployments = make(map[string]*Deployment, len(m.Deployments))
		for k, v := range m.Deployments {
			cloned.Deployments[k] = v.Clone()
		}
	}
	return cloned
}

// Next available tag: 5
type ComplianceRunMetadata struct {
	RunId                string           `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty" sql:"pk" search:"Compliance Run ID,hidden"`
	StandardId           string           `protobuf:"bytes,2,opt,name=standard_id,json=standardId,proto3" json:"standard_id,omitempty" search:"Standard ID,hidden,store"`
	ClusterId            string           `protobuf:"bytes,3,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty" search:"Cluster ID,hidden,store"`
	StartTimestamp       *types.Timestamp `protobuf:"bytes,4,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	FinishTimestamp      *types.Timestamp `protobuf:"bytes,5,opt,name=finish_timestamp,json=finishTimestamp,proto3" json:"finish_timestamp,omitempty" search:"Compliance Run Finished Timestamp,hidden,store"`
	Success              bool             `protobuf:"varint,6,opt,name=success,proto3" json:"success,omitempty"`
	ErrorMessage         string           `protobuf:"bytes,7,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	DomainId             string           `protobuf:"bytes,8,opt,name=domain_id,json=domainId,proto3" json:"domain_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ComplianceRunMetadata) Reset()         { *m = ComplianceRunMetadata{} }
func (m *ComplianceRunMetadata) String() string { return proto.CompactTextString(m) }
func (*ComplianceRunMetadata) ProtoMessage()    {}
func (*ComplianceRunMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{4}
}
func (m *ComplianceRunMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceRunMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceRunMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceRunMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceRunMetadata.Merge(m, src)
}
func (m *ComplianceRunMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceRunMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceRunMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceRunMetadata proto.InternalMessageInfo

func (m *ComplianceRunMetadata) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *ComplianceRunMetadata) GetStandardId() string {
	if m != nil {
		return m.StandardId
	}
	return ""
}

func (m *ComplianceRunMetadata) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *ComplianceRunMetadata) GetStartTimestamp() *types.Timestamp {
	if m != nil {
		return m.StartTimestamp
	}
	return nil
}

func (m *ComplianceRunMetadata) GetFinishTimestamp() *types.Timestamp {
	if m != nil {
		return m.FinishTimestamp
	}
	return nil
}

func (m *ComplianceRunMetadata) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *ComplianceRunMetadata) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *ComplianceRunMetadata) GetDomainId() string {
	if m != nil {
		return m.DomainId
	}
	return ""
}

func (m *ComplianceRunMetadata) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceRunMetadata) Clone() *ComplianceRunMetadata {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceRunMetadata)
	*cloned = *m

	cloned.StartTimestamp = m.StartTimestamp.Clone()
	cloned.FinishTimestamp = m.FinishTimestamp.Clone()
	return cloned
}

// Next available tag: 6
type ComplianceRunResults struct {
	Domain               *ComplianceDomain                              `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty" sql:"-"`
	RunMetadata          *ComplianceRunMetadata                         `protobuf:"bytes,2,opt,name=run_metadata,json=runMetadata,proto3" json:"run_metadata,omitempty"`
	ClusterResults       *ComplianceRunResults_EntityResults            `protobuf:"bytes,3,opt,name=cluster_results,json=clusterResults,proto3" json:"cluster_results,omitempty"`
	NodeResults          map[string]*ComplianceRunResults_EntityResults `protobuf:"bytes,4,rep,name=node_results,json=nodeResults,proto3" json:"node_results,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DeploymentResults    map[string]*ComplianceRunResults_EntityResults `protobuf:"bytes,5,rep,name=deployment_results,json=deploymentResults,proto3" json:"deployment_results,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MachineConfigResults map[string]*ComplianceRunResults_EntityResults `protobuf:"bytes,6,rep,name=machine_config_results,json=machineConfigResults,proto3" json:"machine_config_results,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                       `json:"-"`
	XXX_unrecognized     []byte                                         `json:"-"`
	XXX_sizecache        int32                                          `json:"-"`
}

func (m *ComplianceRunResults) Reset()         { *m = ComplianceRunResults{} }
func (m *ComplianceRunResults) String() string { return proto.CompactTextString(m) }
func (*ComplianceRunResults) ProtoMessage()    {}
func (*ComplianceRunResults) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{5}
}
func (m *ComplianceRunResults) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceRunResults) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceRunResults.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceRunResults) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceRunResults.Merge(m, src)
}
func (m *ComplianceRunResults) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceRunResults) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceRunResults.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceRunResults proto.InternalMessageInfo

func (m *ComplianceRunResults) GetDomain() *ComplianceDomain {
	if m != nil {
		return m.Domain
	}
	return nil
}

func (m *ComplianceRunResults) GetRunMetadata() *ComplianceRunMetadata {
	if m != nil {
		return m.RunMetadata
	}
	return nil
}

func (m *ComplianceRunResults) GetClusterResults() *ComplianceRunResults_EntityResults {
	if m != nil {
		return m.ClusterResults
	}
	return nil
}

func (m *ComplianceRunResults) GetNodeResults() map[string]*ComplianceRunResults_EntityResults {
	if m != nil {
		return m.NodeResults
	}
	return nil
}

func (m *ComplianceRunResults) GetDeploymentResults() map[string]*ComplianceRunResults_EntityResults {
	if m != nil {
		return m.DeploymentResults
	}
	return nil
}

func (m *ComplianceRunResults) GetMachineConfigResults() map[string]*ComplianceRunResults_EntityResults {
	if m != nil {
		return m.MachineConfigResults
	}
	return nil
}

func (m *ComplianceRunResults) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceRunResults) Clone() *ComplianceRunResults {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceRunResults)
	*cloned = *m

	cloned.Domain = m.Domain.Clone()
	cloned.RunMetadata = m.RunMetadata.Clone()
	cloned.ClusterResults = m.ClusterResults.Clone()
	if m.NodeResults != nil {
		cloned.NodeResults = make(map[string]*ComplianceRunResults_EntityResults, len(m.NodeResults))
		for k, v := range m.NodeResults {
			cloned.NodeResults[k] = v.Clone()
		}
	}
	if m.DeploymentResults != nil {
		cloned.DeploymentResults = make(map[string]*ComplianceRunResults_EntityResults, len(m.DeploymentResults))
		for k, v := range m.DeploymentResults {
			cloned.DeploymentResults[k] = v.Clone()
		}
	}
	if m.MachineConfigResults != nil {
		cloned.MachineConfigResults = make(map[string]*ComplianceRunResults_EntityResults, len(m.MachineConfigResults))
		for k, v := range m.MachineConfigResults {
			cloned.MachineConfigResults[k] = v.Clone()
		}
	}
	return cloned
}

type ComplianceRunResults_EntityResults struct {
	ControlResults       map[string]*ComplianceResultValue `protobuf:"bytes,1,rep,name=control_results,json=controlResults,proto3" json:"control_results,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *ComplianceRunResults_EntityResults) Reset()         { *m = ComplianceRunResults_EntityResults{} }
func (m *ComplianceRunResults_EntityResults) String() string { return proto.CompactTextString(m) }
func (*ComplianceRunResults_EntityResults) ProtoMessage()    {}
func (*ComplianceRunResults_EntityResults) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{5, 0}
}
func (m *ComplianceRunResults_EntityResults) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceRunResults_EntityResults) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceRunResults_EntityResults.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceRunResults_EntityResults) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceRunResults_EntityResults.Merge(m, src)
}
func (m *ComplianceRunResults_EntityResults) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceRunResults_EntityResults) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceRunResults_EntityResults.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceRunResults_EntityResults proto.InternalMessageInfo

func (m *ComplianceRunResults_EntityResults) GetControlResults() map[string]*ComplianceResultValue {
	if m != nil {
		return m.ControlResults
	}
	return nil
}

func (m *ComplianceRunResults_EntityResults) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceRunResults_EntityResults) Clone() *ComplianceRunResults_EntityResults {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceRunResults_EntityResults)
	*cloned = *m

	if m.ControlResults != nil {
		cloned.ControlResults = make(map[string]*ComplianceResultValue, len(m.ControlResults))
		for k, v := range m.ControlResults {
			cloned.ControlResults[k] = v.Clone()
		}
	}
	return cloned
}

// Next available tag: 2
type ComplianceStrings struct {
	Id                   string   `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty" sql:"pk"`
	Strings              []string `protobuf:"bytes,1,rep,name=strings,proto3" json:"strings,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ComplianceStrings) Reset()         { *m = ComplianceStrings{} }
func (m *ComplianceStrings) String() string { return proto.CompactTextString(m) }
func (*ComplianceStrings) ProtoMessage()    {}
func (*ComplianceStrings) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{6}
}
func (m *ComplianceStrings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceStrings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceStrings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceStrings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceStrings.Merge(m, src)
}
func (m *ComplianceStrings) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceStrings) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceStrings.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceStrings proto.InternalMessageInfo

func (m *ComplianceStrings) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ComplianceStrings) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *ComplianceStrings) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceStrings) Clone() *ComplianceStrings {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceStrings)
	*cloned = *m

	if m.Strings != nil {
		cloned.Strings = make([]string, len(m.Strings))
		copy(cloned.Strings, m.Strings)
	}
	return cloned
}

type ComplianceAggregation struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ComplianceAggregation) Reset()         { *m = ComplianceAggregation{} }
func (m *ComplianceAggregation) String() string { return proto.CompactTextString(m) }
func (*ComplianceAggregation) ProtoMessage()    {}
func (*ComplianceAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{7}
}
func (m *ComplianceAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceAggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceAggregation.Merge(m, src)
}
func (m *ComplianceAggregation) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceAggregation proto.InternalMessageInfo

func (m *ComplianceAggregation) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceAggregation) Clone() *ComplianceAggregation {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceAggregation)
	*cloned = *m

	return cloned
}

// Next available tag: 3
type ComplianceAggregation_AggregationKey struct {
	Scope                ComplianceAggregation_Scope `protobuf:"varint,1,opt,name=scope,proto3,enum=storage.ComplianceAggregation_Scope" json:"scope,omitempty"`
	Id                   string                      `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ComplianceAggregation_AggregationKey) Reset()         { *m = ComplianceAggregation_AggregationKey{} }
func (m *ComplianceAggregation_AggregationKey) String() string { return proto.CompactTextString(m) }
func (*ComplianceAggregation_AggregationKey) ProtoMessage()    {}
func (*ComplianceAggregation_AggregationKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{7, 0}
}
func (m *ComplianceAggregation_AggregationKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceAggregation_AggregationKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceAggregation_AggregationKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceAggregation_AggregationKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceAggregation_AggregationKey.Merge(m, src)
}
func (m *ComplianceAggregation_AggregationKey) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceAggregation_AggregationKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceAggregation_AggregationKey.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceAggregation_AggregationKey proto.InternalMessageInfo

func (m *ComplianceAggregation_AggregationKey) GetScope() ComplianceAggregation_Scope {
	if m != nil {
		return m.Scope
	}
	return ComplianceAggregation_UNKNOWN
}

func (m *ComplianceAggregation_AggregationKey) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ComplianceAggregation_AggregationKey) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceAggregation_AggregationKey) Clone() *ComplianceAggregation_AggregationKey {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceAggregation_AggregationKey)
	*cloned = *m

	return cloned
}

// Next available tag: 5
type ComplianceAggregation_Result struct {
	AggregationKeys      []*ComplianceAggregation_AggregationKey `protobuf:"bytes,1,rep,name=aggregation_keys,json=aggregationKeys,proto3" json:"aggregation_keys,omitempty"`
	Unit                 ComplianceAggregation_Scope             `protobuf:"varint,2,opt,name=unit,proto3,enum=storage.ComplianceAggregation_Scope" json:"unit,omitempty"`
	NumPassing           int32                                   `protobuf:"varint,3,opt,name=num_passing,json=numPassing,proto3" json:"num_passing,omitempty"`
	NumFailing           int32                                   `protobuf:"varint,4,opt,name=num_failing,json=numFailing,proto3" json:"num_failing,omitempty"`
	NumSkipped           int32                                   `protobuf:"varint,5,opt,name=num_skipped,json=numSkipped,proto3" json:"num_skipped,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *ComplianceAggregation_Result) Reset()         { *m = ComplianceAggregation_Result{} }
func (m *ComplianceAggregation_Result) String() string { return proto.CompactTextString(m) }
func (*ComplianceAggregation_Result) ProtoMessage()    {}
func (*ComplianceAggregation_Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{7, 1}
}
func (m *ComplianceAggregation_Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceAggregation_Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceAggregation_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceAggregation_Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceAggregation_Result.Merge(m, src)
}
func (m *ComplianceAggregation_Result) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceAggregation_Result) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceAggregation_Result.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceAggregation_Result proto.InternalMessageInfo

func (m *ComplianceAggregation_Result) GetAggregationKeys() []*ComplianceAggregation_AggregationKey {
	if m != nil {
		return m.AggregationKeys
	}
	return nil
}

func (m *ComplianceAggregation_Result) GetUnit() ComplianceAggregation_Scope {
	if m != nil {
		return m.Unit
	}
	return ComplianceAggregation_UNKNOWN
}

func (m *ComplianceAggregation_Result) GetNumPassing() int32 {
	if m != nil {
		return m.NumPassing
	}
	return 0
}

func (m *ComplianceAggregation_Result) GetNumFailing() int32 {
	if m != nil {
		return m.NumFailing
	}
	return 0
}

func (m *ComplianceAggregation_Result) GetNumSkipped() int32 {
	if m != nil {
		return m.NumSkipped
	}
	return 0
}

func (m *ComplianceAggregation_Result) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceAggregation_Result) Clone() *ComplianceAggregation_Result {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceAggregation_Result)
	*cloned = *m

	if m.AggregationKeys != nil {
		cloned.AggregationKeys = make([]*ComplianceAggregation_AggregationKey, len(m.AggregationKeys))
		for idx, v := range m.AggregationKeys {
			cloned.AggregationKeys[idx] = v.Clone()
		}
	}
	return cloned
}

// Next available tag: 5
type ComplianceAggregation_Source struct {
	ClusterId            string                   `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	StandardId           string                   `protobuf:"bytes,2,opt,name=standard_id,json=standardId,proto3" json:"standard_id,omitempty"`
	SuccessfulRun        *ComplianceRunMetadata   `protobuf:"bytes,3,opt,name=successful_run,json=successfulRun,proto3" json:"successful_run,omitempty"`
	FailedRuns           []*ComplianceRunMetadata `protobuf:"bytes,4,rep,name=failed_runs,json=failedRuns,proto3" json:"failed_runs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *ComplianceAggregation_Source) Reset()         { *m = ComplianceAggregation_Source{} }
func (m *ComplianceAggregation_Source) String() string { return proto.CompactTextString(m) }
func (*ComplianceAggregation_Source) ProtoMessage()    {}
func (*ComplianceAggregation_Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{7, 2}
}
func (m *ComplianceAggregation_Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceAggregation_Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceAggregation_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceAggregation_Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceAggregation_Source.Merge(m, src)
}
func (m *ComplianceAggregation_Source) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceAggregation_Source) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceAggregation_Source.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceAggregation_Source proto.InternalMessageInfo

func (m *ComplianceAggregation_Source) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *ComplianceAggregation_Source) GetStandardId() string {
	if m != nil {
		return m.StandardId
	}
	return ""
}

func (m *ComplianceAggregation_Source) GetSuccessfulRun() *ComplianceRunMetadata {
	if m != nil {
		return m.SuccessfulRun
	}
	return nil
}

func (m *ComplianceAggregation_Source) GetFailedRuns() []*ComplianceRunMetadata {
	if m != nil {
		return m.FailedRuns
	}
	return nil
}

func (m *ComplianceAggregation_Source) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceAggregation_Source) Clone() *ComplianceAggregation_Source {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceAggregation_Source)
	*cloned = *m

	cloned.SuccessfulRun = m.SuccessfulRun.Clone()
	if m.FailedRuns != nil {
		cloned.FailedRuns = make([]*ComplianceRunMetadata, len(m.FailedRuns))
		for idx, v := range m.FailedRuns {
			cloned.FailedRuns[idx] = v.Clone()
		}
	}
	return cloned
}

// Next available tag: 3
type ComplianceAggregation_Response struct {
	Results              []*ComplianceAggregation_Result `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	Sources              []*ComplianceAggregation_Source `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
	ErrorMessage         string                          `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *ComplianceAggregation_Response) Reset()         { *m = ComplianceAggregation_Response{} }
func (m *ComplianceAggregation_Response) String() string { return proto.CompactTextString(m) }
func (*ComplianceAggregation_Response) ProtoMessage()    {}
func (*ComplianceAggregation_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{7, 3}
}
func (m *ComplianceAggregation_Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceAggregation_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceAggregation_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceAggregation_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceAggregation_Response.Merge(m, src)
}
func (m *ComplianceAggregation_Response) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceAggregation_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceAggregation_Response.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceAggregation_Response proto.InternalMessageInfo

func (m *ComplianceAggregation_Response) GetResults() []*ComplianceAggregation_Result {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *ComplianceAggregation_Response) GetSources() []*ComplianceAggregation_Source {
	if m != nil {
		return m.Sources
	}
	return nil
}

func (m *ComplianceAggregation_Response) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *ComplianceAggregation_Response) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceAggregation_Response) Clone() *ComplianceAggregation_Response {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceAggregation_Response)
	*cloned = *m

	if m.Results != nil {
		cloned.Results = make([]*ComplianceAggregation_Result, len(m.Results))
		for idx, v := range m.Results {
			cloned.Results[idx] = v.Clone()
		}
	}
	if m.Sources != nil {
		cloned.Sources = make([]*ComplianceAggregation_Source, len(m.Sources))
		for idx, v := range m.Sources {
			cloned.Sources[idx] = v.Clone()
		}
	}
	return cloned
}

type PreComputedComplianceAggregation struct {
	Results              []*ComplianceAggregation_Result `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	Sources              []*ComplianceAggregation_Source `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
	DomainPointers       []string                        `protobuf:"bytes,3,rep,name=domain_pointers,json=domainPointers,proto3" json:"domain_pointers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *PreComputedComplianceAggregation) Reset()         { *m = PreComputedComplianceAggregation{} }
func (m *PreComputedComplianceAggregation) String() string { return proto.CompactTextString(m) }
func (*PreComputedComplianceAggregation) ProtoMessage()    {}
func (*PreComputedComplianceAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_148259962d30bc63, []int{8}
}
func (m *PreComputedComplianceAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreComputedComplianceAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreComputedComplianceAggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreComputedComplianceAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreComputedComplianceAggregation.Merge(m, src)
}
func (m *PreComputedComplianceAggregation) XXX_Size() int {
	return m.Size()
}
func (m *PreComputedComplianceAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_PreComputedComplianceAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_PreComputedComplianceAggregation proto.InternalMessageInfo

func (m *PreComputedComplianceAggregation) GetResults() []*ComplianceAggregation_Result {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *PreComputedComplianceAggregation) GetSources() []*ComplianceAggregation_Source {
	if m != nil {
		return m.Sources
	}
	return nil
}

func (m *PreComputedComplianceAggregation) GetDomainPointers() []string {
	if m != nil {
		return m.DomainPointers
	}
	return nil
}

func (m *PreComputedComplianceAggregation) MessageClone() proto.Message {
	return m.Clone()
}
func (m *PreComputedComplianceAggregation) Clone() *PreComputedComplianceAggregation {
	if m == nil {
		return nil
	}
	cloned := new(PreComputedComplianceAggregation)
	*cloned = *m

	if m.Results != nil {
		cloned.Results = make([]*ComplianceAggregation_Result, len(m.Results))
		for idx, v := range m.Results {
			cloned.Results[idx] = v.Clone()
		}
	}
	if m.Sources != nil {
		cloned.Sources = make([]*ComplianceAggregation_Source, len(m.Sources))
		for idx, v := range m.Sources {
			cloned.Sources[idx] = v.Clone()
		}
	}
	if m.DomainPointers != nil {
		cloned.DomainPointers = make([]string, len(m.DomainPointers))
		copy(cloned.DomainPointers, m.DomainPointers)
	}
	return cloned
}

func init() {
	proto.RegisterEnum("storage.ComplianceState", ComplianceState_name, ComplianceState_value)
	proto.RegisterEnum("storage.ComplianceAggregation_Scope", ComplianceAggregation_Scope_name, ComplianceAggregation_Scope_value)
	proto.RegisterType((*ComplianceResource)(nil), "storage.ComplianceResource")
	proto.RegisterType((*ComplianceResource_ClusterName)(nil), "storage.ComplianceResource.ClusterName")
	proto.RegisterType((*ComplianceResource_DeploymentName)(nil), "storage.ComplianceResource.DeploymentName")
	proto.RegisterType((*ComplianceResource_NodeName)(nil), "storage.ComplianceResource.NodeName")
	proto.RegisterType((*ComplianceResultValue)(nil), "storage.ComplianceResultValue")
	proto.RegisterType((*ComplianceResultValue_Evidence)(nil), "storage.ComplianceResultValue.Evidence")
	proto.RegisterType((*ComplianceControlResult)(nil), "storage.ComplianceControlResult")
	proto.RegisterType((*ComplianceDomain)(nil), "storage.ComplianceDomain")
	proto.RegisterMapType((map[string]*Deployment)(nil), "storage.ComplianceDomain.DeploymentsEntry")
	proto.RegisterMapType((map[string]*Node)(nil), "storage.ComplianceDomain.NodesEntry")
	proto.RegisterType((*ComplianceRunMetadata)(nil), "storage.ComplianceRunMetadata")
	proto.RegisterType((*ComplianceRunResults)(nil), "storage.ComplianceRunResults")
	proto.RegisterMapType((map[string]*ComplianceRunResults_EntityResults)(nil), "storage.ComplianceRunResults.DeploymentResultsEntry")
	proto.RegisterMapType((map[string]*ComplianceRunResults_EntityResults)(nil), "storage.ComplianceRunResults.MachineConfigResultsEntry")
	proto.RegisterMapType((map[string]*ComplianceRunResults_EntityResults)(nil), "storage.ComplianceRunResults.NodeResultsEntry")
	proto.RegisterType((*ComplianceRunResults_EntityResults)(nil), "storage.ComplianceRunResults.EntityResults")
	proto.RegisterMapType((map[string]*ComplianceResultValue)(nil), "storage.ComplianceRunResults.EntityResults.ControlResultsEntry")
	proto.RegisterType((*ComplianceStrings)(nil), "storage.ComplianceStrings")
	proto.RegisterType((*ComplianceAggregation)(nil), "storage.ComplianceAggregation")
	proto.RegisterType((*ComplianceAggregation_AggregationKey)(nil), "storage.ComplianceAggregation.AggregationKey")
	proto.RegisterType((*ComplianceAggregation_Result)(nil), "storage.ComplianceAggregation.Result")
	proto.RegisterType((*ComplianceAggregation_Source)(nil), "storage.ComplianceAggregation.Source")
	proto.RegisterType((*ComplianceAggregation_Response)(nil), "storage.ComplianceAggregation.Response")
	proto.RegisterType((*PreComputedComplianceAggregation)(nil), "storage.PreComputedComplianceAggregation")
}

func init() { proto.RegisterFile("storage/compliance.proto", fileDescriptor_148259962d30bc63) }

var fileDescriptor_148259962d30bc63 = []byte{
	// 1663 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xdd, 0x6e, 0x1b, 0x5b,
	0x15, 0xee, 0xf8, 0xdf, 0xcb, 0x89, 0x33, 0x67, 0xf7, 0x07, 0x67, 0x4e, 0x4f, 0xec, 0x33, 0xe7,
	0x1c, 0xb5, 0x84, 0xd6, 0x51, 0x4b, 0xa4, 0x56, 0x41, 0x50, 0xd9, 0xce, 0xa4, 0xb5, 0x92, 0xd8,
	0x61, 0xdb, 0x01, 0x8a, 0x90, 0xac, 0xa9, 0x67, 0xc7, 0x19, 0xc5, 0x9e, 0x71, 0xe6, 0xa7, 0x22,
	0x37, 0x5c, 0xf0, 0x04, 0x70, 0x81, 0xc4, 0x1b, 0x70, 0xcd, 0x03, 0x70, 0x8f, 0x04, 0x48, 0xbd,
	0x45, 0x42, 0x16, 0x2a, 0x6f, 0xe0, 0x07, 0x00, 0x34, 0xfb, 0x67, 0xc6, 0x93, 0x4c, 0x9c, 0x16,
	0xa9, 0xe8, 0x5c, 0x65, 0xf6, 0xda, 0xeb, 0xfb, 0xd6, 0xda, 0x6b, 0xaf, 0xbd, 0xd6, 0x8a, 0xa1,
	0xe2, 0x7a, 0xb6, 0xa3, 0x8f, 0xc8, 0xd6, 0xd0, 0x9e, 0x4c, 0xc7, 0xa6, 0x6e, 0x0d, 0x49, 0x7d,
	0xea, 0xd8, 0x9e, 0x8d, 0xf2, 0x7c, 0x47, 0xb9, 0x33, 0xb2, 0x47, 0x36, 0x95, 0x6d, 0x05, 0x5f,
	0x6c, 0x5b, 0xa9, 0x8e, 0x6c, 0x7b, 0x34, 0x26, 0x5b, 0x74, 0xf5, 0xc6, 0x3f, 0xd9, 0xf2, 0xcc,
	0x09, 0x71, 0x3d, 0x7d, 0x32, 0xe5, 0x0a, 0x77, 0x43, 0xe6, 0xb1, 0xef, 0x7a, 0xc4, 0xe1, 0xe2,
	0xd0, 0xa0, 0x41, 0xa6, 0x63, 0xfb, 0x62, 0x42, 0x2c, 0x8f, 0xef, 0xdc, 0x16, 0x3b, 0xe6, 0x44,
	0x1f, 0x71, 0x2f, 0x14, 0x24, 0x84, 0x96, 0x6d, 0x70, 0x99, 0xfa, 0xf7, 0x0c, 0xa0, 0x56, 0xe8,
	0x2e, 0x26, 0xae, 0xed, 0x3b, 0x43, 0x82, 0x5a, 0x90, 0xe7, 0xa6, 0x2a, 0x52, 0x4d, 0x7a, 0x58,
	0x7a, 0xfa, 0xa0, 0xce, 0xc1, 0xf5, 0xab, 0xda, 0xf5, 0x16, 0x53, 0xed, 0xe8, 0x13, 0xf2, 0xea,
	0x16, 0x16, 0x48, 0x74, 0x00, 0x10, 0x39, 0x56, 0x49, 0x51, 0x9e, 0xcd, 0x65, 0x3c, 0xbb, 0xa1,
	0x36, 0xa7, 0x5a, 0xc0, 0xa3, 0x1d, 0xc8, 0x04, 0x7e, 0x57, 0xd2, 0x94, 0xe7, 0xeb, 0x65, 0x3c,
	0x1d, 0xdb, 0x20, 0x9c, 0x81, 0x62, 0xd0, 0x26, 0x64, 0x69, 0x20, 0x2a, 0x19, 0x0a, 0x46, 0x21,
	0xb8, 0x1d, 0x48, 0xb9, 0x2a, 0x53, 0x51, 0x9e, 0x40, 0x69, 0xe1, 0x3c, 0xa8, 0x0c, 0x29, 0xd3,
	0xa0, 0x41, 0x28, 0xe2, 0x94, 0x69, 0x20, 0x04, 0x19, 0x4b, 0x9f, 0x10, 0x7a, 0x9c, 0x22, 0xa6,
	0xdf, 0xca, 0xef, 0x24, 0x28, 0xc7, 0x7d, 0x47, 0x8d, 0xff, 0x35, 0x80, 0x51, 0xf8, 0x98, 0xe5,
	0xd4, 0x15, 0xcb, 0xe9, 0xc8, 0x32, 0xba, 0x0f, 0xc5, 0xe0, 0xaf, 0x3b, 0xd5, 0x87, 0xec, 0x70,
	0x45, 0x1c, 0x09, 0x94, 0x73, 0x28, 0x88, 0x50, 0xfc, 0x9f, 0x1c, 0x6a, 0x02, 0x14, 0x1c, 0x4e,
	0xa2, 0xfe, 0x26, 0x05, 0x77, 0x63, 0xdc, 0xfe, 0xd8, 0xfb, 0x89, 0x3e, 0xf6, 0x83, 0xf4, 0x2a,
	0x90, 0xb7, 0xa6, 0x41, 0xac, 0x21, 0xa9, 0x48, 0xb5, 0xf4, 0xf5, 0xde, 0x08, 0x44, 0x5d, 0xe3,
	0xea, 0x38, 0x04, 0xa2, 0x1f, 0xc2, 0xaa, 0xfd, 0x96, 0x38, 0xfa, 0x78, 0x3c, 0x70, 0x3d, 0xdd,
	0x63, 0x57, 0x52, 0x7e, 0x5a, 0x49, 0x60, 0xea, 0x05, 0xfb, 0x78, 0x85, 0xab, 0xd3, 0x95, 0xe2,
	0x42, 0x41, 0x90, 0xa2, 0x3a, 0x64, 0x19, 0x85, 0x74, 0x03, 0x05, 0x53, 0x43, 0x15, 0xc8, 0x4f,
	0x88, 0xeb, 0x06, 0x19, 0xc5, 0xc2, 0x21, 0x96, 0xe8, 0x0b, 0x00, 0xfe, 0x39, 0x30, 0x0d, 0x1a,
	0x99, 0x2c, 0x2e, 0x72, 0x49, 0xdb, 0x50, 0xff, 0x20, 0xc1, 0x77, 0x22, 0xce, 0x96, 0x6d, 0x79,
	0x8e, 0x3d, 0x66, 0xe7, 0x44, 0xcf, 0xa2, 0xd0, 0xf1, 0x2b, 0xfa, 0x7c, 0xc9, 0x15, 0xe1, 0x50,
	0x39, 0xb0, 0x39, 0x64, 0x4c, 0x83, 0xf0, 0x7e, 0x8a, 0x5c, 0xd2, 0x36, 0xd0, 0x36, 0x64, 0xdf,
	0x06, 0x31, 0xe4, 0x2f, 0x67, 0x63, 0x79, 0xa4, 0x31, 0x53, 0x56, 0xff, 0x9a, 0x06, 0x39, 0x52,
	0xd8, 0xb5, 0x27, 0xba, 0x69, 0xa1, 0x06, 0xcd, 0x00, 0x9a, 0x67, 0xcd, 0x27, 0xf3, 0x59, 0xf5,
	0xb1, 0x7b, 0x3e, 0xde, 0x51, 0xa7, 0x67, 0x6a, 0xcd, 0x25, 0xba, 0x33, 0x3c, 0xdd, 0x51, 0x23,
	0x48, 0x8d, 0x61, 0x6a, 0xed, 0xdd, 0x47, 0xa7, 0xa6, 0x61, 0x10, 0x4b, 0xa5, 0x49, 0x73, 0x78,
	0x39, 0x0f, 0xe5, 0xc8, 0x1f, 0x26, 0x6f, 0x7e, 0x39, 0x9f, 0x55, 0xbf, 0xa0, 0xcc, 0xe6, 0xc8,
	0xb2, 0x1d, 0x32, 0x98, 0x9e, 0x3d, 0xe2, 0x5f, 0xbe, 0x65, 0x9e, 0xfb, 0x44, 0x8d, 0x72, 0x72,
	0x07, 0xb2, 0xc1, 0x0b, 0x77, 0x2b, 0x29, 0x9a, 0x46, 0x49, 0x65, 0x81, 0xf9, 0x41, 0x8b, 0x82,
	0xab, 0x59, 0x9e, 0x73, 0x81, 0x19, 0x04, 0x1d, 0x40, 0x29, 0xaa, 0x2f, 0x6e, 0x25, 0x4d, 0x19,
	0x36, 0xaf, 0x67, 0x88, 0x9e, 0x38, 0xe7, 0x59, 0x84, 0x2b, 0x2f, 0x01, 0x22, 0x13, 0x48, 0x86,
	0xf4, 0x19, 0xb9, 0xe0, 0x75, 0x23, 0xf8, 0x44, 0x5f, 0x89, 0x6b, 0x60, 0x85, 0x70, 0x35, 0xb4,
	0x13, 0xa0, 0x78, 0xd4, 0x77, 0x52, 0xcf, 0x25, 0xa5, 0x07, 0xf2, 0x65, 0x4b, 0x09, 0x74, 0xdf,
	0x8d, 0xd3, 0xdd, 0x0e, 0xe9, 0x22, 0xec, 0x02, 0xa9, 0xfa, 0xdb, 0x4c, 0xec, 0x2d, 0xfa, 0xd6,
	0x21, 0xf1, 0x74, 0x43, 0xf7, 0x74, 0xa4, 0x41, 0xce, 0xf1, 0xad, 0x81, 0x28, 0x72, 0xcd, 0xfa,
	0x7c, 0x56, 0xdd, 0x5c, 0x76, 0xaf, 0xd8, 0x8f, 0x5d, 0x6a, 0xd6, 0xf1, 0xad, 0xb6, 0x81, 0xf6,
	0xa0, 0xe4, 0x7a, 0xba, 0x65, 0xe8, 0x8e, 0x11, 0x66, 0x61, 0xf3, 0x9b, 0xf9, 0xac, 0xfa, 0xa5,
	0xa0, 0xe8, 0xf1, 0xed, 0x08, 0xfc, 0x28, 0xf0, 0x99, 0xa8, 0x18, 0x04, 0xb2, 0x6d, 0xa0, 0x16,
	0x00, 0xbf, 0x5b, 0xf1, 0x80, 0x8a, 0xcd, 0xaf, 0xe7, 0xb3, 0x6a, 0xe4, 0x09, 0xdb, 0xbd, 0xca,
	0x52, 0xe4, 0x38, 0x4a, 0xb2, 0xe6, 0x7a, 0xba, 0xe3, 0x0d, 0xc2, 0x46, 0xca, 0x2b, 0xbf, 0x52,
	0x67, 0xad, 0xb6, 0x2e, 0x5a, 0x6d, 0xbd, 0x2f, 0x34, 0x70, 0x99, 0x42, 0xc2, 0x35, 0xfa, 0xb5,
	0x04, 0xf2, 0x89, 0x69, 0x99, 0xee, 0xe9, 0x02, 0x4d, 0xf6, 0x26, 0x9a, 0xe6, 0x0f, 0xe6, 0xb3,
	0xea, 0xb3, 0x6b, 0xc2, 0xb6, 0x47, 0xe9, 0x88, 0x51, 0x0b, 0xd5, 0x2f, 0x9d, 0x61, 0x8d, 0x19,
	0x8c, 0x9c, 0xa8, 0x40, 0xde, 0xf5, 0x87, 0x43, 0xe2, 0xba, 0x95, 0x5c, 0x4d, 0x7a, 0x58, 0xc0,
	0x62, 0x89, 0xbe, 0x82, 0x55, 0xe2, 0x38, 0xb6, 0x33, 0x10, 0x95, 0x28, 0x4f, 0x93, 0x63, 0x85,
	0x0a, 0x0f, 0x79, 0x39, 0xfa, 0x1c, 0x8a, 0x06, 0x4d, 0xde, 0x20, 0x98, 0x05, 0xaa, 0x50, 0x60,
	0x82, 0xb6, 0xa1, 0xfe, 0xa5, 0x00, 0x77, 0x62, 0x39, 0xc1, 0xca, 0x80, 0x8b, 0x7e, 0x04, 0x39,
	0xa6, 0xc4, 0x9f, 0xe8, 0xfa, 0xb5, 0x6f, 0xa2, 0x59, 0x9a, 0xcf, 0xaa, 0x79, 0x9a, 0x2d, 0x8f,
	0x55, 0xcc, 0x51, 0xa8, 0x01, 0x2b, 0x41, 0x4a, 0x4d, 0x78, 0x8a, 0xf1, 0x14, 0x4d, 0x2c, 0x3c,
	0x51, 0x22, 0xe2, 0x92, 0xb3, 0x90, 0x95, 0x7d, 0x58, 0x13, 0x69, 0xe0, 0x30, 0xaf, 0x78, 0xf9,
	0xfa, 0x5e, 0x32, 0x0b, 0x77, 0xbd, 0xae, 0x59, 0x9e, 0xe9, 0x5d, 0xf0, 0x15, 0x2e, 0x73, 0x0e,
	0x71, 0xb0, 0x1f, 0xc3, 0x4a, 0xf0, 0xf4, 0x43, 0xca, 0x0c, 0x7d, 0xf2, 0xf5, 0xe5, 0x94, 0xf4,
	0x7d, 0xb2, 0x6f, 0xfe, 0xec, 0xad, 0x48, 0x82, 0x86, 0x80, 0xa2, 0x2a, 0x10, 0x12, 0x67, 0x29,
	0xf1, 0xf6, 0x72, 0xe2, 0x85, 0x97, 0xba, 0x48, 0xff, 0x99, 0x71, 0x59, 0x8e, 0x26, 0x70, 0x6f,
	0xa2, 0x0f, 0x4f, 0x4d, 0x8b, 0x0c, 0x86, 0xb6, 0x75, 0x62, 0x8e, 0x42, 0x43, 0x39, 0x6a, 0xe8,
	0xd9, 0x72, 0x43, 0x87, 0x0c, 0xdb, 0xa2, 0xd0, 0x98, 0xad, 0x3b, 0x93, 0x84, 0x2d, 0xe5, 0x1f,
	0x12, 0xac, 0xc6, 0x02, 0x89, 0x4e, 0x61, 0x4d, 0xb4, 0x18, 0x61, 0x99, 0xf5, 0xed, 0x17, 0x1f,
	0x71, 0x1d, 0xf5, 0x58, 0xbf, 0xe3, 0x1e, 0x94, 0x87, 0x31, 0xa1, 0xa2, 0xc3, 0xed, 0x04, 0xb5,
	0x84, 0x02, 0xb8, 0x1d, 0x2f, 0x80, 0x1f, 0xd6, 0xd6, 0x68, 0x81, 0x3d, 0x03, 0xf9, 0xf2, 0x9d,
	0x26, 0xf0, 0x37, 0xe2, 0xfc, 0x1f, 0x95, 0x77, 0x0b, 0xc6, 0xce, 0xe1, 0x5e, 0xf2, 0x3d, 0x7f,
	0x3a, 0x93, 0x1e, 0xac, 0x5f, 0x7b, 0xe3, 0x9f, 0xcc, 0xaa, 0xba, 0x0f, 0x9f, 0x2d, 0x4e, 0x4b,
	0x8e, 0x69, 0x8d, 0x5c, 0x74, 0x3f, 0x1a, 0x19, 0x9b, 0x2b, 0xf3, 0x59, 0xb5, 0x20, 0x1a, 0x0b,
	0x9d, 0x05, 0x82, 0xe2, 0xc6, 0x14, 0x69, 0x36, 0x15, 0xb1, 0x58, 0xaa, 0xff, 0xce, 0x2d, 0xb6,
	0xab, 0xc6, 0x68, 0xe4, 0x90, 0x91, 0xee, 0x99, 0xb6, 0xa5, 0xfc, 0x02, 0xca, 0x0b, 0xcb, 0x7d,
	0x72, 0x11, 0x8c, 0x00, 0xee, 0xd0, 0x9e, 0x8a, 0xe1, 0x2d, 0x69, 0x04, 0x58, 0x40, 0xd4, 0x7b,
	0x81, 0x2e, 0x66, 0x90, 0xcb, 0x23, 0xad, 0xf2, 0x1f, 0x09, 0x72, 0x7c, 0x1c, 0xfb, 0x19, 0xc8,
	0x7a, 0x04, 0x1b, 0x9c, 0x91, 0x0b, 0x91, 0xf3, 0x8f, 0x6f, 0xb0, 0x10, 0xf7, 0x0f, 0xaf, 0xe9,
	0xb1, 0xb5, 0x8b, 0x9e, 0x43, 0xc6, 0xb7, 0x4c, 0x8f, 0xcf, 0xab, 0x1f, 0xe6, 0x2f, 0x45, 0xa0,
	0x2a, 0x94, 0x2c, 0x7f, 0x32, 0x98, 0xea, 0xae, 0x6b, 0x5a, 0x23, 0x3e, 0x5e, 0x82, 0xe5, 0x4f,
	0x8e, 0x98, 0x44, 0x28, 0x9c, 0xe8, 0xe6, 0x38, 0x50, 0xc8, 0x84, 0x0a, 0x7b, 0x4c, 0x22, 0x14,
	0xdc, 0x33, 0x73, 0x3a, 0x25, 0x06, 0x6d, 0x67, 0x4c, 0xa1, 0xc7, 0x24, 0xca, 0x3b, 0x09, 0x72,
	0xbd, 0x68, 0xae, 0x8c, 0x5a, 0xb1, 0xc4, 0xe7, 0xca, 0xb0, 0xc9, 0x56, 0x13, 0x3a, 0x7e, 0xac,
	0x95, 0x6b, 0x50, 0xe6, 0xcd, 0xea, 0xc4, 0x1f, 0x0f, 0x1c, 0xdf, 0x5a, 0x36, 0x81, 0x2e, 0x34,
	0x82, 0xd5, 0x08, 0x85, 0x7d, 0x0b, 0xbd, 0x80, 0x52, 0x70, 0x1e, 0x62, 0x04, 0x14, 0xa2, 0x66,
	0xdf, 0xc4, 0x01, 0x0c, 0x82, 0x7d, 0xcb, 0x55, 0xfe, 0x28, 0x41, 0x01, 0x13, 0x77, 0x6a, 0x5b,
	0x2e, 0x41, 0x2f, 0x20, 0x1f, 0xaf, 0x60, 0xdf, 0xdc, 0x10, 0x7f, 0x96, 0x0e, 0x58, 0xa0, 0x02,
	0x02, 0x36, 0x77, 0x8b, 0x99, 0xf3, 0x26, 0x02, 0x16, 0x4d, 0x2c, 0x50, 0x57, 0x1b, 0x77, 0xfa,
	0x6a, 0xe3, 0x56, 0x7f, 0x05, 0x59, 0x7a, 0xf1, 0xa8, 0x04, 0xf9, 0xe3, 0xce, 0x7e, 0xa7, 0xfb,
	0xd3, 0x8e, 0x7c, 0x0b, 0xad, 0x40, 0xa1, 0xd7, 0x6f, 0x74, 0x76, 0x1b, 0x78, 0x57, 0x96, 0x82,
	0xad, 0xd6, 0xc1, 0x71, 0xaf, 0xaf, 0x61, 0x39, 0x15, 0x6c, 0xb5, 0x1a, 0x7d, 0xed, 0x65, 0x17,
	0xbf, 0x96, 0xd3, 0x74, 0xab, 0xdb, 0xe9, 0xe3, 0xee, 0x81, 0x9c, 0x41, 0xab, 0x50, 0xec, 0x34,
	0x0e, 0xb5, 0xde, 0x51, 0xa3, 0xa5, 0xc9, 0x59, 0x54, 0x80, 0x4c, 0xa7, 0xbb, 0xab, 0xc9, 0x39,
	0x54, 0x06, 0xd8, 0xd5, 0x8e, 0x0e, 0xba, 0xaf, 0x0f, 0xb5, 0x4e, 0x5f, 0xce, 0xa3, 0x22, 0x64,
	0x5b, 0xaf, 0xb4, 0xd6, 0xbe, 0x5c, 0x50, 0xff, 0x26, 0x41, 0xed, 0xc8, 0x21, 0xc1, 0x89, 0x7c,
	0x8f, 0x18, 0x89, 0x27, 0xfb, 0x16, 0xc4, 0xf2, 0x01, 0xac, 0xf1, 0xf9, 0x66, 0x6a, 0x9b, 0x96,
	0x47, 0x1c, 0x36, 0xc6, 0x17, 0x71, 0x99, 0x89, 0x8f, 0xb8, 0x74, 0xf3, 0x4f, 0x12, 0xac, 0x5d,
	0xfa, 0x67, 0x0e, 0xdd, 0x87, 0x4a, 0xab, 0x7b, 0x78, 0x74, 0xd0, 0x6e, 0x74, 0x5a, 0xda, 0xa0,
	0xd7, 0x6f, 0xf4, 0xb5, 0x41, 0x14, 0xeb, 0x75, 0xb8, 0x7b, 0x65, 0xb7, 0xb7, 0xdf, 0x3e, 0x92,
	0xa5, 0xc4, 0xad, 0x4e, 0xb7, 0xaf, 0xc9, 0xa9, 0x44, 0xce, 0xde, 0x71, 0xab, 0xa5, 0xf5, 0x7a,
	0x72, 0x3a, 0x71, 0x77, 0xaf, 0xd1, 0x3e, 0x38, 0xc6, 0x9a, 0x9c, 0x41, 0x0a, 0xdc, 0xbb, 0xb2,
	0xab, 0x61, 0xdc, 0xc5, 0x72, 0xb6, 0xb9, 0xfd, 0xe7, 0xf7, 0x1b, 0xd2, 0xbb, 0xf7, 0x1b, 0xd2,
	0x3f, 0xdf, 0x6f, 0x48, 0xbf, 0xff, 0xd7, 0xc6, 0x2d, 0x58, 0x37, 0xed, 0xba, 0xeb, 0xe9, 0xc3,
	0x33, 0xc7, 0xfe, 0x25, 0x9b, 0x43, 0x45, 0xec, 0x7e, 0x2e, 0x7e, 0x6e, 0x7a, 0x93, 0xa3, 0xf2,
	0xef, 0xff, 0x37, 0x00, 0x00, 0xff, 0xff, 0x1f, 0xaf, 0xc5, 0x65, 0x9a, 0x12, 0x00, 0x00,
}

func (m *ComplianceResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceResource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceResource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Resource != nil {
		{
			size := m.Resource.Size()
			i -= size
			if _, err := m.Resource.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceResource_Cluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceResource_Cluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ComplianceResource_Deployment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceResource_Deployment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Deployment != nil {
		{
			size, err := m.Deployment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ComplianceResource_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceResource_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ComplianceResource_Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceResource_Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ComplianceResource_ClusterName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceResource_ClusterName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceResource_ClusterName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceResource_DeploymentName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceResource_DeploymentName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceResource_DeploymentName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceResource_NodeName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceResource_NodeName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceResource_NodeName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceResultValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceResultValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceResultValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OverallState != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.OverallState))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Evidence) > 0 {
		for iNdEx := len(m.Evidence) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Evidence[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompliance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceResultValue_Evidence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceResultValue_Evidence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceResultValue_Evidence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MessageId != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.MessageId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.State != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceControlResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceControlResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceControlResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ControlId) > 0 {
		i -= len(m.ControlId)
		copy(dAtA[i:], m.ControlId)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ControlId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Resource != nil {
		{
			size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceDomain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Deployments) > 0 {
		for k := range m.Deployments {
			v := m.Deployments[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCompliance(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCompliance(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCompliance(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Nodes) > 0 {
		for k := range m.Nodes {
			v := m.Nodes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCompliance(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCompliance(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCompliance(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceRunMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceRunMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceRunMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DomainId) > 0 {
		i -= len(m.DomainId)
		copy(dAtA[i:], m.DomainId)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.DomainId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.FinishTimestamp != nil {
		{
			size, err := m.FinishTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.StartTimestamp != nil {
		{
			size, err := m.StartTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StandardId) > 0 {
		i -= len(m.StandardId)
		copy(dAtA[i:], m.StandardId)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.StandardId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceRunResults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceRunResults) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceRunResults) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MachineConfigResults) > 0 {
		for k := range m.MachineConfigResults {
			v := m.MachineConfigResults[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCompliance(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCompliance(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCompliance(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.DeploymentResults) > 0 {
		for k := range m.DeploymentResults {
			v := m.DeploymentResults[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCompliance(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCompliance(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCompliance(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NodeResults) > 0 {
		for k := range m.NodeResults {
			v := m.NodeResults[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCompliance(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCompliance(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCompliance(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ClusterResults != nil {
		{
			size, err := m.ClusterResults.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RunMetadata != nil {
		{
			size, err := m.RunMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Domain != nil {
		{
			size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceRunResults_EntityResults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceRunResults_EntityResults) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceRunResults_EntityResults) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ControlResults) > 0 {
		for k := range m.ControlResults {
			v := m.ControlResults[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCompliance(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCompliance(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCompliance(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceStrings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceStrings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceStrings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Strings[iNdEx])
			copy(dAtA[i:], m.Strings[iNdEx])
			i = encodeVarintCompliance(dAtA, i, uint64(len(m.Strings[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceAggregation_AggregationKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceAggregation_AggregationKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceAggregation_AggregationKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.Scope != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.Scope))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceAggregation_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceAggregation_Result) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceAggregation_Result) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumSkipped != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.NumSkipped))
		i--
		dAtA[i] = 0x28
	}
	if m.NumFailing != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.NumFailing))
		i--
		dAtA[i] = 0x20
	}
	if m.NumPassing != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.NumPassing))
		i--
		dAtA[i] = 0x18
	}
	if m.Unit != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.Unit))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AggregationKeys) > 0 {
		for iNdEx := len(m.AggregationKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AggregationKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompliance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceAggregation_Source) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceAggregation_Source) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceAggregation_Source) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FailedRuns) > 0 {
		for iNdEx := len(m.FailedRuns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FailedRuns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompliance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SuccessfulRun != nil {
		{
			size, err := m.SuccessfulRun.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCompliance(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StandardId) > 0 {
		i -= len(m.StandardId)
		copy(dAtA[i:], m.StandardId)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.StandardId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceAggregation_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceAggregation_Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceAggregation_Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompliance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Results[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompliance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PreComputedComplianceAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreComputedComplianceAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreComputedComplianceAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DomainPointers) > 0 {
		for iNdEx := len(m.DomainPointers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DomainPointers[iNdEx])
			copy(dAtA[i:], m.DomainPointers[iNdEx])
			i = encodeVarintCompliance(dAtA, i, uint64(len(m.DomainPointers[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompliance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Results[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompliance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintCompliance(dAtA []byte, offset int, v uint64) int {
	offset -= sovCompliance(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ComplianceResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resource != nil {
		n += m.Resource.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceResource_Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	return n
}
func (m *ComplianceResource_Deployment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deployment != nil {
		l = m.Deployment.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	return n
}
func (m *ComplianceResource_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	return n
}
func (m *ComplianceResource_Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	return n
}
func (m *ComplianceResource_ClusterName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceResource_DeploymentName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceResource_NodeName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceResultValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Evidence) > 0 {
		for _, e := range m.Evidence {
			l = e.Size()
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	if m.OverallState != 0 {
		n += 1 + sovCompliance(uint64(m.OverallState))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceResultValue_Evidence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovCompliance(uint64(m.State))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.MessageId != 0 {
		n += 1 + sovCompliance(uint64(m.MessageId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceControlResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.ControlId)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCompliance(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCompliance(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCompliance(uint64(mapEntrySize))
		}
	}
	if len(m.Deployments) > 0 {
		for k, v := range m.Deployments {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCompliance(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCompliance(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCompliance(uint64(mapEntrySize))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceRunMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.StandardId)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.StartTimestamp != nil {
		l = m.StartTimestamp.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.FinishTimestamp != nil {
		l = m.FinishTimestamp.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.Success {
		n += 2
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.DomainId)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceRunResults) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.RunMetadata != nil {
		l = m.RunMetadata.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.ClusterResults != nil {
		l = m.ClusterResults.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	if len(m.NodeResults) > 0 {
		for k, v := range m.NodeResults {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCompliance(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCompliance(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCompliance(uint64(mapEntrySize))
		}
	}
	if len(m.DeploymentResults) > 0 {
		for k, v := range m.DeploymentResults {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCompliance(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCompliance(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCompliance(uint64(mapEntrySize))
		}
	}
	if len(m.MachineConfigResults) > 0 {
		for k, v := range m.MachineConfigResults {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCompliance(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCompliance(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCompliance(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceRunResults_EntityResults) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ControlResults) > 0 {
		for k, v := range m.ControlResults {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCompliance(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCompliance(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCompliance(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceStrings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceAggregation_AggregationKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scope != 0 {
		n += 1 + sovCompliance(uint64(m.Scope))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceAggregation_Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AggregationKeys) > 0 {
		for _, e := range m.AggregationKeys {
			l = e.Size()
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	if m.Unit != 0 {
		n += 1 + sovCompliance(uint64(m.Unit))
	}
	if m.NumPassing != 0 {
		n += 1 + sovCompliance(uint64(m.NumPassing))
	}
	if m.NumFailing != 0 {
		n += 1 + sovCompliance(uint64(m.NumFailing))
	}
	if m.NumSkipped != 0 {
		n += 1 + sovCompliance(uint64(m.NumSkipped))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceAggregation_Source) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.StandardId)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.SuccessfulRun != nil {
		l = m.SuccessfulRun.Size()
		n += 1 + l + sovCompliance(uint64(l))
	}
	if len(m.FailedRuns) > 0 {
		for _, e := range m.FailedRuns {
			l = e.Size()
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceAggregation_Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreComputedComplianceAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	if len(m.DomainPointers) > 0 {
		for _, s := range m.DomainPointers {
			l = len(s)
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCompliance(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCompliance(x uint64) (n int) {
	return sovCompliance(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ComplianceResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ComplianceResource_ClusterName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &ComplianceResource_Cluster{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ComplianceResource_DeploymentName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &ComplianceResource_Deployment{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ComplianceResource_NodeName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &ComplianceResource_Node{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ImageName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &ComplianceResource_Image{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceResource_ClusterName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceResource_DeploymentName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &ComplianceResource_ClusterName{}
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceResource_NodeName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &ComplianceResource_ClusterName{}
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceResultValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceResultValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceResultValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Evidence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Evidence = append(m.Evidence, &ComplianceResultValue_Evidence{})
			if err := m.Evidence[len(m.Evidence)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallState", wireType)
			}
			m.OverallState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverallState |= ComplianceState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceResultValue_Evidence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Evidence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Evidence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ComplianceState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceControlResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceControlResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceControlResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &ComplianceResource{}
			}
			if err := m.Resource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &ComplianceResultValue{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceDomain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceDomain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceDomain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &Cluster{}
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nodes == nil {
				m.Nodes = make(map[string]*Node)
			}
			var mapkey string
			var mapvalue *Node
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCompliance
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCompliance
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCompliance
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCompliance
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCompliance
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCompliance
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCompliance
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Node{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCompliance(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCompliance
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deployments == nil {
				m.Deployments = make(map[string]*Deployment)
			}
			var mapkey string
			var mapvalue *Deployment
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCompliance
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCompliance
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCompliance
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCompliance
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCompliance
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCompliance
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCompliance
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Deployment{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCompliance(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCompliance
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Deployments[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceRunMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceRunMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceRunMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTimestamp == nil {
				m.StartTimestamp = &types.Timestamp{}
			}
			if err := m.StartTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinishTimestamp == nil {
				m.FinishTimestamp = &types.Timestamp{}
			}
			if err := m.FinishTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceRunResults) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceRunResults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceRunResults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domain == nil {
				m.Domain = &ComplianceDomain{}
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunMetadata == nil {
				m.RunMetadata = &ComplianceRunMetadata{}
			}
			if err := m.RunMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterResults == nil {
				m.ClusterResults = &ComplianceRunResults_EntityResults{}
			}
			if err := m.ClusterResults.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeResults == nil {
				m.NodeResults = make(map[string]*ComplianceRunResults_EntityResults)
			}
			var mapkey string
			var mapvalue *ComplianceRunResults_EntityResults
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCompliance
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCompliance
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCompliance
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCompliance
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCompliance
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCompliance
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCompliance
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ComplianceRunResults_EntityResults{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCompliance(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCompliance
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeResults[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeploymentResults == nil {
				m.DeploymentResults = make(map[string]*ComplianceRunResults_EntityResults)
			}
			var mapkey string
			var mapvalue *ComplianceRunResults_EntityResults
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCompliance
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCompliance
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCompliance
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCompliance
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCompliance
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCompliance
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCompliance
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ComplianceRunResults_EntityResults{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCompliance(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCompliance
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DeploymentResults[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineConfigResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MachineConfigResults == nil {
				m.MachineConfigResults = make(map[string]*ComplianceRunResults_EntityResults)
			}
			var mapkey string
			var mapvalue *ComplianceRunResults_EntityResults
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCompliance
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCompliance
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCompliance
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCompliance
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCompliance
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCompliance
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCompliance
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ComplianceRunResults_EntityResults{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCompliance(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCompliance
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MachineConfigResults[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceRunResults_EntityResults) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityResults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityResults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlResults == nil {
				m.ControlResults = make(map[string]*ComplianceResultValue)
			}
			var mapkey string
			var mapvalue *ComplianceResultValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCompliance
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCompliance
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCompliance
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCompliance
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCompliance
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCompliance
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCompliance
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ComplianceResultValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCompliance(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCompliance
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ControlResults[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceStrings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceStrings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceStrings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceAggregation_AggregationKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregationKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregationKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scope |= ComplianceAggregation_Scope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceAggregation_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregationKeys = append(m.AggregationKeys, &ComplianceAggregation_AggregationKey{})
			if err := m.AggregationKeys[len(m.AggregationKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= ComplianceAggregation_Scope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPassing", wireType)
			}
			m.NumPassing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPassing |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumFailing", wireType)
			}
			m.NumFailing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumFailing |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSkipped", wireType)
			}
			m.NumSkipped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSkipped |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceAggregation_Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessfulRun", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SuccessfulRun == nil {
				m.SuccessfulRun = &ComplianceRunMetadata{}
			}
			if err := m.SuccessfulRun.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedRuns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedRuns = append(m.FailedRuns, &ComplianceRunMetadata{})
			if err := m.FailedRuns[len(m.FailedRuns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceAggregation_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &ComplianceAggregation_Result{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &ComplianceAggregation_Source{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreComputedComplianceAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreComputedComplianceAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreComputedComplianceAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &ComplianceAggregation_Result{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &ComplianceAggregation_Source{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainPointers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainPointers = append(m.DomainPointers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCompliance(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCompliance
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCompliance
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCompliance
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCompliance        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCompliance          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCompliance = fmt.Errorf("proto: unexpected end of group")
)
