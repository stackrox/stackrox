// Code generated by protoc-gen-go-immutable. DO NOT EDIT.

package storage

import (
	"iter"
	"time"
)

// ImmutablePolicy is an immutable interface for Policy
type ImmutablePolicy interface {
	GetId() string
	// Name of the policy.  Must be unique.
	GetName() string
	// Free-form text description of this policy.
	GetDescription() string
	GetRationale() string
	// Describes how to remediate a violation of this policy.
	GetRemediation() string
	// Toggles whether or not this policy will be executing and actively firing alerts.
	GetDisabled() bool
	// List of categories that this policy falls under.  Category names must already exist in Central.
	GetImmutableCategories() iter.Seq[string]
	// Describes which policy lifecylce stages this policy applies to.  Choices are DEPLOY, BUILD, and RUNTIME.
	GetImmutableLifecycleStages() iter.Seq[LifecycleStage]
	// Describes which events should trigger execution of this policy
	GetEventSource() EventSource
	// Define deployments or images that should be excluded from this policy.
	GetImmutableExclusions() iter.Seq[ImmutableExclusion]
	// Defines clusters, namespaces, and deployments that should be included in this policy.  No scopes defined includes everything.
	GetImmutableScope() iter.Seq[ImmutableScope]
	// Defines how severe a violation from this policy is.  Possible values are UNSET_SEVERITY, LOW_SEVERITY, MEDIUM_SEVERITY, HIGH_SEVERITY, and CRITICAL_SEVERITY.
	GetSeverity() Severity
	// FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates/updates.
	// FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.
	// FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.
	// Lists the enforcement actions to take when a violation from this policy is identified.  Possible value are UNSET_ENFORCEMENT, SCALE_TO_ZERO_ENFORCEMENT, UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT, KILL_POD_ENFORCEMENT, FAIL_BUILD_ENFORCEMENT, FAIL_KUBE_REQUEST_ENFORCEMENT, FAIL_DEPLOYMENT_CREATE_ENFORCEMENT, and. FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT.
	GetImmutableEnforcementActions() iter.Seq[EnforcementAction]
	// List of IDs of the notifiers that should be triggered when a violation from this policy is identified.  IDs should be in the form of a UUID and are found through the Central API.
	GetImmutableNotifiers() iter.Seq[string]
	GetImmutableLastUpdated() time.Time
	// For internal use only.
	GetSORTName() string
	// For internal use only.
	GetSORTLifecycleStage() string
	// For internal use only.
	GetSORTEnforcement() bool
	GetPolicyVersion() string
	// PolicySections define the violation criteria for this policy.
	GetImmutablePolicySections() iter.Seq[ImmutablePolicySection]
	GetImmutableMitreAttackVectors() iter.Seq[ImmutablePolicy_MitreAttackVectors]
	// Read-only field. If true, the policy's criteria fields are rendered read-only.
	GetCriteriaLocked() bool
	// Read-only field. If true, the policy's MITRE ATT&CK fields are rendered read-only.
	GetMitreVectorsLocked() bool
	// Read-only field. Indicates the policy is a default policy if true and a custom policy if false.
	GetIsDefault() bool
	GetSource() PolicySource
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *Policy
}

// GetImmutableCategories implements ImmutablePolicy
func (m *Policy) GetImmutableCategories() iter.Seq[string] {
	return func(yield func(string) bool) {
		if m == nil || m.Categories == nil {
			return
		}
		for _, v := range m.Categories {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableLifecycleStages implements ImmutablePolicy
func (m *Policy) GetImmutableLifecycleStages() iter.Seq[LifecycleStage] {
	return func(yield func(LifecycleStage) bool) {
		if m == nil || m.LifecycleStages == nil {
			return
		}
		for _, v := range m.LifecycleStages {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableExclusions implements ImmutablePolicy
func (m *Policy) GetImmutableExclusions() iter.Seq[ImmutableExclusion] {
	return func(yield func(ImmutableExclusion) bool) {
		if m == nil || m.Exclusions == nil {
			return
		}
		for _, v := range m.Exclusions {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableScope implements ImmutablePolicy
func (m *Policy) GetImmutableScope() iter.Seq[ImmutableScope] {
	return func(yield func(ImmutableScope) bool) {
		if m == nil || m.Scope == nil {
			return
		}
		for _, v := range m.Scope {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableEnforcementActions implements ImmutablePolicy
func (m *Policy) GetImmutableEnforcementActions() iter.Seq[EnforcementAction] {
	return func(yield func(EnforcementAction) bool) {
		if m == nil || m.EnforcementActions == nil {
			return
		}
		for _, v := range m.EnforcementActions {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableNotifiers implements ImmutablePolicy
func (m *Policy) GetImmutableNotifiers() iter.Seq[string] {
	return func(yield func(string) bool) {
		if m == nil || m.Notifiers == nil {
			return
		}
		for _, v := range m.Notifiers {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableLastUpdated implements ImmutablePolicy
func (m *Policy) GetImmutableLastUpdated() time.Time {
	if m == nil || m.LastUpdated == nil {
		return time.Time{}
	}
	return m.LastUpdated.AsTime()
}

// GetImmutablePolicySections implements ImmutablePolicy
func (m *Policy) GetImmutablePolicySections() iter.Seq[ImmutablePolicySection] {
	return func(yield func(ImmutablePolicySection) bool) {
		if m == nil || m.PolicySections == nil {
			return
		}
		for _, v := range m.PolicySections {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableMitreAttackVectors implements ImmutablePolicy
func (m *Policy) GetImmutableMitreAttackVectors() iter.Seq[ImmutablePolicy_MitreAttackVectors] {
	return func(yield func(ImmutablePolicy_MitreAttackVectors) bool) {
		if m == nil || m.MitreAttackVectors == nil {
			return
		}
		for _, v := range m.MitreAttackVectors {
			if !yield(v) {
				return
			}
		}
	}
}

// Verify that Policy implements ImmutablePolicy
var _ ImmutablePolicy = (*Policy)(nil)

// ImmutablePolicy_MitreAttackVectors is an immutable interface for Policy_MitreAttackVectors
type ImmutablePolicy_MitreAttackVectors interface {
	GetTactic() string
	GetImmutableTechniques() iter.Seq[string]
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *Policy_MitreAttackVectors
}

// GetImmutableTechniques implements ImmutablePolicy_MitreAttackVectors
func (m *Policy_MitreAttackVectors) GetImmutableTechniques() iter.Seq[string] {
	return func(yield func(string) bool) {
		if m == nil || m.Techniques == nil {
			return
		}
		for _, v := range m.Techniques {
			if !yield(v) {
				return
			}
		}
	}
}

// Verify that Policy_MitreAttackVectors implements ImmutablePolicy_MitreAttackVectors
var _ ImmutablePolicy_MitreAttackVectors = (*Policy_MitreAttackVectors)(nil)

// ImmutablePolicySection is an immutable interface for PolicySection
type ImmutablePolicySection interface {
	GetSectionName() string
	// The set of policies groups that make up this section.  Each group can be considered an individual criterion.
	GetImmutablePolicyGroups() iter.Seq[ImmutablePolicyGroup]
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *PolicySection
}

// GetImmutablePolicyGroups implements ImmutablePolicySection
func (m *PolicySection) GetImmutablePolicyGroups() iter.Seq[ImmutablePolicyGroup] {
	return func(yield func(ImmutablePolicyGroup) bool) {
		if m == nil || m.PolicyGroups == nil {
			return
		}
		for _, v := range m.PolicyGroups {
			if !yield(v) {
				return
			}
		}
	}
}

// Verify that PolicySection implements ImmutablePolicySection
var _ ImmutablePolicySection = (*PolicySection)(nil)

// ImmutablePolicyGroup is an immutable interface for PolicyGroup
type ImmutablePolicyGroup interface {
	// Defines which field on a deployment or image this PolicyGroup evaluates.  See https://docs.openshift.com/acs/operating/manage-security-policies.html#policy-criteria_manage-security-policies for a complete list of possible values.
	GetFieldName() string
	// Determines if the values are combined with an OR or an AND.  Defaults to OR.
	GetBooleanOperator() BooleanOperator
	// Determines if the evaluation of this PolicyGroup is negated.  Default to false.
	GetNegate() bool
	// List of values for the specified field
	GetImmutableValues() iter.Seq[ImmutablePolicyValue]
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *PolicyGroup
}

// GetImmutableValues implements ImmutablePolicyGroup
func (m *PolicyGroup) GetImmutableValues() iter.Seq[ImmutablePolicyValue] {
	return func(yield func(ImmutablePolicyValue) bool) {
		if m == nil || m.Values == nil {
			return
		}
		for _, v := range m.Values {
			if !yield(v) {
				return
			}
		}
	}
}

// Verify that PolicyGroup implements ImmutablePolicyGroup
var _ ImmutablePolicyGroup = (*PolicyGroup)(nil)

// ImmutablePolicyValue is an immutable interface for PolicyValue
type ImmutablePolicyValue interface {
	GetValue() string
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *PolicyValue
}

// Verify that PolicyValue implements ImmutablePolicyValue
var _ ImmutablePolicyValue = (*PolicyValue)(nil)

// ImmutablePolicyList is an immutable interface for PolicyList
type ImmutablePolicyList interface {
	GetImmutablePolicies() iter.Seq[ImmutablePolicy]
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *PolicyList
}

// GetImmutablePolicies implements ImmutablePolicyList
func (m *PolicyList) GetImmutablePolicies() iter.Seq[ImmutablePolicy] {
	return func(yield func(ImmutablePolicy) bool) {
		if m == nil || m.Policies == nil {
			return
		}
		for _, v := range m.Policies {
			if !yield(v) {
				return
			}
		}
	}
}

// Verify that PolicyList implements ImmutablePolicyList
var _ ImmutablePolicyList = (*PolicyList)(nil)

// ImmutableListPolicy is an immutable interface for ListPolicy
type ImmutableListPolicy interface {
	GetId() string
	GetName() string
	GetDescription() string
	GetSeverity() Severity
	GetDisabled() bool
	GetImmutableLifecycleStages() iter.Seq[LifecycleStage]
	GetImmutableNotifiers() iter.Seq[string]
	GetImmutableLastUpdated() time.Time
	GetEventSource() EventSource
	GetIsDefault() bool
	GetSource() PolicySource
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *ListPolicy
}

// GetImmutableLifecycleStages implements ImmutableListPolicy
func (m *ListPolicy) GetImmutableLifecycleStages() iter.Seq[LifecycleStage] {
	return func(yield func(LifecycleStage) bool) {
		if m == nil || m.LifecycleStages == nil {
			return
		}
		for _, v := range m.LifecycleStages {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableNotifiers implements ImmutableListPolicy
func (m *ListPolicy) GetImmutableNotifiers() iter.Seq[string] {
	return func(yield func(string) bool) {
		if m == nil || m.Notifiers == nil {
			return
		}
		for _, v := range m.Notifiers {
			if !yield(v) {
				return
			}
		}
	}
}

// GetImmutableLastUpdated implements ImmutableListPolicy
func (m *ListPolicy) GetImmutableLastUpdated() time.Time {
	if m == nil || m.LastUpdated == nil {
		return time.Time{}
	}
	return m.LastUpdated.AsTime()
}

// Verify that ListPolicy implements ImmutableListPolicy
var _ ImmutableListPolicy = (*ListPolicy)(nil)

// ImmutableExclusion is an immutable interface for Exclusion
type ImmutableExclusion interface {
	GetName() string
	GetImmutableDeployment() ImmutableExclusion_Deployment
	GetImmutableImage() ImmutableExclusion_Image
	GetImmutableExpiration() time.Time
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *Exclusion
}

// GetImmutableDeployment implements ImmutableExclusion
func (m *Exclusion) GetImmutableDeployment() ImmutableExclusion_Deployment {
	return m.GetDeployment()
}

// GetImmutableImage implements ImmutableExclusion
func (m *Exclusion) GetImmutableImage() ImmutableExclusion_Image {
	return m.GetImage()
}

// GetImmutableExpiration implements ImmutableExclusion
func (m *Exclusion) GetImmutableExpiration() time.Time {
	if m == nil || m.Expiration == nil {
		return time.Time{}
	}
	return m.Expiration.AsTime()
}

// Verify that Exclusion implements ImmutableExclusion
var _ ImmutableExclusion = (*Exclusion)(nil)

// ImmutableExclusion_Container is an immutable interface for Exclusion_Container
type ImmutableExclusion_Container interface {
	GetImmutableImageName() ImmutableImageName
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *Exclusion_Container
}

// GetImmutableImageName implements ImmutableExclusion_Container
func (m *Exclusion_Container) GetImmutableImageName() ImmutableImageName {
	return m.GetImageName()
}

// Verify that Exclusion_Container implements ImmutableExclusion_Container
var _ ImmutableExclusion_Container = (*Exclusion_Container)(nil)

// ImmutableExclusion_Deployment is an immutable interface for Exclusion_Deployment
type ImmutableExclusion_Deployment interface {
	GetName() string
	GetImmutableScope() ImmutableScope
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *Exclusion_Deployment
}

// GetImmutableScope implements ImmutableExclusion_Deployment
func (m *Exclusion_Deployment) GetImmutableScope() ImmutableScope {
	return m.GetScope()
}

// Verify that Exclusion_Deployment implements ImmutableExclusion_Deployment
var _ ImmutableExclusion_Deployment = (*Exclusion_Deployment)(nil)

// ImmutableExclusion_Image is an immutable interface for Exclusion_Image
type ImmutableExclusion_Image interface {
	GetName() string
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *Exclusion_Image
}

// Verify that Exclusion_Image implements ImmutableExclusion_Image
var _ ImmutableExclusion_Image = (*Exclusion_Image)(nil)

// ImmutableExportPoliciesResponse is an immutable interface for ExportPoliciesResponse
type ImmutableExportPoliciesResponse interface {
	GetImmutablePolicies() iter.Seq[ImmutablePolicy]
	// VT proto functions
	SizeVT() int
	MarshalVT() ([]byte, error)
	CloneVT() *ExportPoliciesResponse
}

// GetImmutablePolicies implements ImmutableExportPoliciesResponse
func (m *ExportPoliciesResponse) GetImmutablePolicies() iter.Seq[ImmutablePolicy] {
	return func(yield func(ImmutablePolicy) bool) {
		if m == nil || m.Policies == nil {
			return
		}
		for _, v := range m.Policies {
			if !yield(v) {
				return
			}
		}
	}
}

// Verify that ExportPoliciesResponse implements ImmutableExportPoliciesResponse
var _ ImmutableExportPoliciesResponse = (*ExportPoliciesResponse)(nil)
