// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/node.proto

package storage

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Node_Note int32

const (
	Node_MISSING_SCAN_DATA Node_Note = 0
)

var Node_Note_name = map[int32]string{
	0: "MISSING_SCAN_DATA",
}

var Node_Note_value = map[string]int32{
	"MISSING_SCAN_DATA": 0,
}

func (x Node_Note) String() string {
	return proto.EnumName(Node_Note_name, int32(x))
}

func (Node_Note) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_107f6eed651900c7, []int{0, 0}
}

type NodeScan_Note int32

const (
	NodeScan_UNSET              NodeScan_Note = 0
	NodeScan_UNSUPPORTED        NodeScan_Note = 1
	NodeScan_KERNEL_UNSUPPORTED NodeScan_Note = 2
)

var NodeScan_Note_name = map[int32]string{
	0: "UNSET",
	1: "UNSUPPORTED",
	2: "KERNEL_UNSUPPORTED",
}

var NodeScan_Note_value = map[string]int32{
	"UNSET":              0,
	"UNSUPPORTED":        1,
	"KERNEL_UNSUPPORTED": 2,
}

func (x NodeScan_Note) String() string {
	return proto.EnumName(NodeScan_Note_name, int32(x))
}

func (NodeScan_Note) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_107f6eed651900c7, []int{1, 0}
}

// Node represents information about a node in the cluster.
// next available tag: 28
type Node struct {
	// A unique ID identifying this node.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Node ID,store"`
	// The (host)name of the node. Might or might not be the same as ID.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" search:"Node,store"`
	// Taints on the host
	Taints      []*Taint `protobuf:"bytes,3,rep,name=taints,proto3" json:"taints,omitempty"`
	ClusterId   string   `protobuf:"bytes,4,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty" search:"Cluster ID,store"`
	ClusterName string   `protobuf:"bytes,5,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty" search:"Cluster,store"`
	// TODO(ROX-6895): "Label" search term is ambiguous.
	Labels      map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" search:"Label" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Annotations map[string]string `protobuf:"bytes,7,rep,name=annotations,proto3" json:"annotations,omitempty" search:"Annotation" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// When the cluster reported the node was added
	JoinedAt *types.Timestamp `protobuf:"bytes,13,opt,name=joined_at,json=joinedAt,proto3" json:"joined_at,omitempty" search:"Node Join Time,store"`
	// node internal IP addresses
	InternalIpAddresses []string `protobuf:"bytes,8,rep,name=internal_ip_addresses,json=internalIpAddresses,proto3" json:"internal_ip_addresses,omitempty"`
	// node external IP addresses
	ExternalIpAddresses []string `protobuf:"bytes,9,rep,name=external_ip_addresses,json=externalIpAddresses,proto3" json:"external_ip_addresses,omitempty"`
	// From NodeInfo
	ContainerRuntimeVersion string                `protobuf:"bytes,10,opt,name=container_runtime_version,json=containerRuntimeVersion,proto3" json:"container_runtime_version,omitempty"` // Deprecated: Do not use.
	ContainerRuntime        *ContainerRuntimeInfo `protobuf:"bytes,14,opt,name=container_runtime,json=containerRuntime,proto3" json:"container_runtime,omitempty"`
	KernelVersion           string                `protobuf:"bytes,11,opt,name=kernel_version,json=kernelVersion,proto3" json:"kernel_version,omitempty"`
	// From NodeInfo. Operating system reported by the node (ex: linux).
	OperatingSystem string `protobuf:"bytes,17,opt,name=operating_system,json=operatingSystem,proto3" json:"operating_system,omitempty"`
	// From NodeInfo. OS image reported by the node from /etc/os-release.
	OsImage          string           `protobuf:"bytes,12,opt,name=os_image,json=osImage,proto3" json:"os_image,omitempty" search:"Operating System,store"`
	KubeletVersion   string           `protobuf:"bytes,15,opt,name=kubelet_version,json=kubeletVersion,proto3" json:"kubelet_version,omitempty"`
	KubeProxyVersion string           `protobuf:"bytes,16,opt,name=kube_proxy_version,json=kubeProxyVersion,proto3" json:"kube_proxy_version,omitempty"`
	LastUpdated      *types.Timestamp `protobuf:"bytes,25,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty" search:"Last Updated,hidden"`
	// Time we received an update from Kubernetes.
	K8SUpdated *types.Timestamp `protobuf:"bytes,26,opt,name=k8s_updated,json=k8sUpdated,proto3" json:"k8s_updated,omitempty" sensorhash:"ignore"`
	Scan       *NodeScan        `protobuf:"bytes,18,opt,name=scan,proto3" json:"scan,omitempty" policy:"Node Scan"`
	// Types that are valid to be assigned to SetComponents:
	//	*Node_Components
	SetComponents isNode_SetComponents `protobuf_oneof:"set_components"`
	// Types that are valid to be assigned to SetCves:
	//	*Node_Cves
	SetCves isNode_SetCves `protobuf_oneof:"set_cves"`
	// Types that are valid to be assigned to SetFixable:
	//	*Node_FixableCves
	SetFixable isNode_SetFixable `protobuf_oneof:"set_fixable"`
	Priority   int64             `protobuf:"varint,22,opt,name=priority,proto3" json:"priority,omitempty"`
	RiskScore  float32           `protobuf:"fixed32,23,opt,name=risk_score,json=riskScore,proto3" json:"risk_score,omitempty" search:"Node Risk Score,hidden"`
	// Types that are valid to be assigned to SetTopCvss:
	//	*Node_TopCvss
	SetTopCvss           isNode_SetTopCvss `protobuf_oneof:"set_top_cvss"`
	Notes                []Node_Note       `protobuf:"varint,27,rep,packed,name=notes,proto3,enum=storage.Node_Note" json:"notes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_107f6eed651900c7, []int{0}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

type isNode_SetComponents interface {
	isNode_SetComponents()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isNode_SetComponents
}
type isNode_SetCves interface {
	isNode_SetCves()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isNode_SetCves
}
type isNode_SetFixable interface {
	isNode_SetFixable()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isNode_SetFixable
}
type isNode_SetTopCvss interface {
	isNode_SetTopCvss()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isNode_SetTopCvss
}

type Node_Components struct {
	Components int32 `protobuf:"varint,19,opt,name=components,proto3,oneof" json:"components,omitempty" search:"Component Count,store,hidden"`
}
type Node_Cves struct {
	Cves int32 `protobuf:"varint,20,opt,name=cves,proto3,oneof" json:"cves,omitempty" search:"CVE Count,store,hidden"`
}
type Node_FixableCves struct {
	FixableCves int32 `protobuf:"varint,21,opt,name=fixable_cves,json=fixableCves,proto3,oneof" json:"fixable_cves,omitempty" search:"Fixable CVE Count,store,hidden"`
}
type Node_TopCvss struct {
	TopCvss float32 `protobuf:"fixed32,24,opt,name=top_cvss,json=topCvss,proto3,oneof" json:"top_cvss,omitempty" search:"Node Top CVSS,store"`
}

func (*Node_Components) isNode_SetComponents() {}
func (m *Node_Components) Clone() isNode_SetComponents {
	if m == nil {
		return nil
	}
	cloned := new(Node_Components)
	*cloned = *m

	return cloned
}
func (*Node_Cves) isNode_SetCves() {}
func (m *Node_Cves) Clone() isNode_SetCves {
	if m == nil {
		return nil
	}
	cloned := new(Node_Cves)
	*cloned = *m

	return cloned
}
func (*Node_FixableCves) isNode_SetFixable() {}
func (m *Node_FixableCves) Clone() isNode_SetFixable {
	if m == nil {
		return nil
	}
	cloned := new(Node_FixableCves)
	*cloned = *m

	return cloned
}
func (*Node_TopCvss) isNode_SetTopCvss() {}
func (m *Node_TopCvss) Clone() isNode_SetTopCvss {
	if m == nil {
		return nil
	}
	cloned := new(Node_TopCvss)
	*cloned = *m

	return cloned
}

func (m *Node) GetSetComponents() isNode_SetComponents {
	if m != nil {
		return m.SetComponents
	}
	return nil
}
func (m *Node) GetSetCves() isNode_SetCves {
	if m != nil {
		return m.SetCves
	}
	return nil
}
func (m *Node) GetSetFixable() isNode_SetFixable {
	if m != nil {
		return m.SetFixable
	}
	return nil
}
func (m *Node) GetSetTopCvss() isNode_SetTopCvss {
	if m != nil {
		return m.SetTopCvss
	}
	return nil
}

func (m *Node) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Node) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Node) GetTaints() []*Taint {
	if m != nil {
		return m.Taints
	}
	return nil
}

func (m *Node) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *Node) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *Node) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Node) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Node) GetJoinedAt() *types.Timestamp {
	if m != nil {
		return m.JoinedAt
	}
	return nil
}

func (m *Node) GetInternalIpAddresses() []string {
	if m != nil {
		return m.InternalIpAddresses
	}
	return nil
}

func (m *Node) GetExternalIpAddresses() []string {
	if m != nil {
		return m.ExternalIpAddresses
	}
	return nil
}

// Deprecated: Do not use.
func (m *Node) GetContainerRuntimeVersion() string {
	if m != nil {
		return m.ContainerRuntimeVersion
	}
	return ""
}

func (m *Node) GetContainerRuntime() *ContainerRuntimeInfo {
	if m != nil {
		return m.ContainerRuntime
	}
	return nil
}

func (m *Node) GetKernelVersion() string {
	if m != nil {
		return m.KernelVersion
	}
	return ""
}

func (m *Node) GetOperatingSystem() string {
	if m != nil {
		return m.OperatingSystem
	}
	return ""
}

func (m *Node) GetOsImage() string {
	if m != nil {
		return m.OsImage
	}
	return ""
}

func (m *Node) GetKubeletVersion() string {
	if m != nil {
		return m.KubeletVersion
	}
	return ""
}

func (m *Node) GetKubeProxyVersion() string {
	if m != nil {
		return m.KubeProxyVersion
	}
	return ""
}

func (m *Node) GetLastUpdated() *types.Timestamp {
	if m != nil {
		return m.LastUpdated
	}
	return nil
}

func (m *Node) GetK8SUpdated() *types.Timestamp {
	if m != nil {
		return m.K8SUpdated
	}
	return nil
}

func (m *Node) GetScan() *NodeScan {
	if m != nil {
		return m.Scan
	}
	return nil
}

func (m *Node) GetComponents() int32 {
	if x, ok := m.GetSetComponents().(*Node_Components); ok {
		return x.Components
	}
	return 0
}

func (m *Node) GetCves() int32 {
	if x, ok := m.GetSetCves().(*Node_Cves); ok {
		return x.Cves
	}
	return 0
}

func (m *Node) GetFixableCves() int32 {
	if x, ok := m.GetSetFixable().(*Node_FixableCves); ok {
		return x.FixableCves
	}
	return 0
}

func (m *Node) GetPriority() int64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Node) GetRiskScore() float32 {
	if m != nil {
		return m.RiskScore
	}
	return 0
}

func (m *Node) GetTopCvss() float32 {
	if x, ok := m.GetSetTopCvss().(*Node_TopCvss); ok {
		return x.TopCvss
	}
	return 0
}

func (m *Node) GetNotes() []Node_Note {
	if m != nil {
		return m.Notes
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Node) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Node_Components)(nil),
		(*Node_Cves)(nil),
		(*Node_FixableCves)(nil),
		(*Node_TopCvss)(nil),
	}
}

func (m *Node) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Node) Clone() *Node {
	if m == nil {
		return nil
	}
	cloned := new(Node)
	*cloned = *m

	if m.Taints != nil {
		cloned.Taints = make([]*Taint, len(m.Taints))
		for idx, v := range m.Taints {
			cloned.Taints[idx] = v.Clone()
		}
	}
	if m.Labels != nil {
		cloned.Labels = make(map[string]string, len(m.Labels))
		for k, v := range m.Labels {
			cloned.Labels[k] = v
		}
	}
	if m.Annotations != nil {
		cloned.Annotations = make(map[string]string, len(m.Annotations))
		for k, v := range m.Annotations {
			cloned.Annotations[k] = v
		}
	}
	cloned.JoinedAt = m.JoinedAt.Clone()
	if m.InternalIpAddresses != nil {
		cloned.InternalIpAddresses = make([]string, len(m.InternalIpAddresses))
		copy(cloned.InternalIpAddresses, m.InternalIpAddresses)
	}
	if m.ExternalIpAddresses != nil {
		cloned.ExternalIpAddresses = make([]string, len(m.ExternalIpAddresses))
		copy(cloned.ExternalIpAddresses, m.ExternalIpAddresses)
	}
	cloned.ContainerRuntime = m.ContainerRuntime.Clone()
	cloned.LastUpdated = m.LastUpdated.Clone()
	cloned.K8SUpdated = m.K8SUpdated.Clone()
	cloned.Scan = m.Scan.Clone()
	if m.SetComponents != nil {
		cloned.SetComponents = m.SetComponents.Clone()
	}
	if m.SetCves != nil {
		cloned.SetCves = m.SetCves.Clone()
	}
	if m.SetFixable != nil {
		cloned.SetFixable = m.SetFixable.Clone()
	}
	if m.SetTopCvss != nil {
		cloned.SetTopCvss = m.SetTopCvss.Clone()
	}
	if m.Notes != nil {
		cloned.Notes = make([]Node_Note, len(m.Notes))
		copy(cloned.Notes, m.Notes)
	}
	return cloned
}

// Next tag: 5
type NodeScan struct {
	ScanTime             *types.Timestamp             `protobuf:"bytes,1,opt,name=scan_time,json=scanTime,proto3" json:"scan_time,omitempty" search:"Node Scan Time,store"`
	OperatingSystem      string                       `protobuf:"bytes,3,opt,name=operating_system,json=operatingSystem,proto3" json:"operating_system,omitempty"`
	Components           []*EmbeddedNodeScanComponent `protobuf:"bytes,2,rep,name=components,proto3" json:"components,omitempty"`
	Notes                []NodeScan_Note              `protobuf:"varint,4,rep,packed,name=notes,proto3,enum=storage.NodeScan_Note" json:"notes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *NodeScan) Reset()         { *m = NodeScan{} }
func (m *NodeScan) String() string { return proto.CompactTextString(m) }
func (*NodeScan) ProtoMessage()    {}
func (*NodeScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_107f6eed651900c7, []int{1}
}
func (m *NodeScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeScan.Merge(m, src)
}
func (m *NodeScan) XXX_Size() int {
	return m.Size()
}
func (m *NodeScan) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeScan.DiscardUnknown(m)
}

var xxx_messageInfo_NodeScan proto.InternalMessageInfo

func (m *NodeScan) GetScanTime() *types.Timestamp {
	if m != nil {
		return m.ScanTime
	}
	return nil
}

func (m *NodeScan) GetOperatingSystem() string {
	if m != nil {
		return m.OperatingSystem
	}
	return ""
}

func (m *NodeScan) GetComponents() []*EmbeddedNodeScanComponent {
	if m != nil {
		return m.Components
	}
	return nil
}

func (m *NodeScan) GetNotes() []NodeScan_Note {
	if m != nil {
		return m.Notes
	}
	return nil
}

func (m *NodeScan) MessageClone() proto.Message {
	return m.Clone()
}
func (m *NodeScan) Clone() *NodeScan {
	if m == nil {
		return nil
	}
	cloned := new(NodeScan)
	*cloned = *m

	cloned.ScanTime = m.ScanTime.Clone()
	if m.Components != nil {
		cloned.Components = make([]*EmbeddedNodeScanComponent, len(m.Components))
		for idx, v := range m.Components {
			cloned.Components[idx] = v.Clone()
		}
	}
	if m.Notes != nil {
		cloned.Notes = make([]NodeScan_Note, len(m.Notes))
		copy(cloned.Notes, m.Notes)
	}
	return cloned
}

type EmbeddedNodeScanComponent struct {
	Name     string                   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" search:"Component,store"`
	Version  string                   `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty" search:"Component Version,store"`
	Vulns    []*EmbeddedVulnerability `protobuf:"bytes,3,rep,name=vulns,proto3" json:"vulns,omitempty"`
	Priority int64                    `protobuf:"varint,4,opt,name=priority,proto3" json:"priority,omitempty"`
	// Types that are valid to be assigned to SetTopCvss:
	//	*EmbeddedNodeScanComponent_TopCvss
	SetTopCvss           isEmbeddedNodeScanComponent_SetTopCvss `protobuf_oneof:"set_top_cvss"`
	RiskScore            float32                                `protobuf:"fixed32,6,opt,name=risk_score,json=riskScore,proto3" json:"risk_score,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *EmbeddedNodeScanComponent) Reset()         { *m = EmbeddedNodeScanComponent{} }
func (m *EmbeddedNodeScanComponent) String() string { return proto.CompactTextString(m) }
func (*EmbeddedNodeScanComponent) ProtoMessage()    {}
func (*EmbeddedNodeScanComponent) Descriptor() ([]byte, []int) {
	return fileDescriptor_107f6eed651900c7, []int{2}
}
func (m *EmbeddedNodeScanComponent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmbeddedNodeScanComponent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmbeddedNodeScanComponent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmbeddedNodeScanComponent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmbeddedNodeScanComponent.Merge(m, src)
}
func (m *EmbeddedNodeScanComponent) XXX_Size() int {
	return m.Size()
}
func (m *EmbeddedNodeScanComponent) XXX_DiscardUnknown() {
	xxx_messageInfo_EmbeddedNodeScanComponent.DiscardUnknown(m)
}

var xxx_messageInfo_EmbeddedNodeScanComponent proto.InternalMessageInfo

type isEmbeddedNodeScanComponent_SetTopCvss interface {
	isEmbeddedNodeScanComponent_SetTopCvss()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isEmbeddedNodeScanComponent_SetTopCvss
}

type EmbeddedNodeScanComponent_TopCvss struct {
	TopCvss float32 `protobuf:"fixed32,5,opt,name=top_cvss,json=topCvss,proto3,oneof" json:"top_cvss,omitempty"`
}

func (*EmbeddedNodeScanComponent_TopCvss) isEmbeddedNodeScanComponent_SetTopCvss() {}
func (m *EmbeddedNodeScanComponent_TopCvss) Clone() isEmbeddedNodeScanComponent_SetTopCvss {
	if m == nil {
		return nil
	}
	cloned := new(EmbeddedNodeScanComponent_TopCvss)
	*cloned = *m

	return cloned
}

func (m *EmbeddedNodeScanComponent) GetSetTopCvss() isEmbeddedNodeScanComponent_SetTopCvss {
	if m != nil {
		return m.SetTopCvss
	}
	return nil
}

func (m *EmbeddedNodeScanComponent) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EmbeddedNodeScanComponent) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *EmbeddedNodeScanComponent) GetVulns() []*EmbeddedVulnerability {
	if m != nil {
		return m.Vulns
	}
	return nil
}

func (m *EmbeddedNodeScanComponent) GetPriority() int64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *EmbeddedNodeScanComponent) GetTopCvss() float32 {
	if x, ok := m.GetSetTopCvss().(*EmbeddedNodeScanComponent_TopCvss); ok {
		return x.TopCvss
	}
	return 0
}

func (m *EmbeddedNodeScanComponent) GetRiskScore() float32 {
	if m != nil {
		return m.RiskScore
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EmbeddedNodeScanComponent) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EmbeddedNodeScanComponent_TopCvss)(nil),
	}
}

func (m *EmbeddedNodeScanComponent) MessageClone() proto.Message {
	return m.Clone()
}
func (m *EmbeddedNodeScanComponent) Clone() *EmbeddedNodeScanComponent {
	if m == nil {
		return nil
	}
	cloned := new(EmbeddedNodeScanComponent)
	*cloned = *m

	if m.Vulns != nil {
		cloned.Vulns = make([]*EmbeddedVulnerability, len(m.Vulns))
		for idx, v := range m.Vulns {
			cloned.Vulns[idx] = v.Clone()
		}
	}
	if m.SetTopCvss != nil {
		cloned.SetTopCvss = m.SetTopCvss.Clone()
	}
	return cloned
}

type NodeComponentEdge struct {
	// base 64 encoded Node:Component ids.
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeComponentEdge) Reset()         { *m = NodeComponentEdge{} }
func (m *NodeComponentEdge) String() string { return proto.CompactTextString(m) }
func (*NodeComponentEdge) ProtoMessage()    {}
func (*NodeComponentEdge) Descriptor() ([]byte, []int) {
	return fileDescriptor_107f6eed651900c7, []int{3}
}
func (m *NodeComponentEdge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeComponentEdge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeComponentEdge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeComponentEdge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeComponentEdge.Merge(m, src)
}
func (m *NodeComponentEdge) XXX_Size() int {
	return m.Size()
}
func (m *NodeComponentEdge) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeComponentEdge.DiscardUnknown(m)
}

var xxx_messageInfo_NodeComponentEdge proto.InternalMessageInfo

func (m *NodeComponentEdge) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeComponentEdge) MessageClone() proto.Message {
	return m.Clone()
}
func (m *NodeComponentEdge) Clone() *NodeComponentEdge {
	if m == nil {
		return nil
	}
	cloned := new(NodeComponentEdge)
	*cloned = *m

	return cloned
}

type NodeCVEEdge struct {
	// base 64 encoded Node:CVE ids.
	Id                   string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	FirstNodeOccurrence  *types.Timestamp `protobuf:"bytes,2,opt,name=first_node_occurrence,json=firstNodeOccurrence,proto3" json:"first_node_occurrence,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *NodeCVEEdge) Reset()         { *m = NodeCVEEdge{} }
func (m *NodeCVEEdge) String() string { return proto.CompactTextString(m) }
func (*NodeCVEEdge) ProtoMessage()    {}
func (*NodeCVEEdge) Descriptor() ([]byte, []int) {
	return fileDescriptor_107f6eed651900c7, []int{4}
}
func (m *NodeCVEEdge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeCVEEdge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeCVEEdge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeCVEEdge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeCVEEdge.Merge(m, src)
}
func (m *NodeCVEEdge) XXX_Size() int {
	return m.Size()
}
func (m *NodeCVEEdge) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeCVEEdge.DiscardUnknown(m)
}

var xxx_messageInfo_NodeCVEEdge proto.InternalMessageInfo

func (m *NodeCVEEdge) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeCVEEdge) GetFirstNodeOccurrence() *types.Timestamp {
	if m != nil {
		return m.FirstNodeOccurrence
	}
	return nil
}

func (m *NodeCVEEdge) MessageClone() proto.Message {
	return m.Clone()
}
func (m *NodeCVEEdge) Clone() *NodeCVEEdge {
	if m == nil {
		return nil
	}
	cloned := new(NodeCVEEdge)
	*cloned = *m

	cloned.FirstNodeOccurrence = m.FirstNodeOccurrence.Clone()
	return cloned
}

func init() {
	proto.RegisterEnum("storage.Node_Note", Node_Note_name, Node_Note_value)
	proto.RegisterEnum("storage.NodeScan_Note", NodeScan_Note_name, NodeScan_Note_value)
	proto.RegisterType((*Node)(nil), "storage.Node")
	proto.RegisterMapType((map[string]string)(nil), "storage.Node.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "storage.Node.LabelsEntry")
	proto.RegisterType((*NodeScan)(nil), "storage.NodeScan")
	proto.RegisterType((*EmbeddedNodeScanComponent)(nil), "storage.EmbeddedNodeScanComponent")
	proto.RegisterType((*NodeComponentEdge)(nil), "storage.NodeComponentEdge")
	proto.RegisterType((*NodeCVEEdge)(nil), "storage.NodeCVEEdge")
}

func init() { proto.RegisterFile("storage/node.proto", fileDescriptor_107f6eed651900c7) }

var fileDescriptor_107f6eed651900c7 = []byte{
	// 1302 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xdd, 0x72, 0xda, 0x46,
	0x14, 0xb6, 0x00, 0xdb, 0x70, 0x70, 0x30, 0x5e, 0xc7, 0x8e, 0x4c, 0x62, 0x4b, 0x25, 0x4d, 0x43,
	0x1a, 0x0f, 0xee, 0xb8, 0xb9, 0x48, 0x3c, 0x8d, 0x67, 0x0c, 0xa1, 0x0d, 0x49, 0x4a, 0x3c, 0x02,
	0x7b, 0xa6, 0xb9, 0xd1, 0x08, 0x69, 0x8d, 0x55, 0x40, 0xab, 0xd1, 0x2e, 0x8c, 0x79, 0x93, 0xbe,
	0x43, 0x1f, 0xa2, 0xb7, 0xbd, 0x6b, 0x9f, 0x80, 0xe9, 0xa4, 0x6f, 0xc0, 0x13, 0x74, 0x76, 0xa5,
	0x95, 0x91, 0x71, 0x9a, 0x69, 0xef, 0xc4, 0x39, 0xdf, 0xf7, 0x71, 0x74, 0xfe, 0x74, 0x00, 0x51,
	0x46, 0x02, 0xab, 0x87, 0x0f, 0x3c, 0xe2, 0xe0, 0xaa, 0x1f, 0x10, 0x46, 0xd0, 0x6a, 0x64, 0x2b,
	0x69, 0x3d, 0x42, 0x7a, 0x03, 0x7c, 0x20, 0xcc, 0xdd, 0xd1, 0xc5, 0x01, 0x73, 0x87, 0x98, 0x32,
	0x6b, 0xe8, 0x87, 0xc8, 0x92, 0x26, 0xd9, 0x36, 0xf1, 0x98, 0xe5, 0x7a, 0x38, 0x30, 0x83, 0x91,
	0xc7, 0x51, 0x11, 0xe0, 0xae, 0x04, 0x70, 0x2f, 0xa3, 0x91, 0xf5, 0xbe, 0xb4, 0x8e, 0x47, 0x03,
	0x0f, 0x07, 0x56, 0xd7, 0x1d, 0xb8, 0x6c, 0x22, 0x29, 0x3d, 0xd2, 0x23, 0xe2, 0xf1, 0x80, 0x3f,
	0x85, 0xd6, 0xf2, 0x1f, 0x05, 0xc8, 0xb4, 0x88, 0x83, 0xd1, 0xd7, 0x90, 0x72, 0x1d, 0x55, 0xd1,
	0x95, 0x4a, 0xae, 0x56, 0x9a, 0x4d, 0xb5, 0x6d, 0x8a, 0xad, 0xc0, 0xbe, 0x3c, 0x2a, 0x73, 0xaf,
	0xde, 0x7c, 0xb5, 0xcf, 0xb5, 0x71, 0xd9, 0x48, 0xb9, 0x0e, 0x7a, 0x0a, 0x19, 0xcf, 0x1a, 0x62,
	0x35, 0x25, 0xd0, 0xf7, 0x66, 0x53, 0x6d, 0x73, 0x1e, 0x2d, 0xa1, 0x02, 0x84, 0xbe, 0x82, 0x95,
	0x30, 0x48, 0x35, 0xad, 0xa7, 0x2b, 0xf9, 0xc3, 0x42, 0x35, 0x8a, 0xb2, 0xda, 0xe1, 0x66, 0x23,
	0xf2, 0xa2, 0xef, 0x00, 0xec, 0xc1, 0x88, 0x32, 0x1c, 0x98, 0xae, 0xa3, 0x66, 0x84, 0xf4, 0xee,
	0x6c, 0xaa, 0xed, 0x48, 0xe9, 0x7a, 0xe8, 0x9d, 0x8b, 0x25, 0x17, 0x11, 0x9a, 0x0e, 0x7a, 0x09,
	0x6b, 0x92, 0x2d, 0x42, 0x5b, 0x5e, 0x7c, 0x91, 0x88, 0x2f, 0xc9, 0xf9, 0x08, 0xdf, 0xe2, 0x41,
	0x36, 0x60, 0x65, 0x60, 0x75, 0xf1, 0x80, 0xaa, 0x2b, 0x22, 0xc8, 0x9d, 0x38, 0x48, 0xfe, 0x42,
	0xd5, 0x77, 0xc2, 0xd7, 0xf0, 0x58, 0x30, 0xa9, 0xa1, 0xd9, 0x54, 0x2b, 0x48, 0x4d, 0xe1, 0x28,
	0x1b, 0x11, 0x19, 0xfd, 0x04, 0x79, 0xcb, 0xf3, 0x08, 0xb3, 0x98, 0x4b, 0x3c, 0xaa, 0xae, 0x0a,
	0xad, 0xbd, 0xa4, 0xd6, 0xc9, 0x35, 0x20, 0x14, 0x4c, 0xe4, 0xef, 0xda, 0x5b, 0x36, 0xe6, 0xb5,
	0xd0, 0x07, 0xc8, 0xfd, 0x4c, 0x5c, 0x0f, 0x3b, 0xa6, 0xc5, 0xd4, 0x3b, 0xba, 0x52, 0xc9, 0x1f,
	0x96, 0xaa, 0x61, 0x1f, 0x55, 0x65, 0x1f, 0x55, 0x3b, 0xb2, 0x8f, 0x6a, 0x5f, 0xcc, 0xa6, 0xda,
	0x6e, 0xa2, 0x84, 0x6f, 0x88, 0xeb, 0xe9, 0x1c, 0x20, 0x13, 0x90, 0x0d, 0xf5, 0x4e, 0x18, 0x3a,
	0x84, 0x2d, 0xd7, 0x63, 0x38, 0xf0, 0xac, 0x81, 0xe9, 0xfa, 0xa6, 0xe5, 0x38, 0x01, 0xa6, 0x14,
	0x53, 0x35, 0xab, 0xa7, 0x2b, 0x39, 0x63, 0x53, 0x3a, 0x9b, 0xfe, 0x89, 0x74, 0x71, 0x0e, 0xbe,
	0xba, 0x8d, 0x93, 0x0b, 0x39, 0xd2, 0x39, 0xcf, 0x39, 0x86, 0x9d, 0x85, 0x86, 0x36, 0xc7, 0x38,
	0xa0, 0x2e, 0xf1, 0x54, 0x10, 0x15, 0x4b, 0xa9, 0x8a, 0x71, 0x2f, 0x06, 0x19, 0x21, 0xe6, 0x3c,
	0x84, 0xa0, 0x37, 0xb0, 0xb1, 0xc0, 0x57, 0x0b, 0x22, 0x17, 0xbb, 0x71, 0x92, 0xeb, 0x37, 0xc8,
	0x4d, 0xef, 0x82, 0x18, 0xc5, 0x9b, 0x92, 0xe8, 0x11, 0x14, 0xfa, 0x38, 0xf0, 0xf0, 0x20, 0x0e,
	0x20, 0xcf, 0x03, 0x30, 0xee, 0x84, 0x56, 0xf9, 0x97, 0x4f, 0xa0, 0x48, 0x7c, 0x1c, 0x58, 0xcc,
	0xf5, 0x7a, 0x26, 0x9d, 0x50, 0x86, 0x87, 0xea, 0x86, 0x00, 0xae, 0xc7, 0xf6, 0xb6, 0x30, 0xa3,
	0x63, 0xc8, 0x12, 0x6a, 0xba, 0x43, 0xab, 0x87, 0xd5, 0x35, 0xf1, 0x32, 0x0f, 0x67, 0x53, 0x4d,
	0x93, 0x45, 0x78, 0x2f, 0xe1, 0x7a, 0x88, 0x97, 0x65, 0x58, 0x25, 0xb4, 0xc9, 0x39, 0xe8, 0x31,
	0xac, 0xf7, 0x47, 0x5d, 0x3c, 0xc0, 0x2c, 0x0e, 0x69, 0x5d, 0xfc, 0x53, 0x21, 0x32, 0xcb, 0x98,
	0xf6, 0x01, 0x71, 0x8b, 0xe9, 0x07, 0xe4, 0x6a, 0x12, 0x63, 0x8b, 0x02, 0x5b, 0xe4, 0x9e, 0x53,
	0xee, 0x90, 0x68, 0x13, 0xd6, 0x06, 0x16, 0x65, 0xe6, 0xc8, 0x77, 0x2c, 0x86, 0x1d, 0x75, 0xe7,
	0xb3, 0xbd, 0xa3, 0xcf, 0xa6, 0xda, 0x83, 0xeb, 0x0e, 0xa7, 0x4c, 0x3f, 0x0b, 0xb9, 0xfb, 0x97,
	0xae, 0xe3, 0x60, 0xde, 0x99, 0x5c, 0x31, 0x32, 0xa2, 0x0e, 0xe4, 0xfb, 0xcf, 0x69, 0xac, 0x5f,
	0xfa, 0xac, 0x7e, 0xd4, 0xf0, 0x1e, 0x25, 0xc1, 0xa5, 0x45, 0x2f, 0x8f, 0xca, 0x6e, 0xcf, 0x13,
	0xa9, 0x80, 0xfe, 0x73, 0x2a, 0x55, 0x5f, 0x42, 0x86, 0xda, 0x96, 0xa7, 0x22, 0x21, 0xb7, 0x91,
	0x98, 0xa1, 0xb6, 0x6d, 0x79, 0xb5, 0xed, 0xd9, 0x54, 0x43, 0x3e, 0x19, 0xb8, 0xf6, 0x24, 0xea,
	0x70, 0x6e, 0x2e, 0x1b, 0x82, 0x86, 0xde, 0x02, 0xd8, 0x64, 0xe8, 0x13, 0x0f, 0xf3, 0xcd, 0xb3,
	0xa9, 0x2b, 0x95, 0xe5, 0xda, 0x93, 0xd9, 0x54, 0x7b, 0x14, 0x6f, 0x03, 0xe9, 0xd5, 0xeb, 0x64,
	0xe4, 0xb1, 0xb0, 0x1a, 0xf2, 0x05, 0x5f, 0x2f, 0x19, 0x73, 0x74, 0xf4, 0x02, 0x32, 0xf6, 0x18,
	0x53, 0xf5, 0xae, 0x90, 0x49, 0x54, 0xb5, 0x7e, 0xde, 0xb8, 0x55, 0x40, 0x31, 0x04, 0x05, 0x9d,
	0xc2, 0xda, 0x85, 0x7b, 0x65, 0x75, 0x07, 0xd8, 0x14, 0x12, 0x5b, 0x42, 0xe2, 0xe9, 0x6c, 0xaa,
	0x3d, 0x96, 0x12, 0xdf, 0x87, 0x7e, 0xfd, 0x53, 0x52, 0x29, 0x23, 0x1f, 0x49, 0xd4, 0xb9, 0x62,
	0x09, 0xb2, 0x7e, 0xe0, 0x92, 0xc0, 0x65, 0x13, 0x75, 0x5b, 0x57, 0x2a, 0x69, 0x23, 0xfe, 0x8d,
	0x6a, 0x00, 0x81, 0x4b, 0xfb, 0x26, 0xb5, 0x49, 0x80, 0xd5, 0x7b, 0xba, 0x52, 0x49, 0x25, 0xc3,
	0x15, 0x79, 0x32, 0x5c, 0xda, 0xd7, 0xdb, 0xf6, 0xdc, 0x7f, 0x18, 0x39, 0x4e, 0x13, 0x26, 0xf4,
	0x12, 0xb2, 0x8c, 0xf8, 0xa6, 0x3d, 0xa6, 0x54, 0x55, 0x85, 0x42, 0xa2, 0x1f, 0x84, 0x42, 0x87,
	0xf8, 0x7a, 0xfd, 0xbc, 0xdd, 0x8e, 0x7a, 0xf8, 0x75, 0xda, 0x58, 0x65, 0xc4, 0xaf, 0x8f, 0x29,
	0x45, 0x15, 0x58, 0xf6, 0x08, 0xc3, 0x54, 0xbd, 0xaf, 0xa7, 0x2b, 0x85, 0x43, 0x94, 0x5c, 0x7e,
	0x2d, 0xc2, 0xb0, 0x11, 0x02, 0x4a, 0x2f, 0x20, 0x3f, 0xb7, 0x57, 0x51, 0x11, 0xd2, 0x7d, 0x3c,
	0x09, 0xbf, 0x40, 0x06, 0x7f, 0x44, 0x77, 0x61, 0x79, 0x6c, 0x0d, 0x46, 0xd1, 0x77, 0xc6, 0x08,
	0x7f, 0x1c, 0xa5, 0x9e, 0x2b, 0xa5, 0x63, 0x28, 0xde, 0x5c, 0xa3, 0xff, 0x85, 0x5f, 0xde, 0xe5,
	0x1f, 0x3d, 0x86, 0xd1, 0x16, 0x6c, 0xfc, 0xd8, 0x6c, 0xb7, 0x9b, 0xad, 0x1f, 0xcc, 0x76, 0xfd,
	0xa4, 0x65, 0xbe, 0x3a, 0xe9, 0x9c, 0x14, 0x97, 0x6a, 0x45, 0x28, 0x50, 0xcc, 0xcc, 0xeb, 0x0e,
	0xa8, 0x01, 0x64, 0x85, 0x65, 0x8c, 0x69, 0xed, 0x0e, 0xe4, 0xf9, 0x73, 0x54, 0x93, 0x5a, 0x01,
	0xd6, 0xf8, 0x4f, 0x99, 0xb3, 0xf2, 0x6f, 0x29, 0xc8, 0xca, 0x26, 0xe5, 0x5b, 0x9b, 0xb7, 0xa3,
	0x29, 0x36, 0x95, 0xf2, 0x3f, 0xb6, 0x36, 0x57, 0x49, 0x6e, 0x6d, 0xae, 0xc7, 0x0d, 0xb7, 0xae,
	0xa6, 0xf4, 0xed, 0xab, 0xa9, 0x96, 0x98, 0x86, 0x94, 0xf8, 0x2c, 0x95, 0xe3, 0xca, 0x34, 0x86,
	0x5d, 0xec, 0x38, 0xd8, 0x91, 0x51, 0xc7, 0xa3, 0x91, 0x18, 0x82, 0x7d, 0x59, 0xd8, 0x8c, 0x28,
	0xec, 0xf6, 0xc2, 0x44, 0xce, 0x17, 0xb7, 0x7c, 0x14, 0x65, 0x38, 0x07, 0xcb, 0x67, 0xad, 0x76,
	0xa3, 0x53, 0x5c, 0x42, 0xeb, 0x90, 0x3f, 0x6b, 0xb5, 0xcf, 0x4e, 0x4f, 0xdf, 0x1b, 0x9d, 0xc6,
	0xab, 0xa2, 0x82, 0xb6, 0x01, 0xbd, 0x6d, 0x18, 0xad, 0xc6, 0x3b, 0x73, 0xde, 0x9e, 0x2a, 0xff,
	0x9a, 0x82, 0x9d, 0x4f, 0xc6, 0x84, 0xbe, 0x89, 0x8e, 0x8f, 0xf0, 0x54, 0x79, 0x30, 0x9b, 0x6a,
	0xea, 0xc2, 0x4c, 0x27, 0x2f, 0x90, 0x63, 0x58, 0x95, 0x4b, 0x32, 0xbc, 0x58, 0xbe, 0x9c, 0x4d,
	0x35, 0x7d, 0x71, 0x11, 0x44, 0x1b, 0x33, 0x5e, 0xcc, 0x11, 0x09, 0x3d, 0x83, 0x65, 0x7e, 0x50,
	0xc9, 0x03, 0x66, 0x6f, 0x21, 0x71, 0xe7, 0xf3, 0xe7, 0x96, 0x11, 0x82, 0x13, 0x73, 0x9a, 0xb9,
	0x31, 0xa7, 0xf7, 0xe7, 0x66, 0x8c, 0x5f, 0x2a, 0xa9, 0xd7, 0x4b, 0xd7, 0x13, 0xb4, 0x9b, 0x18,
	0xe2, 0x15, 0xee, 0x9e, 0x9b, 0xcf, 0x85, 0x7e, 0x7b, 0x08, 0x1b, 0x3c, 0x49, 0xf1, 0x6b, 0x34,
	0x9c, 0x1e, 0x46, 0x85, 0xeb, 0x6b, 0x8e, 0x5f, 0x6c, 0xe5, 0x21, 0xe4, 0x05, 0xe8, 0xbc, 0x71,
	0x9b, 0x1b, 0xb5, 0x60, 0xeb, 0xc2, 0x0d, 0x28, 0x33, 0xf9, 0xb5, 0x6a, 0x12, 0xdb, 0x1e, 0x05,
	0x01, 0xf6, 0xec, 0x70, 0x72, 0xfe, 0xb5, 0x65, 0x8d, 0x4d, 0x41, 0xe4, 0xe2, 0xef, 0x63, 0x5a,
	0xed, 0xd9, 0xef, 0x1f, 0xf7, 0x94, 0x3f, 0x3f, 0xee, 0x29, 0x7f, 0x7d, 0xdc, 0x53, 0x7e, 0xf9,
	0x7b, 0x6f, 0x09, 0x76, 0x5c, 0x52, 0xa5, 0xcc, 0xb2, 0xfb, 0x01, 0xb9, 0x0a, 0x65, 0x64, 0x16,
	0x3f, 0xc8, 0xb3, 0xb8, 0xbb, 0x22, 0xec, 0xdf, 0xfe, 0x13, 0x00, 0x00, 0xff, 0xff, 0x9c, 0x6a,
	0x83, 0x48, 0x3c, 0x0b, 0x00, 0x00,
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Notes) > 0 {
		dAtA2 := make([]byte, len(m.Notes)*10)
		var j1 int
		for _, num := range m.Notes {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintNode(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.K8SUpdated != nil {
		{
			size, err := m.K8SUpdated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.LastUpdated != nil {
		{
			size, err := m.LastUpdated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.SetTopCvss != nil {
		{
			size := m.SetTopCvss.Size()
			i -= size
			if _, err := m.SetTopCvss.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.RiskScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RiskScore))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xbd
	}
	if m.Priority != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.SetFixable != nil {
		{
			size := m.SetFixable.Size()
			i -= size
			if _, err := m.SetFixable.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SetCves != nil {
		{
			size := m.SetCves.Size()
			i -= size
			if _, err := m.SetCves.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SetComponents != nil {
		{
			size := m.SetComponents.Size()
			i -= size
			if _, err := m.SetComponents.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Scan != nil {
		{
			size, err := m.Scan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.OperatingSystem) > 0 {
		i -= len(m.OperatingSystem)
		copy(dAtA[i:], m.OperatingSystem)
		i = encodeVarintNode(dAtA, i, uint64(len(m.OperatingSystem)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.KubeProxyVersion) > 0 {
		i -= len(m.KubeProxyVersion)
		copy(dAtA[i:], m.KubeProxyVersion)
		i = encodeVarintNode(dAtA, i, uint64(len(m.KubeProxyVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.KubeletVersion) > 0 {
		i -= len(m.KubeletVersion)
		copy(dAtA[i:], m.KubeletVersion)
		i = encodeVarintNode(dAtA, i, uint64(len(m.KubeletVersion)))
		i--
		dAtA[i] = 0x7a
	}
	if m.ContainerRuntime != nil {
		{
			size, err := m.ContainerRuntime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.JoinedAt != nil {
		{
			size, err := m.JoinedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.OsImage) > 0 {
		i -= len(m.OsImage)
		copy(dAtA[i:], m.OsImage)
		i = encodeVarintNode(dAtA, i, uint64(len(m.OsImage)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.KernelVersion) > 0 {
		i -= len(m.KernelVersion)
		copy(dAtA[i:], m.KernelVersion)
		i = encodeVarintNode(dAtA, i, uint64(len(m.KernelVersion)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ContainerRuntimeVersion) > 0 {
		i -= len(m.ContainerRuntimeVersion)
		copy(dAtA[i:], m.ContainerRuntimeVersion)
		i = encodeVarintNode(dAtA, i, uint64(len(m.ContainerRuntimeVersion)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ExternalIpAddresses) > 0 {
		for iNdEx := len(m.ExternalIpAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExternalIpAddresses[iNdEx])
			copy(dAtA[i:], m.ExternalIpAddresses[iNdEx])
			i = encodeVarintNode(dAtA, i, uint64(len(m.ExternalIpAddresses[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.InternalIpAddresses) > 0 {
		for iNdEx := len(m.InternalIpAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InternalIpAddresses[iNdEx])
			copy(dAtA[i:], m.InternalIpAddresses[iNdEx])
			i = encodeVarintNode(dAtA, i, uint64(len(m.InternalIpAddresses[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintNode(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintNode(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintNode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintNode(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintNode(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintNode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintNode(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintNode(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Taints) > 0 {
		for iNdEx := len(m.Taints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Taints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_Components) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Components) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintNode(dAtA, i, uint64(m.Components))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	return len(dAtA) - i, nil
}
func (m *Node_Cves) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Cves) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintNode(dAtA, i, uint64(m.Cves))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa0
	return len(dAtA) - i, nil
}
func (m *Node_FixableCves) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_FixableCves) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintNode(dAtA, i, uint64(m.FixableCves))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa8
	return len(dAtA) - i, nil
}
func (m *Node_TopCvss) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_TopCvss) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TopCvss))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc5
	return len(dAtA) - i, nil
}
func (m *NodeScan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Notes) > 0 {
		dAtA9 := make([]byte, len(m.Notes)*10)
		var j8 int
		for _, num := range m.Notes {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintNode(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OperatingSystem) > 0 {
		i -= len(m.OperatingSystem)
		copy(dAtA[i:], m.OperatingSystem)
		i = encodeVarintNode(dAtA, i, uint64(len(m.OperatingSystem)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Components) > 0 {
		for iNdEx := len(m.Components) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Components[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ScanTime != nil {
		{
			size, err := m.ScanTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EmbeddedNodeScanComponent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmbeddedNodeScanComponent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmbeddedNodeScanComponent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RiskScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RiskScore))))
		i--
		dAtA[i] = 0x35
	}
	if m.SetTopCvss != nil {
		{
			size := m.SetTopCvss.Size()
			i -= size
			if _, err := m.SetTopCvss.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Priority != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Vulns) > 0 {
		for iNdEx := len(m.Vulns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Vulns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EmbeddedNodeScanComponent_TopCvss) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmbeddedNodeScanComponent_TopCvss) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TopCvss))))
	i--
	dAtA[i] = 0x2d
	return len(dAtA) - i, nil
}
func (m *NodeComponentEdge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeComponentEdge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeComponentEdge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeCVEEdge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCVEEdge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeCVEEdge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FirstNodeOccurrence != nil {
		{
			size, err := m.FirstNodeOccurrence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintNode(dAtA []byte, offset int, v uint64) int {
	offset -= sovNode(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if len(m.Taints) > 0 {
		for _, e := range m.Taints {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovNode(uint64(len(k))) + 1 + len(v) + sovNode(uint64(len(v)))
			n += mapEntrySize + 1 + sovNode(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovNode(uint64(len(k))) + 1 + len(v) + sovNode(uint64(len(v)))
			n += mapEntrySize + 1 + sovNode(uint64(mapEntrySize))
		}
	}
	if len(m.InternalIpAddresses) > 0 {
		for _, s := range m.InternalIpAddresses {
			l = len(s)
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if len(m.ExternalIpAddresses) > 0 {
		for _, s := range m.ExternalIpAddresses {
			l = len(s)
			n += 1 + l + sovNode(uint64(l))
		}
	}
	l = len(m.ContainerRuntimeVersion)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.KernelVersion)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.OsImage)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.JoinedAt != nil {
		l = m.JoinedAt.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.ContainerRuntime != nil {
		l = m.ContainerRuntime.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.KubeletVersion)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.KubeProxyVersion)
	if l > 0 {
		n += 2 + l + sovNode(uint64(l))
	}
	l = len(m.OperatingSystem)
	if l > 0 {
		n += 2 + l + sovNode(uint64(l))
	}
	if m.Scan != nil {
		l = m.Scan.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	if m.SetComponents != nil {
		n += m.SetComponents.Size()
	}
	if m.SetCves != nil {
		n += m.SetCves.Size()
	}
	if m.SetFixable != nil {
		n += m.SetFixable.Size()
	}
	if m.Priority != 0 {
		n += 2 + sovNode(uint64(m.Priority))
	}
	if m.RiskScore != 0 {
		n += 6
	}
	if m.SetTopCvss != nil {
		n += m.SetTopCvss.Size()
	}
	if m.LastUpdated != nil {
		l = m.LastUpdated.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	if m.K8SUpdated != nil {
		l = m.K8SUpdated.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	if len(m.Notes) > 0 {
		l = 0
		for _, e := range m.Notes {
			l += sovNode(uint64(e))
		}
		n += 2 + sovNode(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node_Components) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovNode(uint64(m.Components))
	return n
}
func (m *Node_Cves) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovNode(uint64(m.Cves))
	return n
}
func (m *Node_FixableCves) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovNode(uint64(m.FixableCves))
	return n
}
func (m *Node_TopCvss) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 6
	return n
}
func (m *NodeScan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScanTime != nil {
		l = m.ScanTime.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if len(m.Components) > 0 {
		for _, e := range m.Components {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	l = len(m.OperatingSystem)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if len(m.Notes) > 0 {
		l = 0
		for _, e := range m.Notes {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EmbeddedNodeScanComponent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if len(m.Vulns) > 0 {
		for _, e := range m.Vulns {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if m.Priority != 0 {
		n += 1 + sovNode(uint64(m.Priority))
	}
	if m.SetTopCvss != nil {
		n += m.SetTopCvss.Size()
	}
	if m.RiskScore != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EmbeddedNodeScanComponent_TopCvss) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *NodeComponentEdge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeCVEEdge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.FirstNodeOccurrence != nil {
		l = m.FirstNodeOccurrence.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNode(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNode(x uint64) (n int) {
	return sovNode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Taints = append(m.Taints, &Taint{})
			if err := m.Taints[len(m.Taints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthNode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthNode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthNode
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthNode
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthNode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthNode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthNode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthNode
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthNode
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthNode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalIpAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalIpAddresses = append(m.InternalIpAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIpAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalIpAddresses = append(m.ExternalIpAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRuntimeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerRuntimeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JoinedAt == nil {
				m.JoinedAt = &types.Timestamp{}
			}
			if err := m.JoinedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRuntime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerRuntime == nil {
				m.ContainerRuntime = &ContainerRuntimeInfo{}
			}
			if err := m.ContainerRuntime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeletVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubeletVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeProxyVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubeProxyVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scan == nil {
				m.Scan = &NodeScan{}
			}
			if err := m.Scan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SetComponents = &Node_Components{v}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cves", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SetCves = &Node_Cves{v}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixableCves", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SetFixable = &Node_FixableCves{v}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RiskScore = float32(math.Float32frombits(v))
		case 24:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopCvss", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SetTopCvss = &Node_TopCvss{float32(math.Float32frombits(v))}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdated == nil {
				m.LastUpdated = &types.Timestamp{}
			}
			if err := m.LastUpdated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8SUpdated == nil {
				m.K8SUpdated = &types.Timestamp{}
			}
			if err := m.K8SUpdated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType == 0 {
				var v Node_Note
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Node_Note(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Notes = append(m.Notes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Notes) == 0 {
					m.Notes = make([]Node_Note, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Node_Note
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Node_Note(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Notes = append(m.Notes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScanTime == nil {
				m.ScanTime = &types.Timestamp{}
			}
			if err := m.ScanTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Components = append(m.Components, &EmbeddedNodeScanComponent{})
			if err := m.Components[len(m.Components)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v NodeScan_Note
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= NodeScan_Note(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Notes = append(m.Notes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Notes) == 0 {
					m.Notes = make([]NodeScan_Note, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v NodeScan_Note
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= NodeScan_Note(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Notes = append(m.Notes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmbeddedNodeScanComponent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmbeddedNodeScanComponent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmbeddedNodeScanComponent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vulns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vulns = append(m.Vulns, &EmbeddedVulnerability{})
			if err := m.Vulns[len(m.Vulns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopCvss", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SetTopCvss = &EmbeddedNodeScanComponent_TopCvss{float32(math.Float32frombits(v))}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RiskScore = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeComponentEdge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeComponentEdge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeComponentEdge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCVEEdge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCVEEdge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCVEEdge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstNodeOccurrence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirstNodeOccurrence == nil {
				m.FirstNodeOccurrence = &types.Timestamp{}
			}
			if err := m.FirstNodeOccurrence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNode
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNode
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNode
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNode        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNode          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNode = fmt.Errorf("proto: unexpected end of group")
)
