// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/cluster.proto

package storage

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ClusterType int32

const (
	ClusterType_GENERIC_CLUSTER    ClusterType = 0
	ClusterType_KUBERNETES_CLUSTER ClusterType = 1
	ClusterType_OPENSHIFT_CLUSTER  ClusterType = 2
	ClusterType_OPENSHIFT4_CLUSTER ClusterType = 5
)

var ClusterType_name = map[int32]string{
	0: "GENERIC_CLUSTER",
	1: "KUBERNETES_CLUSTER",
	2: "OPENSHIFT_CLUSTER",
	5: "OPENSHIFT4_CLUSTER",
}

var ClusterType_value = map[string]int32{
	"GENERIC_CLUSTER":    0,
	"KUBERNETES_CLUSTER": 1,
	"OPENSHIFT_CLUSTER":  2,
	"OPENSHIFT4_CLUSTER": 5,
}

func (x ClusterType) String() string {
	return proto.EnumName(ClusterType_name, int32(x))
}

func (ClusterType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{0}
}

type CollectionMethod int32

const (
	CollectionMethod_UNSET_COLLECTION CollectionMethod = 0
	CollectionMethod_NO_COLLECTION    CollectionMethod = 1
	CollectionMethod_KERNEL_MODULE    CollectionMethod = 2 // Deprecated: Do not use.
	CollectionMethod_EBPF             CollectionMethod = 3
	CollectionMethod_CORE_BPF         CollectionMethod = 4
)

var CollectionMethod_name = map[int32]string{
	0: "UNSET_COLLECTION",
	1: "NO_COLLECTION",
	2: "KERNEL_MODULE",
	3: "EBPF",
	4: "CORE_BPF",
}

var CollectionMethod_value = map[string]int32{
	"UNSET_COLLECTION": 0,
	"NO_COLLECTION":    1,
	"KERNEL_MODULE":    2,
	"EBPF":             3,
	"CORE_BPF":         4,
}

func (x CollectionMethod) String() string {
	return proto.EnumName(CollectionMethod_name, int32(x))
}

func (CollectionMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{1}
}

type ManagerType int32

const (
	ManagerType_MANAGER_TYPE_UNKNOWN             ManagerType = 0
	ManagerType_MANAGER_TYPE_MANUAL              ManagerType = 1
	ManagerType_MANAGER_TYPE_HELM_CHART          ManagerType = 2
	ManagerType_MANAGER_TYPE_KUBERNETES_OPERATOR ManagerType = 3
)

var ManagerType_name = map[int32]string{
	0: "MANAGER_TYPE_UNKNOWN",
	1: "MANAGER_TYPE_MANUAL",
	2: "MANAGER_TYPE_HELM_CHART",
	3: "MANAGER_TYPE_KUBERNETES_OPERATOR",
}

var ManagerType_value = map[string]int32{
	"MANAGER_TYPE_UNKNOWN":             0,
	"MANAGER_TYPE_MANUAL":              1,
	"MANAGER_TYPE_HELM_CHART":          2,
	"MANAGER_TYPE_KUBERNETES_OPERATOR": 3,
}

func (x ManagerType) String() string {
	return proto.EnumName(ManagerType_name, int32(x))
}

func (ManagerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{2}
}

type ClusterMetadata_Type int32

const (
	ClusterMetadata_UNSPECIFIED ClusterMetadata_Type = 0
	ClusterMetadata_AKS         ClusterMetadata_Type = 1
	ClusterMetadata_ARO         ClusterMetadata_Type = 2
	ClusterMetadata_EKS         ClusterMetadata_Type = 3
	ClusterMetadata_GKE         ClusterMetadata_Type = 4
	ClusterMetadata_OCP         ClusterMetadata_Type = 5
	ClusterMetadata_OSD         ClusterMetadata_Type = 6
	ClusterMetadata_ROSA        ClusterMetadata_Type = 7
)

var ClusterMetadata_Type_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "AKS",
	2: "ARO",
	3: "EKS",
	4: "GKE",
	5: "OCP",
	6: "OSD",
	7: "ROSA",
}

var ClusterMetadata_Type_value = map[string]int32{
	"UNSPECIFIED": 0,
	"AKS":         1,
	"ARO":         2,
	"EKS":         3,
	"GKE":         4,
	"OCP":         5,
	"OSD":         6,
	"ROSA":        7,
}

func (x ClusterMetadata_Type) String() string {
	return proto.EnumName(ClusterMetadata_Type_name, int32(x))
}

func (ClusterMetadata_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{0, 0}
}

type ClusterUpgradeStatus_Upgradability int32

const (
	ClusterUpgradeStatus_UNSET                   ClusterUpgradeStatus_Upgradability = 0
	ClusterUpgradeStatus_UP_TO_DATE              ClusterUpgradeStatus_Upgradability = 1
	ClusterUpgradeStatus_MANUAL_UPGRADE_REQUIRED ClusterUpgradeStatus_Upgradability = 2
	ClusterUpgradeStatus_AUTO_UPGRADE_POSSIBLE   ClusterUpgradeStatus_Upgradability = 3
	// SENSOR_VERSION_HIGHER occurs when we detect that the sensor
	// is running a newer version than this Central. This is unexpected,
	// but can occur depending on the patches a customer does.
	// In this case, we will NOT automatically "upgrade" the sensor,
	// since that would be a downgrade, even if the autoupgrade setting is
	// on. The user will be allowed to manually trigger the upgrade, but they are
	// strongly discouraged from doing so without upgrading Central first, since this
	// is an unsupported configuration.
	ClusterUpgradeStatus_SENSOR_VERSION_HIGHER ClusterUpgradeStatus_Upgradability = 4
)

var ClusterUpgradeStatus_Upgradability_name = map[int32]string{
	0: "UNSET",
	1: "UP_TO_DATE",
	2: "MANUAL_UPGRADE_REQUIRED",
	3: "AUTO_UPGRADE_POSSIBLE",
	4: "SENSOR_VERSION_HIGHER",
}

var ClusterUpgradeStatus_Upgradability_value = map[string]int32{
	"UNSET":                   0,
	"UP_TO_DATE":              1,
	"MANUAL_UPGRADE_REQUIRED": 2,
	"AUTO_UPGRADE_POSSIBLE":   3,
	"SENSOR_VERSION_HIGHER":   4,
}

func (x ClusterUpgradeStatus_Upgradability) String() string {
	return proto.EnumName(ClusterUpgradeStatus_Upgradability_name, int32(x))
}

func (ClusterUpgradeStatus_Upgradability) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{15, 0}
}

type ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType int32

const (
	// UPGRADE represents a sensor version upgrade.
	ClusterUpgradeStatus_UpgradeProcessStatus_UPGRADE ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType = 0
	// CERT_ROTATION represents an upgrade process that only rotates the TLS certs
	// used by the cluster, without changing anything else.
	ClusterUpgradeStatus_UpgradeProcessStatus_CERT_ROTATION ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType = 1
)

var ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType_name = map[int32]string{
	0: "UPGRADE",
	1: "CERT_ROTATION",
}

var ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType_value = map[string]int32{
	"UPGRADE":       0,
	"CERT_ROTATION": 1,
}

func (x ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType) String() string {
	return proto.EnumName(ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType_name, int32(x))
}

func (ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{15, 0, 0}
}

type UpgradeProgress_UpgradeState int32

const (
	UpgradeProgress_UPGRADE_INITIALIZING UpgradeProgress_UpgradeState = 0
	// In-progress states.
	UpgradeProgress_UPGRADER_LAUNCHING         UpgradeProgress_UpgradeState = 1
	UpgradeProgress_UPGRADER_LAUNCHED          UpgradeProgress_UpgradeState = 2
	UpgradeProgress_PRE_FLIGHT_CHECKS_COMPLETE UpgradeProgress_UpgradeState = 3
	UpgradeProgress_UPGRADE_OPERATIONS_DONE    UpgradeProgress_UpgradeState = 4
	// The success state.
	// PLEASE NUMBER ALL IN-PROGRESS STATES ABOVE THIS
	// AND ALL ERROR STATES BELOW THIS.
	UpgradeProgress_UPGRADE_COMPLETE UpgradeProgress_UpgradeState = 10
	// Error states.
	UpgradeProgress_UPGRADE_INITIALIZATION_ERROR  UpgradeProgress_UpgradeState = 11
	UpgradeProgress_PRE_FLIGHT_CHECKS_FAILED      UpgradeProgress_UpgradeState = 12
	UpgradeProgress_UPGRADE_ERROR_ROLLING_BACK    UpgradeProgress_UpgradeState = 13
	UpgradeProgress_UPGRADE_ERROR_ROLLED_BACK     UpgradeProgress_UpgradeState = 14
	UpgradeProgress_UPGRADE_ERROR_ROLLBACK_FAILED UpgradeProgress_UpgradeState = 15
	UpgradeProgress_UPGRADE_ERROR_UNKNOWN         UpgradeProgress_UpgradeState = 16
	UpgradeProgress_UPGRADE_TIMED_OUT             UpgradeProgress_UpgradeState = 17
)

var UpgradeProgress_UpgradeState_name = map[int32]string{
	0:  "UPGRADE_INITIALIZING",
	1:  "UPGRADER_LAUNCHING",
	2:  "UPGRADER_LAUNCHED",
	3:  "PRE_FLIGHT_CHECKS_COMPLETE",
	4:  "UPGRADE_OPERATIONS_DONE",
	10: "UPGRADE_COMPLETE",
	11: "UPGRADE_INITIALIZATION_ERROR",
	12: "PRE_FLIGHT_CHECKS_FAILED",
	13: "UPGRADE_ERROR_ROLLING_BACK",
	14: "UPGRADE_ERROR_ROLLED_BACK",
	15: "UPGRADE_ERROR_ROLLBACK_FAILED",
	16: "UPGRADE_ERROR_UNKNOWN",
	17: "UPGRADE_TIMED_OUT",
}

var UpgradeProgress_UpgradeState_value = map[string]int32{
	"UPGRADE_INITIALIZING":          0,
	"UPGRADER_LAUNCHING":            1,
	"UPGRADER_LAUNCHED":             2,
	"PRE_FLIGHT_CHECKS_COMPLETE":    3,
	"UPGRADE_OPERATIONS_DONE":       4,
	"UPGRADE_COMPLETE":              10,
	"UPGRADE_INITIALIZATION_ERROR":  11,
	"PRE_FLIGHT_CHECKS_FAILED":      12,
	"UPGRADE_ERROR_ROLLING_BACK":    13,
	"UPGRADE_ERROR_ROLLED_BACK":     14,
	"UPGRADE_ERROR_ROLLBACK_FAILED": 15,
	"UPGRADE_ERROR_UNKNOWN":         16,
	"UPGRADE_TIMED_OUT":             17,
}

func (x UpgradeProgress_UpgradeState) String() string {
	return proto.EnumName(UpgradeProgress_UpgradeState_name, int32(x))
}

func (UpgradeProgress_UpgradeState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{16, 0}
}

type ClusterHealthStatus_HealthStatusLabel int32

const (
	ClusterHealthStatus_UNINITIALIZED ClusterHealthStatus_HealthStatusLabel = 0
	// Only collector can have unavailable status
	ClusterHealthStatus_UNAVAILABLE ClusterHealthStatus_HealthStatusLabel = 1
	ClusterHealthStatus_UNHEALTHY   ClusterHealthStatus_HealthStatusLabel = 2
	ClusterHealthStatus_DEGRADED    ClusterHealthStatus_HealthStatusLabel = 3
	ClusterHealthStatus_HEALTHY     ClusterHealthStatus_HealthStatusLabel = 4
)

var ClusterHealthStatus_HealthStatusLabel_name = map[int32]string{
	0: "UNINITIALIZED",
	1: "UNAVAILABLE",
	2: "UNHEALTHY",
	3: "DEGRADED",
	4: "HEALTHY",
}

var ClusterHealthStatus_HealthStatusLabel_value = map[string]int32{
	"UNINITIALIZED": 0,
	"UNAVAILABLE":   1,
	"UNHEALTHY":     2,
	"DEGRADED":      3,
	"HEALTHY":       4,
}

func (x ClusterHealthStatus_HealthStatusLabel) String() string {
	return proto.EnumName(ClusterHealthStatus_HealthStatusLabel_name, int32(x))
}

func (ClusterHealthStatus_HealthStatusLabel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{18, 0}
}

// ClusterMetadata contains metadata information about the cluster infrastructure.
type ClusterMetadata struct {
	Type ClusterMetadata_Type `protobuf:"varint,1,opt,name=type,proto3,enum=storage.ClusterMetadata_Type" json:"type,omitempty" search:"Cluster Type"`
	// Name represents the name under which the cluster is registered with the
	// cloud provider. In case of self managed OpenShift it is the name chosen
	// by the OpenShift installer.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Id represents a unique ID under which the cluster is registered with the
	// cloud provider. Not all cluster types have an id. For all OpenShift
	// clusters, this is the Red Hat `cluster_id` registered with OCM.
	Id                   string   `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterMetadata) Reset()         { *m = ClusterMetadata{} }
func (m *ClusterMetadata) String() string { return proto.CompactTextString(m) }
func (*ClusterMetadata) ProtoMessage()    {}
func (*ClusterMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{0}
}
func (m *ClusterMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterMetadata.Merge(m, src)
}
func (m *ClusterMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ClusterMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterMetadata proto.InternalMessageInfo

func (m *ClusterMetadata) GetType() ClusterMetadata_Type {
	if m != nil {
		return m.Type
	}
	return ClusterMetadata_UNSPECIFIED
}

func (m *ClusterMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterMetadata) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClusterMetadata) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ClusterMetadata) Clone() *ClusterMetadata {
	if m == nil {
		return nil
	}
	cloned := new(ClusterMetadata)
	*cloned = *m

	return cloned
}

type GoogleProviderMetadata struct {
	Project string `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	// Deprecated in favor of providerMetadata.cluster.name.
	ClusterName          string   `protobuf:"bytes,2,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"` // Deprecated: Do not use.
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GoogleProviderMetadata) Reset()         { *m = GoogleProviderMetadata{} }
func (m *GoogleProviderMetadata) String() string { return proto.CompactTextString(m) }
func (*GoogleProviderMetadata) ProtoMessage()    {}
func (*GoogleProviderMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{1}
}
func (m *GoogleProviderMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleProviderMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleProviderMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleProviderMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleProviderMetadata.Merge(m, src)
}
func (m *GoogleProviderMetadata) XXX_Size() int {
	return m.Size()
}
func (m *GoogleProviderMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleProviderMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleProviderMetadata proto.InternalMessageInfo

func (m *GoogleProviderMetadata) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

// Deprecated: Do not use.
func (m *GoogleProviderMetadata) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *GoogleProviderMetadata) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GoogleProviderMetadata) Clone() *GoogleProviderMetadata {
	if m == nil {
		return nil
	}
	cloned := new(GoogleProviderMetadata)
	*cloned = *m

	return cloned
}

type AWSProviderMetadata struct {
	AccountId            string   `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AWSProviderMetadata) Reset()         { *m = AWSProviderMetadata{} }
func (m *AWSProviderMetadata) String() string { return proto.CompactTextString(m) }
func (*AWSProviderMetadata) ProtoMessage()    {}
func (*AWSProviderMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{2}
}
func (m *AWSProviderMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSProviderMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AWSProviderMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AWSProviderMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSProviderMetadata.Merge(m, src)
}
func (m *AWSProviderMetadata) XXX_Size() int {
	return m.Size()
}
func (m *AWSProviderMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSProviderMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_AWSProviderMetadata proto.InternalMessageInfo

func (m *AWSProviderMetadata) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *AWSProviderMetadata) MessageClone() proto.Message {
	return m.Clone()
}
func (m *AWSProviderMetadata) Clone() *AWSProviderMetadata {
	if m == nil {
		return nil
	}
	cloned := new(AWSProviderMetadata)
	*cloned = *m

	return cloned
}

type AzureProviderMetadata struct {
	SubscriptionId       string   `protobuf:"bytes,1,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscription_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AzureProviderMetadata) Reset()         { *m = AzureProviderMetadata{} }
func (m *AzureProviderMetadata) String() string { return proto.CompactTextString(m) }
func (*AzureProviderMetadata) ProtoMessage()    {}
func (*AzureProviderMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{3}
}
func (m *AzureProviderMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureProviderMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AzureProviderMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AzureProviderMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureProviderMetadata.Merge(m, src)
}
func (m *AzureProviderMetadata) XXX_Size() int {
	return m.Size()
}
func (m *AzureProviderMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureProviderMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_AzureProviderMetadata proto.InternalMessageInfo

func (m *AzureProviderMetadata) GetSubscriptionId() string {
	if m != nil {
		return m.SubscriptionId
	}
	return ""
}

func (m *AzureProviderMetadata) MessageClone() proto.Message {
	return m.Clone()
}
func (m *AzureProviderMetadata) Clone() *AzureProviderMetadata {
	if m == nil {
		return nil
	}
	cloned := new(AzureProviderMetadata)
	*cloned = *m

	return cloned
}

type ProviderMetadata struct {
	Region string `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	Zone   string `protobuf:"bytes,2,opt,name=zone,proto3" json:"zone,omitempty"`
	// Types that are valid to be assigned to Provider:
	//	*ProviderMetadata_Google
	//	*ProviderMetadata_Aws
	//	*ProviderMetadata_Azure
	Provider             isProviderMetadata_Provider `protobuf_oneof:"Provider"`
	Verified             bool                        `protobuf:"varint,15,opt,name=verified,proto3" json:"verified,omitempty"`
	Cluster              *ClusterMetadata            `protobuf:"bytes,16,opt,name=cluster,proto3" json:"cluster,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ProviderMetadata) Reset()         { *m = ProviderMetadata{} }
func (m *ProviderMetadata) String() string { return proto.CompactTextString(m) }
func (*ProviderMetadata) ProtoMessage()    {}
func (*ProviderMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{4}
}
func (m *ProviderMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderMetadata.Merge(m, src)
}
func (m *ProviderMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ProviderMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderMetadata proto.InternalMessageInfo

type isProviderMetadata_Provider interface {
	isProviderMetadata_Provider()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isProviderMetadata_Provider
}

type ProviderMetadata_Google struct {
	Google *GoogleProviderMetadata `protobuf:"bytes,3,opt,name=google,proto3,oneof" json:"google,omitempty"`
}
type ProviderMetadata_Aws struct {
	Aws *AWSProviderMetadata `protobuf:"bytes,4,opt,name=aws,proto3,oneof" json:"aws,omitempty"`
}
type ProviderMetadata_Azure struct {
	Azure *AzureProviderMetadata `protobuf:"bytes,5,opt,name=azure,proto3,oneof" json:"azure,omitempty"`
}

func (*ProviderMetadata_Google) isProviderMetadata_Provider() {}
func (m *ProviderMetadata_Google) Clone() isProviderMetadata_Provider {
	if m == nil {
		return nil
	}
	cloned := new(ProviderMetadata_Google)
	*cloned = *m

	cloned.Google = m.Google.Clone()
	return cloned
}
func (*ProviderMetadata_Aws) isProviderMetadata_Provider() {}
func (m *ProviderMetadata_Aws) Clone() isProviderMetadata_Provider {
	if m == nil {
		return nil
	}
	cloned := new(ProviderMetadata_Aws)
	*cloned = *m

	cloned.Aws = m.Aws.Clone()
	return cloned
}
func (*ProviderMetadata_Azure) isProviderMetadata_Provider() {}
func (m *ProviderMetadata_Azure) Clone() isProviderMetadata_Provider {
	if m == nil {
		return nil
	}
	cloned := new(ProviderMetadata_Azure)
	*cloned = *m

	cloned.Azure = m.Azure.Clone()
	return cloned
}

func (m *ProviderMetadata) GetProvider() isProviderMetadata_Provider {
	if m != nil {
		return m.Provider
	}
	return nil
}

func (m *ProviderMetadata) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *ProviderMetadata) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *ProviderMetadata) GetGoogle() *GoogleProviderMetadata {
	if x, ok := m.GetProvider().(*ProviderMetadata_Google); ok {
		return x.Google
	}
	return nil
}

func (m *ProviderMetadata) GetAws() *AWSProviderMetadata {
	if x, ok := m.GetProvider().(*ProviderMetadata_Aws); ok {
		return x.Aws
	}
	return nil
}

func (m *ProviderMetadata) GetAzure() *AzureProviderMetadata {
	if x, ok := m.GetProvider().(*ProviderMetadata_Azure); ok {
		return x.Azure
	}
	return nil
}

func (m *ProviderMetadata) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

func (m *ProviderMetadata) GetCluster() *ClusterMetadata {
	if m != nil {
		return m.Cluster
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProviderMetadata) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProviderMetadata_Google)(nil),
		(*ProviderMetadata_Aws)(nil),
		(*ProviderMetadata_Azure)(nil),
	}
}

func (m *ProviderMetadata) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ProviderMetadata) Clone() *ProviderMetadata {
	if m == nil {
		return nil
	}
	cloned := new(ProviderMetadata)
	*cloned = *m

	if m.Provider != nil {
		cloned.Provider = m.Provider.Clone()
	}
	cloned.Cluster = m.Cluster.Clone()
	return cloned
}

type OrchestratorMetadata struct {
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Types that are valid to be assigned to IsOpenshift:
	//	*OrchestratorMetadata_OpenshiftVersion
	IsOpenshift          isOrchestratorMetadata_IsOpenshift `protobuf_oneof:"is_openshift"`
	BuildDate            *types.Timestamp                   `protobuf:"bytes,2,opt,name=build_date,json=buildDate,proto3" json:"build_date,omitempty"`
	ApiVersions          []string                           `protobuf:"bytes,3,rep,name=api_versions,json=apiVersions,proto3" json:"api_versions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *OrchestratorMetadata) Reset()         { *m = OrchestratorMetadata{} }
func (m *OrchestratorMetadata) String() string { return proto.CompactTextString(m) }
func (*OrchestratorMetadata) ProtoMessage()    {}
func (*OrchestratorMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{5}
}
func (m *OrchestratorMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrchestratorMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrchestratorMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrchestratorMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrchestratorMetadata.Merge(m, src)
}
func (m *OrchestratorMetadata) XXX_Size() int {
	return m.Size()
}
func (m *OrchestratorMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_OrchestratorMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_OrchestratorMetadata proto.InternalMessageInfo

type isOrchestratorMetadata_IsOpenshift interface {
	isOrchestratorMetadata_IsOpenshift()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isOrchestratorMetadata_IsOpenshift
}

type OrchestratorMetadata_OpenshiftVersion struct {
	OpenshiftVersion string `protobuf:"bytes,4,opt,name=openshift_version,json=openshiftVersion,proto3,oneof" json:"openshift_version,omitempty"`
}

func (*OrchestratorMetadata_OpenshiftVersion) isOrchestratorMetadata_IsOpenshift() {}
func (m *OrchestratorMetadata_OpenshiftVersion) Clone() isOrchestratorMetadata_IsOpenshift {
	if m == nil {
		return nil
	}
	cloned := new(OrchestratorMetadata_OpenshiftVersion)
	*cloned = *m

	return cloned
}

func (m *OrchestratorMetadata) GetIsOpenshift() isOrchestratorMetadata_IsOpenshift {
	if m != nil {
		return m.IsOpenshift
	}
	return nil
}

func (m *OrchestratorMetadata) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *OrchestratorMetadata) GetOpenshiftVersion() string {
	if x, ok := m.GetIsOpenshift().(*OrchestratorMetadata_OpenshiftVersion); ok {
		return x.OpenshiftVersion
	}
	return ""
}

func (m *OrchestratorMetadata) GetBuildDate() *types.Timestamp {
	if m != nil {
		return m.BuildDate
	}
	return nil
}

func (m *OrchestratorMetadata) GetApiVersions() []string {
	if m != nil {
		return m.ApiVersions
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OrchestratorMetadata) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OrchestratorMetadata_OpenshiftVersion)(nil),
	}
}

func (m *OrchestratorMetadata) MessageClone() proto.Message {
	return m.Clone()
}
func (m *OrchestratorMetadata) Clone() *OrchestratorMetadata {
	if m == nil {
		return nil
	}
	cloned := new(OrchestratorMetadata)
	*cloned = *m

	if m.IsOpenshift != nil {
		cloned.IsOpenshift = m.IsOpenshift.Clone()
	}
	cloned.BuildDate = m.BuildDate.Clone()
	if m.ApiVersions != nil {
		cloned.ApiVersions = make([]string, len(m.ApiVersions))
		copy(cloned.ApiVersions, m.ApiVersions)
	}
	return cloned
}

type AdmissionControllerConfig struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	TimeoutSeconds       int32    `protobuf:"varint,2,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
	ScanInline           bool     `protobuf:"varint,3,opt,name=scan_inline,json=scanInline,proto3" json:"scan_inline,omitempty"`
	DisableBypass        bool     `protobuf:"varint,4,opt,name=disable_bypass,json=disableBypass,proto3" json:"disable_bypass,omitempty"`
	EnforceOnUpdates     bool     `protobuf:"varint,5,opt,name=enforce_on_updates,json=enforceOnUpdates,proto3" json:"enforce_on_updates,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdmissionControllerConfig) Reset()         { *m = AdmissionControllerConfig{} }
func (m *AdmissionControllerConfig) String() string { return proto.CompactTextString(m) }
func (*AdmissionControllerConfig) ProtoMessage()    {}
func (*AdmissionControllerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{6}
}
func (m *AdmissionControllerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdmissionControllerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdmissionControllerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdmissionControllerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdmissionControllerConfig.Merge(m, src)
}
func (m *AdmissionControllerConfig) XXX_Size() int {
	return m.Size()
}
func (m *AdmissionControllerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_AdmissionControllerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_AdmissionControllerConfig proto.InternalMessageInfo

func (m *AdmissionControllerConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *AdmissionControllerConfig) GetTimeoutSeconds() int32 {
	if m != nil {
		return m.TimeoutSeconds
	}
	return 0
}

func (m *AdmissionControllerConfig) GetScanInline() bool {
	if m != nil {
		return m.ScanInline
	}
	return false
}

func (m *AdmissionControllerConfig) GetDisableBypass() bool {
	if m != nil {
		return m.DisableBypass
	}
	return false
}

func (m *AdmissionControllerConfig) GetEnforceOnUpdates() bool {
	if m != nil {
		return m.EnforceOnUpdates
	}
	return false
}

func (m *AdmissionControllerConfig) MessageClone() proto.Message {
	return m.Clone()
}
func (m *AdmissionControllerConfig) Clone() *AdmissionControllerConfig {
	if m == nil {
		return nil
	}
	cloned := new(AdmissionControllerConfig)
	*cloned = *m

	return cloned
}

type TolerationsConfig struct {
	Disabled             bool     `protobuf:"varint,1,opt,name=disabled,proto3" json:"disabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TolerationsConfig) Reset()         { *m = TolerationsConfig{} }
func (m *TolerationsConfig) String() string { return proto.CompactTextString(m) }
func (*TolerationsConfig) ProtoMessage()    {}
func (*TolerationsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{7}
}
func (m *TolerationsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TolerationsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TolerationsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TolerationsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TolerationsConfig.Merge(m, src)
}
func (m *TolerationsConfig) XXX_Size() int {
	return m.Size()
}
func (m *TolerationsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TolerationsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TolerationsConfig proto.InternalMessageInfo

func (m *TolerationsConfig) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *TolerationsConfig) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TolerationsConfig) Clone() *TolerationsConfig {
	if m == nil {
		return nil
	}
	cloned := new(TolerationsConfig)
	*cloned = *m

	return cloned
}

// The difference between Static and Dynamic cluster config is that Static values are not sent over the Central to Sensor gRPC connection. They are used, for example, to generate manifests that can be used to set up the Secured Cluster's k8s components. They are *not* dynamically reloaded.
type StaticClusterConfig struct {
	Type                       ClusterType        `protobuf:"varint,1,opt,name=type,proto3,enum=storage.ClusterType" json:"type,omitempty"`
	MainImage                  string             `protobuf:"bytes,2,opt,name=main_image,json=mainImage,proto3" json:"main_image,omitempty"`
	CentralApiEndpoint         string             `protobuf:"bytes,3,opt,name=central_api_endpoint,json=centralApiEndpoint,proto3" json:"central_api_endpoint,omitempty"`
	CollectionMethod           CollectionMethod   `protobuf:"varint,4,opt,name=collection_method,json=collectionMethod,proto3,enum=storage.CollectionMethod" json:"collection_method,omitempty"`
	CollectorImage             string             `protobuf:"bytes,5,opt,name=collector_image,json=collectorImage,proto3" json:"collector_image,omitempty"`
	AdmissionController        bool               `protobuf:"varint,6,opt,name=admission_controller,json=admissionController,proto3" json:"admission_controller,omitempty"`
	AdmissionControllerUpdates bool               `protobuf:"varint,7,opt,name=admission_controller_updates,json=admissionControllerUpdates,proto3" json:"admission_controller_updates,omitempty"`
	TolerationsConfig          *TolerationsConfig `protobuf:"bytes,8,opt,name=tolerations_config,json=tolerationsConfig,proto3" json:"tolerations_config,omitempty"`
	SlimCollector              bool               `protobuf:"varint,9,opt,name=slim_collector,json=slimCollector,proto3" json:"slim_collector,omitempty"`
	AdmissionControllerEvents  bool               `protobuf:"varint,10,opt,name=admission_controller_events,json=admissionControllerEvents,proto3" json:"admission_controller_events,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}           `json:"-"`
	XXX_unrecognized           []byte             `json:"-"`
	XXX_sizecache              int32              `json:"-"`
}

func (m *StaticClusterConfig) Reset()         { *m = StaticClusterConfig{} }
func (m *StaticClusterConfig) String() string { return proto.CompactTextString(m) }
func (*StaticClusterConfig) ProtoMessage()    {}
func (*StaticClusterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{8}
}
func (m *StaticClusterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaticClusterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StaticClusterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StaticClusterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaticClusterConfig.Merge(m, src)
}
func (m *StaticClusterConfig) XXX_Size() int {
	return m.Size()
}
func (m *StaticClusterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StaticClusterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StaticClusterConfig proto.InternalMessageInfo

func (m *StaticClusterConfig) GetType() ClusterType {
	if m != nil {
		return m.Type
	}
	return ClusterType_GENERIC_CLUSTER
}

func (m *StaticClusterConfig) GetMainImage() string {
	if m != nil {
		return m.MainImage
	}
	return ""
}

func (m *StaticClusterConfig) GetCentralApiEndpoint() string {
	if m != nil {
		return m.CentralApiEndpoint
	}
	return ""
}

func (m *StaticClusterConfig) GetCollectionMethod() CollectionMethod {
	if m != nil {
		return m.CollectionMethod
	}
	return CollectionMethod_UNSET_COLLECTION
}

func (m *StaticClusterConfig) GetCollectorImage() string {
	if m != nil {
		return m.CollectorImage
	}
	return ""
}

func (m *StaticClusterConfig) GetAdmissionController() bool {
	if m != nil {
		return m.AdmissionController
	}
	return false
}

func (m *StaticClusterConfig) GetAdmissionControllerUpdates() bool {
	if m != nil {
		return m.AdmissionControllerUpdates
	}
	return false
}

func (m *StaticClusterConfig) GetTolerationsConfig() *TolerationsConfig {
	if m != nil {
		return m.TolerationsConfig
	}
	return nil
}

func (m *StaticClusterConfig) GetSlimCollector() bool {
	if m != nil {
		return m.SlimCollector
	}
	return false
}

func (m *StaticClusterConfig) GetAdmissionControllerEvents() bool {
	if m != nil {
		return m.AdmissionControllerEvents
	}
	return false
}

func (m *StaticClusterConfig) MessageClone() proto.Message {
	return m.Clone()
}
func (m *StaticClusterConfig) Clone() *StaticClusterConfig {
	if m == nil {
		return nil
	}
	cloned := new(StaticClusterConfig)
	*cloned = *m

	cloned.TolerationsConfig = m.TolerationsConfig.Clone()
	return cloned
}

// The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for "hot reloading" of values without restarting Secured cluster components.
type DynamicClusterConfig struct {
	AdmissionControllerConfig *AdmissionControllerConfig `protobuf:"bytes,1,opt,name=admission_controller_config,json=admissionControllerConfig,proto3" json:"admission_controller_config,omitempty"`
	RegistryOverride          string                     `protobuf:"bytes,2,opt,name=registry_override,json=registryOverride,proto3" json:"registry_override,omitempty"`
	DisableAuditLogs          bool                       `protobuf:"varint,3,opt,name=disable_audit_logs,json=disableAuditLogs,proto3" json:"disable_audit_logs,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}                   `json:"-"`
	XXX_unrecognized          []byte                     `json:"-"`
	XXX_sizecache             int32                      `json:"-"`
}

func (m *DynamicClusterConfig) Reset()         { *m = DynamicClusterConfig{} }
func (m *DynamicClusterConfig) String() string { return proto.CompactTextString(m) }
func (*DynamicClusterConfig) ProtoMessage()    {}
func (*DynamicClusterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{9}
}
func (m *DynamicClusterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicClusterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynamicClusterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynamicClusterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicClusterConfig.Merge(m, src)
}
func (m *DynamicClusterConfig) XXX_Size() int {
	return m.Size()
}
func (m *DynamicClusterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicClusterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicClusterConfig proto.InternalMessageInfo

func (m *DynamicClusterConfig) GetAdmissionControllerConfig() *AdmissionControllerConfig {
	if m != nil {
		return m.AdmissionControllerConfig
	}
	return nil
}

func (m *DynamicClusterConfig) GetRegistryOverride() string {
	if m != nil {
		return m.RegistryOverride
	}
	return ""
}

func (m *DynamicClusterConfig) GetDisableAuditLogs() bool {
	if m != nil {
		return m.DisableAuditLogs
	}
	return false
}

func (m *DynamicClusterConfig) MessageClone() proto.Message {
	return m.Clone()
}
func (m *DynamicClusterConfig) Clone() *DynamicClusterConfig {
	if m == nil {
		return nil
	}
	cloned := new(DynamicClusterConfig)
	*cloned = *m

	cloned.AdmissionControllerConfig = m.AdmissionControllerConfig.Clone()
	return cloned
}

// Encodes a complete cluster configuration minus ID/Name identifiers
// including static and dynamic settings.
type CompleteClusterConfig struct {
	DynamicConfig        *DynamicClusterConfig `protobuf:"bytes,1,opt,name=dynamic_config,json=dynamicConfig,proto3" json:"dynamic_config,omitempty"`
	StaticConfig         *StaticClusterConfig  `protobuf:"bytes,2,opt,name=static_config,json=staticConfig,proto3" json:"static_config,omitempty"`
	ConfigFingerprint    string                `protobuf:"bytes,3,opt,name=config_fingerprint,json=configFingerprint,proto3" json:"config_fingerprint,omitempty"`
	ClusterLabels        map[string]string     `protobuf:"bytes,4,rep,name=cluster_labels,json=clusterLabels,proto3" json:"cluster_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *CompleteClusterConfig) Reset()         { *m = CompleteClusterConfig{} }
func (m *CompleteClusterConfig) String() string { return proto.CompactTextString(m) }
func (*CompleteClusterConfig) ProtoMessage()    {}
func (*CompleteClusterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{10}
}
func (m *CompleteClusterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompleteClusterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompleteClusterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompleteClusterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompleteClusterConfig.Merge(m, src)
}
func (m *CompleteClusterConfig) XXX_Size() int {
	return m.Size()
}
func (m *CompleteClusterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CompleteClusterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CompleteClusterConfig proto.InternalMessageInfo

func (m *CompleteClusterConfig) GetDynamicConfig() *DynamicClusterConfig {
	if m != nil {
		return m.DynamicConfig
	}
	return nil
}

func (m *CompleteClusterConfig) GetStaticConfig() *StaticClusterConfig {
	if m != nil {
		return m.StaticConfig
	}
	return nil
}

func (m *CompleteClusterConfig) GetConfigFingerprint() string {
	if m != nil {
		return m.ConfigFingerprint
	}
	return ""
}

func (m *CompleteClusterConfig) GetClusterLabels() map[string]string {
	if m != nil {
		return m.ClusterLabels
	}
	return nil
}

func (m *CompleteClusterConfig) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CompleteClusterConfig) Clone() *CompleteClusterConfig {
	if m == nil {
		return nil
	}
	cloned := new(CompleteClusterConfig)
	*cloned = *m

	cloned.DynamicConfig = m.DynamicConfig.Clone()
	cloned.StaticConfig = m.StaticConfig.Clone()
	if m.ClusterLabels != nil {
		cloned.ClusterLabels = make(map[string]string, len(m.ClusterLabels))
		for k, v := range m.ClusterLabels {
			cloned.ClusterLabels[k] = v
		}
	}
	return cloned
}

// StackRoxDeploymentIdentification aims at uniquely identifying a StackRox Sensor deployment. It is used to determine
// whether a sensor connection comes from a sensor pod that has restarted or was recreated (possibly after a network
// partition), or from a deployment in a different namespace or cluster.
type SensorDeploymentIdentification struct {
	SystemNamespaceId    string   `protobuf:"bytes,1,opt,name=system_namespace_id,json=systemNamespaceId,proto3" json:"system_namespace_id,omitempty"`
	DefaultNamespaceId   string   `protobuf:"bytes,2,opt,name=default_namespace_id,json=defaultNamespaceId,proto3" json:"default_namespace_id,omitempty"`
	AppNamespace         string   `protobuf:"bytes,3,opt,name=app_namespace,json=appNamespace,proto3" json:"app_namespace,omitempty"`
	AppNamespaceId       string   `protobuf:"bytes,4,opt,name=app_namespace_id,json=appNamespaceId,proto3" json:"app_namespace_id,omitempty"`
	AppServiceaccountId  string   `protobuf:"bytes,5,opt,name=app_serviceaccount_id,json=appServiceaccountId,proto3" json:"app_serviceaccount_id,omitempty"`
	K8SNodeName          string   `protobuf:"bytes,6,opt,name=k8s_node_name,json=k8sNodeName,proto3" json:"k8s_node_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SensorDeploymentIdentification) Reset()         { *m = SensorDeploymentIdentification{} }
func (m *SensorDeploymentIdentification) String() string { return proto.CompactTextString(m) }
func (*SensorDeploymentIdentification) ProtoMessage()    {}
func (*SensorDeploymentIdentification) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{11}
}
func (m *SensorDeploymentIdentification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensorDeploymentIdentification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SensorDeploymentIdentification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SensorDeploymentIdentification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorDeploymentIdentification.Merge(m, src)
}
func (m *SensorDeploymentIdentification) XXX_Size() int {
	return m.Size()
}
func (m *SensorDeploymentIdentification) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorDeploymentIdentification.DiscardUnknown(m)
}

var xxx_messageInfo_SensorDeploymentIdentification proto.InternalMessageInfo

func (m *SensorDeploymentIdentification) GetSystemNamespaceId() string {
	if m != nil {
		return m.SystemNamespaceId
	}
	return ""
}

func (m *SensorDeploymentIdentification) GetDefaultNamespaceId() string {
	if m != nil {
		return m.DefaultNamespaceId
	}
	return ""
}

func (m *SensorDeploymentIdentification) GetAppNamespace() string {
	if m != nil {
		return m.AppNamespace
	}
	return ""
}

func (m *SensorDeploymentIdentification) GetAppNamespaceId() string {
	if m != nil {
		return m.AppNamespaceId
	}
	return ""
}

func (m *SensorDeploymentIdentification) GetAppServiceaccountId() string {
	if m != nil {
		return m.AppServiceaccountId
	}
	return ""
}

func (m *SensorDeploymentIdentification) GetK8SNodeName() string {
	if m != nil {
		return m.K8SNodeName
	}
	return ""
}

func (m *SensorDeploymentIdentification) MessageClone() proto.Message {
	return m.Clone()
}
func (m *SensorDeploymentIdentification) Clone() *SensorDeploymentIdentification {
	if m == nil {
		return nil
	}
	cloned := new(SensorDeploymentIdentification)
	*cloned = *m

	return cloned
}

type Cluster struct {
	Id                         string                `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Cluster ID,hidden,store" sql:"pk,type(uuid)"`
	Name                       string                `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" search:"Cluster,store" sql:"unique"`
	Type                       ClusterType           `protobuf:"varint,3,opt,name=type,proto3,enum=storage.ClusterType" json:"type,omitempty"`
	Labels                     map[string]string     `protobuf:"bytes,27,rep,name=labels,proto3" json:"labels,omitempty" search:"Cluster Label" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MainImage                  string                `protobuf:"bytes,4,opt,name=main_image,json=mainImage,proto3" json:"main_image,omitempty"`
	CollectorImage             string                `protobuf:"bytes,16,opt,name=collector_image,json=collectorImage,proto3" json:"collector_image,omitempty"`
	CentralApiEndpoint         string                `protobuf:"bytes,5,opt,name=central_api_endpoint,json=centralApiEndpoint,proto3" json:"central_api_endpoint,omitempty"`
	RuntimeSupport             bool                  `protobuf:"varint,7,opt,name=runtime_support,json=runtimeSupport,proto3" json:"runtime_support,omitempty"` // Deprecated: Do not use.
	CollectionMethod           CollectionMethod      `protobuf:"varint,17,opt,name=collection_method,json=collectionMethod,proto3,enum=storage.CollectionMethod" json:"collection_method,omitempty"`
	AdmissionController        bool                  `protobuf:"varint,13,opt,name=admission_controller,json=admissionController,proto3" json:"admission_controller,omitempty"`
	AdmissionControllerUpdates bool                  `protobuf:"varint,21,opt,name=admission_controller_updates,json=admissionControllerUpdates,proto3" json:"admission_controller_updates,omitempty"`
	AdmissionControllerEvents  bool                  `protobuf:"varint,25,opt,name=admission_controller_events,json=admissionControllerEvents,proto3" json:"admission_controller_events,omitempty"`
	Status                     *ClusterStatus        `protobuf:"bytes,15,opt,name=status,proto3" json:"status,omitempty"`
	DynamicConfig              *DynamicClusterConfig `protobuf:"bytes,18,opt,name=dynamic_config,json=dynamicConfig,proto3" json:"dynamic_config,omitempty"`
	TolerationsConfig          *TolerationsConfig    `protobuf:"bytes,19,opt,name=tolerations_config,json=tolerationsConfig,proto3" json:"tolerations_config,omitempty"`
	Priority                   int64                 `protobuf:"varint,20,opt,name=priority,proto3" json:"priority,omitempty"`
	HealthStatus               *ClusterHealthStatus  `protobuf:"bytes,22,opt,name=health_status,json=healthStatus,proto3" json:"health_status,omitempty" sql:"-"`
	SlimCollector              bool                  `protobuf:"varint,23,opt,name=slim_collector,json=slimCollector,proto3" json:"slim_collector,omitempty"`
	// The Helm configuration of a cluster is only present in case the cluster is Helm- or Operator-managed.
	HelmConfig *CompleteClusterConfig `protobuf:"bytes,24,opt,name=helm_config,json=helmConfig,proto3" json:"helm_config,omitempty"`
	// most_recent_sensor_id is the current or most recent identification of a successfully connected sensor (if any).
	MostRecentSensorId *SensorDeploymentIdentification `protobuf:"bytes,26,opt,name=most_recent_sensor_id,json=mostRecentSensorId,proto3" json:"most_recent_sensor_id,omitempty"`
	// For internal use only.
	AuditLogState        map[string]*AuditLogFileState `protobuf:"bytes,28,rep,name=audit_log_state,json=auditLogState,proto3" json:"audit_log_state,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	InitBundleId         string                        `protobuf:"bytes,29,opt,name=init_bundle_id,json=initBundleId,proto3" json:"init_bundle_id,omitempty"`
	ManagedBy            ManagerType                   `protobuf:"varint,30,opt,name=managed_by,json=managedBy,proto3,enum=storage.ManagerType" json:"managed_by,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{12}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(m, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Cluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster) GetType() ClusterType {
	if m != nil {
		return m.Type
	}
	return ClusterType_GENERIC_CLUSTER
}

func (m *Cluster) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Cluster) GetMainImage() string {
	if m != nil {
		return m.MainImage
	}
	return ""
}

func (m *Cluster) GetCollectorImage() string {
	if m != nil {
		return m.CollectorImage
	}
	return ""
}

func (m *Cluster) GetCentralApiEndpoint() string {
	if m != nil {
		return m.CentralApiEndpoint
	}
	return ""
}

// Deprecated: Do not use.
func (m *Cluster) GetRuntimeSupport() bool {
	if m != nil {
		return m.RuntimeSupport
	}
	return false
}

func (m *Cluster) GetCollectionMethod() CollectionMethod {
	if m != nil {
		return m.CollectionMethod
	}
	return CollectionMethod_UNSET_COLLECTION
}

func (m *Cluster) GetAdmissionController() bool {
	if m != nil {
		return m.AdmissionController
	}
	return false
}

func (m *Cluster) GetAdmissionControllerUpdates() bool {
	if m != nil {
		return m.AdmissionControllerUpdates
	}
	return false
}

func (m *Cluster) GetAdmissionControllerEvents() bool {
	if m != nil {
		return m.AdmissionControllerEvents
	}
	return false
}

func (m *Cluster) GetStatus() *ClusterStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Cluster) GetDynamicConfig() *DynamicClusterConfig {
	if m != nil {
		return m.DynamicConfig
	}
	return nil
}

func (m *Cluster) GetTolerationsConfig() *TolerationsConfig {
	if m != nil {
		return m.TolerationsConfig
	}
	return nil
}

func (m *Cluster) GetPriority() int64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Cluster) GetHealthStatus() *ClusterHealthStatus {
	if m != nil {
		return m.HealthStatus
	}
	return nil
}

func (m *Cluster) GetSlimCollector() bool {
	if m != nil {
		return m.SlimCollector
	}
	return false
}

func (m *Cluster) GetHelmConfig() *CompleteClusterConfig {
	if m != nil {
		return m.HelmConfig
	}
	return nil
}

func (m *Cluster) GetMostRecentSensorId() *SensorDeploymentIdentification {
	if m != nil {
		return m.MostRecentSensorId
	}
	return nil
}

func (m *Cluster) GetAuditLogState() map[string]*AuditLogFileState {
	if m != nil {
		return m.AuditLogState
	}
	return nil
}

func (m *Cluster) GetInitBundleId() string {
	if m != nil {
		return m.InitBundleId
	}
	return ""
}

func (m *Cluster) GetManagedBy() ManagerType {
	if m != nil {
		return m.ManagedBy
	}
	return ManagerType_MANAGER_TYPE_UNKNOWN
}

func (m *Cluster) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Cluster) Clone() *Cluster {
	if m == nil {
		return nil
	}
	cloned := new(Cluster)
	*cloned = *m

	if m.Labels != nil {
		cloned.Labels = make(map[string]string, len(m.Labels))
		for k, v := range m.Labels {
			cloned.Labels[k] = v
		}
	}
	cloned.Status = m.Status.Clone()
	cloned.DynamicConfig = m.DynamicConfig.Clone()
	cloned.TolerationsConfig = m.TolerationsConfig.Clone()
	cloned.HealthStatus = m.HealthStatus.Clone()
	cloned.HelmConfig = m.HelmConfig.Clone()
	cloned.MostRecentSensorId = m.MostRecentSensorId.Clone()
	if m.AuditLogState != nil {
		cloned.AuditLogState = make(map[string]*AuditLogFileState, len(m.AuditLogState))
		for k, v := range m.AuditLogState {
			cloned.AuditLogState[k] = v.Clone()
		}
	}
	return cloned
}

type ClusterCertExpiryStatus struct {
	SensorCertExpiry     *types.Timestamp `protobuf:"bytes,1,opt,name=sensor_cert_expiry,json=sensorCertExpiry,proto3" json:"sensor_cert_expiry,omitempty"`
	SensorCertNotBefore  *types.Timestamp `protobuf:"bytes,2,opt,name=sensor_cert_not_before,json=sensorCertNotBefore,proto3" json:"sensor_cert_not_before,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ClusterCertExpiryStatus) Reset()         { *m = ClusterCertExpiryStatus{} }
func (m *ClusterCertExpiryStatus) String() string { return proto.CompactTextString(m) }
func (*ClusterCertExpiryStatus) ProtoMessage()    {}
func (*ClusterCertExpiryStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{13}
}
func (m *ClusterCertExpiryStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterCertExpiryStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterCertExpiryStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterCertExpiryStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterCertExpiryStatus.Merge(m, src)
}
func (m *ClusterCertExpiryStatus) XXX_Size() int {
	return m.Size()
}
func (m *ClusterCertExpiryStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterCertExpiryStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterCertExpiryStatus proto.InternalMessageInfo

func (m *ClusterCertExpiryStatus) GetSensorCertExpiry() *types.Timestamp {
	if m != nil {
		return m.SensorCertExpiry
	}
	return nil
}

func (m *ClusterCertExpiryStatus) GetSensorCertNotBefore() *types.Timestamp {
	if m != nil {
		return m.SensorCertNotBefore
	}
	return nil
}

func (m *ClusterCertExpiryStatus) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ClusterCertExpiryStatus) Clone() *ClusterCertExpiryStatus {
	if m == nil {
		return nil
	}
	cloned := new(ClusterCertExpiryStatus)
	*cloned = *m

	cloned.SensorCertExpiry = m.SensorCertExpiry.Clone()
	cloned.SensorCertNotBefore = m.SensorCertNotBefore.Clone()
	return cloned
}

type ClusterStatus struct {
	SensorVersion string `protobuf:"bytes,1,opt,name=sensor_version,json=sensorVersion,proto3" json:"sensor_version,omitempty"`
	// This field has been deprecated starting release 49.0. Use healthStatus.lastContact instead.
	DEPRECATEDLastContact *types.Timestamp         `protobuf:"bytes,2,opt,name=DEPRECATED_last_contact,json=DEPRECATEDLastContact,proto3" json:"DEPRECATED_last_contact,omitempty"`
	ProviderMetadata      *ProviderMetadata        `protobuf:"bytes,3,opt,name=provider_metadata,json=providerMetadata,proto3" json:"provider_metadata,omitempty"`
	OrchestratorMetadata  *OrchestratorMetadata    `protobuf:"bytes,4,opt,name=orchestrator_metadata,json=orchestratorMetadata,proto3" json:"orchestrator_metadata,omitempty"`
	UpgradeStatus         *ClusterUpgradeStatus    `protobuf:"bytes,5,opt,name=upgrade_status,json=upgradeStatus,proto3" json:"upgrade_status,omitempty"`
	CertExpiryStatus      *ClusterCertExpiryStatus `protobuf:"bytes,6,opt,name=cert_expiry_status,json=certExpiryStatus,proto3" json:"cert_expiry_status,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                 `json:"-"`
	XXX_unrecognized      []byte                   `json:"-"`
	XXX_sizecache         int32                    `json:"-"`
}

func (m *ClusterStatus) Reset()         { *m = ClusterStatus{} }
func (m *ClusterStatus) String() string { return proto.CompactTextString(m) }
func (*ClusterStatus) ProtoMessage()    {}
func (*ClusterStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{14}
}
func (m *ClusterStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterStatus.Merge(m, src)
}
func (m *ClusterStatus) XXX_Size() int {
	return m.Size()
}
func (m *ClusterStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterStatus proto.InternalMessageInfo

func (m *ClusterStatus) GetSensorVersion() string {
	if m != nil {
		return m.SensorVersion
	}
	return ""
}

func (m *ClusterStatus) GetDEPRECATEDLastContact() *types.Timestamp {
	if m != nil {
		return m.DEPRECATEDLastContact
	}
	return nil
}

func (m *ClusterStatus) GetProviderMetadata() *ProviderMetadata {
	if m != nil {
		return m.ProviderMetadata
	}
	return nil
}

func (m *ClusterStatus) GetOrchestratorMetadata() *OrchestratorMetadata {
	if m != nil {
		return m.OrchestratorMetadata
	}
	return nil
}

func (m *ClusterStatus) GetUpgradeStatus() *ClusterUpgradeStatus {
	if m != nil {
		return m.UpgradeStatus
	}
	return nil
}

func (m *ClusterStatus) GetCertExpiryStatus() *ClusterCertExpiryStatus {
	if m != nil {
		return m.CertExpiryStatus
	}
	return nil
}

func (m *ClusterStatus) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ClusterStatus) Clone() *ClusterStatus {
	if m == nil {
		return nil
	}
	cloned := new(ClusterStatus)
	*cloned = *m

	cloned.DEPRECATEDLastContact = m.DEPRECATEDLastContact.Clone()
	cloned.ProviderMetadata = m.ProviderMetadata.Clone()
	cloned.OrchestratorMetadata = m.OrchestratorMetadata.Clone()
	cloned.UpgradeStatus = m.UpgradeStatus.Clone()
	cloned.CertExpiryStatus = m.CertExpiryStatus.Clone()
	return cloned
}

type ClusterUpgradeStatus struct {
	Upgradability             ClusterUpgradeStatus_Upgradability `protobuf:"varint,1,opt,name=upgradability,proto3,enum=storage.ClusterUpgradeStatus_Upgradability" json:"upgradability,omitempty"`
	UpgradabilityStatusReason string                             `protobuf:"bytes,2,opt,name=upgradability_status_reason,json=upgradabilityStatusReason,proto3" json:"upgradability_status_reason,omitempty"`
	// The progress of the current or most recent upgrade, if any,
	// Note that we don't store any historical data -- the moment
	// a new upgrade attempt is triggered, we overwrite
	// information from the previous attempt.
	MostRecentProcess    *ClusterUpgradeStatus_UpgradeProcessStatus `protobuf:"bytes,3,opt,name=most_recent_process,json=mostRecentProcess,proto3" json:"most_recent_process,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *ClusterUpgradeStatus) Reset()         { *m = ClusterUpgradeStatus{} }
func (m *ClusterUpgradeStatus) String() string { return proto.CompactTextString(m) }
func (*ClusterUpgradeStatus) ProtoMessage()    {}
func (*ClusterUpgradeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{15}
}
func (m *ClusterUpgradeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterUpgradeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterUpgradeStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterUpgradeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterUpgradeStatus.Merge(m, src)
}
func (m *ClusterUpgradeStatus) XXX_Size() int {
	return m.Size()
}
func (m *ClusterUpgradeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterUpgradeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterUpgradeStatus proto.InternalMessageInfo

func (m *ClusterUpgradeStatus) GetUpgradability() ClusterUpgradeStatus_Upgradability {
	if m != nil {
		return m.Upgradability
	}
	return ClusterUpgradeStatus_UNSET
}

func (m *ClusterUpgradeStatus) GetUpgradabilityStatusReason() string {
	if m != nil {
		return m.UpgradabilityStatusReason
	}
	return ""
}

func (m *ClusterUpgradeStatus) GetMostRecentProcess() *ClusterUpgradeStatus_UpgradeProcessStatus {
	if m != nil {
		return m.MostRecentProcess
	}
	return nil
}

func (m *ClusterUpgradeStatus) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ClusterUpgradeStatus) Clone() *ClusterUpgradeStatus {
	if m == nil {
		return nil
	}
	cloned := new(ClusterUpgradeStatus)
	*cloned = *m

	cloned.MostRecentProcess = m.MostRecentProcess.Clone()
	return cloned
}

type ClusterUpgradeStatus_UpgradeProcessStatus struct {
	Active               bool                                                         `protobuf:"varint,1,opt,name=active,proto3" json:"active,omitempty"`
	Id                   string                                                       `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	TargetVersion        string                                                       `protobuf:"bytes,3,opt,name=target_version,json=targetVersion,proto3" json:"target_version,omitempty"` // only relevant if type == Upgrade
	UpgraderImage        string                                                       `protobuf:"bytes,4,opt,name=upgrader_image,json=upgraderImage,proto3" json:"upgrader_image,omitempty"`
	InitiatedAt          *types.Timestamp                                             `protobuf:"bytes,5,opt,name=initiated_at,json=initiatedAt,proto3" json:"initiated_at,omitempty"`
	Progress             *UpgradeProgress                                             `protobuf:"bytes,6,opt,name=progress,proto3" json:"progress,omitempty"`
	Type                 ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType `protobuf:"varint,7,opt,name=type,proto3,enum=storage.ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                     `json:"-"`
	XXX_unrecognized     []byte                                                       `json:"-"`
	XXX_sizecache        int32                                                        `json:"-"`
}

func (m *ClusterUpgradeStatus_UpgradeProcessStatus) Reset() {
	*m = ClusterUpgradeStatus_UpgradeProcessStatus{}
}
func (m *ClusterUpgradeStatus_UpgradeProcessStatus) String() string {
	return proto.CompactTextString(m)
}
func (*ClusterUpgradeStatus_UpgradeProcessStatus) ProtoMessage() {}
func (*ClusterUpgradeStatus_UpgradeProcessStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{15, 0}
}
func (m *ClusterUpgradeStatus_UpgradeProcessStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterUpgradeStatus_UpgradeProcessStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterUpgradeStatus_UpgradeProcessStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterUpgradeStatus_UpgradeProcessStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterUpgradeStatus_UpgradeProcessStatus.Merge(m, src)
}
func (m *ClusterUpgradeStatus_UpgradeProcessStatus) XXX_Size() int {
	return m.Size()
}
func (m *ClusterUpgradeStatus_UpgradeProcessStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterUpgradeStatus_UpgradeProcessStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterUpgradeStatus_UpgradeProcessStatus proto.InternalMessageInfo

func (m *ClusterUpgradeStatus_UpgradeProcessStatus) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *ClusterUpgradeStatus_UpgradeProcessStatus) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClusterUpgradeStatus_UpgradeProcessStatus) GetTargetVersion() string {
	if m != nil {
		return m.TargetVersion
	}
	return ""
}

func (m *ClusterUpgradeStatus_UpgradeProcessStatus) GetUpgraderImage() string {
	if m != nil {
		return m.UpgraderImage
	}
	return ""
}

func (m *ClusterUpgradeStatus_UpgradeProcessStatus) GetInitiatedAt() *types.Timestamp {
	if m != nil {
		return m.InitiatedAt
	}
	return nil
}

func (m *ClusterUpgradeStatus_UpgradeProcessStatus) GetProgress() *UpgradeProgress {
	if m != nil {
		return m.Progress
	}
	return nil
}

func (m *ClusterUpgradeStatus_UpgradeProcessStatus) GetType() ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType {
	if m != nil {
		return m.Type
	}
	return ClusterUpgradeStatus_UpgradeProcessStatus_UPGRADE
}

func (m *ClusterUpgradeStatus_UpgradeProcessStatus) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ClusterUpgradeStatus_UpgradeProcessStatus) Clone() *ClusterUpgradeStatus_UpgradeProcessStatus {
	if m == nil {
		return nil
	}
	cloned := new(ClusterUpgradeStatus_UpgradeProcessStatus)
	*cloned = *m

	cloned.InitiatedAt = m.InitiatedAt.Clone()
	cloned.Progress = m.Progress.Clone()
	return cloned
}

type UpgradeProgress struct {
	UpgradeState         UpgradeProgress_UpgradeState `protobuf:"varint,1,opt,name=upgrade_state,json=upgradeState,proto3,enum=storage.UpgradeProgress_UpgradeState" json:"upgrade_state,omitempty"`
	UpgradeStatusDetail  string                       `protobuf:"bytes,2,opt,name=upgrade_status_detail,json=upgradeStatusDetail,proto3" json:"upgrade_status_detail,omitempty"`
	Since                *types.Timestamp             `protobuf:"bytes,3,opt,name=since,proto3" json:"since,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *UpgradeProgress) Reset()         { *m = UpgradeProgress{} }
func (m *UpgradeProgress) String() string { return proto.CompactTextString(m) }
func (*UpgradeProgress) ProtoMessage()    {}
func (*UpgradeProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{16}
}
func (m *UpgradeProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeProgress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeProgress.Merge(m, src)
}
func (m *UpgradeProgress) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeProgress.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeProgress proto.InternalMessageInfo

func (m *UpgradeProgress) GetUpgradeState() UpgradeProgress_UpgradeState {
	if m != nil {
		return m.UpgradeState
	}
	return UpgradeProgress_UPGRADE_INITIALIZING
}

func (m *UpgradeProgress) GetUpgradeStatusDetail() string {
	if m != nil {
		return m.UpgradeStatusDetail
	}
	return ""
}

func (m *UpgradeProgress) GetSince() *types.Timestamp {
	if m != nil {
		return m.Since
	}
	return nil
}

func (m *UpgradeProgress) MessageClone() proto.Message {
	return m.Clone()
}
func (m *UpgradeProgress) Clone() *UpgradeProgress {
	if m == nil {
		return nil
	}
	cloned := new(UpgradeProgress)
	*cloned = *m

	cloned.Since = m.Since.Clone()
	return cloned
}

// AuditLogFileState tracks the last audit log event timestamp and ID that was collected by Compliance
// For internal use only
type AuditLogFileState struct {
	CollectLogsSince     *types.Timestamp `protobuf:"bytes,1,opt,name=collect_logs_since,json=collectLogsSince,proto3" json:"collect_logs_since,omitempty"`
	LastAuditId          string           `protobuf:"bytes,2,opt,name=last_audit_id,json=lastAuditId,proto3" json:"last_audit_id,omitempty"` // Previously received audit id. May be empty
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AuditLogFileState) Reset()         { *m = AuditLogFileState{} }
func (m *AuditLogFileState) String() string { return proto.CompactTextString(m) }
func (*AuditLogFileState) ProtoMessage()    {}
func (*AuditLogFileState) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{17}
}
func (m *AuditLogFileState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuditLogFileState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuditLogFileState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuditLogFileState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuditLogFileState.Merge(m, src)
}
func (m *AuditLogFileState) XXX_Size() int {
	return m.Size()
}
func (m *AuditLogFileState) XXX_DiscardUnknown() {
	xxx_messageInfo_AuditLogFileState.DiscardUnknown(m)
}

var xxx_messageInfo_AuditLogFileState proto.InternalMessageInfo

func (m *AuditLogFileState) GetCollectLogsSince() *types.Timestamp {
	if m != nil {
		return m.CollectLogsSince
	}
	return nil
}

func (m *AuditLogFileState) GetLastAuditId() string {
	if m != nil {
		return m.LastAuditId
	}
	return ""
}

func (m *AuditLogFileState) MessageClone() proto.Message {
	return m.Clone()
}
func (m *AuditLogFileState) Clone() *AuditLogFileState {
	if m == nil {
		return nil
	}
	cloned := new(AuditLogFileState)
	*cloned = *m

	cloned.CollectLogsSince = m.CollectLogsSince.Clone()
	return cloned
}

type ClusterHealthStatus struct {
	Id                         string                      `protobuf:"bytes,9,opt,name=id,proto3" json:"id,omitempty" sql:"pk,fk(Cluster:id),no-fk-constraint,type(uuid)"`
	CollectorHealthInfo        *CollectorHealthInfo        `protobuf:"bytes,1,opt,name=collector_health_info,json=collectorHealthInfo,proto3" json:"collector_health_info,omitempty"`
	AdmissionControlHealthInfo *AdmissionControlHealthInfo `protobuf:"bytes,8,opt,name=admission_control_health_info,json=admissionControlHealthInfo,proto3" json:"admission_control_health_info,omitempty"`
	// scanner_health_info is filled when the scanner is deployed on a secured cluster (so called "local scanner").
	// Please do not confuse this with the default scanner deployment on a central cluster.
	ScannerHealthInfo *ScannerHealthInfo `protobuf:"bytes,10,opt,name=scanner_health_info,json=scannerHealthInfo,proto3" json:"scanner_health_info,omitempty"`
	// The following _health_status fields provide aggregated health status of the respective components and are assigned by central.
	SensorHealthStatus           ClusterHealthStatus_HealthStatusLabel `protobuf:"varint,2,opt,name=sensor_health_status,json=sensorHealthStatus,proto3,enum=storage.ClusterHealthStatus_HealthStatusLabel" json:"sensor_health_status,omitempty" search:"Sensor Status,store"`
	CollectorHealthStatus        ClusterHealthStatus_HealthStatusLabel `protobuf:"varint,3,opt,name=collector_health_status,json=collectorHealthStatus,proto3,enum=storage.ClusterHealthStatus_HealthStatusLabel" json:"collector_health_status,omitempty" search:"Collector Status,store"`
	OverallHealthStatus          ClusterHealthStatus_HealthStatusLabel `protobuf:"varint,4,opt,name=overall_health_status,json=overallHealthStatus,proto3,enum=storage.ClusterHealthStatus_HealthStatusLabel" json:"overall_health_status,omitempty" search:"Cluster Status,store"`
	AdmissionControlHealthStatus ClusterHealthStatus_HealthStatusLabel `protobuf:"varint,7,opt,name=admission_control_health_status,json=admissionControlHealthStatus,proto3,enum=storage.ClusterHealthStatus_HealthStatusLabel" json:"admission_control_health_status,omitempty" search:"Admission Control Status,store"`
	ScannerHealthStatus          ClusterHealthStatus_HealthStatusLabel `protobuf:"varint,11,opt,name=scanner_health_status,json=scannerHealthStatus,proto3,enum=storage.ClusterHealthStatus_HealthStatusLabel" json:"scanner_health_status,omitempty" search:"Scanner Status,store"`
	// For sensors not having health capability, this will be filled with gRPC connection poll. Otherwise,
	// this timestamp will be updated by central pipeline when message is processed
	LastContact *types.Timestamp `protobuf:"bytes,5,opt,name=last_contact,json=lastContact,proto3" json:"last_contact,omitempty" search:"Last Contact,store"`
	// To track cases such as when sensor is healthy, but collector status data is unavailable because the sensor is on an old version
	HealthInfoComplete   bool     `protobuf:"varint,6,opt,name=health_info_complete,json=healthInfoComplete,proto3" json:"health_info_complete,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterHealthStatus) Reset()         { *m = ClusterHealthStatus{} }
func (m *ClusterHealthStatus) String() string { return proto.CompactTextString(m) }
func (*ClusterHealthStatus) ProtoMessage()    {}
func (*ClusterHealthStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{18}
}
func (m *ClusterHealthStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterHealthStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterHealthStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterHealthStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterHealthStatus.Merge(m, src)
}
func (m *ClusterHealthStatus) XXX_Size() int {
	return m.Size()
}
func (m *ClusterHealthStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterHealthStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterHealthStatus proto.InternalMessageInfo

func (m *ClusterHealthStatus) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClusterHealthStatus) GetCollectorHealthInfo() *CollectorHealthInfo {
	if m != nil {
		return m.CollectorHealthInfo
	}
	return nil
}

func (m *ClusterHealthStatus) GetAdmissionControlHealthInfo() *AdmissionControlHealthInfo {
	if m != nil {
		return m.AdmissionControlHealthInfo
	}
	return nil
}

func (m *ClusterHealthStatus) GetScannerHealthInfo() *ScannerHealthInfo {
	if m != nil {
		return m.ScannerHealthInfo
	}
	return nil
}

func (m *ClusterHealthStatus) GetSensorHealthStatus() ClusterHealthStatus_HealthStatusLabel {
	if m != nil {
		return m.SensorHealthStatus
	}
	return ClusterHealthStatus_UNINITIALIZED
}

func (m *ClusterHealthStatus) GetCollectorHealthStatus() ClusterHealthStatus_HealthStatusLabel {
	if m != nil {
		return m.CollectorHealthStatus
	}
	return ClusterHealthStatus_UNINITIALIZED
}

func (m *ClusterHealthStatus) GetOverallHealthStatus() ClusterHealthStatus_HealthStatusLabel {
	if m != nil {
		return m.OverallHealthStatus
	}
	return ClusterHealthStatus_UNINITIALIZED
}

func (m *ClusterHealthStatus) GetAdmissionControlHealthStatus() ClusterHealthStatus_HealthStatusLabel {
	if m != nil {
		return m.AdmissionControlHealthStatus
	}
	return ClusterHealthStatus_UNINITIALIZED
}

func (m *ClusterHealthStatus) GetScannerHealthStatus() ClusterHealthStatus_HealthStatusLabel {
	if m != nil {
		return m.ScannerHealthStatus
	}
	return ClusterHealthStatus_UNINITIALIZED
}

func (m *ClusterHealthStatus) GetLastContact() *types.Timestamp {
	if m != nil {
		return m.LastContact
	}
	return nil
}

func (m *ClusterHealthStatus) GetHealthInfoComplete() bool {
	if m != nil {
		return m.HealthInfoComplete
	}
	return false
}

func (m *ClusterHealthStatus) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ClusterHealthStatus) Clone() *ClusterHealthStatus {
	if m == nil {
		return nil
	}
	cloned := new(ClusterHealthStatus)
	*cloned = *m

	cloned.CollectorHealthInfo = m.CollectorHealthInfo.Clone()
	cloned.AdmissionControlHealthInfo = m.AdmissionControlHealthInfo.Clone()
	cloned.ScannerHealthInfo = m.ScannerHealthInfo.Clone()
	cloned.LastContact = m.LastContact.Clone()
	return cloned
}

// CollectorHealthInfo carries data about collector deployment but does not include collector health status derived from this data.
// Aggregated collector health status is not included because it is derived in central and not in the component that
// first reports CollectorHealthInfo (sensor).
type CollectorHealthInfo struct {
	// This is the version of the collector deamonset as returned by k8s API
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Types that are valid to be assigned to TotalDesiredPodsOpt:
	//
	//	*CollectorHealthInfo_TotalDesiredPods
	TotalDesiredPodsOpt isCollectorHealthInfo_TotalDesiredPodsOpt `protobuf_oneof:"total_desired_pods_opt"`
	// Types that are valid to be assigned to TotalReadyPodsOpt:
	//
	//	*CollectorHealthInfo_TotalReadyPods
	TotalReadyPodsOpt isCollectorHealthInfo_TotalReadyPodsOpt `protobuf_oneof:"total_ready_pods_opt"`
	// Types that are valid to be assigned to TotalRegisteredNodesOpt:
	//
	//	*CollectorHealthInfo_TotalRegisteredNodes
	TotalRegisteredNodesOpt isCollectorHealthInfo_TotalRegisteredNodesOpt `protobuf_oneof:"total_registered_nodes_opt"`
	// Collection of errors that occurred while trying to obtain collector health info.
	StatusErrors         []string `protobuf:"bytes,5,rep,name=status_errors,json=statusErrors,proto3" json:"status_errors,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CollectorHealthInfo) Reset()         { *m = CollectorHealthInfo{} }
func (m *CollectorHealthInfo) String() string { return proto.CompactTextString(m) }
func (*CollectorHealthInfo) ProtoMessage()    {}
func (*CollectorHealthInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{19}
}
func (m *CollectorHealthInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectorHealthInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectorHealthInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectorHealthInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectorHealthInfo.Merge(m, src)
}
func (m *CollectorHealthInfo) XXX_Size() int {
	return m.Size()
}
func (m *CollectorHealthInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectorHealthInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CollectorHealthInfo proto.InternalMessageInfo

type isCollectorHealthInfo_TotalDesiredPodsOpt interface {
	isCollectorHealthInfo_TotalDesiredPodsOpt()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isCollectorHealthInfo_TotalDesiredPodsOpt
}
type isCollectorHealthInfo_TotalReadyPodsOpt interface {
	isCollectorHealthInfo_TotalReadyPodsOpt()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isCollectorHealthInfo_TotalReadyPodsOpt
}
type isCollectorHealthInfo_TotalRegisteredNodesOpt interface {
	isCollectorHealthInfo_TotalRegisteredNodesOpt()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isCollectorHealthInfo_TotalRegisteredNodesOpt
}

type CollectorHealthInfo_TotalDesiredPods struct {
	TotalDesiredPods int32 `protobuf:"varint,2,opt,name=total_desired_pods,json=totalDesiredPods,proto3,oneof" json:"total_desired_pods,omitempty"`
}
type CollectorHealthInfo_TotalReadyPods struct {
	TotalReadyPods int32 `protobuf:"varint,3,opt,name=total_ready_pods,json=totalReadyPods,proto3,oneof" json:"total_ready_pods,omitempty"`
}
type CollectorHealthInfo_TotalRegisteredNodes struct {
	TotalRegisteredNodes int32 `protobuf:"varint,4,opt,name=total_registered_nodes,json=totalRegisteredNodes,proto3,oneof" json:"total_registered_nodes,omitempty"`
}

func (*CollectorHealthInfo_TotalDesiredPods) isCollectorHealthInfo_TotalDesiredPodsOpt() {}
func (m *CollectorHealthInfo_TotalDesiredPods) Clone() isCollectorHealthInfo_TotalDesiredPodsOpt {
	if m == nil {
		return nil
	}
	cloned := new(CollectorHealthInfo_TotalDesiredPods)
	*cloned = *m

	return cloned
}
func (*CollectorHealthInfo_TotalReadyPods) isCollectorHealthInfo_TotalReadyPodsOpt() {}
func (m *CollectorHealthInfo_TotalReadyPods) Clone() isCollectorHealthInfo_TotalReadyPodsOpt {
	if m == nil {
		return nil
	}
	cloned := new(CollectorHealthInfo_TotalReadyPods)
	*cloned = *m

	return cloned
}
func (*CollectorHealthInfo_TotalRegisteredNodes) isCollectorHealthInfo_TotalRegisteredNodesOpt() {}
func (m *CollectorHealthInfo_TotalRegisteredNodes) Clone() isCollectorHealthInfo_TotalRegisteredNodesOpt {
	if m == nil {
		return nil
	}
	cloned := new(CollectorHealthInfo_TotalRegisteredNodes)
	*cloned = *m

	return cloned
}

func (m *CollectorHealthInfo) GetTotalDesiredPodsOpt() isCollectorHealthInfo_TotalDesiredPodsOpt {
	if m != nil {
		return m.TotalDesiredPodsOpt
	}
	return nil
}
func (m *CollectorHealthInfo) GetTotalReadyPodsOpt() isCollectorHealthInfo_TotalReadyPodsOpt {
	if m != nil {
		return m.TotalReadyPodsOpt
	}
	return nil
}
func (m *CollectorHealthInfo) GetTotalRegisteredNodesOpt() isCollectorHealthInfo_TotalRegisteredNodesOpt {
	if m != nil {
		return m.TotalRegisteredNodesOpt
	}
	return nil
}

func (m *CollectorHealthInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *CollectorHealthInfo) GetTotalDesiredPods() int32 {
	if x, ok := m.GetTotalDesiredPodsOpt().(*CollectorHealthInfo_TotalDesiredPods); ok {
		return x.TotalDesiredPods
	}
	return 0
}

func (m *CollectorHealthInfo) GetTotalReadyPods() int32 {
	if x, ok := m.GetTotalReadyPodsOpt().(*CollectorHealthInfo_TotalReadyPods); ok {
		return x.TotalReadyPods
	}
	return 0
}

func (m *CollectorHealthInfo) GetTotalRegisteredNodes() int32 {
	if x, ok := m.GetTotalRegisteredNodesOpt().(*CollectorHealthInfo_TotalRegisteredNodes); ok {
		return x.TotalRegisteredNodes
	}
	return 0
}

func (m *CollectorHealthInfo) GetStatusErrors() []string {
	if m != nil {
		return m.StatusErrors
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CollectorHealthInfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CollectorHealthInfo_TotalDesiredPods)(nil),
		(*CollectorHealthInfo_TotalReadyPods)(nil),
		(*CollectorHealthInfo_TotalRegisteredNodes)(nil),
	}
}

func (m *CollectorHealthInfo) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CollectorHealthInfo) Clone() *CollectorHealthInfo {
	if m == nil {
		return nil
	}
	cloned := new(CollectorHealthInfo)
	*cloned = *m

	if m.TotalDesiredPodsOpt != nil {
		cloned.TotalDesiredPodsOpt = m.TotalDesiredPodsOpt.Clone()
	}
	if m.TotalReadyPodsOpt != nil {
		cloned.TotalReadyPodsOpt = m.TotalReadyPodsOpt.Clone()
	}
	if m.TotalRegisteredNodesOpt != nil {
		cloned.TotalRegisteredNodesOpt = m.TotalRegisteredNodesOpt.Clone()
	}
	if m.StatusErrors != nil {
		cloned.StatusErrors = make([]string, len(m.StatusErrors))
		copy(cloned.StatusErrors, m.StatusErrors)
	}
	return cloned
}

// AdmissionControlHealthInfo carries data about admission control deployment but does not include admission control health status
// derived from this data.
// Aggregated admission control health status is not included because it is derived in central and not in the component that
// first reports AdmissionControlHealthInfo (sensor).
type AdmissionControlHealthInfo struct {
	// Types that are valid to be assigned to TotalDesiredPodsOpt:
	//
	//	*AdmissionControlHealthInfo_TotalDesiredPods
	TotalDesiredPodsOpt isAdmissionControlHealthInfo_TotalDesiredPodsOpt `protobuf_oneof:"total_desired_pods_opt"`
	// Types that are valid to be assigned to TotalReadyPodsOpt:
	//
	//	*AdmissionControlHealthInfo_TotalReadyPods
	TotalReadyPodsOpt isAdmissionControlHealthInfo_TotalReadyPodsOpt `protobuf_oneof:"total_ready_pods_opt"`
	// Collection of errors that occurred while trying to obtain admission control health info.
	StatusErrors         []string `protobuf:"bytes,3,rep,name=status_errors,json=statusErrors,proto3" json:"status_errors,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdmissionControlHealthInfo) Reset()         { *m = AdmissionControlHealthInfo{} }
func (m *AdmissionControlHealthInfo) String() string { return proto.CompactTextString(m) }
func (*AdmissionControlHealthInfo) ProtoMessage()    {}
func (*AdmissionControlHealthInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{20}
}
func (m *AdmissionControlHealthInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdmissionControlHealthInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdmissionControlHealthInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdmissionControlHealthInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdmissionControlHealthInfo.Merge(m, src)
}
func (m *AdmissionControlHealthInfo) XXX_Size() int {
	return m.Size()
}
func (m *AdmissionControlHealthInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AdmissionControlHealthInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AdmissionControlHealthInfo proto.InternalMessageInfo

type isAdmissionControlHealthInfo_TotalDesiredPodsOpt interface {
	isAdmissionControlHealthInfo_TotalDesiredPodsOpt()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isAdmissionControlHealthInfo_TotalDesiredPodsOpt
}
type isAdmissionControlHealthInfo_TotalReadyPodsOpt interface {
	isAdmissionControlHealthInfo_TotalReadyPodsOpt()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isAdmissionControlHealthInfo_TotalReadyPodsOpt
}

type AdmissionControlHealthInfo_TotalDesiredPods struct {
	TotalDesiredPods int32 `protobuf:"varint,1,opt,name=total_desired_pods,json=totalDesiredPods,proto3,oneof" json:"total_desired_pods,omitempty"`
}
type AdmissionControlHealthInfo_TotalReadyPods struct {
	TotalReadyPods int32 `protobuf:"varint,2,opt,name=total_ready_pods,json=totalReadyPods,proto3,oneof" json:"total_ready_pods,omitempty"`
}

func (*AdmissionControlHealthInfo_TotalDesiredPods) isAdmissionControlHealthInfo_TotalDesiredPodsOpt() {
}
func (m *AdmissionControlHealthInfo_TotalDesiredPods) Clone() isAdmissionControlHealthInfo_TotalDesiredPodsOpt {
	if m == nil {
		return nil
	}
	cloned := new(AdmissionControlHealthInfo_TotalDesiredPods)
	*cloned = *m

	return cloned
}
func (*AdmissionControlHealthInfo_TotalReadyPods) isAdmissionControlHealthInfo_TotalReadyPodsOpt() {}
func (m *AdmissionControlHealthInfo_TotalReadyPods) Clone() isAdmissionControlHealthInfo_TotalReadyPodsOpt {
	if m == nil {
		return nil
	}
	cloned := new(AdmissionControlHealthInfo_TotalReadyPods)
	*cloned = *m

	return cloned
}

func (m *AdmissionControlHealthInfo) GetTotalDesiredPodsOpt() isAdmissionControlHealthInfo_TotalDesiredPodsOpt {
	if m != nil {
		return m.TotalDesiredPodsOpt
	}
	return nil
}
func (m *AdmissionControlHealthInfo) GetTotalReadyPodsOpt() isAdmissionControlHealthInfo_TotalReadyPodsOpt {
	if m != nil {
		return m.TotalReadyPodsOpt
	}
	return nil
}

func (m *AdmissionControlHealthInfo) GetTotalDesiredPods() int32 {
	if x, ok := m.GetTotalDesiredPodsOpt().(*AdmissionControlHealthInfo_TotalDesiredPods); ok {
		return x.TotalDesiredPods
	}
	return 0
}

func (m *AdmissionControlHealthInfo) GetTotalReadyPods() int32 {
	if x, ok := m.GetTotalReadyPodsOpt().(*AdmissionControlHealthInfo_TotalReadyPods); ok {
		return x.TotalReadyPods
	}
	return 0
}

func (m *AdmissionControlHealthInfo) GetStatusErrors() []string {
	if m != nil {
		return m.StatusErrors
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AdmissionControlHealthInfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AdmissionControlHealthInfo_TotalDesiredPods)(nil),
		(*AdmissionControlHealthInfo_TotalReadyPods)(nil),
	}
}

func (m *AdmissionControlHealthInfo) MessageClone() proto.Message {
	return m.Clone()
}
func (m *AdmissionControlHealthInfo) Clone() *AdmissionControlHealthInfo {
	if m == nil {
		return nil
	}
	cloned := new(AdmissionControlHealthInfo)
	*cloned = *m

	if m.TotalDesiredPodsOpt != nil {
		cloned.TotalDesiredPodsOpt = m.TotalDesiredPodsOpt.Clone()
	}
	if m.TotalReadyPodsOpt != nil {
		cloned.TotalReadyPodsOpt = m.TotalReadyPodsOpt.Clone()
	}
	if m.StatusErrors != nil {
		cloned.StatusErrors = make([]string, len(m.StatusErrors))
		copy(cloned.StatusErrors, m.StatusErrors)
	}
	return cloned
}

// ScannerHealthInfo represents health info of a scanner instance that is deployed on a secured cluster (so called "local scanner").
// When the scanner is deployed on a central cluster, the following message is NOT used.
// ScannerHealthInfo carries data about scanner deployment but does not include scanner health status
// derived from this data.
// Aggregated scanner health status is not included because it is derived in central and not in the component that
// first reports ScannerHealthInfo (sensor).
type ScannerHealthInfo struct {
	// Types that are valid to be assigned to TotalDesiredAnalyzerPodsOpt:
	//
	//	*ScannerHealthInfo_TotalDesiredAnalyzerPods
	TotalDesiredAnalyzerPodsOpt isScannerHealthInfo_TotalDesiredAnalyzerPodsOpt `protobuf_oneof:"total_desired_analyzer_pods_opt"`
	// Types that are valid to be assigned to TotalReadyAnalyzerPodsOpt:
	//
	//	*ScannerHealthInfo_TotalReadyAnalyzerPods
	TotalReadyAnalyzerPodsOpt isScannerHealthInfo_TotalReadyAnalyzerPodsOpt `protobuf_oneof:"total_ready_analyzer_pods_opt"`
	// Types that are valid to be assigned to TotalDesiredDbPodsOpt:
	//
	//	*ScannerHealthInfo_TotalDesiredDbPods
	TotalDesiredDbPodsOpt isScannerHealthInfo_TotalDesiredDbPodsOpt `protobuf_oneof:"total_desired_db_pods_opt"`
	// Types that are valid to be assigned to TotalReadyDbPodsOpt:
	//
	//	*ScannerHealthInfo_TotalReadyDbPods
	TotalReadyDbPodsOpt isScannerHealthInfo_TotalReadyDbPodsOpt `protobuf_oneof:"total_ready_db_pods_opt"`
	// Collection of errors that occurred while trying to obtain scanner health info.
	StatusErrors         []string `protobuf:"bytes,5,rep,name=status_errors,json=statusErrors,proto3" json:"status_errors,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScannerHealthInfo) Reset()         { *m = ScannerHealthInfo{} }
func (m *ScannerHealthInfo) String() string { return proto.CompactTextString(m) }
func (*ScannerHealthInfo) ProtoMessage()    {}
func (*ScannerHealthInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd4108636841f8d0, []int{21}
}
func (m *ScannerHealthInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScannerHealthInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScannerHealthInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScannerHealthInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScannerHealthInfo.Merge(m, src)
}
func (m *ScannerHealthInfo) XXX_Size() int {
	return m.Size()
}
func (m *ScannerHealthInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ScannerHealthInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ScannerHealthInfo proto.InternalMessageInfo

type isScannerHealthInfo_TotalDesiredAnalyzerPodsOpt interface {
	isScannerHealthInfo_TotalDesiredAnalyzerPodsOpt()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isScannerHealthInfo_TotalDesiredAnalyzerPodsOpt
}
type isScannerHealthInfo_TotalReadyAnalyzerPodsOpt interface {
	isScannerHealthInfo_TotalReadyAnalyzerPodsOpt()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isScannerHealthInfo_TotalReadyAnalyzerPodsOpt
}
type isScannerHealthInfo_TotalDesiredDbPodsOpt interface {
	isScannerHealthInfo_TotalDesiredDbPodsOpt()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isScannerHealthInfo_TotalDesiredDbPodsOpt
}
type isScannerHealthInfo_TotalReadyDbPodsOpt interface {
	isScannerHealthInfo_TotalReadyDbPodsOpt()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isScannerHealthInfo_TotalReadyDbPodsOpt
}

type ScannerHealthInfo_TotalDesiredAnalyzerPods struct {
	TotalDesiredAnalyzerPods int32 `protobuf:"varint,1,opt,name=total_desired_analyzer_pods,json=totalDesiredAnalyzerPods,proto3,oneof" json:"total_desired_analyzer_pods,omitempty"`
}
type ScannerHealthInfo_TotalReadyAnalyzerPods struct {
	TotalReadyAnalyzerPods int32 `protobuf:"varint,2,opt,name=total_ready_analyzer_pods,json=totalReadyAnalyzerPods,proto3,oneof" json:"total_ready_analyzer_pods,omitempty"`
}
type ScannerHealthInfo_TotalDesiredDbPods struct {
	TotalDesiredDbPods int32 `protobuf:"varint,3,opt,name=total_desired_db_pods,json=totalDesiredDbPods,proto3,oneof" json:"total_desired_db_pods,omitempty"`
}
type ScannerHealthInfo_TotalReadyDbPods struct {
	TotalReadyDbPods int32 `protobuf:"varint,4,opt,name=total_ready_db_pods,json=totalReadyDbPods,proto3,oneof" json:"total_ready_db_pods,omitempty"`
}

func (*ScannerHealthInfo_TotalDesiredAnalyzerPods) isScannerHealthInfo_TotalDesiredAnalyzerPodsOpt() {
}
func (m *ScannerHealthInfo_TotalDesiredAnalyzerPods) Clone() isScannerHealthInfo_TotalDesiredAnalyzerPodsOpt {
	if m == nil {
		return nil
	}
	cloned := new(ScannerHealthInfo_TotalDesiredAnalyzerPods)
	*cloned = *m

	return cloned
}
func (*ScannerHealthInfo_TotalReadyAnalyzerPods) isScannerHealthInfo_TotalReadyAnalyzerPodsOpt() {}
func (m *ScannerHealthInfo_TotalReadyAnalyzerPods) Clone() isScannerHealthInfo_TotalReadyAnalyzerPodsOpt {
	if m == nil {
		return nil
	}
	cloned := new(ScannerHealthInfo_TotalReadyAnalyzerPods)
	*cloned = *m

	return cloned
}
func (*ScannerHealthInfo_TotalDesiredDbPods) isScannerHealthInfo_TotalDesiredDbPodsOpt() {}
func (m *ScannerHealthInfo_TotalDesiredDbPods) Clone() isScannerHealthInfo_TotalDesiredDbPodsOpt {
	if m == nil {
		return nil
	}
	cloned := new(ScannerHealthInfo_TotalDesiredDbPods)
	*cloned = *m

	return cloned
}
func (*ScannerHealthInfo_TotalReadyDbPods) isScannerHealthInfo_TotalReadyDbPodsOpt() {}
func (m *ScannerHealthInfo_TotalReadyDbPods) Clone() isScannerHealthInfo_TotalReadyDbPodsOpt {
	if m == nil {
		return nil
	}
	cloned := new(ScannerHealthInfo_TotalReadyDbPods)
	*cloned = *m

	return cloned
}

func (m *ScannerHealthInfo) GetTotalDesiredAnalyzerPodsOpt() isScannerHealthInfo_TotalDesiredAnalyzerPodsOpt {
	if m != nil {
		return m.TotalDesiredAnalyzerPodsOpt
	}
	return nil
}
func (m *ScannerHealthInfo) GetTotalReadyAnalyzerPodsOpt() isScannerHealthInfo_TotalReadyAnalyzerPodsOpt {
	if m != nil {
		return m.TotalReadyAnalyzerPodsOpt
	}
	return nil
}
func (m *ScannerHealthInfo) GetTotalDesiredDbPodsOpt() isScannerHealthInfo_TotalDesiredDbPodsOpt {
	if m != nil {
		return m.TotalDesiredDbPodsOpt
	}
	return nil
}
func (m *ScannerHealthInfo) GetTotalReadyDbPodsOpt() isScannerHealthInfo_TotalReadyDbPodsOpt {
	if m != nil {
		return m.TotalReadyDbPodsOpt
	}
	return nil
}

func (m *ScannerHealthInfo) GetTotalDesiredAnalyzerPods() int32 {
	if x, ok := m.GetTotalDesiredAnalyzerPodsOpt().(*ScannerHealthInfo_TotalDesiredAnalyzerPods); ok {
		return x.TotalDesiredAnalyzerPods
	}
	return 0
}

func (m *ScannerHealthInfo) GetTotalReadyAnalyzerPods() int32 {
	if x, ok := m.GetTotalReadyAnalyzerPodsOpt().(*ScannerHealthInfo_TotalReadyAnalyzerPods); ok {
		return x.TotalReadyAnalyzerPods
	}
	return 0
}

func (m *ScannerHealthInfo) GetTotalDesiredDbPods() int32 {
	if x, ok := m.GetTotalDesiredDbPodsOpt().(*ScannerHealthInfo_TotalDesiredDbPods); ok {
		return x.TotalDesiredDbPods
	}
	return 0
}

func (m *ScannerHealthInfo) GetTotalReadyDbPods() int32 {
	if x, ok := m.GetTotalReadyDbPodsOpt().(*ScannerHealthInfo_TotalReadyDbPods); ok {
		return x.TotalReadyDbPods
	}
	return 0
}

func (m *ScannerHealthInfo) GetStatusErrors() []string {
	if m != nil {
		return m.StatusErrors
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ScannerHealthInfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ScannerHealthInfo_TotalDesiredAnalyzerPods)(nil),
		(*ScannerHealthInfo_TotalReadyAnalyzerPods)(nil),
		(*ScannerHealthInfo_TotalDesiredDbPods)(nil),
		(*ScannerHealthInfo_TotalReadyDbPods)(nil),
	}
}

func (m *ScannerHealthInfo) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ScannerHealthInfo) Clone() *ScannerHealthInfo {
	if m == nil {
		return nil
	}
	cloned := new(ScannerHealthInfo)
	*cloned = *m

	if m.TotalDesiredAnalyzerPodsOpt != nil {
		cloned.TotalDesiredAnalyzerPodsOpt = m.TotalDesiredAnalyzerPodsOpt.Clone()
	}
	if m.TotalReadyAnalyzerPodsOpt != nil {
		cloned.TotalReadyAnalyzerPodsOpt = m.TotalReadyAnalyzerPodsOpt.Clone()
	}
	if m.TotalDesiredDbPodsOpt != nil {
		cloned.TotalDesiredDbPodsOpt = m.TotalDesiredDbPodsOpt.Clone()
	}
	if m.TotalReadyDbPodsOpt != nil {
		cloned.TotalReadyDbPodsOpt = m.TotalReadyDbPodsOpt.Clone()
	}
	if m.StatusErrors != nil {
		cloned.StatusErrors = make([]string, len(m.StatusErrors))
		copy(cloned.StatusErrors, m.StatusErrors)
	}
	return cloned
}

func init() {
	proto.RegisterEnum("storage.ClusterType", ClusterType_name, ClusterType_value)
	proto.RegisterEnum("storage.CollectionMethod", CollectionMethod_name, CollectionMethod_value)
	proto.RegisterEnum("storage.ManagerType", ManagerType_name, ManagerType_value)
	proto.RegisterEnum("storage.ClusterMetadata_Type", ClusterMetadata_Type_name, ClusterMetadata_Type_value)
	proto.RegisterEnum("storage.ClusterUpgradeStatus_Upgradability", ClusterUpgradeStatus_Upgradability_name, ClusterUpgradeStatus_Upgradability_value)
	proto.RegisterEnum("storage.ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType", ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType_name, ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType_value)
	proto.RegisterEnum("storage.UpgradeProgress_UpgradeState", UpgradeProgress_UpgradeState_name, UpgradeProgress_UpgradeState_value)
	proto.RegisterEnum("storage.ClusterHealthStatus_HealthStatusLabel", ClusterHealthStatus_HealthStatusLabel_name, ClusterHealthStatus_HealthStatusLabel_value)
	proto.RegisterType((*ClusterMetadata)(nil), "storage.ClusterMetadata")
	proto.RegisterType((*GoogleProviderMetadata)(nil), "storage.GoogleProviderMetadata")
	proto.RegisterType((*AWSProviderMetadata)(nil), "storage.AWSProviderMetadata")
	proto.RegisterType((*AzureProviderMetadata)(nil), "storage.AzureProviderMetadata")
	proto.RegisterType((*ProviderMetadata)(nil), "storage.ProviderMetadata")
	proto.RegisterType((*OrchestratorMetadata)(nil), "storage.OrchestratorMetadata")
	proto.RegisterType((*AdmissionControllerConfig)(nil), "storage.AdmissionControllerConfig")
	proto.RegisterType((*TolerationsConfig)(nil), "storage.TolerationsConfig")
	proto.RegisterType((*StaticClusterConfig)(nil), "storage.StaticClusterConfig")
	proto.RegisterType((*DynamicClusterConfig)(nil), "storage.DynamicClusterConfig")
	proto.RegisterType((*CompleteClusterConfig)(nil), "storage.CompleteClusterConfig")
	proto.RegisterMapType((map[string]string)(nil), "storage.CompleteClusterConfig.ClusterLabelsEntry")
	proto.RegisterType((*SensorDeploymentIdentification)(nil), "storage.SensorDeploymentIdentification")
	proto.RegisterType((*Cluster)(nil), "storage.Cluster")
	proto.RegisterMapType((map[string]*AuditLogFileState)(nil), "storage.Cluster.AuditLogStateEntry")
	proto.RegisterMapType((map[string]string)(nil), "storage.Cluster.LabelsEntry")
	proto.RegisterType((*ClusterCertExpiryStatus)(nil), "storage.ClusterCertExpiryStatus")
	proto.RegisterType((*ClusterStatus)(nil), "storage.ClusterStatus")
	proto.RegisterType((*ClusterUpgradeStatus)(nil), "storage.ClusterUpgradeStatus")
	proto.RegisterType((*ClusterUpgradeStatus_UpgradeProcessStatus)(nil), "storage.ClusterUpgradeStatus.UpgradeProcessStatus")
	proto.RegisterType((*UpgradeProgress)(nil), "storage.UpgradeProgress")
	proto.RegisterType((*AuditLogFileState)(nil), "storage.AuditLogFileState")
	proto.RegisterType((*ClusterHealthStatus)(nil), "storage.ClusterHealthStatus")
	proto.RegisterType((*CollectorHealthInfo)(nil), "storage.CollectorHealthInfo")
	proto.RegisterType((*AdmissionControlHealthInfo)(nil), "storage.AdmissionControlHealthInfo")
	proto.RegisterType((*ScannerHealthInfo)(nil), "storage.ScannerHealthInfo")
}

func init() { proto.RegisterFile("storage/cluster.proto", fileDescriptor_bd4108636841f8d0) }

var fileDescriptor_bd4108636841f8d0 = []byte{
	// 3412 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x3a, 0x3d, 0x73, 0xe3, 0x48,
	0x76, 0xe2, 0x87, 0x24, 0xea, 0x51, 0xa4, 0xc0, 0x26, 0x25, 0x51, 0x1c, 0x49, 0xd4, 0x62, 0x6e,
	0x6a, 0x75, 0xbb, 0x33, 0x9c, 0x3d, 0xed, 0xd4, 0x79, 0x77, 0xaf, 0xec, 0x5b, 0x7e, 0x40, 0x22,
	0x24, 0x8a, 0xe4, 0x35, 0xc9, 0x5d, 0xcf, 0x96, 0xcb, 0x28, 0x88, 0x68, 0x51, 0xb8, 0xa1, 0x00,
	0x1c, 0x00, 0xca, 0xa7, 0xad, 0x72, 0x60, 0xbb, 0x1c, 0xd9, 0x91, 0xa3, 0x4b, 0xd7, 0x91, 0x9d,
	0x3b, 0x70, 0xe0, 0x2a, 0x27, 0x0e, 0x9c, 0xb8, 0xec, 0xc0, 0xce, 0x5c, 0x2a, 0xd7, 0x3a, 0x74,
	0xa6, 0x1f, 0xe0, 0x72, 0x75, 0xa3, 0x41, 0x02, 0x20, 0xa5, 0x99, 0x1d, 0x5f, 0x86, 0x7e, 0x5f,
	0xfd, 0xde, 0xeb, 0xd7, 0xef, 0xa3, 0x49, 0xd8, 0x74, 0x5c, 0xd3, 0x56, 0x47, 0xe4, 0xe5, 0x70,
	0x3c, 0x71, 0x5c, 0x62, 0x57, 0x2c, 0xdb, 0x74, 0x4d, 0xb4, 0xca, 0xc1, 0xa5, 0xc2, 0xc8, 0x1c,
	0x99, 0x0c, 0xf6, 0x92, 0x7e, 0x79, 0xe8, 0x52, 0x79, 0x64, 0x9a, 0xa3, 0x31, 0x79, 0xc9, 0x56,
	0x17, 0x93, 0xcb, 0x97, 0xae, 0x7e, 0x4d, 0x1c, 0x57, 0xbd, 0xb6, 0x3c, 0x02, 0xf1, 0x3f, 0x63,
	0xb0, 0x51, 0xf7, 0x24, 0x9e, 0x13, 0x57, 0xd5, 0x54, 0x57, 0x45, 0x2d, 0x48, 0xba, 0xb7, 0x16,
	0x29, 0xc6, 0x0e, 0x62, 0x87, 0xd9, 0xa3, 0xbd, 0x0a, 0xdf, 0xa2, 0x12, 0xa1, 0xab, 0xf4, 0x6f,
	0x2d, 0x52, 0xdb, 0xb9, 0xbf, 0x2b, 0x6f, 0x3a, 0x44, 0xb5, 0x87, 0x57, 0x5f, 0x88, 0x9c, 0xe2,
	0x80, 0x62, 0x44, 0xcc, 0xa4, 0x20, 0x04, 0x49, 0x43, 0xbd, 0x26, 0xc5, 0xf8, 0x41, 0xec, 0x70,
	0x0d, 0xb3, 0x6f, 0x94, 0x85, 0xb8, 0xae, 0x15, 0x13, 0x0c, 0x12, 0xd7, 0x35, 0xf1, 0x6b, 0x48,
	0x52, 0x16, 0xb4, 0x01, 0xe9, 0x41, 0xbb, 0xd7, 0x95, 0xea, 0xf2, 0xb1, 0x2c, 0x35, 0x84, 0x25,
	0xb4, 0x0a, 0x89, 0xea, 0x59, 0x4f, 0x88, 0xb1, 0x0f, 0xdc, 0x11, 0xe2, 0xf4, 0x43, 0x3a, 0xeb,
	0x09, 0x09, 0xfa, 0x71, 0x72, 0x26, 0x09, 0x49, 0xfa, 0xd1, 0xa9, 0x77, 0x85, 0x65, 0xf6, 0xd1,
	0x6b, 0x08, 0x2b, 0x28, 0x05, 0x49, 0xdc, 0xe9, 0x55, 0x85, 0x55, 0xf1, 0x35, 0x6c, 0x9d, 0x30,
	0x0f, 0x74, 0x6d, 0xf3, 0x46, 0xd7, 0x02, 0x46, 0x16, 0x61, 0xd5, 0xb2, 0xcd, 0x5f, 0x92, 0xa1,
	0xcb, 0xec, 0x5c, 0xc3, 0xfe, 0x12, 0x3d, 0x83, 0x75, 0xee, 0x63, 0x65, 0xa6, 0x78, 0x2d, 0x5e,
	0x8c, 0xe1, 0x34, 0x87, 0xb7, 0xd5, 0x6b, 0x22, 0xbe, 0x82, 0x7c, 0xf5, 0xeb, 0xde, 0x9c, 0xdc,
	0x3d, 0x00, 0x75, 0x38, 0x34, 0x27, 0x86, 0xab, 0xe8, 0x1a, 0x17, 0xbd, 0xc6, 0x21, 0xb2, 0x26,
	0x7e, 0x09, 0x9b, 0xd5, 0x6f, 0x27, 0xf6, 0xbc, 0x3e, 0x1f, 0xc2, 0x86, 0x33, 0xb9, 0x70, 0x86,
	0xb6, 0x6e, 0xb9, 0xba, 0x69, 0xcc, 0x98, 0xb3, 0x41, 0xb0, 0xac, 0x89, 0xff, 0x18, 0x07, 0x61,
	0x8e, 0x7b, 0x0b, 0x56, 0x6c, 0x32, 0xd2, 0x4d, 0x83, 0x33, 0xf1, 0x15, 0x75, 0xfe, 0xb7, 0xa6,
	0x31, 0x75, 0x3e, 0xfd, 0x46, 0x9f, 0xc3, 0x8a, 0x17, 0x15, 0xec, 0x00, 0xd2, 0x47, 0xe5, 0xe9,
	0x01, 0x2f, 0x76, 0x55, 0x73, 0x09, 0x73, 0x06, 0xf4, 0x09, 0x24, 0xd4, 0x3f, 0x72, 0x8a, 0x49,
	0xc6, 0xb7, 0x3b, 0xe5, 0x5b, 0xe0, 0x87, 0xe6, 0x12, 0xa6, 0xa4, 0xe8, 0xa7, 0xb0, 0xac, 0x52,
	0x7b, 0x8b, 0xcb, 0x8c, 0x67, 0x7f, 0xc6, 0xb3, 0xc8, 0x0b, 0xcd, 0x25, 0xec, 0x91, 0xa3, 0x12,
	0xa4, 0x6e, 0x88, 0xad, 0x5f, 0xea, 0x44, 0x2b, 0x6e, 0x1c, 0xc4, 0x0e, 0x53, 0x78, 0xba, 0x46,
	0x47, 0xb0, 0xca, 0x0f, 0xa2, 0x28, 0x30, 0xa9, 0xc5, 0x87, 0x42, 0x14, 0xfb, 0x84, 0x35, 0x80,
	0x94, 0xbf, 0x99, 0xf8, 0x2f, 0x31, 0x28, 0x74, 0xec, 0xe1, 0x15, 0x71, 0x5c, 0x5b, 0x75, 0xcd,
	0x50, 0x4c, 0xdc, 0x10, 0xdb, 0x99, 0xb9, 0xd1, 0x5f, 0xa2, 0x17, 0x90, 0x33, 0x2d, 0x62, 0x38,
	0x57, 0xfa, 0xa5, 0xab, 0xf8, 0x34, 0xd4, 0x0d, 0x6b, 0xcd, 0x25, 0x2c, 0x4c, 0x51, 0x5f, 0x71,
	0xf2, 0xcf, 0x01, 0x2e, 0x26, 0xfa, 0x58, 0x53, 0x34, 0xd5, 0xf5, 0x9c, 0x9f, 0x3e, 0x2a, 0x55,
	0x3c, 0x27, 0x56, 0xfc, 0xbb, 0x58, 0xe9, 0xfb, 0x77, 0x11, 0xaf, 0x31, 0xea, 0x86, 0xea, 0x12,
	0xf4, 0x01, 0xac, 0xab, 0x96, 0xee, 0xef, 0xe1, 0x14, 0x13, 0x07, 0x89, 0xc3, 0x35, 0x9c, 0x56,
	0x2d, 0x9d, 0x0b, 0x77, 0x6a, 0x59, 0x58, 0xd7, 0x1d, 0x65, 0xba, 0xa9, 0xf8, 0xef, 0x31, 0xd8,
	0xa9, 0x6a, 0xd7, 0xba, 0x43, 0xd1, 0x75, 0xd3, 0x70, 0x6d, 0x73, 0x3c, 0x26, 0x76, 0xdd, 0x34,
	0x2e, 0xf5, 0x11, 0x35, 0x8a, 0x18, 0xea, 0xc5, 0x98, 0x78, 0x01, 0x95, 0xc2, 0xfe, 0x92, 0x86,
	0x1c, 0x4d, 0x07, 0xe6, 0xc4, 0x55, 0x1c, 0x32, 0x34, 0x0d, 0xcd, 0x61, 0xaa, 0x2e, 0xe3, 0x2c,
	0x07, 0xf7, 0x3c, 0x28, 0x2a, 0x43, 0xda, 0x19, 0xaa, 0x86, 0xa2, 0x1b, 0x63, 0xdd, 0xf0, 0xc2,
	0x26, 0x85, 0x81, 0x82, 0x64, 0x06, 0x41, 0xcf, 0x20, 0xab, 0xe9, 0x0e, 0x95, 0xaa, 0x5c, 0xdc,
	0x5a, 0xaa, 0xe3, 0x85, 0x48, 0x0a, 0x67, 0x38, 0xb4, 0xc6, 0x80, 0xe8, 0x39, 0x20, 0x62, 0x5c,
	0x9a, 0xf6, 0x90, 0x28, 0xa6, 0xa1, 0x4c, 0x2c, 0xea, 0x1d, 0x87, 0x45, 0x46, 0x0a, 0x0b, 0x1c,
	0xd3, 0x31, 0x06, 0x1e, 0x5c, 0x7c, 0x09, 0xb9, 0xbe, 0x39, 0x26, 0xb6, 0x4a, 0x03, 0xdf, 0xe1,
	0xd6, 0x94, 0x20, 0xc5, 0x65, 0xfa, 0xe6, 0x4c, 0xd7, 0xe2, 0xdf, 0x24, 0x21, 0xdf, 0x73, 0x55,
	0x57, 0x1f, 0xf2, 0x30, 0xe0, 0x3c, 0x87, 0xa1, 0x7c, 0x56, 0x88, 0x06, 0x0b, 0xcd, 0x3c, 0x3c,
	0x57, 0xed, 0x01, 0x5c, 0xab, 0xba, 0xa1, 0xe8, 0xd7, 0xea, 0xc8, 0xbf, 0x34, 0x6b, 0x14, 0x22,
	0x53, 0x00, 0xfa, 0x04, 0x0a, 0x43, 0x62, 0xb8, 0xb6, 0x3a, 0x56, 0xe8, 0x19, 0x11, 0x43, 0xb3,
	0x4c, 0xdd, 0x70, 0x79, 0x22, 0x43, 0x1c, 0x57, 0xb5, 0x74, 0x89, 0x63, 0xd0, 0x31, 0xe4, 0x86,
	0xf4, 0x30, 0x86, 0xec, 0x4e, 0x5f, 0x13, 0xf7, 0xca, 0xd4, 0x98, 0x6f, 0xb2, 0x47, 0x3b, 0x33,
	0x3d, 0xa6, 0x14, 0xe7, 0x8c, 0x00, 0x0b, 0xc3, 0x08, 0x84, 0x1e, 0x15, 0x87, 0x99, 0x36, 0xd7,
	0x6e, 0xd9, 0xcb, 0x0e, 0x53, 0xb0, 0xa7, 0xe2, 0x4f, 0xa0, 0xa0, 0xfa, 0xa1, 0xa0, 0x0c, 0xa7,
	0xb1, 0x50, 0x5c, 0x61, 0xbe, 0xca, 0xab, 0xf3, 0x61, 0x82, 0xbe, 0x84, 0xdd, 0x45, 0x2c, 0xd3,
	0xf3, 0x59, 0x65, 0xac, 0xa5, 0x05, 0xac, 0xfc, 0xa4, 0x90, 0x0c, 0xc8, 0x9d, 0x9d, 0x14, 0x95,
	0x71, 0xa9, 0x8f, 0x8a, 0x29, 0x1e, 0xf6, 0xbe, 0x99, 0x73, 0x87, 0x89, 0x73, 0xee, 0xdc, 0xf9,
	0x3e, 0x83, 0xac, 0x33, 0xd6, 0xaf, 0x95, 0xa9, 0x59, 0xc5, 0x35, 0x2f, 0x92, 0x28, 0xb4, 0xee,
	0x03, 0xd1, 0xef, 0xc1, 0x93, 0x85, 0x3a, 0x93, 0x1b, 0x62, 0xb8, 0x4e, 0x11, 0x18, 0xcf, 0xce,
	0x02, 0x95, 0x25, 0x46, 0x20, 0xfe, 0x47, 0x0c, 0x0a, 0x8d, 0x5b, 0x43, 0xbd, 0x8e, 0xc6, 0xca,
	0xc5, 0x03, 0x82, 0xb9, 0x4d, 0x31, 0x66, 0x93, 0x38, 0xcb, 0x62, 0x0f, 0x5d, 0xbb, 0x85, 0x9b,
	0xf3, 0x3d, 0x3e, 0x86, 0x1c, 0x4d, 0xcf, 0x8e, 0x6b, 0xdf, 0x2a, 0xe6, 0x0d, 0xb1, 0x6d, 0x5d,
	0xf3, 0x83, 0x4d, 0xf0, 0x11, 0x1d, 0x0e, 0xa7, 0x77, 0xc6, 0xbf, 0x5a, 0xea, 0x44, 0xd3, 0x5d,
	0x65, 0x6c, 0x8e, 0x1c, 0x7e, 0x05, 0x05, 0x8e, 0xa9, 0x52, 0x44, 0xcb, 0x1c, 0x39, 0xe2, 0xff,
	0xc4, 0x61, 0xb3, 0x6e, 0x5e, 0x5b, 0x63, 0xe2, 0x92, 0xb0, 0x61, 0x0d, 0xc8, 0x6a, 0x9e, 0xc1,
	0x61, 0x5b, 0x66, 0xe5, 0x7d, 0x91, 0x3f, 0x70, 0x86, 0x33, 0x71, 0x29, 0x55, 0xc8, 0x38, 0xec,
	0x86, 0xf9, 0x42, 0xe2, 0x91, 0x52, 0xb0, 0xe0, 0xfe, 0xe1, 0x75, 0x8f, 0x85, 0x8b, 0x78, 0x01,
	0xc8, 0xe3, 0x55, 0x2e, 0x75, 0x63, 0x44, 0x6c, 0xcb, 0x9e, 0x5d, 0xa1, 0x9c, 0x87, 0x39, 0x9e,
	0x21, 0xd0, 0xef, 0x43, 0xd6, 0xaf, 0xc6, 0x63, 0xf5, 0x82, 0x8c, 0x69, 0x6a, 0x49, 0x1c, 0xa6,
	0x8f, 0x7e, 0x12, 0xb8, 0x3e, 0x0b, 0xec, 0xf5, 0x2f, 0x77, 0x8b, 0xf1, 0x48, 0x86, 0x6b, 0xdf,
	0xe2, 0xcc, 0x30, 0x08, 0x2b, 0x7d, 0x09, 0x68, 0x9e, 0x08, 0x09, 0x90, 0x78, 0x43, 0x6e, 0x79,
	0xfe, 0xa7, 0x9f, 0xa8, 0x00, 0xcb, 0x37, 0xea, 0x78, 0xe2, 0x1f, 0x91, 0xb7, 0xf8, 0x22, 0xfe,
	0x59, 0x4c, 0xfc, 0xdb, 0x38, 0xec, 0xf7, 0x88, 0xe1, 0x98, 0x76, 0x83, 0x58, 0x63, 0xf3, 0xf6,
	0x9a, 0xd0, 0x1a, 0x4f, 0x0c, 0x57, 0xbf, 0xd4, 0x87, 0x2c, 0xac, 0x51, 0x05, 0xf2, 0xce, 0xad,
	0xe3, 0x92, 0x6b, 0xd6, 0x4b, 0x38, 0x96, 0x3a, 0x24, 0xb3, 0xd2, 0x9e, 0xf3, 0x50, 0x6d, 0x1f,
	0x23, 0x6b, 0x34, 0xc5, 0x68, 0xe4, 0x52, 0x9d, 0x8c, 0xdd, 0x30, 0x83, 0xb7, 0x37, 0xe2, 0xb8,
	0x20, 0xc7, 0x53, 0xc8, 0xa8, 0x96, 0x35, 0xa3, 0xe6, 0xae, 0x5c, 0x57, 0x2d, 0x6b, 0x4a, 0x86,
	0x0e, 0x41, 0x08, 0x11, 0x51, 0x91, 0x49, 0x2f, 0x81, 0x04, 0xe9, 0x64, 0x5a, 0x5c, 0x37, 0x29,
	0xa5, 0x43, 0xec, 0x1b, 0x7d, 0x48, 0x02, 0xad, 0x8c, 0x97, 0x6f, 0xf2, 0xaa, 0x65, 0xf5, 0x42,
	0x38, 0x59, 0x43, 0x22, 0x64, 0xde, 0x7c, 0xe6, 0x28, 0x86, 0xa9, 0x11, 0xaf, 0x65, 0x5a, 0x61,
	0xb4, 0xe9, 0x37, 0x9f, 0x39, 0x6d, 0x53, 0x23, 0xac, 0x5d, 0xfa, 0xcb, 0x75, 0x58, 0xe5, 0xee,
	0x46, 0x4d, 0xd6, 0xfe, 0x31, 0x1f, 0xd4, 0x3e, 0xbb, 0xbf, 0x2b, 0xbf, 0x8a, 0xf6, 0x8f, 0x72,
	0xe3, 0xf9, 0x95, 0xae, 0x69, 0xc4, 0x78, 0x4e, 0x0f, 0x99, 0x88, 0x07, 0xce, 0xaf, 0xc6, 0x5f,
	0x88, 0xd6, 0x9b, 0xe7, 0x34, 0x4b, 0x1f, 0x4e, 0x26, 0xba, 0xf6, 0x63, 0x91, 0x36, 0x8e, 0xe8,
	0x67, 0xc1, 0xe6, 0xb2, 0xf6, 0xe1, 0xfd, 0x5d, 0xf9, 0x69, 0x44, 0x56, 0x48, 0xc2, 0xc4, 0xd0,
	0x7f, 0x35, 0xa1, 0x9d, 0x29, 0xeb, 0x42, 0xfd, 0xba, 0x90, 0x78, 0x6b, 0x5d, 0xe8, 0xc2, 0x0a,
	0x0f, 0xbe, 0x27, 0x2c, 0xf8, 0x76, 0xa3, 0xb4, 0x95, 0x40, 0x08, 0xd5, 0x4a, 0xf7, 0x77, 0xe5,
	0xad, 0xa8, 0x49, 0x8c, 0x40, 0xc4, 0x5c, 0x4e, 0xa4, 0xd2, 0x24, 0xa3, 0x95, 0x66, 0x41, 0xbe,
	0x17, 0x16, 0xe6, 0xfb, 0x87, 0x4a, 0xd2, 0xf2, 0x83, 0x25, 0xe9, 0x63, 0xd8, 0xb0, 0x27, 0x06,
	0xad, 0xf0, 0x8a, 0x33, 0xb1, 0x2c, 0xd3, 0x76, 0xbd, 0x0c, 0xcf, 0x3a, 0xdc, 0x2c, 0x47, 0xf5,
	0x3c, 0xcc, 0xe2, 0xfa, 0x95, 0xfb, 0xe1, 0xf5, 0xeb, 0xa1, 0xb2, 0x94, 0x79, 0xff, 0xb2, 0xb4,
	0xf9, 0xd6, 0xb2, 0xf4, 0x96, 0x22, 0xb1, 0xf3, 0x96, 0x22, 0x81, 0x2a, 0xb0, 0x42, 0x33, 0xd7,
	0xc4, 0x61, 0x1d, 0x68, 0xfa, 0x68, 0x2b, 0x7a, 0xea, 0x3d, 0x86, 0xc5, 0x9c, 0x6a, 0x41, 0x8a,
	0x45, 0xef, 0x91, 0x62, 0x17, 0x17, 0xd3, 0xfc, 0xfb, 0x14, 0xd3, 0x12, 0xa4, 0x2c, 0x5b, 0x37,
	0x6d, 0xdd, 0xbd, 0x2d, 0x16, 0x0e, 0x62, 0x87, 0x09, 0x3c, 0x5d, 0xa3, 0x36, 0x64, 0xae, 0x88,
	0x3a, 0x76, 0xaf, 0x14, 0x6e, 0xe3, 0x56, 0x24, 0x93, 0x73, 0x25, 0x9b, 0x8c, 0xc8, 0xb3, 0xb4,
	0x96, 0xbe, 0xbf, 0x2b, 0xaf, 0xb2, 0x9b, 0xf4, 0x42, 0xc4, 0xeb, 0x57, 0x01, 0xd4, 0x82, 0xc2,
	0xbd, 0xbd, 0xa8, 0x70, 0xff, 0x1c, 0xd2, 0x57, 0x64, 0x7c, 0xed, 0x9b, 0x55, 0x8c, 0x4c, 0x05,
	0x0b, 0x73, 0x39, 0x06, 0xca, 0xc2, 0x6d, 0xfa, 0x06, 0x36, 0xaf, 0x4d, 0xc7, 0x55, 0x6c, 0x42,
	0x63, 0x5b, 0x71, 0x58, 0xfa, 0xa5, 0xf9, 0xa9, 0xc4, 0x44, 0x7d, 0x38, 0xab, 0x44, 0x8f, 0x26,
	0x66, 0x8c, 0xa8, 0x14, 0xcc, 0x84, 0x78, 0x94, 0xb2, 0x86, 0xce, 0x60, 0x63, 0x5a, 0x63, 0x99,
	0x5b, 0x48, 0x71, 0x97, 0xdd, 0xf7, 0xa7, 0x73, 0xf7, 0xdd, 0x2f, 0xb9, 0xd4, 0x7a, 0xc2, 0xcb,
	0x8b, 0x1a, 0x84, 0xa1, 0x1f, 0x41, 0x56, 0x37, 0x74, 0x57, 0xb9, 0x98, 0x18, 0xda, 0x98, 0x25,
	0xdc, 0x3d, 0x2f, 0x31, 0x53, 0x68, 0x8d, 0x01, 0x65, 0x0d, 0x7d, 0x4a, 0xf3, 0x80, 0xa1, 0x8e,
	0x88, 0xa6, 0x5c, 0xdc, 0x16, 0xf7, 0x23, 0x99, 0xe8, 0x9c, 0xa1, 0xbc, 0x4c, 0xb4, 0xc6, 0xe9,
	0x6a, 0xb7, 0xa5, 0xcf, 0x21, 0xfd, 0x9e, 0x25, 0xab, 0xf4, 0x07, 0x80, 0xe6, 0x55, 0x5f, 0x20,
	0xe1, 0x93, 0xa0, 0x84, 0x60, 0xe0, 0xf9, 0xdc, 0xc7, 0xfa, 0x98, 0x30, 0x09, 0x01, 0xe9, 0xa7,
	0xc9, 0xd4, 0x8a, 0xb0, 0x7a, 0x9a, 0x4c, 0xa5, 0x84, 0xb5, 0xd3, 0x64, 0x6a, 0x4d, 0x80, 0xd3,
	0x64, 0x0a, 0x84, 0xf4, 0x69, 0x32, 0x95, 0x16, 0xd6, 0x4f, 0x93, 0xa9, 0x75, 0x21, 0x73, 0x9a,
	0x4c, 0x65, 0x85, 0x0d, 0xf1, 0xef, 0x62, 0xb0, 0xed, 0x1f, 0x32, 0xb1, 0x5d, 0xe9, 0xd7, 0x96,
	0x6e, 0xdf, 0xf2, 0x50, 0x6a, 0x02, 0xe2, 0xc7, 0x3a, 0x24, 0xb6, 0xab, 0x10, 0x86, 0xe3, 0xed,
	0xca, 0x63, 0x53, 0x94, 0xe0, 0x71, 0xcd, 0xe4, 0xa1, 0x0e, 0x6c, 0x05, 0x25, 0x19, 0xa6, 0xab,
	0x5c, 0x90, 0x4b, 0xd3, 0x7e, 0x97, 0x99, 0x2c, 0x3f, 0x93, 0xd6, 0x36, 0xdd, 0x1a, 0x63, 0x13,
	0xff, 0x21, 0x01, 0x99, 0xd0, 0xe5, 0x67, 0x71, 0xef, 0x6d, 0x11, 0x1e, 0x1d, 0x33, 0x1e, 0xd4,
	0x9f, 0x08, 0x31, 0x6c, 0x37, 0xa4, 0x2e, 0x96, 0xea, 0xd5, 0xbe, 0xd4, 0x50, 0xc6, 0xaa, 0xe3,
	0xb2, 0x8c, 0xa4, 0x0e, 0xdd, 0x77, 0x50, 0x65, 0x73, 0xc6, 0xda, 0x52, 0x1d, 0xb7, 0xee, 0x31,
	0xd2, 0xe4, 0x6c, 0xf1, 0x99, 0x96, 0xa6, 0x66, 0x36, 0xc3, 0xf2, 0x99, 0x7e, 0x96, 0x9c, 0xa3,
	0x23, 0x36, 0x16, 0xac, 0xe8, 0xe3, 0x01, 0x86, 0x4d, 0x33, 0x30, 0x0e, 0xcf, 0x64, 0x25, 0x23,
	0xe9, 0x6b, 0xd1, 0xd0, 0x8c, 0x0b, 0xe6, 0xa2, 0x51, 0xba, 0x01, 0xd9, 0x89, 0x35, 0xb2, 0x55,
	0x8d, 0xf8, 0xf9, 0x65, 0x39, 0x22, 0x8c, 0xbb, 0x71, 0xe0, 0x51, 0xf1, 0x54, 0x9a, 0x99, 0x04,
	0x97, 0xa8, 0x0d, 0x28, 0x10, 0x02, 0xbe, 0xa4, 0x15, 0x26, 0xe9, 0x20, 0x2a, 0x29, 0x1a, 0x47,
	0x58, 0x18, 0x46, 0x20, 0xe2, 0x77, 0x2b, 0x50, 0x58, 0xb4, 0x2f, 0xfa, 0x05, 0xf0, 0x9d, 0xd5,
	0x0b, 0x7d, 0x4c, 0xd3, 0xa5, 0x37, 0x2b, 0x7e, 0xfc, 0xa8, 0xb6, 0x95, 0x41, 0x90, 0x05, 0x87,
	0x25, 0xd0, 0xea, 0x13, 0x02, 0x70, 0xed, 0x15, 0x9b, 0xa8, 0x8e, 0x69, 0xf0, 0x9b, 0xb9, 0x13,
	0x22, 0xe1, 0x7a, 0x33, 0x02, 0x74, 0x01, 0xf9, 0x60, 0xa2, 0xb3, 0x6c, 0x73, 0x48, 0x1c, 0x87,
	0x9f, 0xef, 0xd1, 0xbb, 0x28, 0x46, 0xba, 0x1e, 0x0f, 0x17, 0x9b, 0x9b, 0x65, 0x3c, 0x8e, 0x28,
	0xfd, 0x55, 0x02, 0x0a, 0x8b, 0x68, 0xd1, 0x16, 0xac, 0xa8, 0x43, 0x57, 0xbf, 0x21, 0x7c, 0xc8,
	0xe6, 0x2b, 0xfe, 0x70, 0x17, 0xf7, 0x1f, 0xee, 0x68, 0xf4, 0xbb, 0xaa, 0x3d, 0x22, 0xb3, 0x47,
	0x11, 0xaf, 0xfb, 0xcc, 0x78, 0x50, 0x3f, 0xfa, 0x9f, 0x4d, 0xa3, 0xc1, 0x0e, 0x75, 0x3c, 0xfe,
	0x71, 0xf3, 0x66, 0xe6, 0x77, 0x81, 0x25, 0x47, 0x5d, 0x75, 0x89, 0xa6, 0xa8, 0x2e, 0x0f, 0x99,
	0xc7, 0x6e, 0x46, 0x7a, 0x4a, 0x5f, 0x75, 0xd1, 0x2b, 0x5a, 0xee, 0xcc, 0x91, 0x4d, 0xdd, 0xb4,
	0x12, 0x79, 0x18, 0x9a, 0x59, 0xc9, 0xf0, 0x78, 0x4a, 0x89, 0x5e, 0xf3, 0x2e, 0x70, 0x95, 0x9d,
	0xb8, 0xf4, 0xc3, 0x1d, 0x1b, 0x01, 0xce, 0xda, 0x46, 0xf1, 0x15, 0xa0, 0x79, 0x1c, 0x4a, 0xc3,
	0xea, 0xa0, 0x7b, 0x82, 0xab, 0x0d, 0x49, 0x58, 0x42, 0x39, 0xc8, 0xd4, 0x25, 0xdc, 0x57, 0x70,
	0xa7, 0x5f, 0xed, 0xcb, 0x9d, 0xb6, 0x10, 0x13, 0xff, 0x18, 0x32, 0xa1, 0xc0, 0x42, 0x6b, 0xb0,
	0x3c, 0x68, 0xf7, 0xa4, 0xbe, 0xb0, 0x84, 0xb2, 0x00, 0x83, 0xae, 0xd2, 0xef, 0x28, 0x8d, 0x6a,
	0x5f, 0x12, 0x62, 0xe8, 0x09, 0x6c, 0x9f, 0x57, 0xdb, 0x83, 0x6a, 0x4b, 0xe1, 0x22, 0x15, 0x2c,
	0xfd, 0x62, 0x20, 0x63, 0xa9, 0x21, 0xc4, 0xd1, 0x0e, 0x6c, 0x56, 0x07, 0xfd, 0xce, 0x14, 0xd5,
	0xed, 0xf4, 0x7a, 0x72, 0xad, 0x25, 0x09, 0x09, 0x8a, 0xea, 0x49, 0xed, 0x5e, 0x07, 0x2b, 0x5f,
	0x49, 0xb8, 0x27, 0x77, 0xda, 0x4a, 0x53, 0x3e, 0x69, 0x4a, 0x58, 0x48, 0x8a, 0xff, 0x94, 0x84,
	0x8d, 0x88, 0xb7, 0xd0, 0xa9, 0x7f, 0x3d, 0x08, 0x2f, 0x8b, 0xde, 0xf5, 0x78, 0xf6, 0x90, 0x7b,
	0x2b, 0x01, 0xaf, 0x11, 0xbc, 0x1e, 0xb8, 0xd4, 0x84, 0x0e, 0x18, 0xe1, 0xcc, 0xa0, 0x68, 0xc4,
	0x55, 0xf5, 0x31, 0x8f, 0xaa, 0x7c, 0x28, 0x03, 0x34, 0x18, 0x8a, 0x56, 0x23, 0x47, 0x37, 0x86,
	0xfe, 0x8b, 0xe5, 0x63, 0x11, 0xe1, 0x11, 0x8a, 0xff, 0x1b, 0x87, 0xf5, 0xa0, 0x12, 0xa8, 0x08,
	0x05, 0xdf, 0x0f, 0x72, 0x5b, 0xee, 0xcb, 0xd5, 0x96, 0xfc, 0x8d, 0xdc, 0x3e, 0x11, 0x96, 0xd0,
	0x16, 0x20, 0x8e, 0xc1, 0x4a, 0xab, 0x3a, 0x68, 0xd7, 0x9b, 0x14, 0x1e, 0x43, 0x9b, 0x90, 0x8b,
	0xc0, 0x99, 0x57, 0xf7, 0xa1, 0xd4, 0xc5, 0x92, 0x72, 0xdc, 0x92, 0x4f, 0x9a, 0x7d, 0xa5, 0xde,
	0x94, 0xea, 0x67, 0x3d, 0xa5, 0xde, 0x39, 0xef, 0xb6, 0xa4, 0x3e, 0x75, 0xed, 0x13, 0xd8, 0xf6,
	0x37, 0xea, 0x74, 0x25, 0xcc, 0x4e, 0xb5, 0xa7, 0x34, 0x3a, 0x6d, 0x49, 0x48, 0xa2, 0x02, 0x08,
	0x3e, 0x72, 0xca, 0x02, 0xe8, 0x00, 0x76, 0xe7, 0x74, 0x63, 0x7c, 0x8a, 0x84, 0x71, 0x07, 0x0b,
	0x69, 0xb4, 0x0b, 0xc5, 0xf9, 0x4d, 0x8f, 0xab, 0x72, 0x4b, 0x6a, 0x08, 0xeb, 0x54, 0x25, 0x9f,
	0x9f, 0x31, 0x28, 0xb8, 0xd3, 0x6a, 0xc9, 0xed, 0x13, 0xa5, 0x56, 0xad, 0x9f, 0x09, 0x19, 0xb4,
	0x07, 0x3b, 0xf3, 0x78, 0xa9, 0xe1, 0xa1, 0xb3, 0xe8, 0x03, 0xd8, 0x9b, 0x47, 0x53, 0x9c, 0xbf,
	0xc3, 0x06, 0x8d, 0x97, 0x30, 0xc9, 0xa0, 0x7d, 0xd6, 0xee, 0x7c, 0xdd, 0x16, 0x84, 0x80, 0x9b,
	0x94, 0xbe, 0x7c, 0x2e, 0x35, 0x94, 0xce, 0xa0, 0x2f, 0xe4, 0xc4, 0x3f, 0x89, 0x41, 0x6e, 0xae,
	0x57, 0xa0, 0xa5, 0x9d, 0x37, 0x88, 0xec, 0x1d, 0x43, 0xf1, 0x4e, 0xf5, 0x1d, 0x4a, 0x3b, 0xe7,
	0x6a, 0x99, 0x23, 0xa7, 0x47, 0x79, 0xe8, 0xcc, 0xc9, 0xaa, 0xa8, 0xd7, 0xb0, 0x4d, 0x93, 0x52,
	0x9a, 0x02, 0xd9, 0xbe, 0xb2, 0x26, 0x7e, 0x07, 0x90, 0x5f, 0xd0, 0xc6, 0xa2, 0x13, 0x96, 0xc5,
	0xd6, 0xd8, 0xcc, 0xf8, 0x3b, 0xf7, 0x77, 0xe5, 0x4f, 0xfd, 0xf1, 0xf2, 0xf2, 0xcd, 0x21, 0xa7,
	0xff, 0x42, 0xd7, 0x7e, 0xfc, 0xdc, 0x30, 0x5f, 0x5c, 0xbe, 0x79, 0x31, 0x34, 0x0d, 0x5a, 0xdd,
	0x74, 0xc3, 0x9d, 0x1b, 0x3f, 0xbb, 0xb0, 0x39, 0x1b, 0xd3, 0x78, 0x3b, 0xad, 0x1b, 0x97, 0x26,
	0xb7, 0x68, 0x37, 0x3a, 0x22, 0x99, 0x5c, 0x0f, 0xd9, 0xb8, 0x34, 0x71, 0x7e, 0x38, 0x0f, 0x44,
	0x97, 0xb0, 0x37, 0x37, 0xb3, 0x84, 0x24, 0x7b, 0xaf, 0x6a, 0x4f, 0x1f, 0x7c, 0x81, 0x0a, 0x6c,
	0x30, 0x37, 0x1b, 0x05, 0xf6, 0x39, 0x85, 0xbc, 0x33, 0x54, 0x0d, 0x83, 0x84, 0xf5, 0x86, 0x48,
	0xb7, 0xd7, 0xf3, 0x68, 0x02, 0x42, 0x73, 0x4e, 0x14, 0x84, 0xfe, 0x34, 0x06, 0x05, 0xde, 0x03,
	0x85, 0x47, 0x8a, 0x38, 0xcb, 0x12, 0x95, 0xc7, 0x46, 0x8a, 0x4a, 0x70, 0xc1, 0x9a, 0xda, 0xda,
	0xc1, 0xfd, 0x5d, 0x79, 0xd7, 0x1f, 0x9f, 0xbd, 0xde, 0xfc, 0xc0, 0xc3, 0xf3, 0x59, 0x1e, 0xf3,
	0xf6, 0x30, 0x74, 0xa6, 0x7f, 0x11, 0x83, 0xed, 0xb9, 0xb3, 0xe0, 0x7a, 0x24, 0xde, 0x4b, 0x8f,
	0xa7, 0xf7, 0x77, 0xe5, 0xf2, 0x74, 0x8c, 0xf7, 0x45, 0x47, 0x54, 0xd9, 0x8c, 0x1c, 0x22, 0xd7,
	0xe6, 0xcf, 0x63, 0xb0, 0x69, 0xde, 0x10, 0x5b, 0x1d, 0x8f, 0x23, 0xba, 0x24, 0xdf, 0x4b, 0x97,
	0x0f, 0xee, 0xef, 0xca, 0x7b, 0xd1, 0x27, 0x85, 0xb0, 0x26, 0x79, 0xbe, 0x5f, 0x48, 0x8f, 0xbf,
	0x8e, 0x41, 0xf9, 0xc1, 0x78, 0xe2, 0x1a, 0xad, 0xbe, 0x97, 0x46, 0x1f, 0xdf, 0xdf, 0x95, 0x3f,
	0xf4, 0x35, 0x9a, 0x06, 0xe1, 0x01, 0x8f, 0xb4, 0x88, 0x6e, 0xbb, 0x8b, 0x23, 0x31, 0xe0, 0xac,
	0x48, 0x30, 0x72, 0xd5, 0xd2, 0xff, 0x7f, 0x67, 0xf1, 0x08, 0x8e, 0x3a, 0x2b, 0x14, 0xc5, 0x5c,
	0x8f, 0x3f, 0x84, 0xf5, 0x50, 0x63, 0xfe, 0xd6, 0xf6, 0xa3, 0x56, 0xbe, 0xbf, 0x2b, 0x3f, 0xf1,
	0x77, 0xa2, 0xad, 0xf9, 0x01, 0xef, 0xcd, 0xfd, 0x7d, 0x58, 0x3a, 0xf2, 0xfb, 0xf5, 0x4f, 0xa0,
	0x10, 0xb8, 0x6b, 0xca, 0x90, 0xcf, 0xba, 0xfc, 0x6d, 0x1e, 0x5d, 0x4d, 0x6f, 0x94, 0x3f, 0x05,
	0x8b, 0x2a, 0xe4, 0xe6, 0xcc, 0xa3, 0x2d, 0xc3, 0xa0, 0x3d, 0xad, 0x13, 0xec, 0x67, 0x52, 0xf6,
	0xbb, 0x69, 0xf5, 0xab, 0xaa, 0xdc, 0xaa, 0xd2, 0xfa, 0x1e, 0x43, 0x19, 0x58, 0x1b, 0xb4, 0x9b,
	0x52, 0xb5, 0xd5, 0x6f, 0xbe, 0x16, 0xe2, 0x68, 0x1d, 0x52, 0x0d, 0x89, 0xe5, 0xe8, 0x86, 0x90,
	0xa0, 0x0d, 0x88, 0x8f, 0x4a, 0x8a, 0x7f, 0x1f, 0x87, 0xfc, 0x82, 0xec, 0xf4, 0xc8, 0x6f, 0x61,
	0x15, 0x40, 0xae, 0xe9, 0xaa, 0x63, 0x45, 0x23, 0x8e, 0x6e, 0x13, 0x4d, 0xb1, 0x4c, 0xff, 0x97,
	0xa3, 0xe6, 0x12, 0x16, 0x18, 0xae, 0xe1, 0xa1, 0xba, 0xa6, 0xe6, 0xa0, 0x8f, 0xc0, 0x83, 0xd1,
	0xce, 0x57, 0xbb, 0xf5, 0xa8, 0x13, 0x8c, 0x3a, 0x86, 0xb3, 0x0c, 0x83, 0x29, 0x82, 0xd1, 0xfe,
	0x14, 0xb6, 0x7c, 0xda, 0x91, 0x4e, 0x8f, 0x9a, 0x68, 0xec, 0x59, 0xd1, 0xbb, 0x37, 0xcb, 0xcd,
	0x38, 0x2e, 0x70, 0x0e, 0x1f, 0xdd, 0xa6, 0x58, 0xf4, 0xd4, 0x7b, 0x97, 0x9e, 0x38, 0x0a, 0xb1,
	0x6d, 0xd3, 0xa6, 0xd3, 0x46, 0x82, 0xce, 0xda, 0x1e, 0x50, 0x62, 0xb0, 0x5a, 0xd1, 0x17, 0x1e,
	0x54, 0x5c, 0x31, 0x2d, 0xb7, 0xb6, 0x05, 0x85, 0xa8, 0x8a, 0x0c, 0xbe, 0x0b, 0xa5, 0xc5, 0xea,
	0x50, 0xac, 0xf8, 0xaf, 0x31, 0x28, 0x3d, 0x9c, 0x7e, 0x1f, 0xf0, 0x53, 0xec, 0x07, 0xf9, 0x29,
	0xfe, 0x80, 0x9f, 0xe6, 0xec, 0x4d, 0xfc, 0x36, 0xec, 0x15, 0x7f, 0x93, 0x80, 0xdc, 0x5c, 0xca,
	0x47, 0x3f, 0x87, 0x27, 0x61, 0x39, 0xaa, 0xa1, 0x8e, 0x6f, 0xbf, 0x25, 0x76, 0xd8, 0xa2, 0x62,
	0xd0, 0xa2, 0x2a, 0x27, 0x61, 0xda, 0xfe, 0x0c, 0x76, 0x82, 0xdb, 0x85, 0xd9, 0x7d, 0x13, 0xb7,
	0x66, 0x26, 0x86, 0x98, 0x3f, 0x85, 0xcd, 0xf0, 0xee, 0xda, 0x45, 0x30, 0x86, 0xe2, 0x18, 0x05,
	0xf7, 0x6d, 0x5c, 0x30, 0xa6, 0x97, 0x90, 0x0f, 0xee, 0xe8, 0xb3, 0x78, 0x41, 0x94, 0xe0, 0xce,
	0x67, 0x7b, 0x71, 0x86, 0x77, 0x0a, 0xa0, 0x0f, 0xa0, 0xfc, 0x88, 0x23, 0x98, 0x67, 0xcb, 0xb0,
	0xf7, 0xa0, 0xa9, 0x8c, 0xe0, 0x89, 0xef, 0x8b, 0x88, 0x39, 0x0c, 0xb9, 0x03, 0xdb, 0x0b, 0xd4,
	0xa6, 0xa8, 0x8f, 0x26, 0x90, 0x0e, 0xbc, 0x4b, 0xa3, 0x3c, 0x6c, 0x9c, 0x48, 0x6d, 0x09, 0xcb,
	0x75, 0xa5, 0xde, 0x1a, 0xf4, 0xfa, 0x12, 0xf6, 0x3a, 0xd9, 0xb3, 0x41, 0x4d, 0xc2, 0x6d, 0xa9,
	0x2f, 0xf5, 0xa6, 0x70, 0xd6, 0xc9, 0x76, 0xba, 0x52, 0xbb, 0xd7, 0x94, 0x8f, 0xfb, 0x53, 0x70,
	0x9c, 0x92, 0x4f, 0xc1, 0xaf, 0xa6, 0xf0, 0x65, 0x31, 0x99, 0x4a, 0x08, 0x09, 0x31, 0x99, 0x4a,
	0x0a, 0xc9, 0x8f, 0x7e, 0x09, 0x42, 0xf4, 0x79, 0x97, 0x35, 0xb1, 0x74, 0x1e, 0x51, 0xea, 0xb4,
	0x8d, 0xac, 0xb3, 0xb1, 0x85, 0x4d, 0x32, 0xed, 0x4e, 0x10, 0x44, 0xf7, 0xcd, 0x9c, 0x51, 0x6d,
	0x5a, 0xca, 0x79, 0xa7, 0x31, 0x68, 0x49, 0x42, 0xbc, 0x14, 0x4f, 0xc5, 0x50, 0x0a, 0x92, 0x52,
	0xad, 0x7b, 0x2c, 0x24, 0x68, 0x5e, 0xaa, 0x77, 0xb0, 0xa4, 0xd0, 0x55, 0xf2, 0xa3, 0x3f, 0x8b,
	0x41, 0x3a, 0xf0, 0xe2, 0x45, 0x5b, 0xf6, 0xf3, 0x6a, 0xbb, 0x7a, 0x22, 0x61, 0xa5, 0xff, 0xba,
	0x2b, 0x4d, 0x7b, 0xce, 0x25, 0xb4, 0x0d, 0xf9, 0x10, 0xc6, 0x9b, 0x81, 0xa6, 0xf3, 0xd0, 0x0c,
	0xd1, 0x94, 0x5a, 0xe7, 0x4a, 0xbd, 0x59, 0xc5, 0x7d, 0x21, 0x8e, 0x7e, 0x04, 0x07, 0x21, 0x64,
	0xc0, 0x57, 0x5e, 0xa7, 0xde, 0xc1, 0x42, 0xa2, 0xf6, 0xea, 0x9f, 0xbf, 0xdf, 0x8f, 0xfd, 0xdb,
	0xf7, 0xfb, 0xb1, 0xff, 0xfa, 0x7e, 0x3f, 0xf6, 0x9b, 0xff, 0xde, 0x5f, 0x82, 0x1d, 0xdd, 0xac,
	0x38, 0xae, 0x3a, 0x7c, 0x63, 0x9b, 0xbf, 0xf6, 0xaa, 0x80, 0x5f, 0x90, 0xbe, 0xf1, 0xff, 0x7e,
	0x73, 0xb1, 0xc2, 0xe0, 0x9f, 0xfe, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9d, 0x37, 0x9d, 0x20,
	0xa7, 0x23, 0x00, 0x00,
}

func (m *ClusterMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleProviderMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleProviderMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleProviderMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Project) > 0 {
		i -= len(m.Project)
		copy(dAtA[i:], m.Project)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Project)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSProviderMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSProviderMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSProviderMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureProviderMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureProviderMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureProviderMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SubscriptionId) > 0 {
		i -= len(m.SubscriptionId)
		copy(dAtA[i:], m.SubscriptionId)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.SubscriptionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProviderMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Verified {
		i--
		if m.Verified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.Provider != nil {
		{
			size := m.Provider.Size()
			i -= size
			if _, err := m.Provider.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Zone) > 0 {
		i -= len(m.Zone)
		copy(dAtA[i:], m.Zone)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Zone)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProviderMetadata_Google) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderMetadata_Google) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Google != nil {
		{
			size, err := m.Google.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ProviderMetadata_Aws) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderMetadata_Aws) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Aws != nil {
		{
			size, err := m.Aws.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ProviderMetadata_Azure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderMetadata_Azure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Azure != nil {
		{
			size, err := m.Azure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *OrchestratorMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrchestratorMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrchestratorMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsOpenshift != nil {
		{
			size := m.IsOpenshift.Size()
			i -= size
			if _, err := m.IsOpenshift.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.ApiVersions) > 0 {
		for iNdEx := len(m.ApiVersions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ApiVersions[iNdEx])
			copy(dAtA[i:], m.ApiVersions[iNdEx])
			i = encodeVarintCluster(dAtA, i, uint64(len(m.ApiVersions[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.BuildDate != nil {
		{
			size, err := m.BuildDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrchestratorMetadata_OpenshiftVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrchestratorMetadata_OpenshiftVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.OpenshiftVersion)
	copy(dAtA[i:], m.OpenshiftVersion)
	i = encodeVarintCluster(dAtA, i, uint64(len(m.OpenshiftVersion)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *AdmissionControllerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdmissionControllerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdmissionControllerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EnforceOnUpdates {
		i--
		if m.EnforceOnUpdates {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.DisableBypass {
		i--
		if m.DisableBypass {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ScanInline {
		i--
		if m.ScanInline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.TimeoutSeconds != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.TimeoutSeconds))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TolerationsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TolerationsConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TolerationsConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StaticClusterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticClusterConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticClusterConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AdmissionControllerEvents {
		i--
		if m.AdmissionControllerEvents {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.SlimCollector {
		i--
		if m.SlimCollector {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.TolerationsConfig != nil {
		{
			size, err := m.TolerationsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.AdmissionControllerUpdates {
		i--
		if m.AdmissionControllerUpdates {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.AdmissionController {
		i--
		if m.AdmissionController {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CollectorImage) > 0 {
		i -= len(m.CollectorImage)
		copy(dAtA[i:], m.CollectorImage)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.CollectorImage)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CollectionMethod != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.CollectionMethod))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CentralApiEndpoint) > 0 {
		i -= len(m.CentralApiEndpoint)
		copy(dAtA[i:], m.CentralApiEndpoint)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.CentralApiEndpoint)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MainImage) > 0 {
		i -= len(m.MainImage)
		copy(dAtA[i:], m.MainImage)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.MainImage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DynamicClusterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicClusterConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DynamicClusterConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DisableAuditLogs {
		i--
		if m.DisableAuditLogs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.RegistryOverride) > 0 {
		i -= len(m.RegistryOverride)
		copy(dAtA[i:], m.RegistryOverride)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.RegistryOverride)))
		i--
		dAtA[i] = 0x12
	}
	if m.AdmissionControllerConfig != nil {
		{
			size, err := m.AdmissionControllerConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompleteClusterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompleteClusterConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteClusterConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClusterLabels) > 0 {
		for k := range m.ClusterLabels {
			v := m.ClusterLabels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCluster(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCluster(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCluster(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ConfigFingerprint) > 0 {
		i -= len(m.ConfigFingerprint)
		copy(dAtA[i:], m.ConfigFingerprint)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.ConfigFingerprint)))
		i--
		dAtA[i] = 0x1a
	}
	if m.StaticConfig != nil {
		{
			size, err := m.StaticConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DynamicConfig != nil {
		{
			size, err := m.DynamicConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SensorDeploymentIdentification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensorDeploymentIdentification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensorDeploymentIdentification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.K8SNodeName) > 0 {
		i -= len(m.K8SNodeName)
		copy(dAtA[i:], m.K8SNodeName)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.K8SNodeName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AppServiceaccountId) > 0 {
		i -= len(m.AppServiceaccountId)
		copy(dAtA[i:], m.AppServiceaccountId)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.AppServiceaccountId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AppNamespaceId) > 0 {
		i -= len(m.AppNamespaceId)
		copy(dAtA[i:], m.AppNamespaceId)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.AppNamespaceId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AppNamespace) > 0 {
		i -= len(m.AppNamespace)
		copy(dAtA[i:], m.AppNamespace)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.AppNamespace)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DefaultNamespaceId) > 0 {
		i -= len(m.DefaultNamespaceId)
		copy(dAtA[i:], m.DefaultNamespaceId)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.DefaultNamespaceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SystemNamespaceId) > 0 {
		i -= len(m.SystemNamespaceId)
		copy(dAtA[i:], m.SystemNamespaceId)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.SystemNamespaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ManagedBy != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.ManagedBy))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.InitBundleId) > 0 {
		i -= len(m.InitBundleId)
		copy(dAtA[i:], m.InitBundleId)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.InitBundleId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if len(m.AuditLogState) > 0 {
		for k := range m.AuditLogState {
			v := m.AuditLogState[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCluster(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCluster(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCluster(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCluster(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCluster(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCluster(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if m.MostRecentSensorId != nil {
		{
			size, err := m.MostRecentSensorId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.AdmissionControllerEvents {
		i--
		if m.AdmissionControllerEvents {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.HelmConfig != nil {
		{
			size, err := m.HelmConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.SlimCollector {
		i--
		if m.SlimCollector {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.HealthStatus != nil {
		{
			size, err := m.HealthStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.AdmissionControllerUpdates {
		i--
		if m.AdmissionControllerUpdates {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Priority != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.TolerationsConfig != nil {
		{
			size, err := m.TolerationsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.DynamicConfig != nil {
		{
			size, err := m.DynamicConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.CollectionMethod != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.CollectionMethod))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.CollectorImage) > 0 {
		i -= len(m.CollectorImage)
		copy(dAtA[i:], m.CollectorImage)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.CollectorImage)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.AdmissionController {
		i--
		if m.AdmissionController {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.RuntimeSupport {
		i--
		if m.RuntimeSupport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.CentralApiEndpoint) > 0 {
		i -= len(m.CentralApiEndpoint)
		copy(dAtA[i:], m.CentralApiEndpoint)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.CentralApiEndpoint)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MainImage) > 0 {
		i -= len(m.MainImage)
		copy(dAtA[i:], m.MainImage)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.MainImage)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterCertExpiryStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterCertExpiryStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterCertExpiryStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SensorCertNotBefore != nil {
		{
			size, err := m.SensorCertNotBefore.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SensorCertExpiry != nil {
		{
			size, err := m.SensorCertExpiry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CertExpiryStatus != nil {
		{
			size, err := m.CertExpiryStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.UpgradeStatus != nil {
		{
			size, err := m.UpgradeStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.OrchestratorMetadata != nil {
		{
			size, err := m.OrchestratorMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ProviderMetadata != nil {
		{
			size, err := m.ProviderMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DEPRECATEDLastContact != nil {
		{
			size, err := m.DEPRECATEDLastContact.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SensorVersion) > 0 {
		i -= len(m.SensorVersion)
		copy(dAtA[i:], m.SensorVersion)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.SensorVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterUpgradeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterUpgradeStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterUpgradeStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MostRecentProcess != nil {
		{
			size, err := m.MostRecentProcess.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UpgradabilityStatusReason) > 0 {
		i -= len(m.UpgradabilityStatusReason)
		copy(dAtA[i:], m.UpgradabilityStatusReason)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.UpgradabilityStatusReason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Upgradability != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.Upgradability))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClusterUpgradeStatus_UpgradeProcessStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterUpgradeStatus_UpgradeProcessStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterUpgradeStatus_UpgradeProcessStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x38
	}
	if m.Progress != nil {
		{
			size, err := m.Progress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.InitiatedAt != nil {
		{
			size, err := m.InitiatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UpgraderImage) > 0 {
		i -= len(m.UpgraderImage)
		copy(dAtA[i:], m.UpgraderImage)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.UpgraderImage)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TargetVersion) > 0 {
		i -= len(m.TargetVersion)
		copy(dAtA[i:], m.TargetVersion)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.TargetVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpgradeProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeProgress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeProgress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Since != nil {
		{
			size, err := m.Since.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UpgradeStatusDetail) > 0 {
		i -= len(m.UpgradeStatusDetail)
		copy(dAtA[i:], m.UpgradeStatusDetail)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.UpgradeStatusDetail)))
		i--
		dAtA[i] = 0x12
	}
	if m.UpgradeState != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.UpgradeState))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuditLogFileState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditLogFileState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditLogFileState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastAuditId) > 0 {
		i -= len(m.LastAuditId)
		copy(dAtA[i:], m.LastAuditId)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.LastAuditId)))
		i--
		dAtA[i] = 0x12
	}
	if m.CollectLogsSince != nil {
		{
			size, err := m.CollectLogsSince.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterHealthStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterHealthStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterHealthStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ScannerHealthStatus != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.ScannerHealthStatus))
		i--
		dAtA[i] = 0x58
	}
	if m.ScannerHealthInfo != nil {
		{
			size, err := m.ScannerHealthInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x4a
	}
	if m.AdmissionControlHealthInfo != nil {
		{
			size, err := m.AdmissionControlHealthInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.AdmissionControlHealthStatus != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.AdmissionControlHealthStatus))
		i--
		dAtA[i] = 0x38
	}
	if m.HealthInfoComplete {
		i--
		if m.HealthInfoComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.LastContact != nil {
		{
			size, err := m.LastContact.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.OverallHealthStatus != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.OverallHealthStatus))
		i--
		dAtA[i] = 0x20
	}
	if m.CollectorHealthStatus != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.CollectorHealthStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.SensorHealthStatus != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.SensorHealthStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.CollectorHealthInfo != nil {
		{
			size, err := m.CollectorHealthInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectorHealthInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorHealthInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorHealthInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StatusErrors) > 0 {
		for iNdEx := len(m.StatusErrors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StatusErrors[iNdEx])
			copy(dAtA[i:], m.StatusErrors[iNdEx])
			i = encodeVarintCluster(dAtA, i, uint64(len(m.StatusErrors[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TotalRegisteredNodesOpt != nil {
		{
			size := m.TotalRegisteredNodesOpt.Size()
			i -= size
			if _, err := m.TotalRegisteredNodesOpt.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TotalReadyPodsOpt != nil {
		{
			size := m.TotalReadyPodsOpt.Size()
			i -= size
			if _, err := m.TotalReadyPodsOpt.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TotalDesiredPodsOpt != nil {
		{
			size := m.TotalDesiredPodsOpt.Size()
			i -= size
			if _, err := m.TotalDesiredPodsOpt.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectorHealthInfo_TotalDesiredPods) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorHealthInfo_TotalDesiredPods) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCluster(dAtA, i, uint64(m.TotalDesiredPods))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *CollectorHealthInfo_TotalReadyPods) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorHealthInfo_TotalReadyPods) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCluster(dAtA, i, uint64(m.TotalReadyPods))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *CollectorHealthInfo_TotalRegisteredNodes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorHealthInfo_TotalRegisteredNodes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCluster(dAtA, i, uint64(m.TotalRegisteredNodes))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *AdmissionControlHealthInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdmissionControlHealthInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdmissionControlHealthInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StatusErrors) > 0 {
		for iNdEx := len(m.StatusErrors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StatusErrors[iNdEx])
			copy(dAtA[i:], m.StatusErrors[iNdEx])
			i = encodeVarintCluster(dAtA, i, uint64(len(m.StatusErrors[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TotalReadyPodsOpt != nil {
		{
			size := m.TotalReadyPodsOpt.Size()
			i -= size
			if _, err := m.TotalReadyPodsOpt.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TotalDesiredPodsOpt != nil {
		{
			size := m.TotalDesiredPodsOpt.Size()
			i -= size
			if _, err := m.TotalDesiredPodsOpt.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AdmissionControlHealthInfo_TotalDesiredPods) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdmissionControlHealthInfo_TotalDesiredPods) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCluster(dAtA, i, uint64(m.TotalDesiredPods))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *AdmissionControlHealthInfo_TotalReadyPods) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdmissionControlHealthInfo_TotalReadyPods) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCluster(dAtA, i, uint64(m.TotalReadyPods))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *ScannerHealthInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScannerHealthInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScannerHealthInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StatusErrors) > 0 {
		for iNdEx := len(m.StatusErrors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StatusErrors[iNdEx])
			copy(dAtA[i:], m.StatusErrors[iNdEx])
			i = encodeVarintCluster(dAtA, i, uint64(len(m.StatusErrors[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TotalReadyDbPodsOpt != nil {
		{
			size := m.TotalReadyDbPodsOpt.Size()
			i -= size
			if _, err := m.TotalReadyDbPodsOpt.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TotalDesiredDbPodsOpt != nil {
		{
			size := m.TotalDesiredDbPodsOpt.Size()
			i -= size
			if _, err := m.TotalDesiredDbPodsOpt.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TotalReadyAnalyzerPodsOpt != nil {
		{
			size := m.TotalReadyAnalyzerPodsOpt.Size()
			i -= size
			if _, err := m.TotalReadyAnalyzerPodsOpt.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TotalDesiredAnalyzerPodsOpt != nil {
		{
			size := m.TotalDesiredAnalyzerPodsOpt.Size()
			i -= size
			if _, err := m.TotalDesiredAnalyzerPodsOpt.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ScannerHealthInfo_TotalDesiredAnalyzerPods) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScannerHealthInfo_TotalDesiredAnalyzerPods) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCluster(dAtA, i, uint64(m.TotalDesiredAnalyzerPods))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *ScannerHealthInfo_TotalReadyAnalyzerPods) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScannerHealthInfo_TotalReadyAnalyzerPods) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCluster(dAtA, i, uint64(m.TotalReadyAnalyzerPods))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *ScannerHealthInfo_TotalDesiredDbPods) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScannerHealthInfo_TotalDesiredDbPods) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCluster(dAtA, i, uint64(m.TotalDesiredDbPods))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *ScannerHealthInfo_TotalReadyDbPods) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScannerHealthInfo_TotalReadyDbPods) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCluster(dAtA, i, uint64(m.TotalReadyDbPods))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func encodeVarintCluster(dAtA []byte, offset int, v uint64) int {
	offset -= sovCluster(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClusterMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCluster(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GoogleProviderMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Project)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AWSProviderMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AzureProviderMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubscriptionId)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProviderMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.Provider != nil {
		n += m.Provider.Size()
	}
	if m.Verified {
		n += 2
	}
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProviderMetadata_Google) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Google != nil {
		l = m.Google.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}
func (m *ProviderMetadata_Aws) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aws != nil {
		l = m.Aws.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}
func (m *ProviderMetadata_Azure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Azure != nil {
		l = m.Azure.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}
func (m *OrchestratorMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.BuildDate != nil {
		l = m.BuildDate.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if len(m.ApiVersions) > 0 {
		for _, s := range m.ApiVersions {
			l = len(s)
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	if m.IsOpenshift != nil {
		n += m.IsOpenshift.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrchestratorMetadata_OpenshiftVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OpenshiftVersion)
	n += 1 + l + sovCluster(uint64(l))
	return n
}
func (m *AdmissionControllerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.TimeoutSeconds != 0 {
		n += 1 + sovCluster(uint64(m.TimeoutSeconds))
	}
	if m.ScanInline {
		n += 2
	}
	if m.DisableBypass {
		n += 2
	}
	if m.EnforceOnUpdates {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TolerationsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StaticClusterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCluster(uint64(m.Type))
	}
	l = len(m.MainImage)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.CentralApiEndpoint)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.CollectionMethod != 0 {
		n += 1 + sovCluster(uint64(m.CollectionMethod))
	}
	l = len(m.CollectorImage)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.AdmissionController {
		n += 2
	}
	if m.AdmissionControllerUpdates {
		n += 2
	}
	if m.TolerationsConfig != nil {
		l = m.TolerationsConfig.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.SlimCollector {
		n += 2
	}
	if m.AdmissionControllerEvents {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynamicClusterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdmissionControllerConfig != nil {
		l = m.AdmissionControllerConfig.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.RegistryOverride)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.DisableAuditLogs {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompleteClusterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DynamicConfig != nil {
		l = m.DynamicConfig.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.StaticConfig != nil {
		l = m.StaticConfig.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.ConfigFingerprint)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if len(m.ClusterLabels) > 0 {
		for k, v := range m.ClusterLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCluster(uint64(len(k))) + 1 + len(v) + sovCluster(uint64(len(v)))
			n += mapEntrySize + 1 + sovCluster(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SensorDeploymentIdentification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SystemNamespaceId)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.DefaultNamespaceId)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.AppNamespace)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.AppNamespaceId)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.AppServiceaccountId)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.K8SNodeName)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCluster(uint64(m.Type))
	}
	l = len(m.MainImage)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.CentralApiEndpoint)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.RuntimeSupport {
		n += 2
	}
	if m.AdmissionController {
		n += 2
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.CollectorImage)
	if l > 0 {
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.CollectionMethod != 0 {
		n += 2 + sovCluster(uint64(m.CollectionMethod))
	}
	if m.DynamicConfig != nil {
		l = m.DynamicConfig.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.TolerationsConfig != nil {
		l = m.TolerationsConfig.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.Priority != 0 {
		n += 2 + sovCluster(uint64(m.Priority))
	}
	if m.AdmissionControllerUpdates {
		n += 3
	}
	if m.HealthStatus != nil {
		l = m.HealthStatus.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.SlimCollector {
		n += 3
	}
	if m.HelmConfig != nil {
		l = m.HelmConfig.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.AdmissionControllerEvents {
		n += 3
	}
	if m.MostRecentSensorId != nil {
		l = m.MostRecentSensorId.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCluster(uint64(len(k))) + 1 + len(v) + sovCluster(uint64(len(v)))
			n += mapEntrySize + 2 + sovCluster(uint64(mapEntrySize))
		}
	}
	if len(m.AuditLogState) > 0 {
		for k, v := range m.AuditLogState {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCluster(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCluster(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCluster(uint64(mapEntrySize))
		}
	}
	l = len(m.InitBundleId)
	if l > 0 {
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.ManagedBy != 0 {
		n += 2 + sovCluster(uint64(m.ManagedBy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterCertExpiryStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SensorCertExpiry != nil {
		l = m.SensorCertExpiry.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.SensorCertNotBefore != nil {
		l = m.SensorCertNotBefore.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SensorVersion)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.DEPRECATEDLastContact != nil {
		l = m.DEPRECATEDLastContact.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.ProviderMetadata != nil {
		l = m.ProviderMetadata.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.OrchestratorMetadata != nil {
		l = m.OrchestratorMetadata.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.UpgradeStatus != nil {
		l = m.UpgradeStatus.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.CertExpiryStatus != nil {
		l = m.CertExpiryStatus.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterUpgradeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Upgradability != 0 {
		n += 1 + sovCluster(uint64(m.Upgradability))
	}
	l = len(m.UpgradabilityStatusReason)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.MostRecentProcess != nil {
		l = m.MostRecentProcess.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterUpgradeStatus_UpgradeProcessStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Active {
		n += 2
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.TargetVersion)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.UpgraderImage)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.InitiatedAt != nil {
		l = m.InitiatedAt.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.Progress != nil {
		l = m.Progress.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCluster(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpgradeProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpgradeState != 0 {
		n += 1 + sovCluster(uint64(m.UpgradeState))
	}
	l = len(m.UpgradeStatusDetail)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.Since != nil {
		l = m.Since.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuditLogFileState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CollectLogsSince != nil {
		l = m.CollectLogsSince.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.LastAuditId)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterHealthStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CollectorHealthInfo != nil {
		l = m.CollectorHealthInfo.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.SensorHealthStatus != 0 {
		n += 1 + sovCluster(uint64(m.SensorHealthStatus))
	}
	if m.CollectorHealthStatus != 0 {
		n += 1 + sovCluster(uint64(m.CollectorHealthStatus))
	}
	if m.OverallHealthStatus != 0 {
		n += 1 + sovCluster(uint64(m.OverallHealthStatus))
	}
	if m.LastContact != nil {
		l = m.LastContact.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.HealthInfoComplete {
		n += 2
	}
	if m.AdmissionControlHealthStatus != 0 {
		n += 1 + sovCluster(uint64(m.AdmissionControlHealthStatus))
	}
	if m.AdmissionControlHealthInfo != nil {
		l = m.AdmissionControlHealthInfo.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.ScannerHealthInfo != nil {
		l = m.ScannerHealthInfo.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.ScannerHealthStatus != 0 {
		n += 1 + sovCluster(uint64(m.ScannerHealthStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectorHealthInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.TotalDesiredPodsOpt != nil {
		n += m.TotalDesiredPodsOpt.Size()
	}
	if m.TotalReadyPodsOpt != nil {
		n += m.TotalReadyPodsOpt.Size()
	}
	if m.TotalRegisteredNodesOpt != nil {
		n += m.TotalRegisteredNodesOpt.Size()
	}
	if len(m.StatusErrors) > 0 {
		for _, s := range m.StatusErrors {
			l = len(s)
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectorHealthInfo_TotalDesiredPods) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCluster(uint64(m.TotalDesiredPods))
	return n
}
func (m *CollectorHealthInfo_TotalReadyPods) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCluster(uint64(m.TotalReadyPods))
	return n
}
func (m *CollectorHealthInfo_TotalRegisteredNodes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCluster(uint64(m.TotalRegisteredNodes))
	return n
}
func (m *AdmissionControlHealthInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalDesiredPodsOpt != nil {
		n += m.TotalDesiredPodsOpt.Size()
	}
	if m.TotalReadyPodsOpt != nil {
		n += m.TotalReadyPodsOpt.Size()
	}
	if len(m.StatusErrors) > 0 {
		for _, s := range m.StatusErrors {
			l = len(s)
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdmissionControlHealthInfo_TotalDesiredPods) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCluster(uint64(m.TotalDesiredPods))
	return n
}
func (m *AdmissionControlHealthInfo_TotalReadyPods) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCluster(uint64(m.TotalReadyPods))
	return n
}
func (m *ScannerHealthInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalDesiredAnalyzerPodsOpt != nil {
		n += m.TotalDesiredAnalyzerPodsOpt.Size()
	}
	if m.TotalReadyAnalyzerPodsOpt != nil {
		n += m.TotalReadyAnalyzerPodsOpt.Size()
	}
	if m.TotalDesiredDbPodsOpt != nil {
		n += m.TotalDesiredDbPodsOpt.Size()
	}
	if m.TotalReadyDbPodsOpt != nil {
		n += m.TotalReadyDbPodsOpt.Size()
	}
	if len(m.StatusErrors) > 0 {
		for _, s := range m.StatusErrors {
			l = len(s)
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScannerHealthInfo_TotalDesiredAnalyzerPods) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCluster(uint64(m.TotalDesiredAnalyzerPods))
	return n
}
func (m *ScannerHealthInfo_TotalReadyAnalyzerPods) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCluster(uint64(m.TotalReadyAnalyzerPods))
	return n
}
func (m *ScannerHealthInfo_TotalDesiredDbPods) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCluster(uint64(m.TotalDesiredDbPods))
	return n
}
func (m *ScannerHealthInfo_TotalReadyDbPods) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCluster(uint64(m.TotalReadyDbPods))
	return n
}

func sovCluster(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCluster(x uint64) (n int) {
	return sovCluster(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClusterMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ClusterMetadata_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleProviderMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoogleProviderMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoogleProviderMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Project = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSProviderMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSProviderMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSProviderMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureProviderMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureProviderMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureProviderMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Google", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GoogleProviderMetadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Provider = &ProviderMetadata_Google{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aws", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSProviderMetadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Provider = &ProviderMetadata_Aws{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Azure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureProviderMetadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Provider = &ProviderMetadata_Azure{v}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verified = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &ClusterMetadata{}
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrchestratorMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrchestratorMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrchestratorMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuildDate == nil {
				m.BuildDate = &types.Timestamp{}
			}
			if err := m.BuildDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiVersions = append(m.ApiVersions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenshiftVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsOpenshift = &OrchestratorMetadata_OpenshiftVersion{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdmissionControllerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdmissionControllerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdmissionControllerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutSeconds", wireType)
			}
			m.TimeoutSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanInline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ScanInline = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableBypass", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableBypass = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnforceOnUpdates", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnforceOnUpdates = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TolerationsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TolerationsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TolerationsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticClusterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticClusterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticClusterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ClusterType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MainImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CentralApiEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CentralApiEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMethod", wireType)
			}
			m.CollectionMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionMethod |= CollectionMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectorImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectorImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionController", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdmissionController = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionControllerUpdates", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdmissionControllerUpdates = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TolerationsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TolerationsConfig == nil {
				m.TolerationsConfig = &TolerationsConfig{}
			}
			if err := m.TolerationsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlimCollector", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SlimCollector = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionControllerEvents", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdmissionControllerEvents = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicClusterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicClusterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicClusterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionControllerConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdmissionControllerConfig == nil {
				m.AdmissionControllerConfig = &AdmissionControllerConfig{}
			}
			if err := m.AdmissionControllerConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistryOverride", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegistryOverride = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAuditLogs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAuditLogs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompleteClusterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompleteClusterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompleteClusterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicConfig == nil {
				m.DynamicConfig = &DynamicClusterConfig{}
			}
			if err := m.DynamicConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StaticConfig == nil {
				m.StaticConfig = &StaticClusterConfig{}
			}
			if err := m.StaticConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterLabels == nil {
				m.ClusterLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ClusterLabels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensorDeploymentIdentification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensorDeploymentIdentification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensorDeploymentIdentification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemNamespaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemNamespaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultNamespaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultNamespaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppNamespaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppNamespaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppServiceaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppServiceaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SNodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K8SNodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ClusterType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MainImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CentralApiEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CentralApiEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeSupport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RuntimeSupport = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionController", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdmissionController = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ClusterStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectorImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectorImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMethod", wireType)
			}
			m.CollectionMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionMethod |= CollectionMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicConfig == nil {
				m.DynamicConfig = &DynamicClusterConfig{}
			}
			if err := m.DynamicConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TolerationsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TolerationsConfig == nil {
				m.TolerationsConfig = &TolerationsConfig{}
			}
			if err := m.TolerationsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionControllerUpdates", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdmissionControllerUpdates = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthStatus == nil {
				m.HealthStatus = &ClusterHealthStatus{}
			}
			if err := m.HealthStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlimCollector", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SlimCollector = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelmConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HelmConfig == nil {
				m.HelmConfig = &CompleteClusterConfig{}
			}
			if err := m.HelmConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionControllerEvents", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdmissionControllerEvents = bool(v != 0)
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MostRecentSensorId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MostRecentSensorId == nil {
				m.MostRecentSensorId = &SensorDeploymentIdentification{}
			}
			if err := m.MostRecentSensorId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditLogState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuditLogState == nil {
				m.AuditLogState = make(map[string]*AuditLogFileState)
			}
			var mapkey string
			var mapvalue *AuditLogFileState
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCluster
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCluster
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AuditLogFileState{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AuditLogState[mapkey] = mapvalue
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitBundleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitBundleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagedBy", wireType)
			}
			m.ManagedBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ManagedBy |= ManagerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterCertExpiryStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterCertExpiryStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterCertExpiryStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SensorCertExpiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SensorCertExpiry == nil {
				m.SensorCertExpiry = &types.Timestamp{}
			}
			if err := m.SensorCertExpiry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SensorCertNotBefore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SensorCertNotBefore == nil {
				m.SensorCertNotBefore = &types.Timestamp{}
			}
			if err := m.SensorCertNotBefore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SensorVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SensorVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEPRECATEDLastContact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DEPRECATEDLastContact == nil {
				m.DEPRECATEDLastContact = &types.Timestamp{}
			}
			if err := m.DEPRECATEDLastContact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderMetadata == nil {
				m.ProviderMetadata = &ProviderMetadata{}
			}
			if err := m.ProviderMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrchestratorMetadata == nil {
				m.OrchestratorMetadata = &OrchestratorMetadata{}
			}
			if err := m.OrchestratorMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradeStatus == nil {
				m.UpgradeStatus = &ClusterUpgradeStatus{}
			}
			if err := m.UpgradeStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertExpiryStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CertExpiryStatus == nil {
				m.CertExpiryStatus = &ClusterCertExpiryStatus{}
			}
			if err := m.CertExpiryStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterUpgradeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterUpgradeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterUpgradeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upgradability", wireType)
			}
			m.Upgradability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Upgradability |= ClusterUpgradeStatus_Upgradability(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradabilityStatusReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgradabilityStatusReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MostRecentProcess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MostRecentProcess == nil {
				m.MostRecentProcess = &ClusterUpgradeStatus_UpgradeProcessStatus{}
			}
			if err := m.MostRecentProcess.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterUpgradeStatus_UpgradeProcessStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeProcessStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeProcessStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgraderImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgraderImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatedAt == nil {
				m.InitiatedAt = &types.Timestamp{}
			}
			if err := m.InitiatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Progress == nil {
				m.Progress = &UpgradeProgress{}
			}
			if err := m.Progress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradeProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeState", wireType)
			}
			m.UpgradeState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeState |= UpgradeProgress_UpgradeState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeStatusDetail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgradeStatusDetail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Since == nil {
				m.Since = &types.Timestamp{}
			}
			if err := m.Since.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditLogFileState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditLogFileState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditLogFileState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectLogsSince", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectLogsSince == nil {
				m.CollectLogsSince = &types.Timestamp{}
			}
			if err := m.CollectLogsSince.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAuditId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastAuditId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterHealthStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterHealthStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterHealthStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectorHealthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectorHealthInfo == nil {
				m.CollectorHealthInfo = &CollectorHealthInfo{}
			}
			if err := m.CollectorHealthInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SensorHealthStatus", wireType)
			}
			m.SensorHealthStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SensorHealthStatus |= ClusterHealthStatus_HealthStatusLabel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectorHealthStatus", wireType)
			}
			m.CollectorHealthStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectorHealthStatus |= ClusterHealthStatus_HealthStatusLabel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallHealthStatus", wireType)
			}
			m.OverallHealthStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverallHealthStatus |= ClusterHealthStatus_HealthStatusLabel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastContact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastContact == nil {
				m.LastContact = &types.Timestamp{}
			}
			if err := m.LastContact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthInfoComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HealthInfoComplete = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionControlHealthStatus", wireType)
			}
			m.AdmissionControlHealthStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdmissionControlHealthStatus |= ClusterHealthStatus_HealthStatusLabel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionControlHealthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdmissionControlHealthInfo == nil {
				m.AdmissionControlHealthInfo = &AdmissionControlHealthInfo{}
			}
			if err := m.AdmissionControlHealthInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScannerHealthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScannerHealthInfo == nil {
				m.ScannerHealthInfo = &ScannerHealthInfo{}
			}
			if err := m.ScannerHealthInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScannerHealthStatus", wireType)
			}
			m.ScannerHealthStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScannerHealthStatus |= ClusterHealthStatus_HealthStatusLabel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorHealthInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorHealthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorHealthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDesiredPods", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDesiredPodsOpt = &CollectorHealthInfo_TotalDesiredPods{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReadyPods", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalReadyPodsOpt = &CollectorHealthInfo_TotalReadyPods{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRegisteredNodes", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalRegisteredNodesOpt = &CollectorHealthInfo_TotalRegisteredNodes{v}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusErrors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusErrors = append(m.StatusErrors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdmissionControlHealthInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdmissionControlHealthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdmissionControlHealthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDesiredPods", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDesiredPodsOpt = &AdmissionControlHealthInfo_TotalDesiredPods{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReadyPods", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalReadyPodsOpt = &AdmissionControlHealthInfo_TotalReadyPods{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusErrors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusErrors = append(m.StatusErrors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScannerHealthInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScannerHealthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScannerHealthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDesiredAnalyzerPods", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDesiredAnalyzerPodsOpt = &ScannerHealthInfo_TotalDesiredAnalyzerPods{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReadyAnalyzerPods", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalReadyAnalyzerPodsOpt = &ScannerHealthInfo_TotalReadyAnalyzerPods{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDesiredDbPods", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDesiredDbPodsOpt = &ScannerHealthInfo_TotalDesiredDbPods{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReadyDbPods", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalReadyDbPodsOpt = &ScannerHealthInfo_TotalReadyDbPods{v}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusErrors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusErrors = append(m.StatusErrors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCluster(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCluster
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCluster
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCluster
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCluster        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCluster          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCluster = fmt.Errorf("proto: unexpected end of group")
)
