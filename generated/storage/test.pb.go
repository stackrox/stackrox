// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/test.proto

package storage

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type TestSingleKeyStruct_Enum int32

const (
	TestSingleKeyStruct_ENUM0 TestSingleKeyStruct_Enum = 0
	TestSingleKeyStruct_ENUM1 TestSingleKeyStruct_Enum = 1
	TestSingleKeyStruct_ENUM2 TestSingleKeyStruct_Enum = 2
)

var TestSingleKeyStruct_Enum_name = map[int32]string{
	0: "ENUM0",
	1: "ENUM1",
	2: "ENUM2",
}

var TestSingleKeyStruct_Enum_value = map[string]int32{
	"ENUM0": 0,
	"ENUM1": 1,
	"ENUM2": 2,
}

func (x TestSingleKeyStruct_Enum) String() string {
	return proto.EnumName(TestSingleKeyStruct_Enum_name, int32(x))
}

func (TestSingleKeyStruct_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 0}
}

type TestMultiKeyStruct_Enum int32

const (
	TestMultiKeyStruct_ENUM0 TestMultiKeyStruct_Enum = 0
	TestMultiKeyStruct_ENUM1 TestMultiKeyStruct_Enum = 1
	TestMultiKeyStruct_ENUM2 TestMultiKeyStruct_Enum = 2
)

var TestMultiKeyStruct_Enum_name = map[int32]string{
	0: "ENUM0",
	1: "ENUM1",
	2: "ENUM2",
}

var TestMultiKeyStruct_Enum_value = map[string]int32{
	"ENUM0": 0,
	"ENUM1": 1,
	"ENUM2": 2,
}

func (x TestMultiKeyStruct_Enum) String() string {
	return proto.EnumName(TestMultiKeyStruct_Enum_name, int32(x))
}

func (TestMultiKeyStruct_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 0}
}

type TestSingleKeyStruct struct {
	Key         string                        `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" sql:"pk,index=hash" search:"Test Key"`
	Name        string                        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" sql:"unique" search:"Test Name"`
	StringSlice []string                      `protobuf:"bytes,3,rep,name=string_slice,json=stringSlice,proto3" json:"string_slice,omitempty" search:"Test String Slice"`
	Bool        bool                          `protobuf:"varint,4,opt,name=bool,proto3" json:"bool,omitempty" search:"Test Bool"`
	Uint64      uint64                        `protobuf:"varint,5,opt,name=uint64,proto3" json:"uint64,omitempty" search:"Test Uint64"`
	Int64       int64                         `protobuf:"varint,6,opt,name=int64,proto3" json:"int64,omitempty" search:"Test Int64"`
	Float       float32                       `protobuf:"fixed32,7,opt,name=float,proto3" json:"float,omitempty" search:"Test Float"`
	Labels      map[string]string             `protobuf:"bytes,8,rep,name=labels,proto3" json:"labels,omitempty" search:"Test Labels" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Timestamp   *types.Timestamp              `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty" search:"Test Timestamp"`
	Enum        TestSingleKeyStruct_Enum      `protobuf:"varint,10,opt,name=enum,proto3,enum=storage.TestSingleKeyStruct_Enum" json:"enum,omitempty" search:"Test Enum"`
	Enums       []TestSingleKeyStruct_Enum    `protobuf:"varint,11,rep,packed,name=enums,proto3,enum=storage.TestSingleKeyStruct_Enum" json:"enums,omitempty" search:"Test Enum Slice"`
	Embedded    *TestSingleKeyStruct_Embedded `protobuf:"bytes,12,opt,name=embedded,proto3" json:"embedded,omitempty"`
	Nested      []*TestSingleKeyStruct_Nested `protobuf:"bytes,13,rep,name=nested,proto3" json:"nested,omitempty"`
	// Types that are valid to be assigned to Oneof:
	//	*TestSingleKeyStruct_Oneofstring
	//	*TestSingleKeyStruct_Oneofnested
	Oneof                isTestSingleKeyStruct_Oneof `protobuf_oneof:"oneof"`
	Bytess               []byte                      `protobuf:"bytes,16,opt,name=bytess,proto3" json:"bytess,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *TestSingleKeyStruct) Reset()         { *m = TestSingleKeyStruct{} }
func (m *TestSingleKeyStruct) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct) ProtoMessage()    {}
func (*TestSingleKeyStruct) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0}
}
func (m *TestSingleKeyStruct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct.Merge(m, src)
}
func (m *TestSingleKeyStruct) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct proto.InternalMessageInfo

type isTestSingleKeyStruct_Oneof interface {
	isTestSingleKeyStruct_Oneof()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isTestSingleKeyStruct_Oneof
}

type TestSingleKeyStruct_Oneofstring struct {
	Oneofstring string `protobuf:"bytes,14,opt,name=oneofstring,proto3,oneof" json:"oneofstring,omitempty"`
}
type TestSingleKeyStruct_Oneofnested struct {
	Oneofnested *TestSingleKeyStruct_OneOfNested `protobuf:"bytes,15,opt,name=oneofnested,proto3,oneof" json:"oneofnested,omitempty"`
}

func (*TestSingleKeyStruct_Oneofstring) isTestSingleKeyStruct_Oneof() {}
func (m *TestSingleKeyStruct_Oneofstring) Clone() isTestSingleKeyStruct_Oneof {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_Oneofstring)
	*cloned = *m

	return cloned
}
func (*TestSingleKeyStruct_Oneofnested) isTestSingleKeyStruct_Oneof() {}
func (m *TestSingleKeyStruct_Oneofnested) Clone() isTestSingleKeyStruct_Oneof {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_Oneofnested)
	*cloned = *m

	cloned.Oneofnested = m.Oneofnested.Clone()
	return cloned
}

func (m *TestSingleKeyStruct) GetOneof() isTestSingleKeyStruct_Oneof {
	if m != nil {
		return m.Oneof
	}
	return nil
}

func (m *TestSingleKeyStruct) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *TestSingleKeyStruct) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TestSingleKeyStruct) GetStringSlice() []string {
	if m != nil {
		return m.StringSlice
	}
	return nil
}

func (m *TestSingleKeyStruct) GetBool() bool {
	if m != nil {
		return m.Bool
	}
	return false
}

func (m *TestSingleKeyStruct) GetUint64() uint64 {
	if m != nil {
		return m.Uint64
	}
	return 0
}

func (m *TestSingleKeyStruct) GetInt64() int64 {
	if m != nil {
		return m.Int64
	}
	return 0
}

func (m *TestSingleKeyStruct) GetFloat() float32 {
	if m != nil {
		return m.Float
	}
	return 0
}

func (m *TestSingleKeyStruct) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *TestSingleKeyStruct) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestSingleKeyStruct) GetEnum() TestSingleKeyStruct_Enum {
	if m != nil {
		return m.Enum
	}
	return TestSingleKeyStruct_ENUM0
}

func (m *TestSingleKeyStruct) GetEnums() []TestSingleKeyStruct_Enum {
	if m != nil {
		return m.Enums
	}
	return nil
}

func (m *TestSingleKeyStruct) GetEmbedded() *TestSingleKeyStruct_Embedded {
	if m != nil {
		return m.Embedded
	}
	return nil
}

func (m *TestSingleKeyStruct) GetNested() []*TestSingleKeyStruct_Nested {
	if m != nil {
		return m.Nested
	}
	return nil
}

func (m *TestSingleKeyStruct) GetOneofstring() string {
	if x, ok := m.GetOneof().(*TestSingleKeyStruct_Oneofstring); ok {
		return x.Oneofstring
	}
	return ""
}

func (m *TestSingleKeyStruct) GetOneofnested() *TestSingleKeyStruct_OneOfNested {
	if x, ok := m.GetOneof().(*TestSingleKeyStruct_Oneofnested); ok {
		return x.Oneofnested
	}
	return nil
}

func (m *TestSingleKeyStruct) GetBytess() []byte {
	if m != nil {
		return m.Bytess
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TestSingleKeyStruct) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TestSingleKeyStruct_Oneofstring)(nil),
		(*TestSingleKeyStruct_Oneofnested)(nil),
	}
}

func (m *TestSingleKeyStruct) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct) Clone() *TestSingleKeyStruct {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct)
	*cloned = *m

	if m.StringSlice != nil {
		cloned.StringSlice = make([]string, len(m.StringSlice))
		copy(cloned.StringSlice, m.StringSlice)
	}
	if m.Labels != nil {
		cloned.Labels = make(map[string]string, len(m.Labels))
		for k, v := range m.Labels {
			cloned.Labels[k] = v
		}
	}
	cloned.Timestamp = m.Timestamp.Clone()
	if m.Enums != nil {
		cloned.Enums = make([]TestSingleKeyStruct_Enum, len(m.Enums))
		copy(cloned.Enums, m.Enums)
	}
	cloned.Embedded = m.Embedded.Clone()
	if m.Nested != nil {
		cloned.Nested = make([]*TestSingleKeyStruct_Nested, len(m.Nested))
		for idx, v := range m.Nested {
			cloned.Nested[idx] = v.Clone()
		}
	}
	if m.Oneof != nil {
		cloned.Oneof = m.Oneof.Clone()
	}
	if m.Bytess != nil {
		cloned.Bytess = make([]byte, len(m.Bytess))
		copy(cloned.Bytess, m.Bytess)
	}
	return cloned
}

type TestSingleKeyStruct_Embedded struct {
	Embedded             string   `protobuf:"bytes,1,opt,name=embedded,proto3" json:"embedded,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestSingleKeyStruct_Embedded) Reset()         { *m = TestSingleKeyStruct_Embedded{} }
func (m *TestSingleKeyStruct_Embedded) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct_Embedded) ProtoMessage()    {}
func (*TestSingleKeyStruct_Embedded) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 1}
}
func (m *TestSingleKeyStruct_Embedded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct_Embedded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct_Embedded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct_Embedded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct_Embedded.Merge(m, src)
}
func (m *TestSingleKeyStruct_Embedded) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct_Embedded) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct_Embedded.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct_Embedded proto.InternalMessageInfo

func (m *TestSingleKeyStruct_Embedded) GetEmbedded() string {
	if m != nil {
		return m.Embedded
	}
	return ""
}

func (m *TestSingleKeyStruct_Embedded) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct_Embedded) Clone() *TestSingleKeyStruct_Embedded {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_Embedded)
	*cloned = *m

	return cloned
}

type TestSingleKeyStruct_Embedded_Embedded2 struct {
	Embedded             string   `protobuf:"bytes,2,opt,name=embedded,proto3" json:"embedded,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestSingleKeyStruct_Embedded_Embedded2) Reset() {
	*m = TestSingleKeyStruct_Embedded_Embedded2{}
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct_Embedded_Embedded2) ProtoMessage()    {}
func (*TestSingleKeyStruct_Embedded_Embedded2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 1, 0}
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct_Embedded_Embedded2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct_Embedded_Embedded2.Merge(m, src)
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct_Embedded_Embedded2.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct_Embedded_Embedded2 proto.InternalMessageInfo

func (m *TestSingleKeyStruct_Embedded_Embedded2) GetEmbedded() string {
	if m != nil {
		return m.Embedded
	}
	return ""
}

func (m *TestSingleKeyStruct_Embedded_Embedded2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) Clone() *TestSingleKeyStruct_Embedded_Embedded2 {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_Embedded_Embedded2)
	*cloned = *m

	return cloned
}

type TestSingleKeyStruct_Nested struct {
	Nested               string                              `protobuf:"bytes,1,opt,name=nested,proto3" json:"nested,omitempty"`
	Nested2              *TestSingleKeyStruct_Nested_Nested2 `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *TestSingleKeyStruct_Nested) Reset()         { *m = TestSingleKeyStruct_Nested{} }
func (m *TestSingleKeyStruct_Nested) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct_Nested) ProtoMessage()    {}
func (*TestSingleKeyStruct_Nested) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 2}
}
func (m *TestSingleKeyStruct_Nested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct_Nested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct_Nested.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct_Nested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct_Nested.Merge(m, src)
}
func (m *TestSingleKeyStruct_Nested) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct_Nested) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct_Nested.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct_Nested proto.InternalMessageInfo

func (m *TestSingleKeyStruct_Nested) GetNested() string {
	if m != nil {
		return m.Nested
	}
	return ""
}

func (m *TestSingleKeyStruct_Nested) GetNested2() *TestSingleKeyStruct_Nested_Nested2 {
	if m != nil {
		return m.Nested2
	}
	return nil
}

func (m *TestSingleKeyStruct_Nested) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct_Nested) Clone() *TestSingleKeyStruct_Nested {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_Nested)
	*cloned = *m

	cloned.Nested2 = m.Nested2.Clone()
	return cloned
}

type TestSingleKeyStruct_Nested_Nested2 struct {
	Nested2              string   `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestSingleKeyStruct_Nested_Nested2) Reset()         { *m = TestSingleKeyStruct_Nested_Nested2{} }
func (m *TestSingleKeyStruct_Nested_Nested2) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct_Nested_Nested2) ProtoMessage()    {}
func (*TestSingleKeyStruct_Nested_Nested2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 2, 0}
}
func (m *TestSingleKeyStruct_Nested_Nested2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct_Nested_Nested2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct_Nested_Nested2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct_Nested_Nested2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct_Nested_Nested2.Merge(m, src)
}
func (m *TestSingleKeyStruct_Nested_Nested2) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct_Nested_Nested2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct_Nested_Nested2.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct_Nested_Nested2 proto.InternalMessageInfo

func (m *TestSingleKeyStruct_Nested_Nested2) GetNested2() string {
	if m != nil {
		return m.Nested2
	}
	return ""
}

func (m *TestSingleKeyStruct_Nested_Nested2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct_Nested_Nested2) Clone() *TestSingleKeyStruct_Nested_Nested2 {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_Nested_Nested2)
	*cloned = *m

	return cloned
}

type TestSingleKeyStruct_OneOfNested struct {
	Nested               string                                   `protobuf:"bytes,1,opt,name=nested,proto3" json:"nested,omitempty"`
	Nested2              *TestSingleKeyStruct_OneOfNested_Nested2 `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *TestSingleKeyStruct_OneOfNested) Reset()         { *m = TestSingleKeyStruct_OneOfNested{} }
func (m *TestSingleKeyStruct_OneOfNested) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct_OneOfNested) ProtoMessage()    {}
func (*TestSingleKeyStruct_OneOfNested) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 3}
}
func (m *TestSingleKeyStruct_OneOfNested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct_OneOfNested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct_OneOfNested.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct_OneOfNested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct_OneOfNested.Merge(m, src)
}
func (m *TestSingleKeyStruct_OneOfNested) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct_OneOfNested) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct_OneOfNested.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct_OneOfNested proto.InternalMessageInfo

func (m *TestSingleKeyStruct_OneOfNested) GetNested() string {
	if m != nil {
		return m.Nested
	}
	return ""
}

func (m *TestSingleKeyStruct_OneOfNested) GetNested2() *TestSingleKeyStruct_OneOfNested_Nested2 {
	if m != nil {
		return m.Nested2
	}
	return nil
}

func (m *TestSingleKeyStruct_OneOfNested) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct_OneOfNested) Clone() *TestSingleKeyStruct_OneOfNested {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_OneOfNested)
	*cloned = *m

	cloned.Nested2 = m.Nested2.Clone()
	return cloned
}

type TestSingleKeyStruct_OneOfNested_Nested2 struct {
	Nested2              string   `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestSingleKeyStruct_OneOfNested_Nested2) Reset() {
	*m = TestSingleKeyStruct_OneOfNested_Nested2{}
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct_OneOfNested_Nested2) ProtoMessage()    {}
func (*TestSingleKeyStruct_OneOfNested_Nested2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 3, 0}
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct_OneOfNested_Nested2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct_OneOfNested_Nested2.Merge(m, src)
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct_OneOfNested_Nested2.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct_OneOfNested_Nested2 proto.InternalMessageInfo

func (m *TestSingleKeyStruct_OneOfNested_Nested2) GetNested2() string {
	if m != nil {
		return m.Nested2
	}
	return ""
}

func (m *TestSingleKeyStruct_OneOfNested_Nested2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) Clone() *TestSingleKeyStruct_OneOfNested_Nested2 {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_OneOfNested_Nested2)
	*cloned = *m

	return cloned
}

type TestMultiKeyStruct struct {
	Key1        string                       `protobuf:"bytes,1,opt,name=key1,proto3" json:"key1,omitempty" sql:"pk,id" search:"Test Key"`
	Key2        string                       `protobuf:"bytes,2,opt,name=key2,proto3" json:"key2,omitempty" sql:"pk" search:"Test Key 2,store,hidden"`
	StringSlice []string                     `protobuf:"bytes,3,rep,name=string_slice,json=stringSlice,proto3" json:"string_slice,omitempty" search:"Test String Slice"`
	Bool        bool                         `protobuf:"varint,4,opt,name=bool,proto3" json:"bool,omitempty" search:"Test Bool"`
	Uint64      uint64                       `protobuf:"varint,5,opt,name=uint64,proto3" json:"uint64,omitempty" search:"Test Uint64"`
	Int64       int64                        `protobuf:"varint,6,opt,name=int64,proto3" json:"int64,omitempty" search:"Test Int64"`
	Float       float32                      `protobuf:"fixed32,7,opt,name=float,proto3" json:"float,omitempty" search:"Test Float"`
	Labels      map[string]string            `protobuf:"bytes,8,rep,name=labels,proto3" json:"labels,omitempty" search:"Test Labels" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Timestamp   *types.Timestamp             `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty" search:"Test Timestamp"`
	Enum        TestMultiKeyStruct_Enum      `protobuf:"varint,10,opt,name=enum,proto3,enum=storage.TestMultiKeyStruct_Enum" json:"enum,omitempty" search:"Test Enum"`
	Enums       []TestMultiKeyStruct_Enum    `protobuf:"varint,11,rep,packed,name=enums,proto3,enum=storage.TestMultiKeyStruct_Enum" json:"enums,omitempty" search:"Test Enum Slice"`
	String_     string                       `protobuf:"bytes,16,opt,name=string,proto3" json:"string,omitempty" search:"Test String"`
	IntSlice    []int64                      `protobuf:"varint,17,rep,packed,name=int_slice,json=intSlice,proto3" json:"int_slice,omitempty" search:"Test Int64 Slice"`
	Embedded    *TestMultiKeyStruct_Embedded `protobuf:"bytes,12,opt,name=embedded,proto3" json:"embedded,omitempty"`
	Nested      []*TestMultiKeyStruct_Nested `protobuf:"bytes,13,rep,name=nested,proto3" json:"nested,omitempty"`
	// Types that are valid to be assigned to Oneof:
	//	*TestMultiKeyStruct_Oneofstring
	//	*TestMultiKeyStruct_Oneofnested
	Oneof                isTestMultiKeyStruct_Oneof `protobuf_oneof:"oneof"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TestMultiKeyStruct) Reset()         { *m = TestMultiKeyStruct{} }
func (m *TestMultiKeyStruct) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct) ProtoMessage()    {}
func (*TestMultiKeyStruct) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1}
}
func (m *TestMultiKeyStruct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct.Merge(m, src)
}
func (m *TestMultiKeyStruct) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct proto.InternalMessageInfo

type isTestMultiKeyStruct_Oneof interface {
	isTestMultiKeyStruct_Oneof()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isTestMultiKeyStruct_Oneof
}

type TestMultiKeyStruct_Oneofstring struct {
	Oneofstring string `protobuf:"bytes,14,opt,name=oneofstring,proto3,oneof" json:"oneofstring,omitempty"`
}
type TestMultiKeyStruct_Oneofnested struct {
	Oneofnested *TestMultiKeyStruct_OneOfNested `protobuf:"bytes,15,opt,name=oneofnested,proto3,oneof" json:"oneofnested,omitempty"`
}

func (*TestMultiKeyStruct_Oneofstring) isTestMultiKeyStruct_Oneof() {}
func (m *TestMultiKeyStruct_Oneofstring) Clone() isTestMultiKeyStruct_Oneof {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_Oneofstring)
	*cloned = *m

	return cloned
}
func (*TestMultiKeyStruct_Oneofnested) isTestMultiKeyStruct_Oneof() {}
func (m *TestMultiKeyStruct_Oneofnested) Clone() isTestMultiKeyStruct_Oneof {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_Oneofnested)
	*cloned = *m

	cloned.Oneofnested = m.Oneofnested.Clone()
	return cloned
}

func (m *TestMultiKeyStruct) GetOneof() isTestMultiKeyStruct_Oneof {
	if m != nil {
		return m.Oneof
	}
	return nil
}

func (m *TestMultiKeyStruct) GetKey1() string {
	if m != nil {
		return m.Key1
	}
	return ""
}

func (m *TestMultiKeyStruct) GetKey2() string {
	if m != nil {
		return m.Key2
	}
	return ""
}

func (m *TestMultiKeyStruct) GetStringSlice() []string {
	if m != nil {
		return m.StringSlice
	}
	return nil
}

func (m *TestMultiKeyStruct) GetBool() bool {
	if m != nil {
		return m.Bool
	}
	return false
}

func (m *TestMultiKeyStruct) GetUint64() uint64 {
	if m != nil {
		return m.Uint64
	}
	return 0
}

func (m *TestMultiKeyStruct) GetInt64() int64 {
	if m != nil {
		return m.Int64
	}
	return 0
}

func (m *TestMultiKeyStruct) GetFloat() float32 {
	if m != nil {
		return m.Float
	}
	return 0
}

func (m *TestMultiKeyStruct) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *TestMultiKeyStruct) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestMultiKeyStruct) GetEnum() TestMultiKeyStruct_Enum {
	if m != nil {
		return m.Enum
	}
	return TestMultiKeyStruct_ENUM0
}

func (m *TestMultiKeyStruct) GetEnums() []TestMultiKeyStruct_Enum {
	if m != nil {
		return m.Enums
	}
	return nil
}

func (m *TestMultiKeyStruct) GetString_() string {
	if m != nil {
		return m.String_
	}
	return ""
}

func (m *TestMultiKeyStruct) GetIntSlice() []int64 {
	if m != nil {
		return m.IntSlice
	}
	return nil
}

func (m *TestMultiKeyStruct) GetEmbedded() *TestMultiKeyStruct_Embedded {
	if m != nil {
		return m.Embedded
	}
	return nil
}

func (m *TestMultiKeyStruct) GetNested() []*TestMultiKeyStruct_Nested {
	if m != nil {
		return m.Nested
	}
	return nil
}

func (m *TestMultiKeyStruct) GetOneofstring() string {
	if x, ok := m.GetOneof().(*TestMultiKeyStruct_Oneofstring); ok {
		return x.Oneofstring
	}
	return ""
}

func (m *TestMultiKeyStruct) GetOneofnested() *TestMultiKeyStruct_OneOfNested {
	if x, ok := m.GetOneof().(*TestMultiKeyStruct_Oneofnested); ok {
		return x.Oneofnested
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TestMultiKeyStruct) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TestMultiKeyStruct_Oneofstring)(nil),
		(*TestMultiKeyStruct_Oneofnested)(nil),
	}
}

func (m *TestMultiKeyStruct) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct) Clone() *TestMultiKeyStruct {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct)
	*cloned = *m

	if m.StringSlice != nil {
		cloned.StringSlice = make([]string, len(m.StringSlice))
		copy(cloned.StringSlice, m.StringSlice)
	}
	if m.Labels != nil {
		cloned.Labels = make(map[string]string, len(m.Labels))
		for k, v := range m.Labels {
			cloned.Labels[k] = v
		}
	}
	cloned.Timestamp = m.Timestamp.Clone()
	if m.Enums != nil {
		cloned.Enums = make([]TestMultiKeyStruct_Enum, len(m.Enums))
		copy(cloned.Enums, m.Enums)
	}
	if m.IntSlice != nil {
		cloned.IntSlice = make([]int64, len(m.IntSlice))
		copy(cloned.IntSlice, m.IntSlice)
	}
	cloned.Embedded = m.Embedded.Clone()
	if m.Nested != nil {
		cloned.Nested = make([]*TestMultiKeyStruct_Nested, len(m.Nested))
		for idx, v := range m.Nested {
			cloned.Nested[idx] = v.Clone()
		}
	}
	if m.Oneof != nil {
		cloned.Oneof = m.Oneof.Clone()
	}
	return cloned
}

type TestMultiKeyStruct_Embedded struct {
	Embedded             string   `protobuf:"bytes,1,opt,name=embedded,proto3" json:"embedded,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestMultiKeyStruct_Embedded) Reset()         { *m = TestMultiKeyStruct_Embedded{} }
func (m *TestMultiKeyStruct_Embedded) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct_Embedded) ProtoMessage()    {}
func (*TestMultiKeyStruct_Embedded) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 1}
}
func (m *TestMultiKeyStruct_Embedded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct_Embedded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct_Embedded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct_Embedded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct_Embedded.Merge(m, src)
}
func (m *TestMultiKeyStruct_Embedded) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct_Embedded) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct_Embedded.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct_Embedded proto.InternalMessageInfo

func (m *TestMultiKeyStruct_Embedded) GetEmbedded() string {
	if m != nil {
		return m.Embedded
	}
	return ""
}

func (m *TestMultiKeyStruct_Embedded) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct_Embedded) Clone() *TestMultiKeyStruct_Embedded {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_Embedded)
	*cloned = *m

	return cloned
}

type TestMultiKeyStruct_Embedded_Embedded2 struct {
	Embedded             string   `protobuf:"bytes,2,opt,name=embedded,proto3" json:"embedded,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestMultiKeyStruct_Embedded_Embedded2) Reset()         { *m = TestMultiKeyStruct_Embedded_Embedded2{} }
func (m *TestMultiKeyStruct_Embedded_Embedded2) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct_Embedded_Embedded2) ProtoMessage()    {}
func (*TestMultiKeyStruct_Embedded_Embedded2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 1, 0}
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct_Embedded_Embedded2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct_Embedded_Embedded2.Merge(m, src)
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct_Embedded_Embedded2.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct_Embedded_Embedded2 proto.InternalMessageInfo

func (m *TestMultiKeyStruct_Embedded_Embedded2) GetEmbedded() string {
	if m != nil {
		return m.Embedded
	}
	return ""
}

func (m *TestMultiKeyStruct_Embedded_Embedded2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) Clone() *TestMultiKeyStruct_Embedded_Embedded2 {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_Embedded_Embedded2)
	*cloned = *m

	return cloned
}

type TestMultiKeyStruct_Nested struct {
	Nested               string                             `protobuf:"bytes,1,opt,name=nested,proto3" json:"nested,omitempty" search:"Test Nested String"`
	IsNested             bool                               `protobuf:"varint,3,opt,name=is_nested,json=isNested,proto3" json:"is_nested,omitempty" search:"Test Nested Bool"`
	Int64                int64                              `protobuf:"varint,4,opt,name=int64,proto3" json:"int64,omitempty" search:"Test Nested Int64"`
	Nested2              *TestMultiKeyStruct_Nested_Nested2 `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *TestMultiKeyStruct_Nested) Reset()         { *m = TestMultiKeyStruct_Nested{} }
func (m *TestMultiKeyStruct_Nested) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct_Nested) ProtoMessage()    {}
func (*TestMultiKeyStruct_Nested) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 2}
}
func (m *TestMultiKeyStruct_Nested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct_Nested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct_Nested.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct_Nested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct_Nested.Merge(m, src)
}
func (m *TestMultiKeyStruct_Nested) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct_Nested) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct_Nested.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct_Nested proto.InternalMessageInfo

func (m *TestMultiKeyStruct_Nested) GetNested() string {
	if m != nil {
		return m.Nested
	}
	return ""
}

func (m *TestMultiKeyStruct_Nested) GetIsNested() bool {
	if m != nil {
		return m.IsNested
	}
	return false
}

func (m *TestMultiKeyStruct_Nested) GetInt64() int64 {
	if m != nil {
		return m.Int64
	}
	return 0
}

func (m *TestMultiKeyStruct_Nested) GetNested2() *TestMultiKeyStruct_Nested_Nested2 {
	if m != nil {
		return m.Nested2
	}
	return nil
}

func (m *TestMultiKeyStruct_Nested) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct_Nested) Clone() *TestMultiKeyStruct_Nested {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_Nested)
	*cloned = *m

	cloned.Nested2 = m.Nested2.Clone()
	return cloned
}

type TestMultiKeyStruct_Nested_Nested2 struct {
	Nested2              string   `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty" search:"Test Nested String 2"`
	IsNested             bool     `protobuf:"varint,3,opt,name=is_nested,json=isNested,proto3" json:"is_nested,omitempty" search:"Test Nested Bool 2"`
	Int64                int64    `protobuf:"varint,4,opt,name=int64,proto3" json:"int64,omitempty" search:"Test Nested Int64 2"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestMultiKeyStruct_Nested_Nested2) Reset()         { *m = TestMultiKeyStruct_Nested_Nested2{} }
func (m *TestMultiKeyStruct_Nested_Nested2) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct_Nested_Nested2) ProtoMessage()    {}
func (*TestMultiKeyStruct_Nested_Nested2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 2, 0}
}
func (m *TestMultiKeyStruct_Nested_Nested2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct_Nested_Nested2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct_Nested_Nested2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct_Nested_Nested2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct_Nested_Nested2.Merge(m, src)
}
func (m *TestMultiKeyStruct_Nested_Nested2) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct_Nested_Nested2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct_Nested_Nested2.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct_Nested_Nested2 proto.InternalMessageInfo

func (m *TestMultiKeyStruct_Nested_Nested2) GetNested2() string {
	if m != nil {
		return m.Nested2
	}
	return ""
}

func (m *TestMultiKeyStruct_Nested_Nested2) GetIsNested() bool {
	if m != nil {
		return m.IsNested
	}
	return false
}

func (m *TestMultiKeyStruct_Nested_Nested2) GetInt64() int64 {
	if m != nil {
		return m.Int64
	}
	return 0
}

func (m *TestMultiKeyStruct_Nested_Nested2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct_Nested_Nested2) Clone() *TestMultiKeyStruct_Nested_Nested2 {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_Nested_Nested2)
	*cloned = *m

	return cloned
}

type TestMultiKeyStruct_OneOfNested struct {
	Nested               string   `protobuf:"bytes,1,opt,name=nested,proto3" json:"nested,omitempty" search:"Test Oneof Nested String"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestMultiKeyStruct_OneOfNested) Reset()         { *m = TestMultiKeyStruct_OneOfNested{} }
func (m *TestMultiKeyStruct_OneOfNested) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct_OneOfNested) ProtoMessage()    {}
func (*TestMultiKeyStruct_OneOfNested) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 3}
}
func (m *TestMultiKeyStruct_OneOfNested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct_OneOfNested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct_OneOfNested.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct_OneOfNested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct_OneOfNested.Merge(m, src)
}
func (m *TestMultiKeyStruct_OneOfNested) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct_OneOfNested) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct_OneOfNested.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct_OneOfNested proto.InternalMessageInfo

func (m *TestMultiKeyStruct_OneOfNested) GetNested() string {
	if m != nil {
		return m.Nested
	}
	return ""
}

func (m *TestMultiKeyStruct_OneOfNested) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct_OneOfNested) Clone() *TestMultiKeyStruct_OneOfNested {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_OneOfNested)
	*cloned = *m

	return cloned
}

type TestMultiKeyStruct_OneOfNested_Nested2 struct {
	Nested2              string   `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestMultiKeyStruct_OneOfNested_Nested2) Reset() {
	*m = TestMultiKeyStruct_OneOfNested_Nested2{}
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct_OneOfNested_Nested2) ProtoMessage()    {}
func (*TestMultiKeyStruct_OneOfNested_Nested2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 3, 0}
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct_OneOfNested_Nested2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct_OneOfNested_Nested2.Merge(m, src)
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct_OneOfNested_Nested2.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct_OneOfNested_Nested2 proto.InternalMessageInfo

func (m *TestMultiKeyStruct_OneOfNested_Nested2) GetNested2() string {
	if m != nil {
		return m.Nested2
	}
	return ""
}

func (m *TestMultiKeyStruct_OneOfNested_Nested2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) Clone() *TestMultiKeyStruct_OneOfNested_Nested2 {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_OneOfNested_Nested2)
	*cloned = *m

	return cloned
}

// The test graph is as below. The numbers next to the edges
// indicate the cardinality of the relationship, either n-1, 1-n or n-n.
// The first element is the child and second is the parent.
//             TestGrandparent
//        (n-1) /      (n-1) |   (n-1) \
//       TestParent1  TestParent2   TestParent3
//       (n-n) |           | (n-1)
//       TestChild1    TestChild2
//         (1-n)  |
//       TestGrandChild1
//         (n-1)  |
//       TestGGrandChild1
//         (1-n)   |
//       TestG2GrandChild1
//        (n-1)   |
//        TestG3GrandChild1
type TestGrandparent struct {
	Id                   string                      `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Test Grandparent ID" sql:"pk"`
	Val                  string                      `protobuf:"bytes,2,opt,name=val,proto3" json:"val,omitempty" search:"Test Grandparent Val"`
	Embedded             []*TestGrandparent_Embedded `protobuf:"bytes,3,rep,name=embedded,proto3" json:"embedded,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *TestGrandparent) Reset()         { *m = TestGrandparent{} }
func (m *TestGrandparent) String() string { return proto.CompactTextString(m) }
func (*TestGrandparent) ProtoMessage()    {}
func (*TestGrandparent) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{2}
}
func (m *TestGrandparent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestGrandparent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestGrandparent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestGrandparent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestGrandparent.Merge(m, src)
}
func (m *TestGrandparent) XXX_Size() int {
	return m.Size()
}
func (m *TestGrandparent) XXX_DiscardUnknown() {
	xxx_messageInfo_TestGrandparent.DiscardUnknown(m)
}

var xxx_messageInfo_TestGrandparent proto.InternalMessageInfo

func (m *TestGrandparent) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestGrandparent) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *TestGrandparent) GetEmbedded() []*TestGrandparent_Embedded {
	if m != nil {
		return m.Embedded
	}
	return nil
}

func (m *TestGrandparent) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestGrandparent) Clone() *TestGrandparent {
	if m == nil {
		return nil
	}
	cloned := new(TestGrandparent)
	*cloned = *m

	if m.Embedded != nil {
		cloned.Embedded = make([]*TestGrandparent_Embedded, len(m.Embedded))
		for idx, v := range m.Embedded {
			cloned.Embedded[idx] = v.Clone()
		}
	}
	return cloned
}

type TestGrandparent_Embedded struct {
	Val                  string                                `protobuf:"bytes,1,opt,name=val,proto3" json:"val,omitempty" search:"Test Grandparent Embedded"`
	Embedded2            []*TestGrandparent_Embedded_Embedded2 `protobuf:"bytes,2,rep,name=embedded2,proto3" json:"embedded2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *TestGrandparent_Embedded) Reset()         { *m = TestGrandparent_Embedded{} }
func (m *TestGrandparent_Embedded) String() string { return proto.CompactTextString(m) }
func (*TestGrandparent_Embedded) ProtoMessage()    {}
func (*TestGrandparent_Embedded) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{2, 0}
}
func (m *TestGrandparent_Embedded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestGrandparent_Embedded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestGrandparent_Embedded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestGrandparent_Embedded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestGrandparent_Embedded.Merge(m, src)
}
func (m *TestGrandparent_Embedded) XXX_Size() int {
	return m.Size()
}
func (m *TestGrandparent_Embedded) XXX_DiscardUnknown() {
	xxx_messageInfo_TestGrandparent_Embedded.DiscardUnknown(m)
}

var xxx_messageInfo_TestGrandparent_Embedded proto.InternalMessageInfo

func (m *TestGrandparent_Embedded) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *TestGrandparent_Embedded) GetEmbedded2() []*TestGrandparent_Embedded_Embedded2 {
	if m != nil {
		return m.Embedded2
	}
	return nil
}

func (m *TestGrandparent_Embedded) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestGrandparent_Embedded) Clone() *TestGrandparent_Embedded {
	if m == nil {
		return nil
	}
	cloned := new(TestGrandparent_Embedded)
	*cloned = *m

	if m.Embedded2 != nil {
		cloned.Embedded2 = make([]*TestGrandparent_Embedded_Embedded2, len(m.Embedded2))
		for idx, v := range m.Embedded2 {
			cloned.Embedded2[idx] = v.Clone()
		}
	}
	return cloned
}

type TestGrandparent_Embedded_Embedded2 struct {
	Val                  string   `protobuf:"bytes,1,opt,name=val,proto3" json:"val,omitempty" search:"Test Grandparent Embedded2"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestGrandparent_Embedded_Embedded2) Reset()         { *m = TestGrandparent_Embedded_Embedded2{} }
func (m *TestGrandparent_Embedded_Embedded2) String() string { return proto.CompactTextString(m) }
func (*TestGrandparent_Embedded_Embedded2) ProtoMessage()    {}
func (*TestGrandparent_Embedded_Embedded2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{2, 0, 0}
}
func (m *TestGrandparent_Embedded_Embedded2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestGrandparent_Embedded_Embedded2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestGrandparent_Embedded_Embedded2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestGrandparent_Embedded_Embedded2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestGrandparent_Embedded_Embedded2.Merge(m, src)
}
func (m *TestGrandparent_Embedded_Embedded2) XXX_Size() int {
	return m.Size()
}
func (m *TestGrandparent_Embedded_Embedded2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestGrandparent_Embedded_Embedded2.DiscardUnknown(m)
}

var xxx_messageInfo_TestGrandparent_Embedded_Embedded2 proto.InternalMessageInfo

func (m *TestGrandparent_Embedded_Embedded2) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *TestGrandparent_Embedded_Embedded2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestGrandparent_Embedded_Embedded2) Clone() *TestGrandparent_Embedded_Embedded2 {
	if m == nil {
		return nil
	}
	cloned := new(TestGrandparent_Embedded_Embedded2)
	*cloned = *m

	return cloned
}

type TestParent1 struct {
	Id                   string                   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Test Parent1 ID" sql:"pk"`
	ParentId             string                   `protobuf:"bytes,2,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty" search:"Test Grandparent ID" sql:"fk(TestGrandparent:id)"`
	Children             []*TestParent1_Child1Ref `protobuf:"bytes,3,rep,name=children,proto3" json:"children,omitempty"`
	Val                  string                   `protobuf:"bytes,4,opt,name=val,proto3" json:"val,omitempty" search:"Test Parent1 Val"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TestParent1) Reset()         { *m = TestParent1{} }
func (m *TestParent1) String() string { return proto.CompactTextString(m) }
func (*TestParent1) ProtoMessage()    {}
func (*TestParent1) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{3}
}
func (m *TestParent1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestParent1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestParent1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestParent1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestParent1.Merge(m, src)
}
func (m *TestParent1) XXX_Size() int {
	return m.Size()
}
func (m *TestParent1) XXX_DiscardUnknown() {
	xxx_messageInfo_TestParent1.DiscardUnknown(m)
}

var xxx_messageInfo_TestParent1 proto.InternalMessageInfo

func (m *TestParent1) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestParent1) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *TestParent1) GetChildren() []*TestParent1_Child1Ref {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *TestParent1) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *TestParent1) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestParent1) Clone() *TestParent1 {
	if m == nil {
		return nil
	}
	cloned := new(TestParent1)
	*cloned = *m

	if m.Children != nil {
		cloned.Children = make([]*TestParent1_Child1Ref, len(m.Children))
		for idx, v := range m.Children {
			cloned.Children[idx] = v.Clone()
		}
	}
	return cloned
}

type TestParent1_Child1Ref struct {
	ChildId              string   `protobuf:"bytes,1,opt,name=child_id,json=childId,proto3" json:"child_id,omitempty" search:"Test Child1 ID" sql:"fk(TestChild1:id),no-fk-constraint"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestParent1_Child1Ref) Reset()         { *m = TestParent1_Child1Ref{} }
func (m *TestParent1_Child1Ref) String() string { return proto.CompactTextString(m) }
func (*TestParent1_Child1Ref) ProtoMessage()    {}
func (*TestParent1_Child1Ref) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{3, 0}
}
func (m *TestParent1_Child1Ref) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestParent1_Child1Ref) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestParent1_Child1Ref.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestParent1_Child1Ref) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestParent1_Child1Ref.Merge(m, src)
}
func (m *TestParent1_Child1Ref) XXX_Size() int {
	return m.Size()
}
func (m *TestParent1_Child1Ref) XXX_DiscardUnknown() {
	xxx_messageInfo_TestParent1_Child1Ref.DiscardUnknown(m)
}

var xxx_messageInfo_TestParent1_Child1Ref proto.InternalMessageInfo

func (m *TestParent1_Child1Ref) GetChildId() string {
	if m != nil {
		return m.ChildId
	}
	return ""
}

func (m *TestParent1_Child1Ref) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestParent1_Child1Ref) Clone() *TestParent1_Child1Ref {
	if m == nil {
		return nil
	}
	cloned := new(TestParent1_Child1Ref)
	*cloned = *m

	return cloned
}

type TestChild1 struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Test Child1 ID" sql:"pk"`
	Val                  string   `protobuf:"bytes,2,opt,name=val,proto3" json:"val,omitempty" search:"Test Child1 Val"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestChild1) Reset()         { *m = TestChild1{} }
func (m *TestChild1) String() string { return proto.CompactTextString(m) }
func (*TestChild1) ProtoMessage()    {}
func (*TestChild1) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{4}
}
func (m *TestChild1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestChild1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestChild1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestChild1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestChild1.Merge(m, src)
}
func (m *TestChild1) XXX_Size() int {
	return m.Size()
}
func (m *TestChild1) XXX_DiscardUnknown() {
	xxx_messageInfo_TestChild1.DiscardUnknown(m)
}

var xxx_messageInfo_TestChild1 proto.InternalMessageInfo

func (m *TestChild1) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestChild1) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *TestChild1) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestChild1) Clone() *TestChild1 {
	if m == nil {
		return nil
	}
	cloned := new(TestChild1)
	*cloned = *m

	return cloned
}

type TestGrandChild1 struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Test Grandchild1 ID" sql:"pk"`
	ParentId             string   `protobuf:"bytes,2,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty" search:"Test Child1 ID" sql:"fk(TestChild1:id)"`
	ChildId              string   `protobuf:"bytes,3,opt,name=child_id,json=childId,proto3" json:"child_id,omitempty" search:"Test GGrandchild1 ID" sql:"fk(TestGGrandChild1:id),no-fk-constraint"`
	Val                  string   `protobuf:"bytes,4,opt,name=val,proto3" json:"val,omitempty" search:"Test Grandchild1 Val"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestGrandChild1) Reset()         { *m = TestGrandChild1{} }
func (m *TestGrandChild1) String() string { return proto.CompactTextString(m) }
func (*TestGrandChild1) ProtoMessage()    {}
func (*TestGrandChild1) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{5}
}
func (m *TestGrandChild1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestGrandChild1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestGrandChild1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestGrandChild1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestGrandChild1.Merge(m, src)
}
func (m *TestGrandChild1) XXX_Size() int {
	return m.Size()
}
func (m *TestGrandChild1) XXX_DiscardUnknown() {
	xxx_messageInfo_TestGrandChild1.DiscardUnknown(m)
}

var xxx_messageInfo_TestGrandChild1 proto.InternalMessageInfo

func (m *TestGrandChild1) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestGrandChild1) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *TestGrandChild1) GetChildId() string {
	if m != nil {
		return m.ChildId
	}
	return ""
}

func (m *TestGrandChild1) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *TestGrandChild1) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestGrandChild1) Clone() *TestGrandChild1 {
	if m == nil {
		return nil
	}
	cloned := new(TestGrandChild1)
	*cloned = *m

	return cloned
}

type TestGGrandChild1 struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Test GGrandchild1 ID" sql:"pk"`
	Val                  string   `protobuf:"bytes,2,opt,name=val,proto3" json:"val,omitempty" search:"Test GGrandchild1 Val"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestGGrandChild1) Reset()         { *m = TestGGrandChild1{} }
func (m *TestGGrandChild1) String() string { return proto.CompactTextString(m) }
func (*TestGGrandChild1) ProtoMessage()    {}
func (*TestGGrandChild1) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{6}
}
func (m *TestGGrandChild1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestGGrandChild1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestGGrandChild1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestGGrandChild1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestGGrandChild1.Merge(m, src)
}
func (m *TestGGrandChild1) XXX_Size() int {
	return m.Size()
}
func (m *TestGGrandChild1) XXX_DiscardUnknown() {
	xxx_messageInfo_TestGGrandChild1.DiscardUnknown(m)
}

var xxx_messageInfo_TestGGrandChild1 proto.InternalMessageInfo

func (m *TestGGrandChild1) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestGGrandChild1) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *TestGGrandChild1) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestGGrandChild1) Clone() *TestGGrandChild1 {
	if m == nil {
		return nil
	}
	cloned := new(TestGGrandChild1)
	*cloned = *m

	return cloned
}

type TestG2GrandChild1 struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Test G2Grandchild1 ID" sql:"pk"`
	ParentId             string   `protobuf:"bytes,2,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty" search:"Test GGrandchild1 ID" sql:"fk(TestGGrandChild1:id)"`
	ChildId              string   `protobuf:"bytes,3,opt,name=child_id,json=childId,proto3" json:"child_id,omitempty" search:"Test G3Grandchild1 ID" sql:"fk(TestG3GrandChild1:id),no-fk-constraint"`
	Val                  string   `protobuf:"bytes,4,opt,name=val,proto3" json:"val,omitempty" search:"Test G2Grandchild1 Val"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestG2GrandChild1) Reset()         { *m = TestG2GrandChild1{} }
func (m *TestG2GrandChild1) String() string { return proto.CompactTextString(m) }
func (*TestG2GrandChild1) ProtoMessage()    {}
func (*TestG2GrandChild1) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{7}
}
func (m *TestG2GrandChild1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestG2GrandChild1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestG2GrandChild1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestG2GrandChild1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestG2GrandChild1.Merge(m, src)
}
func (m *TestG2GrandChild1) XXX_Size() int {
	return m.Size()
}
func (m *TestG2GrandChild1) XXX_DiscardUnknown() {
	xxx_messageInfo_TestG2GrandChild1.DiscardUnknown(m)
}

var xxx_messageInfo_TestG2GrandChild1 proto.InternalMessageInfo

func (m *TestG2GrandChild1) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestG2GrandChild1) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *TestG2GrandChild1) GetChildId() string {
	if m != nil {
		return m.ChildId
	}
	return ""
}

func (m *TestG2GrandChild1) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *TestG2GrandChild1) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestG2GrandChild1) Clone() *TestG2GrandChild1 {
	if m == nil {
		return nil
	}
	cloned := new(TestG2GrandChild1)
	*cloned = *m

	return cloned
}

type TestG3GrandChild1 struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Test G3Grandchild1 ID" sql:"pk"`
	Val                  string   `protobuf:"bytes,2,opt,name=val,proto3" json:"val,omitempty" search:"Test G3Grandchild1 Val"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestG3GrandChild1) Reset()         { *m = TestG3GrandChild1{} }
func (m *TestG3GrandChild1) String() string { return proto.CompactTextString(m) }
func (*TestG3GrandChild1) ProtoMessage()    {}
func (*TestG3GrandChild1) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{8}
}
func (m *TestG3GrandChild1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestG3GrandChild1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestG3GrandChild1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestG3GrandChild1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestG3GrandChild1.Merge(m, src)
}
func (m *TestG3GrandChild1) XXX_Size() int {
	return m.Size()
}
func (m *TestG3GrandChild1) XXX_DiscardUnknown() {
	xxx_messageInfo_TestG3GrandChild1.DiscardUnknown(m)
}

var xxx_messageInfo_TestG3GrandChild1 proto.InternalMessageInfo

func (m *TestG3GrandChild1) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestG3GrandChild1) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *TestG3GrandChild1) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestG3GrandChild1) Clone() *TestG3GrandChild1 {
	if m == nil {
		return nil
	}
	cloned := new(TestG3GrandChild1)
	*cloned = *m

	return cloned
}

type TestParent2 struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Test Parent2 ID" sql:"pk"`
	ParentId             string   `protobuf:"bytes,2,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty" search:"Test Grandparent ID" sql:"fk(TestGrandparent:id)"`
	Val                  string   `protobuf:"bytes,3,opt,name=val,proto3" json:"val,omitempty" search:"Test Parent2 Val"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestParent2) Reset()         { *m = TestParent2{} }
func (m *TestParent2) String() string { return proto.CompactTextString(m) }
func (*TestParent2) ProtoMessage()    {}
func (*TestParent2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{9}
}
func (m *TestParent2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestParent2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestParent2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestParent2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestParent2.Merge(m, src)
}
func (m *TestParent2) XXX_Size() int {
	return m.Size()
}
func (m *TestParent2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestParent2.DiscardUnknown(m)
}

var xxx_messageInfo_TestParent2 proto.InternalMessageInfo

func (m *TestParent2) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestParent2) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *TestParent2) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *TestParent2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestParent2) Clone() *TestParent2 {
	if m == nil {
		return nil
	}
	cloned := new(TestParent2)
	*cloned = *m

	return cloned
}

type TestChild2 struct {
	Id       string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Test Child2 ID" sql:"pk"`
	ParentId string `protobuf:"bytes,2,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty" search:"Test Parent2 ID" sql:"fk(TestParent2:id)"`
	// For a potential optimization, insert a direct link from child to grandparent.
	GrandparentId        string   `protobuf:"bytes,3,opt,name=grandparent_id,json=grandparentId,proto3" json:"grandparent_id,omitempty" search:"Test Grandparent ID" sql:"fk(TestGrandparent:id),no-fk-constraint"`
	Val                  string   `protobuf:"bytes,4,opt,name=val,proto3" json:"val,omitempty" search:"Test Child2 Val"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestChild2) Reset()         { *m = TestChild2{} }
func (m *TestChild2) String() string { return proto.CompactTextString(m) }
func (*TestChild2) ProtoMessage()    {}
func (*TestChild2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{10}
}
func (m *TestChild2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestChild2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestChild2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestChild2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestChild2.Merge(m, src)
}
func (m *TestChild2) XXX_Size() int {
	return m.Size()
}
func (m *TestChild2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestChild2.DiscardUnknown(m)
}

var xxx_messageInfo_TestChild2 proto.InternalMessageInfo

func (m *TestChild2) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestChild2) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *TestChild2) GetGrandparentId() string {
	if m != nil {
		return m.GrandparentId
	}
	return ""
}

func (m *TestChild2) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *TestChild2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestChild2) Clone() *TestChild2 {
	if m == nil {
		return nil
	}
	cloned := new(TestChild2)
	*cloned = *m

	return cloned
}

type TestParent3 struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Test Parent3 ID" sql:"pk"`
	ParentId             string   `protobuf:"bytes,2,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty" search:"Test Grandparent ID" sql:"fk(TestGrandparent:id)"`
	Val                  string   `protobuf:"bytes,3,opt,name=val,proto3" json:"val,omitempty" search:"Test Parent3 Val"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestParent3) Reset()         { *m = TestParent3{} }
func (m *TestParent3) String() string { return proto.CompactTextString(m) }
func (*TestParent3) ProtoMessage()    {}
func (*TestParent3) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{11}
}
func (m *TestParent3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestParent3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestParent3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestParent3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestParent3.Merge(m, src)
}
func (m *TestParent3) XXX_Size() int {
	return m.Size()
}
func (m *TestParent3) XXX_DiscardUnknown() {
	xxx_messageInfo_TestParent3.DiscardUnknown(m)
}

var xxx_messageInfo_TestParent3 proto.InternalMessageInfo

func (m *TestParent3) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestParent3) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *TestParent3) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *TestParent3) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestParent3) Clone() *TestParent3 {
	if m == nil {
		return nil
	}
	cloned := new(TestParent3)
	*cloned = *m

	return cloned
}

func init() {
	proto.RegisterEnum("storage.TestSingleKeyStruct_Enum", TestSingleKeyStruct_Enum_name, TestSingleKeyStruct_Enum_value)
	proto.RegisterEnum("storage.TestMultiKeyStruct_Enum", TestMultiKeyStruct_Enum_name, TestMultiKeyStruct_Enum_value)
	proto.RegisterType((*TestSingleKeyStruct)(nil), "storage.TestSingleKeyStruct")
	proto.RegisterMapType((map[string]string)(nil), "storage.TestSingleKeyStruct.LabelsEntry")
	proto.RegisterType((*TestSingleKeyStruct_Embedded)(nil), "storage.TestSingleKeyStruct.Embedded")
	proto.RegisterType((*TestSingleKeyStruct_Embedded_Embedded2)(nil), "storage.TestSingleKeyStruct.Embedded.Embedded2")
	proto.RegisterType((*TestSingleKeyStruct_Nested)(nil), "storage.TestSingleKeyStruct.Nested")
	proto.RegisterType((*TestSingleKeyStruct_Nested_Nested2)(nil), "storage.TestSingleKeyStruct.Nested.Nested2")
	proto.RegisterType((*TestSingleKeyStruct_OneOfNested)(nil), "storage.TestSingleKeyStruct.OneOfNested")
	proto.RegisterType((*TestSingleKeyStruct_OneOfNested_Nested2)(nil), "storage.TestSingleKeyStruct.OneOfNested.Nested2")
	proto.RegisterType((*TestMultiKeyStruct)(nil), "storage.TestMultiKeyStruct")
	proto.RegisterMapType((map[string]string)(nil), "storage.TestMultiKeyStruct.LabelsEntry")
	proto.RegisterType((*TestMultiKeyStruct_Embedded)(nil), "storage.TestMultiKeyStruct.Embedded")
	proto.RegisterType((*TestMultiKeyStruct_Embedded_Embedded2)(nil), "storage.TestMultiKeyStruct.Embedded.Embedded2")
	proto.RegisterType((*TestMultiKeyStruct_Nested)(nil), "storage.TestMultiKeyStruct.Nested")
	proto.RegisterType((*TestMultiKeyStruct_Nested_Nested2)(nil), "storage.TestMultiKeyStruct.Nested.Nested2")
	proto.RegisterType((*TestMultiKeyStruct_OneOfNested)(nil), "storage.TestMultiKeyStruct.OneOfNested")
	proto.RegisterType((*TestMultiKeyStruct_OneOfNested_Nested2)(nil), "storage.TestMultiKeyStruct.OneOfNested.Nested2")
	proto.RegisterType((*TestGrandparent)(nil), "storage.TestGrandparent")
	proto.RegisterType((*TestGrandparent_Embedded)(nil), "storage.TestGrandparent.Embedded")
	proto.RegisterType((*TestGrandparent_Embedded_Embedded2)(nil), "storage.TestGrandparent.Embedded.Embedded2")
	proto.RegisterType((*TestParent1)(nil), "storage.TestParent1")
	proto.RegisterType((*TestParent1_Child1Ref)(nil), "storage.TestParent1.Child1Ref")
	proto.RegisterType((*TestChild1)(nil), "storage.TestChild1")
	proto.RegisterType((*TestGrandChild1)(nil), "storage.TestGrandChild1")
	proto.RegisterType((*TestGGrandChild1)(nil), "storage.TestGGrandChild1")
	proto.RegisterType((*TestG2GrandChild1)(nil), "storage.TestG2GrandChild1")
	proto.RegisterType((*TestG3GrandChild1)(nil), "storage.TestG3GrandChild1")
	proto.RegisterType((*TestParent2)(nil), "storage.TestParent2")
	proto.RegisterType((*TestChild2)(nil), "storage.TestChild2")
	proto.RegisterType((*TestParent3)(nil), "storage.TestParent3")
}

func init() { proto.RegisterFile("storage/test.proto", fileDescriptor_f80f1f1db1167453) }

var fileDescriptor_f80f1f1db1167453 = []byte{
	// 1622 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0x41, 0x6f, 0xdb, 0x46,
	0x16, 0x0e, 0x45, 0x59, 0x96, 0x46, 0x89, 0xe3, 0x4c, 0x82, 0x84, 0x51, 0x12, 0x0f, 0x43, 0x27,
	0xb1, 0x92, 0xd8, 0xb2, 0x4d, 0xd9, 0x49, 0x6c, 0xaf, 0xb1, 0x89, 0x36, 0xce, 0xae, 0x13, 0xc7,
	0x0e, 0xe8, 0x78, 0x81, 0x0d, 0x16, 0x30, 0x68, 0x69, 0x2c, 0x13, 0xa6, 0x48, 0x47, 0xa4, 0x82,
	0xf8, 0xbe, 0xc0, 0x5e, 0xf6, 0xbc, 0x58, 0xec, 0x6f, 0xe8, 0x0f, 0xe8, 0xa1, 0x05, 0x7a, 0xec,
	0xb1, 0x45, 0x0b, 0xf4, 0x46, 0x14, 0xe9, 0x3f, 0xe0, 0xa9, 0x40, 0x2f, 0x05, 0x67, 0x86, 0xd4,
	0x50, 0x94, 0x68, 0xc5, 0x40, 0x8b, 0x00, 0x3d, 0x89, 0x9c, 0x79, 0xef, 0xcd, 0xf7, 0xbe, 0xf7,
	0xe6, 0x7b, 0x92, 0x00, 0x74, 0x5c, 0xbb, 0xad, 0x37, 0xf1, 0xac, 0x8b, 0x1d, 0xb7, 0x72, 0xd4,
	0xb6, 0x5d, 0x1b, 0x8e, 0xb2, 0xb5, 0x12, 0x6a, 0xda, 0x76, 0xd3, 0xc4, 0xb3, 0x64, 0x79, 0xaf,
	0xb3, 0x3f, 0xeb, 0x1a, 0x2d, 0xec, 0xb8, 0x7a, 0xeb, 0x88, 0x5a, 0x96, 0x2e, 0x35, 0xed, 0xa6,
	0x4d, 0x1e, 0x67, 0x83, 0x27, 0xba, 0xaa, 0x7c, 0x57, 0x04, 0x17, 0x5f, 0x63, 0xc7, 0xdd, 0x36,
	0xac, 0xa6, 0x89, 0x5f, 0xe0, 0xe3, 0x6d, 0xb7, 0xdd, 0xa9, 0xbb, 0x70, 0x05, 0x88, 0x87, 0xf8,
	0x58, 0x12, 0x64, 0xa1, 0x5c, 0xa8, 0xdd, 0xf5, 0x3d, 0x74, 0xdb, 0x79, 0x6b, 0x2e, 0x2b, 0x47,
	0x87, 0xd3, 0x86, 0xd5, 0xc0, 0xef, 0x57, 0x0f, 0x74, 0xe7, 0x40, 0x91, 0x1d, 0xac, 0xb7, 0xeb,
	0x07, 0xcb, 0x4a, 0x10, 0x41, 0x7e, 0x81, 0x8f, 0x15, 0x2d, 0xf0, 0x82, 0x0f, 0x41, 0xd6, 0xd2,
	0x5b, 0x58, 0xca, 0x10, 0xef, 0x49, 0xdf, 0x43, 0x88, 0x78, 0x77, 0x2c, 0xe3, 0x6d, 0x07, 0xf7,
	0xb8, 0x6d, 0xea, 0x2d, 0xac, 0x68, 0xc4, 0x01, 0x3e, 0x01, 0x67, 0x1d, 0xb7, 0x6d, 0x58, 0xcd,
	0x5d, 0xc7, 0x34, 0xea, 0x58, 0x12, 0x65, 0xb1, 0x5c, 0xa8, 0x4d, 0xf8, 0x1e, 0x2a, 0xc5, 0x7c,
	0xb6, 0x89, 0x91, 0xbc, 0x1d, 0x18, 0x29, 0x5a, 0x91, 0xfa, 0x90, 0x37, 0x78, 0x0f, 0x64, 0xf7,
	0x6c, 0xdb, 0x94, 0xb2, 0xb2, 0x50, 0xce, 0xd7, 0x2e, 0xfb, 0x1e, 0x82, 0x31, 0xd7, 0x9a, 0x6d,
	0x9b, 0x8a, 0x46, 0x6c, 0xe0, 0x1c, 0xc8, 0x75, 0x0c, 0xcb, 0x7d, 0xb0, 0x20, 0x8d, 0xc8, 0x42,
	0x39, 0x5b, 0x93, 0x7c, 0x0f, 0x5d, 0x8a, 0x59, 0xef, 0x90, 0x6d, 0x45, 0x63, 0x76, 0x70, 0x06,
	0x8c, 0x50, 0x87, 0x9c, 0x2c, 0x94, 0xc5, 0xda, 0x15, 0xdf, 0x43, 0x17, 0x63, 0x0e, 0xeb, 0xd4,
	0x7e, 0x24, 0x32, 0xdf, 0x37, 0x6d, 0xdd, 0x95, 0x46, 0x65, 0xa1, 0x9c, 0xe9, 0x63, 0xfe, 0x2c,
	0xd8, 0x55, 0x34, 0x6a, 0x05, 0xdf, 0x80, 0x9c, 0xa9, 0xef, 0x61, 0xd3, 0x91, 0xf2, 0xb2, 0x58,
	0x2e, 0xaa, 0xe5, 0x0a, 0xab, 0x6e, 0xa5, 0x4f, 0x89, 0x2a, 0x1b, 0xc4, 0x74, 0xcd, 0x72, 0xdb,
	0xc7, 0x7d, 0x90, 0xd3, 0x5d, 0x45, 0x63, 0x11, 0xe1, 0x0e, 0x28, 0x44, 0x1d, 0x21, 0x15, 0x64,
	0xa1, 0x5c, 0x54, 0x4b, 0x15, 0xda, 0x33, 0x95, 0xb0, 0x67, 0x2a, 0xaf, 0x43, 0x8b, 0xda, 0x35,
	0xdf, 0x43, 0x57, 0x62, 0x01, 0xa3, 0x3d, 0x45, 0xeb, 0x46, 0x82, 0x2f, 0x41, 0x16, 0x5b, 0x9d,
	0x96, 0x04, 0x64, 0xa1, 0x3c, 0xa6, 0xde, 0x4c, 0x05, 0xbc, 0x66, 0x75, 0x5a, 0x7d, 0x2a, 0x12,
	0x2c, 0x2b, 0x1a, 0x09, 0x03, 0x77, 0xc0, 0x48, 0xf0, 0xe9, 0x48, 0x45, 0x59, 0x1c, 0x2e, 0xde,
	0x75, 0xdf, 0x43, 0x52, 0x22, 0x5e, 0xd8, 0x1a, 0x34, 0x1a, 0x7c, 0x02, 0xf2, 0xb8, 0xb5, 0x87,
	0x1b, 0x0d, 0xdc, 0x90, 0xce, 0x92, 0xdc, 0x6f, 0xa7, 0x47, 0x66, 0xc6, 0x5a, 0xe4, 0x06, 0x57,
	0x40, 0xce, 0xc2, 0x8e, 0x8b, 0x1b, 0xd2, 0x39, 0x52, 0x9b, 0xc9, 0xd4, 0x00, 0x9b, 0xc4, 0x54,
	0x63, 0x2e, 0x50, 0x01, 0x45, 0xdb, 0xc2, 0xf6, 0x3e, 0x6d, 0x54, 0x69, 0x2c, 0xb8, 0x17, 0x7f,
	0x3b, 0xa3, 0xf1, 0x8b, 0x70, 0x83, 0xd9, 0xb0, 0x53, 0xce, 0x13, 0x98, 0xe9, 0x1d, 0xb0, 0x65,
	0xe1, 0xad, 0x7d, 0x7a, 0x54, 0x14, 0x8d, 0x9d, 0x78, 0x19, 0xe4, 0xf6, 0x8e, 0x5d, 0xec, 0x38,
	0xd2, 0xb8, 0x2c, 0x94, 0xcf, 0x6a, 0xec, 0xad, 0xb4, 0x04, 0x8a, 0x5c, 0xdf, 0xc0, 0x71, 0xee,
	0x9a, 0xd3, 0xbb, 0x7b, 0x09, 0x8c, 0xbc, 0xd3, 0xcd, 0x0e, 0xbb, 0xbc, 0x1a, 0x7d, 0x59, 0xce,
	0x3c, 0x12, 0x4a, 0x5b, 0x20, 0x1f, 0xf2, 0x02, 0x4b, 0x1c, 0xa1, 0xd4, 0x39, 0x7a, 0x2f, 0x4d,
	0x81, 0x42, 0x68, 0xa7, 0xc6, 0x0c, 0x33, 0x3d, 0x86, 0xff, 0x11, 0x40, 0x6e, 0x33, 0x82, 0xcb,
	0xf2, 0xa6, 0xd1, 0x42, 0xe2, 0xd6, 0xc0, 0x28, 0x7d, 0x52, 0x89, 0x77, 0x51, 0xbd, 0x3f, 0x04,
	0xed, 0xec, 0x43, 0xd5, 0x42, 0xdf, 0xd2, 0x24, 0x18, 0x65, 0x6b, 0x50, 0x8a, 0x47, 0x2c, 0x74,
	0x8d, 0xfe, 0x2b, 0x80, 0x22, 0xc7, 0xe8, 0x40, 0x4c, 0xcf, 0x7b, 0x31, 0xcd, 0x0d, 0x5b, 0xa4,
	0xd3, 0x01, 0x53, 0xa6, 0x40, 0x36, 0xe8, 0x69, 0x58, 0x00, 0x23, 0x6b, 0x9b, 0x3b, 0x2f, 0xe7,
	0xc6, 0xcf, 0x84, 0x8f, 0xf3, 0xe3, 0x42, 0xf8, 0xa8, 0x8e, 0x67, 0x6a, 0xa3, 0x60, 0x84, 0xf4,
	0x80, 0xf2, 0xd9, 0x18, 0x80, 0x01, 0x96, 0x97, 0x1d, 0xd3, 0x35, 0xba, 0xa2, 0xbe, 0x08, 0xb2,
	0x87, 0xf8, 0x78, 0x9e, 0xa9, 0xfa, 0x4d, 0xdf, 0x43, 0x37, 0x22, 0x55, 0x6f, 0xf4, 0x53, 0x73,
	0x62, 0x0e, 0x9f, 0x10, 0x37, 0x06, 0xab, 0x36, 0xe3, 0x7b, 0xe8, 0x2e, 0x73, 0x4b, 0xfa, 0xc8,
	0xea, 0x74, 0x40, 0x06, 0x9e, 0x3e, 0x30, 0x1a, 0x0d, 0x6c, 0xd1, 0x10, 0xea, 0x1f, 0x5d, 0xd8,
	0xff, 0xd1, 0x23, 0xec, 0x53, 0xb1, 0x8e, 0x89, 0x57, 0xe9, 0xd3, 0xd0, 0xf5, 0x8d, 0x98, 0xae,
	0xcb, 0x69, 0x78, 0x87, 0x90, 0xf5, 0xd7, 0x71, 0x59, 0x3f, 0x39, 0xdc, 0x50, 0xaa, 0x3e, 0x07,
	0x72, 0x4c, 0x50, 0xc7, 0x49, 0x67, 0x26, 0xc9, 0xa2, 0xed, 0xa4, 0x68, 0xcc, 0x0e, 0x2e, 0x83,
	0x82, 0x61, 0xb9, 0xac, 0x07, 0x2f, 0xc8, 0x62, 0x59, 0xac, 0xdd, 0xf0, 0x3d, 0x74, 0x35, 0x59,
	0xe9, 0xf0, 0xa8, 0xbc, 0x61, 0xb9, 0xb4, 0xff, 0x1e, 0x27, 0x66, 0xc8, 0xad, 0xd4, 0x34, 0x92,
	0x23, 0x64, 0xb9, 0x67, 0x84, 0x28, 0x69, 0xfe, 0xa7, 0x98, 0x20, 0x2f, 0xfa, 0x4d, 0x90, 0xd4,
	0x56, 0x1b, 0x3c, 0x40, 0x3e, 0xa9, 0x41, 0xf1, 0xb9, 0x18, 0x0d, 0x8a, 0x87, 0x71, 0x51, 0xae,
	0x21, 0xdf, 0x43, 0xd7, 0xe2, 0xdf, 0x27, 0xc9, 0x76, 0xb7, 0xf4, 0x8c, 0xc0, 0xa0, 0xf4, 0xce,
	0x2e, 0xf3, 0x15, 0x89, 0x86, 0x24, 0x4b, 0xcf, 0x7c, 0xa9, 0x94, 0xe4, 0x0d, 0x87, 0x1d, 0xba,
	0x10, 0x8a, 0x43, 0x96, 0x88, 0x43, 0x52, 0xb6, 0x98, 0x5f, 0x5c, 0x23, 0x9e, 0xf6, 0xce, 0x89,
	0x7b, 0x27, 0xd7, 0x3b, 0x39, 0x21, 0xbe, 0x10, 0xba, 0x23, 0x62, 0xa5, 0x67, 0x44, 0x30, 0x09,
	0x1f, 0x98, 0xbd, 0xac, 0x2a, 0x51, 0x20, 0xf8, 0xa7, 0x24, 0x01, 0x03, 0xc9, 0x0b, 0x08, 0x08,
	0x9c, 0xbb, 0x14, 0x3c, 0x88, 0x53, 0x20, 0xfb, 0x1e, 0xba, 0x3e, 0x90, 0x82, 0xc0, 0x95, 0x9a,
	0x97, 0xde, 0xc6, 0x67, 0xea, 0x6a, 0x4f, 0xf9, 0x6e, 0xfb, 0x1e, 0xba, 0x19, 0x8b, 0xb3, 0x15,
	0xf4, 0xe0, 0x80, 0x22, 0xfe, 0x56, 0xe3, 0xf2, 0xff, 0x22, 0x38, 0x1f, 0x1c, 0xfe, 0xd7, 0xb6,
	0x6e, 0x35, 0x8e, 0xf4, 0x36, 0xb6, 0x5c, 0xb8, 0x04, 0x32, 0x46, 0x23, 0xf6, 0xfb, 0x87, 0x47,
	0xc9, 0x59, 0xca, 0xeb, 0x4f, 0x15, 0x39, 0x9c, 0x87, 0x5a, 0xc6, 0x68, 0xc0, 0x2a, 0x10, 0xdf,
	0xe9, 0xe6, 0xc0, 0x12, 0xf1, 0xbe, 0x7f, 0xd7, 0x4d, 0x45, 0x0b, 0xac, 0xe1, 0x2a, 0xd7, 0xff,
	0x22, 0x91, 0x87, 0xf8, 0x97, 0x5f, 0xce, 0xab, 0x8f, 0xb6, 0x94, 0x7e, 0x10, 0xb8, 0x4b, 0xf7,
	0x88, 0x02, 0xa0, 0xe0, 0xef, 0xf8, 0x1e, 0x52, 0x06, 0x02, 0x08, 0x7d, 0x18, 0x8a, 0x75, 0x50,
	0x08, 0x43, 0x06, 0xbc, 0x8a, 0x89, 0x6f, 0x5c, 0xfd, 0x60, 0x44, 0x0f, 0xaa, 0xd6, 0xf5, 0x2e,
	0x3d, 0xe3, 0x6f, 0xf7, 0x12, 0x8f, 0x68, 0xca, 0xf7, 0xd0, 0xe4, 0x89, 0x88, 0x54, 0x0a, 0x49,
	0xf9, 0x25, 0x03, 0x8a, 0x81, 0xd1, 0x2b, 0xb2, 0x3d, 0x0f, 0x17, 0xb9, 0xc2, 0x24, 0xdb, 0x87,
	0x59, 0x25, 0x8b, 0xf2, 0x06, 0x14, 0xe8, 0x01, 0xbb, 0x06, 0x13, 0x98, 0xda, 0xaa, 0xef, 0xa1,
	0xa5, 0x93, 0xcb, 0xba, 0x7f, 0x58, 0xee, 0xc9, 0x7c, 0xd9, 0x68, 0xdc, 0x55, 0xb4, 0x3c, 0x7d,
	0x59, 0x0f, 0xb4, 0x25, 0x5f, 0x3f, 0x30, 0xcc, 0x46, 0x1b, 0x5b, 0xac, 0x76, 0x13, 0x31, 0xd2,
	0x18, 0xa8, 0xca, 0x5f, 0x02, 0xa3, 0x79, 0x0d, 0xef, 0x6b, 0x91, 0x3d, 0x9c, 0xa5, 0xcc, 0x64,
	0x09, 0xa2, 0xa4, 0x22, 0x85, 0xf9, 0x44, 0x8d, 0x52, 0x32, 0x41, 0x21, 0x8a, 0x03, 0x77, 0xd9,
	0xc9, 0xbb, 0x11, 0x25, 0x4f, 0x7d, 0x0f, 0x3d, 0x8e, 0x85, 0xa0, 0xd6, 0x89, 0x7c, 0xe8, 0x72,
	0x90, 0xca, 0xb4, 0x65, 0xcf, 0xec, 0x1f, 0xce, 0xd4, 0x6d, 0xcb, 0x71, 0xdb, 0xba, 0x61, 0xb9,
	0x8a, 0x36, 0x4a, 0xa2, 0xae, 0x37, 0x94, 0x36, 0x00, 0x5d, 0x63, 0xb8, 0xc0, 0x71, 0x7f, 0xcb,
	0xf7, 0x90, 0x9c, 0x7a, 0x50, 0x48, 0x7d, 0x85, 0xbf, 0x0f, 0xc9, 0xc9, 0xce, 0xdc, 0xa2, 0x0c,
	0x95, 0xaf, 0x32, 0xdc, 0x75, 0x64, 0x27, 0x0f, 0x71, 0x1d, 0xeb, 0x03, 0x8e, 0x7f, 0x95, 0xac,
	0x7c, 0xd5, 0xf7, 0xd0, 0xec, 0xc7, 0x91, 0xc4, 0xd7, 0xfb, 0x90, 0x63, 0x5d, 0x24, 0x01, 0x5f,
	0xf9, 0x1e, 0xda, 0x88, 0x43, 0xea, 0x8b, 0x29, 0xec, 0x25, 0x2e, 0xb5, 0x13, 0x2a, 0x10, 0xaa,
	0x49, 0x36, 0x4d, 0x4d, 0xea, 0xbd, 0x14, 0xfe, 0x4b, 0x00, 0xe3, 0xbd, 0x07, 0xc1, 0x65, 0x8e,
	0xc3, 0x7b, 0xbe, 0x87, 0xee, 0x0c, 0x01, 0x38, 0x24, 0x71, 0x81, 0xaf, 0xa1, 0xe2, 0x7b, 0x68,
	0x62, 0xb0, 0x73, 0x17, 0xc6, 0xf7, 0x19, 0x70, 0x81, 0xc0, 0x50, 0x79, 0x1c, 0x2b, 0x1c, 0x8e,
	0xfb, 0xbe, 0x87, 0xa6, 0xe2, 0xa1, 0xd4, 0x54, 0x20, 0xff, 0x4c, 0x56, 0xf3, 0xcf, 0xbe, 0x87,
	0x56, 0x4e, 0x4f, 0x3e, 0x5f, 0xd9, 0x56, 0xa2, 0xb2, 0x9a, 0xef, 0xa1, 0xcd, 0x78, 0xf0, 0x6a,
	0x6a, 0xf4, 0xea, 0x47, 0xd4, 0x76, 0x91, 0xaf, 0x2d, 0xfd, 0x9f, 0x6c, 0x30, 0x15, 0x5d, 0x5a,
	0xff, 0x2d, 0x30, 0x5a, 0xab, 0x1f, 0x41, 0x6b, 0x35, 0x95, 0xd6, 0x45, 0xbe, 0xbe, 0x7d, 0x90,
	0x54, 0xfb, 0x23, 0xf9, 0x56, 0xe0, 0xc5, 0x59, 0x1d, 0x4a, 0x9c, 0xd5, 0xdf, 0x57, 0x9c, 0x99,
	0xc0, 0x8a, 0xa9, 0x02, 0xab, 0x72, 0x39, 0x7d, 0x99, 0xe1, 0x34, 0x4f, 0x1d, 0x46, 0xf3, 0xfa,
	0x64, 0xa4, 0x25, 0x33, 0x5a, 0xf4, 0x3d, 0x34, 0x9f, 0xce, 0x07, 0xcb, 0x86, 0xad, 0xf7, 0x66,
	0xd2, 0x01, 0x63, 0xcd, 0x6e, 0x9e, 0xdd, 0x16, 0xdd, 0xf4, 0x3d, 0xf4, 0xfc, 0xb4, 0x54, 0xf5,
	0x69, 0xcf, 0x73, 0xdc, 0x29, 0xeb, 0x91, 0x7c, 0x67, 0xd3, 0xe4, 0x5b, 0x1d, 0xd8, 0x13, 0xd5,
	0xa1, 0x7a, 0xa2, 0xfa, 0x09, 0xf6, 0x44, 0xb5, 0x9b, 0x53, 0xed, 0xe1, 0xd7, 0x1f, 0x26, 0x84,
	0x6f, 0x3e, 0x4c, 0x08, 0x3f, 0x7e, 0x98, 0x10, 0xfe, 0xf7, 0xd3, 0xc4, 0x19, 0x70, 0xd5, 0xb0,
	0x2b, 0x8e, 0xab, 0xd7, 0x0f, 0xdb, 0xf6, 0x7b, 0xfa, 0x43, 0x3b, 0x1c, 0xf9, 0x6f, 0xc2, 0xff,
	0xe4, 0x7f, 0x16, 0x84, 0xbd, 0x1c, 0xd9, 0xaa, 0xfe, 0x1a, 0x00, 0x00, 0xff, 0xff, 0x1e, 0x51,
	0xaa, 0xe2, 0xbc, 0x17, 0x00, 0x00,
}

func (m *TestSingleKeyStruct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Bytess) > 0 {
		i -= len(m.Bytess)
		copy(dAtA[i:], m.Bytess)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Bytess)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Oneof != nil {
		{
			size := m.Oneof.Size()
			i -= size
			if _, err := m.Oneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Nested) > 0 {
		for iNdEx := len(m.Nested) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nested[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.Embedded != nil {
		{
			size, err := m.Embedded.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Enums) > 0 {
		dAtA3 := make([]byte, len(m.Enums)*10)
		var j2 int
		for _, num := range m.Enums {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintTest(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x5a
	}
	if m.Enum != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Enum))
		i--
		dAtA[i] = 0x50
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTest(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTest(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Float != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Float))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Int64 != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Int64))
		i--
		dAtA[i] = 0x30
	}
	if m.Uint64 != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Uint64))
		i--
		dAtA[i] = 0x28
	}
	if m.Bool {
		i--
		if m.Bool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.StringSlice) > 0 {
		for iNdEx := len(m.StringSlice) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StringSlice[iNdEx])
			copy(dAtA[i:], m.StringSlice[iNdEx])
			i = encodeVarintTest(dAtA, i, uint64(len(m.StringSlice[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestSingleKeyStruct_Oneofstring) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_Oneofstring) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Oneofstring)
	copy(dAtA[i:], m.Oneofstring)
	i = encodeVarintTest(dAtA, i, uint64(len(m.Oneofstring)))
	i--
	dAtA[i] = 0x72
	return len(dAtA) - i, nil
}
func (m *TestSingleKeyStruct_Oneofnested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_Oneofnested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Oneofnested != nil {
		{
			size, err := m.Oneofnested.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *TestSingleKeyStruct_Embedded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct_Embedded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_Embedded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Embedded) > 0 {
		i -= len(m.Embedded)
		copy(dAtA[i:], m.Embedded)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Embedded)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestSingleKeyStruct_Embedded_Embedded2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct_Embedded_Embedded2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_Embedded_Embedded2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Embedded) > 0 {
		i -= len(m.Embedded)
		copy(dAtA[i:], m.Embedded)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Embedded)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestSingleKeyStruct_Nested) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct_Nested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_Nested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Nested2 != nil {
		{
			size, err := m.Nested2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nested) > 0 {
		i -= len(m.Nested)
		copy(dAtA[i:], m.Nested)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestSingleKeyStruct_Nested_Nested2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct_Nested_Nested2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_Nested_Nested2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nested2) > 0 {
		i -= len(m.Nested2)
		copy(dAtA[i:], m.Nested2)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested2)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestSingleKeyStruct_OneOfNested) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct_OneOfNested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_OneOfNested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Nested2 != nil {
		{
			size, err := m.Nested2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nested) > 0 {
		i -= len(m.Nested)
		copy(dAtA[i:], m.Nested)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestSingleKeyStruct_OneOfNested_Nested2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct_OneOfNested_Nested2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_OneOfNested_Nested2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nested2) > 0 {
		i -= len(m.Nested2)
		copy(dAtA[i:], m.Nested2)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested2)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IntSlice) > 0 {
		dAtA9 := make([]byte, len(m.IntSlice)*10)
		var j8 int
		for _, num1 := range m.IntSlice {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintTest(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.String_) > 0 {
		i -= len(m.String_)
		copy(dAtA[i:], m.String_)
		i = encodeVarintTest(dAtA, i, uint64(len(m.String_)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Oneof != nil {
		{
			size := m.Oneof.Size()
			i -= size
			if _, err := m.Oneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Nested) > 0 {
		for iNdEx := len(m.Nested) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nested[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.Embedded != nil {
		{
			size, err := m.Embedded.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Enums) > 0 {
		dAtA12 := make([]byte, len(m.Enums)*10)
		var j11 int
		for _, num := range m.Enums {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintTest(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x5a
	}
	if m.Enum != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Enum))
		i--
		dAtA[i] = 0x50
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTest(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTest(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Float != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Float))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Int64 != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Int64))
		i--
		dAtA[i] = 0x30
	}
	if m.Uint64 != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Uint64))
		i--
		dAtA[i] = 0x28
	}
	if m.Bool {
		i--
		if m.Bool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.StringSlice) > 0 {
		for iNdEx := len(m.StringSlice) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StringSlice[iNdEx])
			copy(dAtA[i:], m.StringSlice[iNdEx])
			i = encodeVarintTest(dAtA, i, uint64(len(m.StringSlice[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Key2) > 0 {
		i -= len(m.Key2)
		copy(dAtA[i:], m.Key2)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Key2)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key1) > 0 {
		i -= len(m.Key1)
		copy(dAtA[i:], m.Key1)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Key1)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct_Oneofstring) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_Oneofstring) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Oneofstring)
	copy(dAtA[i:], m.Oneofstring)
	i = encodeVarintTest(dAtA, i, uint64(len(m.Oneofstring)))
	i--
	dAtA[i] = 0x72
	return len(dAtA) - i, nil
}
func (m *TestMultiKeyStruct_Oneofnested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_Oneofnested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Oneofnested != nil {
		{
			size, err := m.Oneofnested.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *TestMultiKeyStruct_Embedded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct_Embedded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_Embedded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Embedded) > 0 {
		i -= len(m.Embedded)
		copy(dAtA[i:], m.Embedded)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Embedded)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct_Embedded_Embedded2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct_Embedded_Embedded2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_Embedded_Embedded2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Embedded) > 0 {
		i -= len(m.Embedded)
		copy(dAtA[i:], m.Embedded)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Embedded)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct_Nested) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct_Nested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_Nested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Int64 != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Int64))
		i--
		dAtA[i] = 0x20
	}
	if m.IsNested {
		i--
		if m.IsNested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Nested2 != nil {
		{
			size, err := m.Nested2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nested) > 0 {
		i -= len(m.Nested)
		copy(dAtA[i:], m.Nested)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct_Nested_Nested2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct_Nested_Nested2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_Nested_Nested2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Int64 != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Int64))
		i--
		dAtA[i] = 0x20
	}
	if m.IsNested {
		i--
		if m.IsNested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Nested2) > 0 {
		i -= len(m.Nested2)
		copy(dAtA[i:], m.Nested2)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested2)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct_OneOfNested) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct_OneOfNested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_OneOfNested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nested) > 0 {
		i -= len(m.Nested)
		copy(dAtA[i:], m.Nested)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct_OneOfNested_Nested2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct_OneOfNested_Nested2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_OneOfNested_Nested2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nested2) > 0 {
		i -= len(m.Nested2)
		copy(dAtA[i:], m.Nested2)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested2)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestGrandparent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestGrandparent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestGrandparent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Embedded) > 0 {
		for iNdEx := len(m.Embedded) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Embedded[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestGrandparent_Embedded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestGrandparent_Embedded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestGrandparent_Embedded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Embedded2) > 0 {
		for iNdEx := len(m.Embedded2) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Embedded2[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestGrandparent_Embedded_Embedded2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestGrandparent_Embedded_Embedded2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestGrandparent_Embedded_Embedded2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestParent1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestParent1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestParent1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintTest(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestParent1_Child1Ref) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestParent1_Child1Ref) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestParent1_Child1Ref) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ChildId) > 0 {
		i -= len(m.ChildId)
		copy(dAtA[i:], m.ChildId)
		i = encodeVarintTest(dAtA, i, uint64(len(m.ChildId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestChild1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestChild1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestChild1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestGrandChild1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestGrandChild1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestGrandChild1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChildId) > 0 {
		i -= len(m.ChildId)
		copy(dAtA[i:], m.ChildId)
		i = encodeVarintTest(dAtA, i, uint64(len(m.ChildId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintTest(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestGGrandChild1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestGGrandChild1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestGGrandChild1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestG2GrandChild1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestG2GrandChild1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestG2GrandChild1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChildId) > 0 {
		i -= len(m.ChildId)
		copy(dAtA[i:], m.ChildId)
		i = encodeVarintTest(dAtA, i, uint64(len(m.ChildId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintTest(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestG3GrandChild1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestG3GrandChild1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestG3GrandChild1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestParent2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestParent2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestParent2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintTest(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestChild2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestChild2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestChild2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GrandparentId) > 0 {
		i -= len(m.GrandparentId)
		copy(dAtA[i:], m.GrandparentId)
		i = encodeVarintTest(dAtA, i, uint64(len(m.GrandparentId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintTest(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestParent3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestParent3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestParent3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintTest(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTest(dAtA []byte, offset int, v uint64) int {
	offset -= sovTest(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TestSingleKeyStruct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.StringSlice) > 0 {
		for _, s := range m.StringSlice {
			l = len(s)
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if m.Bool {
		n += 2
	}
	if m.Uint64 != 0 {
		n += 1 + sovTest(uint64(m.Uint64))
	}
	if m.Int64 != 0 {
		n += 1 + sovTest(uint64(m.Int64))
	}
	if m.Float != 0 {
		n += 5
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + len(v) + sovTest(uint64(len(v)))
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if m.Enum != 0 {
		n += 1 + sovTest(uint64(m.Enum))
	}
	if len(m.Enums) > 0 {
		l = 0
		for _, e := range m.Enums {
			l += sovTest(uint64(e))
		}
		n += 1 + sovTest(uint64(l)) + l
	}
	if m.Embedded != nil {
		l = m.Embedded.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.Nested) > 0 {
		for _, e := range m.Nested {
			l = e.Size()
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if m.Oneof != nil {
		n += m.Oneof.Size()
	}
	l = len(m.Bytess)
	if l > 0 {
		n += 2 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSingleKeyStruct_Oneofstring) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Oneofstring)
	n += 1 + l + sovTest(uint64(l))
	return n
}
func (m *TestSingleKeyStruct_Oneofnested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Oneofnested != nil {
		l = m.Oneofnested.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	return n
}
func (m *TestSingleKeyStruct_Embedded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Embedded)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSingleKeyStruct_Embedded_Embedded2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Embedded)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSingleKeyStruct_Nested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.Nested2 != nil {
		l = m.Nested2.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSingleKeyStruct_Nested_Nested2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested2)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSingleKeyStruct_OneOfNested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.Nested2 != nil {
		l = m.Nested2.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSingleKeyStruct_OneOfNested_Nested2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested2)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key1)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Key2)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.StringSlice) > 0 {
		for _, s := range m.StringSlice {
			l = len(s)
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if m.Bool {
		n += 2
	}
	if m.Uint64 != 0 {
		n += 1 + sovTest(uint64(m.Uint64))
	}
	if m.Int64 != 0 {
		n += 1 + sovTest(uint64(m.Int64))
	}
	if m.Float != 0 {
		n += 5
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + len(v) + sovTest(uint64(len(v)))
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if m.Enum != 0 {
		n += 1 + sovTest(uint64(m.Enum))
	}
	if len(m.Enums) > 0 {
		l = 0
		for _, e := range m.Enums {
			l += sovTest(uint64(e))
		}
		n += 1 + sovTest(uint64(l)) + l
	}
	if m.Embedded != nil {
		l = m.Embedded.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.Nested) > 0 {
		for _, e := range m.Nested {
			l = e.Size()
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if m.Oneof != nil {
		n += m.Oneof.Size()
	}
	l = len(m.String_)
	if l > 0 {
		n += 2 + l + sovTest(uint64(l))
	}
	if len(m.IntSlice) > 0 {
		l = 0
		for _, e := range m.IntSlice {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct_Oneofstring) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Oneofstring)
	n += 1 + l + sovTest(uint64(l))
	return n
}
func (m *TestMultiKeyStruct_Oneofnested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Oneofnested != nil {
		l = m.Oneofnested.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	return n
}
func (m *TestMultiKeyStruct_Embedded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Embedded)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct_Embedded_Embedded2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Embedded)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct_Nested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.Nested2 != nil {
		l = m.Nested2.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if m.IsNested {
		n += 2
	}
	if m.Int64 != 0 {
		n += 1 + sovTest(uint64(m.Int64))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct_Nested_Nested2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested2)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.IsNested {
		n += 2
	}
	if m.Int64 != 0 {
		n += 1 + sovTest(uint64(m.Int64))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct_OneOfNested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct_OneOfNested_Nested2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested2)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestGrandparent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.Embedded) > 0 {
		for _, e := range m.Embedded {
			l = e.Size()
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestGrandparent_Embedded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.Embedded2) > 0 {
		for _, e := range m.Embedded2 {
			l = e.Size()
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestGrandparent_Embedded_Embedded2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestParent1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovTest(uint64(l))
		}
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestParent1_Child1Ref) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChildId)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestChild1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestGrandChild1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.ChildId)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestGGrandChild1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestG2GrandChild1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.ChildId)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestG3GrandChild1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestParent2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestChild2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.GrandparentId)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestParent3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTest(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTest(x uint64) (n int) {
	return sovTest(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TestSingleKeyStruct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestSingleKeyStruct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestSingleKeyStruct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringSlice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringSlice = append(m.StringSlice, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bool = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64", wireType)
			}
			m.Uint64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uint64 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			m.Int64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Int64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Float = float32(math.Float32frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTest
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			m.Enum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Enum |= TestSingleKeyStruct_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v TestSingleKeyStruct_Enum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TestSingleKeyStruct_Enum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Enums = append(m.Enums, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTest
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Enums) == 0 {
					m.Enums = make([]TestSingleKeyStruct_Enum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TestSingleKeyStruct_Enum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TestSingleKeyStruct_Enum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Enums = append(m.Enums, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Enums", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Embedded == nil {
				m.Embedded = &TestSingleKeyStruct_Embedded{}
			}
			if err := m.Embedded.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested = append(m.Nested, &TestSingleKeyStruct_Nested{})
			if err := m.Nested[len(m.Nested)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oneofstring", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oneof = &TestSingleKeyStruct_Oneofstring{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oneofnested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestSingleKeyStruct_OneOfNested{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &TestSingleKeyStruct_Oneofnested{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytess", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytess = append(m.Bytess[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytess == nil {
				m.Bytess = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSingleKeyStruct_Embedded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Embedded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Embedded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Embedded = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Embedded2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Embedded2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Embedded = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSingleKeyStruct_Nested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nested2 == nil {
				m.Nested2 = &TestSingleKeyStruct_Nested_Nested2{}
			}
			if err := m.Nested2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSingleKeyStruct_Nested_Nested2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSingleKeyStruct_OneOfNested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OneOfNested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OneOfNested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nested2 == nil {
				m.Nested2 = &TestSingleKeyStruct_OneOfNested_Nested2{}
			}
			if err := m.Nested2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestMultiKeyStruct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestMultiKeyStruct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringSlice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringSlice = append(m.StringSlice, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bool = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64", wireType)
			}
			m.Uint64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uint64 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			m.Int64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Int64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Float = float32(math.Float32frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTest
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			m.Enum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Enum |= TestMultiKeyStruct_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v TestMultiKeyStruct_Enum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TestMultiKeyStruct_Enum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Enums = append(m.Enums, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTest
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Enums) == 0 {
					m.Enums = make([]TestMultiKeyStruct_Enum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TestMultiKeyStruct_Enum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TestMultiKeyStruct_Enum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Enums = append(m.Enums, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Enums", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Embedded == nil {
				m.Embedded = &TestMultiKeyStruct_Embedded{}
			}
			if err := m.Embedded.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested = append(m.Nested, &TestMultiKeyStruct_Nested{})
			if err := m.Nested[len(m.Nested)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oneofstring", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oneof = &TestMultiKeyStruct_Oneofstring{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oneofnested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestMultiKeyStruct_OneOfNested{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &TestMultiKeyStruct_Oneofnested{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.String_ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IntSlice = append(m.IntSlice, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTest
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IntSlice) == 0 {
					m.IntSlice = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IntSlice = append(m.IntSlice, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IntSlice", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct_Embedded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Embedded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Embedded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Embedded = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Embedded2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Embedded2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Embedded = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct_Nested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nested2 == nil {
				m.Nested2 = &TestMultiKeyStruct_Nested_Nested2{}
			}
			if err := m.Nested2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNested = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			m.Int64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Int64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct_Nested_Nested2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNested = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			m.Int64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Int64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct_OneOfNested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OneOfNested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OneOfNested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestGrandparent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestGrandparent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestGrandparent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Embedded = append(m.Embedded, &TestGrandparent_Embedded{})
			if err := m.Embedded[len(m.Embedded)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestGrandparent_Embedded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Embedded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Embedded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Embedded2 = append(m.Embedded2, &TestGrandparent_Embedded_Embedded2{})
			if err := m.Embedded2[len(m.Embedded2)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestGrandparent_Embedded_Embedded2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Embedded2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Embedded2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestParent1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestParent1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestParent1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &TestParent1_Child1Ref{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestParent1_Child1Ref) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Child1Ref: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Child1Ref: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestChild1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestChild1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestChild1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestGrandChild1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestGrandChild1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestGrandChild1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestGGrandChild1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestGGrandChild1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestGGrandChild1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestG2GrandChild1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestG2GrandChild1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestG2GrandChild1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestG3GrandChild1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestG3GrandChild1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestG3GrandChild1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestParent2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestParent2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestParent2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestChild2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestChild2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestChild2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrandparentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GrandparentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestParent3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestParent3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestParent3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTest(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTest
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTest
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTest
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTest
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTest        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTest          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTest = fmt.Errorf("proto: unexpected end of group")
)
