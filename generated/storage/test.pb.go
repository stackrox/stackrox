// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/test.proto

package storage

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type TestSingleKeyStruct_Enum int32

const (
	TestSingleKeyStruct_ENUM0 TestSingleKeyStruct_Enum = 0
	TestSingleKeyStruct_ENUM1 TestSingleKeyStruct_Enum = 1
	TestSingleKeyStruct_ENUM2 TestSingleKeyStruct_Enum = 2
)

var TestSingleKeyStruct_Enum_name = map[int32]string{
	0: "ENUM0",
	1: "ENUM1",
	2: "ENUM2",
}

var TestSingleKeyStruct_Enum_value = map[string]int32{
	"ENUM0": 0,
	"ENUM1": 1,
	"ENUM2": 2,
}

func (x TestSingleKeyStruct_Enum) String() string {
	return proto.EnumName(TestSingleKeyStruct_Enum_name, int32(x))
}

func (TestSingleKeyStruct_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 0}
}

type TestMultiKeyStruct_Enum int32

const (
	TestMultiKeyStruct_ENUM0 TestMultiKeyStruct_Enum = 0
	TestMultiKeyStruct_ENUM1 TestMultiKeyStruct_Enum = 1
	TestMultiKeyStruct_ENUM2 TestMultiKeyStruct_Enum = 2
)

var TestMultiKeyStruct_Enum_name = map[int32]string{
	0: "ENUM0",
	1: "ENUM1",
	2: "ENUM2",
}

var TestMultiKeyStruct_Enum_value = map[string]int32{
	"ENUM0": 0,
	"ENUM1": 1,
	"ENUM2": 2,
}

func (x TestMultiKeyStruct_Enum) String() string {
	return proto.EnumName(TestMultiKeyStruct_Enum_name, int32(x))
}

func (TestMultiKeyStruct_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 0}
}

type TestSingleKeyStruct struct {
	Key         string                        `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" sql:"pk,index=hash" search:"Test Key"`
	Name        string                        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" sql:"unique" search:"Test Name"`
	StringSlice []string                      `protobuf:"bytes,3,rep,name=string_slice,json=stringSlice,proto3" json:"string_slice,omitempty" search:"Test String Slice"`
	Bool        bool                          `protobuf:"varint,4,opt,name=bool,proto3" json:"bool,omitempty" search:"Test Bool"`
	Uint64      uint64                        `protobuf:"varint,5,opt,name=uint64,proto3" json:"uint64,omitempty" search:"Test Uint64"`
	Int64       int64                         `protobuf:"varint,6,opt,name=int64,proto3" json:"int64,omitempty" search:"Test Int64"`
	Float       float32                       `protobuf:"fixed32,7,opt,name=float,proto3" json:"float,omitempty" search:"Test Float"`
	Labels      map[string]string             `protobuf:"bytes,8,rep,name=labels,proto3" json:"labels,omitempty" search:"Test Labels" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Timestamp   *types.Timestamp              `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty" search:"Test Timestamp"`
	Enum        TestSingleKeyStruct_Enum      `protobuf:"varint,10,opt,name=enum,proto3,enum=storage.TestSingleKeyStruct_Enum" json:"enum,omitempty" search:"Test Enum"`
	Enums       []TestSingleKeyStruct_Enum    `protobuf:"varint,11,rep,packed,name=enums,proto3,enum=storage.TestSingleKeyStruct_Enum" json:"enums,omitempty" search:"Test Enum Slice"`
	Embedded    *TestSingleKeyStruct_Embedded `protobuf:"bytes,12,opt,name=embedded,proto3" json:"embedded,omitempty"`
	Nested      []*TestSingleKeyStruct_Nested `protobuf:"bytes,13,rep,name=nested,proto3" json:"nested,omitempty"`
	// Types that are valid to be assigned to Oneof:
	//	*TestSingleKeyStruct_Oneofstring
	//	*TestSingleKeyStruct_Oneofnested
	Oneof                isTestSingleKeyStruct_Oneof `protobuf_oneof:"oneof"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *TestSingleKeyStruct) Reset()         { *m = TestSingleKeyStruct{} }
func (m *TestSingleKeyStruct) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct) ProtoMessage()    {}
func (*TestSingleKeyStruct) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0}
}
func (m *TestSingleKeyStruct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct.Merge(m, src)
}
func (m *TestSingleKeyStruct) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct proto.InternalMessageInfo

type isTestSingleKeyStruct_Oneof interface {
	isTestSingleKeyStruct_Oneof()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isTestSingleKeyStruct_Oneof
}

type TestSingleKeyStruct_Oneofstring struct {
	Oneofstring string `protobuf:"bytes,14,opt,name=oneofstring,proto3,oneof" json:"oneofstring,omitempty"`
}
type TestSingleKeyStruct_Oneofnested struct {
	Oneofnested *TestSingleKeyStruct_OneOfNested `protobuf:"bytes,15,opt,name=oneofnested,proto3,oneof" json:"oneofnested,omitempty"`
}

func (*TestSingleKeyStruct_Oneofstring) isTestSingleKeyStruct_Oneof() {}
func (m *TestSingleKeyStruct_Oneofstring) Clone() isTestSingleKeyStruct_Oneof {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_Oneofstring)
	*cloned = *m

	return cloned
}
func (*TestSingleKeyStruct_Oneofnested) isTestSingleKeyStruct_Oneof() {}
func (m *TestSingleKeyStruct_Oneofnested) Clone() isTestSingleKeyStruct_Oneof {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_Oneofnested)
	*cloned = *m

	cloned.Oneofnested = m.Oneofnested.Clone()
	return cloned
}

func (m *TestSingleKeyStruct) GetOneof() isTestSingleKeyStruct_Oneof {
	if m != nil {
		return m.Oneof
	}
	return nil
}

func (m *TestSingleKeyStruct) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *TestSingleKeyStruct) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TestSingleKeyStruct) GetStringSlice() []string {
	if m != nil {
		return m.StringSlice
	}
	return nil
}

func (m *TestSingleKeyStruct) GetBool() bool {
	if m != nil {
		return m.Bool
	}
	return false
}

func (m *TestSingleKeyStruct) GetUint64() uint64 {
	if m != nil {
		return m.Uint64
	}
	return 0
}

func (m *TestSingleKeyStruct) GetInt64() int64 {
	if m != nil {
		return m.Int64
	}
	return 0
}

func (m *TestSingleKeyStruct) GetFloat() float32 {
	if m != nil {
		return m.Float
	}
	return 0
}

func (m *TestSingleKeyStruct) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *TestSingleKeyStruct) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestSingleKeyStruct) GetEnum() TestSingleKeyStruct_Enum {
	if m != nil {
		return m.Enum
	}
	return TestSingleKeyStruct_ENUM0
}

func (m *TestSingleKeyStruct) GetEnums() []TestSingleKeyStruct_Enum {
	if m != nil {
		return m.Enums
	}
	return nil
}

func (m *TestSingleKeyStruct) GetEmbedded() *TestSingleKeyStruct_Embedded {
	if m != nil {
		return m.Embedded
	}
	return nil
}

func (m *TestSingleKeyStruct) GetNested() []*TestSingleKeyStruct_Nested {
	if m != nil {
		return m.Nested
	}
	return nil
}

func (m *TestSingleKeyStruct) GetOneofstring() string {
	if x, ok := m.GetOneof().(*TestSingleKeyStruct_Oneofstring); ok {
		return x.Oneofstring
	}
	return ""
}

func (m *TestSingleKeyStruct) GetOneofnested() *TestSingleKeyStruct_OneOfNested {
	if x, ok := m.GetOneof().(*TestSingleKeyStruct_Oneofnested); ok {
		return x.Oneofnested
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TestSingleKeyStruct) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TestSingleKeyStruct_Oneofstring)(nil),
		(*TestSingleKeyStruct_Oneofnested)(nil),
	}
}

func (m *TestSingleKeyStruct) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct) Clone() *TestSingleKeyStruct {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct)
	*cloned = *m

	if m.StringSlice != nil {
		cloned.StringSlice = make([]string, len(m.StringSlice))
		copy(cloned.StringSlice, m.StringSlice)
	}
	if m.Labels != nil {
		cloned.Labels = make(map[string]string, len(m.Labels))
		for k, v := range m.Labels {
			cloned.Labels[k] = v
		}
	}
	cloned.Timestamp = m.Timestamp.Clone()
	if m.Enums != nil {
		cloned.Enums = make([]TestSingleKeyStruct_Enum, len(m.Enums))
		copy(cloned.Enums, m.Enums)
	}
	cloned.Embedded = m.Embedded.Clone()
	if m.Nested != nil {
		cloned.Nested = make([]*TestSingleKeyStruct_Nested, len(m.Nested))
		for idx, v := range m.Nested {
			cloned.Nested[idx] = v.Clone()
		}
	}
	if m.Oneof != nil {
		cloned.Oneof = m.Oneof.Clone()
	}
	return cloned
}

type TestSingleKeyStruct_Embedded struct {
	Embedded             string   `protobuf:"bytes,1,opt,name=embedded,proto3" json:"embedded,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestSingleKeyStruct_Embedded) Reset()         { *m = TestSingleKeyStruct_Embedded{} }
func (m *TestSingleKeyStruct_Embedded) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct_Embedded) ProtoMessage()    {}
func (*TestSingleKeyStruct_Embedded) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 1}
}
func (m *TestSingleKeyStruct_Embedded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct_Embedded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct_Embedded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct_Embedded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct_Embedded.Merge(m, src)
}
func (m *TestSingleKeyStruct_Embedded) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct_Embedded) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct_Embedded.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct_Embedded proto.InternalMessageInfo

func (m *TestSingleKeyStruct_Embedded) GetEmbedded() string {
	if m != nil {
		return m.Embedded
	}
	return ""
}

func (m *TestSingleKeyStruct_Embedded) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct_Embedded) Clone() *TestSingleKeyStruct_Embedded {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_Embedded)
	*cloned = *m

	return cloned
}

type TestSingleKeyStruct_Embedded_Embedded2 struct {
	Embedded             string   `protobuf:"bytes,2,opt,name=embedded,proto3" json:"embedded,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestSingleKeyStruct_Embedded_Embedded2) Reset() {
	*m = TestSingleKeyStruct_Embedded_Embedded2{}
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct_Embedded_Embedded2) ProtoMessage()    {}
func (*TestSingleKeyStruct_Embedded_Embedded2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 1, 0}
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct_Embedded_Embedded2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct_Embedded_Embedded2.Merge(m, src)
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct_Embedded_Embedded2.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct_Embedded_Embedded2 proto.InternalMessageInfo

func (m *TestSingleKeyStruct_Embedded_Embedded2) GetEmbedded() string {
	if m != nil {
		return m.Embedded
	}
	return ""
}

func (m *TestSingleKeyStruct_Embedded_Embedded2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) Clone() *TestSingleKeyStruct_Embedded_Embedded2 {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_Embedded_Embedded2)
	*cloned = *m

	return cloned
}

type TestSingleKeyStruct_Nested struct {
	Nested               string                              `protobuf:"bytes,1,opt,name=nested,proto3" json:"nested,omitempty"`
	Nested2              *TestSingleKeyStruct_Nested_Nested2 `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *TestSingleKeyStruct_Nested) Reset()         { *m = TestSingleKeyStruct_Nested{} }
func (m *TestSingleKeyStruct_Nested) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct_Nested) ProtoMessage()    {}
func (*TestSingleKeyStruct_Nested) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 2}
}
func (m *TestSingleKeyStruct_Nested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct_Nested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct_Nested.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct_Nested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct_Nested.Merge(m, src)
}
func (m *TestSingleKeyStruct_Nested) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct_Nested) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct_Nested.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct_Nested proto.InternalMessageInfo

func (m *TestSingleKeyStruct_Nested) GetNested() string {
	if m != nil {
		return m.Nested
	}
	return ""
}

func (m *TestSingleKeyStruct_Nested) GetNested2() *TestSingleKeyStruct_Nested_Nested2 {
	if m != nil {
		return m.Nested2
	}
	return nil
}

func (m *TestSingleKeyStruct_Nested) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct_Nested) Clone() *TestSingleKeyStruct_Nested {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_Nested)
	*cloned = *m

	cloned.Nested2 = m.Nested2.Clone()
	return cloned
}

type TestSingleKeyStruct_Nested_Nested2 struct {
	Nested2              string   `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestSingleKeyStruct_Nested_Nested2) Reset()         { *m = TestSingleKeyStruct_Nested_Nested2{} }
func (m *TestSingleKeyStruct_Nested_Nested2) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct_Nested_Nested2) ProtoMessage()    {}
func (*TestSingleKeyStruct_Nested_Nested2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 2, 0}
}
func (m *TestSingleKeyStruct_Nested_Nested2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct_Nested_Nested2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct_Nested_Nested2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct_Nested_Nested2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct_Nested_Nested2.Merge(m, src)
}
func (m *TestSingleKeyStruct_Nested_Nested2) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct_Nested_Nested2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct_Nested_Nested2.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct_Nested_Nested2 proto.InternalMessageInfo

func (m *TestSingleKeyStruct_Nested_Nested2) GetNested2() string {
	if m != nil {
		return m.Nested2
	}
	return ""
}

func (m *TestSingleKeyStruct_Nested_Nested2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct_Nested_Nested2) Clone() *TestSingleKeyStruct_Nested_Nested2 {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_Nested_Nested2)
	*cloned = *m

	return cloned
}

type TestSingleKeyStruct_OneOfNested struct {
	Nested               string                                   `protobuf:"bytes,1,opt,name=nested,proto3" json:"nested,omitempty"`
	Nested2              *TestSingleKeyStruct_OneOfNested_Nested2 `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *TestSingleKeyStruct_OneOfNested) Reset()         { *m = TestSingleKeyStruct_OneOfNested{} }
func (m *TestSingleKeyStruct_OneOfNested) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct_OneOfNested) ProtoMessage()    {}
func (*TestSingleKeyStruct_OneOfNested) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 3}
}
func (m *TestSingleKeyStruct_OneOfNested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct_OneOfNested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct_OneOfNested.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct_OneOfNested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct_OneOfNested.Merge(m, src)
}
func (m *TestSingleKeyStruct_OneOfNested) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct_OneOfNested) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct_OneOfNested.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct_OneOfNested proto.InternalMessageInfo

func (m *TestSingleKeyStruct_OneOfNested) GetNested() string {
	if m != nil {
		return m.Nested
	}
	return ""
}

func (m *TestSingleKeyStruct_OneOfNested) GetNested2() *TestSingleKeyStruct_OneOfNested_Nested2 {
	if m != nil {
		return m.Nested2
	}
	return nil
}

func (m *TestSingleKeyStruct_OneOfNested) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct_OneOfNested) Clone() *TestSingleKeyStruct_OneOfNested {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_OneOfNested)
	*cloned = *m

	cloned.Nested2 = m.Nested2.Clone()
	return cloned
}

type TestSingleKeyStruct_OneOfNested_Nested2 struct {
	Nested2              string   `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestSingleKeyStruct_OneOfNested_Nested2) Reset() {
	*m = TestSingleKeyStruct_OneOfNested_Nested2{}
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) String() string { return proto.CompactTextString(m) }
func (*TestSingleKeyStruct_OneOfNested_Nested2) ProtoMessage()    {}
func (*TestSingleKeyStruct_OneOfNested_Nested2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{0, 3, 0}
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSingleKeyStruct_OneOfNested_Nested2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSingleKeyStruct_OneOfNested_Nested2.Merge(m, src)
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) XXX_Size() int {
	return m.Size()
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSingleKeyStruct_OneOfNested_Nested2.DiscardUnknown(m)
}

var xxx_messageInfo_TestSingleKeyStruct_OneOfNested_Nested2 proto.InternalMessageInfo

func (m *TestSingleKeyStruct_OneOfNested_Nested2) GetNested2() string {
	if m != nil {
		return m.Nested2
	}
	return ""
}

func (m *TestSingleKeyStruct_OneOfNested_Nested2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) Clone() *TestSingleKeyStruct_OneOfNested_Nested2 {
	if m == nil {
		return nil
	}
	cloned := new(TestSingleKeyStruct_OneOfNested_Nested2)
	*cloned = *m

	return cloned
}

type TestMultiKeyStruct struct {
	Key1        string                       `protobuf:"bytes,1,opt,name=key1,proto3" json:"key1,omitempty" sql:"pk" search:"Test Key"`
	Key2        string                       `protobuf:"bytes,2,opt,name=key2,proto3" json:"key2,omitempty" sql:"pk"`
	StringSlice []string                     `protobuf:"bytes,3,rep,name=string_slice,json=stringSlice,proto3" json:"string_slice,omitempty" search:"Test String Slice"`
	Bool        bool                         `protobuf:"varint,4,opt,name=bool,proto3" json:"bool,omitempty" search:"Test Bool"`
	Uint64      uint64                       `protobuf:"varint,5,opt,name=uint64,proto3" json:"uint64,omitempty" search:"Test Uint64"`
	Int64       int64                        `protobuf:"varint,6,opt,name=int64,proto3" json:"int64,omitempty" search:"Test Int64"`
	Float       float32                      `protobuf:"fixed32,7,opt,name=float,proto3" json:"float,omitempty" search:"Test Float"`
	Labels      map[string]string            `protobuf:"bytes,8,rep,name=labels,proto3" json:"labels,omitempty" search:"Test Labels" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Timestamp   *types.Timestamp             `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty" search:"Test Timestamp"`
	Enum        TestMultiKeyStruct_Enum      `protobuf:"varint,10,opt,name=enum,proto3,enum=storage.TestMultiKeyStruct_Enum" json:"enum,omitempty" search:"Test Enum"`
	Enums       []TestMultiKeyStruct_Enum    `protobuf:"varint,11,rep,packed,name=enums,proto3,enum=storage.TestMultiKeyStruct_Enum" json:"enums,omitempty" search:"Test Enum Slice"`
	String_     string                       `protobuf:"bytes,16,opt,name=string,proto3" json:"string,omitempty" search:"Test String"`
	IntSlice    []int64                      `protobuf:"varint,17,rep,packed,name=int_slice,json=intSlice,proto3" json:"int_slice,omitempty" search:"Test Int64 Slice"`
	Embedded    *TestMultiKeyStruct_Embedded `protobuf:"bytes,12,opt,name=embedded,proto3" json:"embedded,omitempty"`
	Nested      []*TestMultiKeyStruct_Nested `protobuf:"bytes,13,rep,name=nested,proto3" json:"nested,omitempty"`
	// Types that are valid to be assigned to Oneof:
	//	*TestMultiKeyStruct_Oneofstring
	//	*TestMultiKeyStruct_Oneofnested
	Oneof                isTestMultiKeyStruct_Oneof `protobuf_oneof:"oneof"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TestMultiKeyStruct) Reset()         { *m = TestMultiKeyStruct{} }
func (m *TestMultiKeyStruct) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct) ProtoMessage()    {}
func (*TestMultiKeyStruct) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1}
}
func (m *TestMultiKeyStruct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct.Merge(m, src)
}
func (m *TestMultiKeyStruct) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct proto.InternalMessageInfo

type isTestMultiKeyStruct_Oneof interface {
	isTestMultiKeyStruct_Oneof()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isTestMultiKeyStruct_Oneof
}

type TestMultiKeyStruct_Oneofstring struct {
	Oneofstring string `protobuf:"bytes,14,opt,name=oneofstring,proto3,oneof" json:"oneofstring,omitempty"`
}
type TestMultiKeyStruct_Oneofnested struct {
	Oneofnested *TestMultiKeyStruct_OneOfNested `protobuf:"bytes,15,opt,name=oneofnested,proto3,oneof" json:"oneofnested,omitempty"`
}

func (*TestMultiKeyStruct_Oneofstring) isTestMultiKeyStruct_Oneof() {}
func (m *TestMultiKeyStruct_Oneofstring) Clone() isTestMultiKeyStruct_Oneof {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_Oneofstring)
	*cloned = *m

	return cloned
}
func (*TestMultiKeyStruct_Oneofnested) isTestMultiKeyStruct_Oneof() {}
func (m *TestMultiKeyStruct_Oneofnested) Clone() isTestMultiKeyStruct_Oneof {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_Oneofnested)
	*cloned = *m

	cloned.Oneofnested = m.Oneofnested.Clone()
	return cloned
}

func (m *TestMultiKeyStruct) GetOneof() isTestMultiKeyStruct_Oneof {
	if m != nil {
		return m.Oneof
	}
	return nil
}

func (m *TestMultiKeyStruct) GetKey1() string {
	if m != nil {
		return m.Key1
	}
	return ""
}

func (m *TestMultiKeyStruct) GetKey2() string {
	if m != nil {
		return m.Key2
	}
	return ""
}

func (m *TestMultiKeyStruct) GetStringSlice() []string {
	if m != nil {
		return m.StringSlice
	}
	return nil
}

func (m *TestMultiKeyStruct) GetBool() bool {
	if m != nil {
		return m.Bool
	}
	return false
}

func (m *TestMultiKeyStruct) GetUint64() uint64 {
	if m != nil {
		return m.Uint64
	}
	return 0
}

func (m *TestMultiKeyStruct) GetInt64() int64 {
	if m != nil {
		return m.Int64
	}
	return 0
}

func (m *TestMultiKeyStruct) GetFloat() float32 {
	if m != nil {
		return m.Float
	}
	return 0
}

func (m *TestMultiKeyStruct) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *TestMultiKeyStruct) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestMultiKeyStruct) GetEnum() TestMultiKeyStruct_Enum {
	if m != nil {
		return m.Enum
	}
	return TestMultiKeyStruct_ENUM0
}

func (m *TestMultiKeyStruct) GetEnums() []TestMultiKeyStruct_Enum {
	if m != nil {
		return m.Enums
	}
	return nil
}

func (m *TestMultiKeyStruct) GetString_() string {
	if m != nil {
		return m.String_
	}
	return ""
}

func (m *TestMultiKeyStruct) GetIntSlice() []int64 {
	if m != nil {
		return m.IntSlice
	}
	return nil
}

func (m *TestMultiKeyStruct) GetEmbedded() *TestMultiKeyStruct_Embedded {
	if m != nil {
		return m.Embedded
	}
	return nil
}

func (m *TestMultiKeyStruct) GetNested() []*TestMultiKeyStruct_Nested {
	if m != nil {
		return m.Nested
	}
	return nil
}

func (m *TestMultiKeyStruct) GetOneofstring() string {
	if x, ok := m.GetOneof().(*TestMultiKeyStruct_Oneofstring); ok {
		return x.Oneofstring
	}
	return ""
}

func (m *TestMultiKeyStruct) GetOneofnested() *TestMultiKeyStruct_OneOfNested {
	if x, ok := m.GetOneof().(*TestMultiKeyStruct_Oneofnested); ok {
		return x.Oneofnested
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TestMultiKeyStruct) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TestMultiKeyStruct_Oneofstring)(nil),
		(*TestMultiKeyStruct_Oneofnested)(nil),
	}
}

func (m *TestMultiKeyStruct) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct) Clone() *TestMultiKeyStruct {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct)
	*cloned = *m

	if m.StringSlice != nil {
		cloned.StringSlice = make([]string, len(m.StringSlice))
		copy(cloned.StringSlice, m.StringSlice)
	}
	if m.Labels != nil {
		cloned.Labels = make(map[string]string, len(m.Labels))
		for k, v := range m.Labels {
			cloned.Labels[k] = v
		}
	}
	cloned.Timestamp = m.Timestamp.Clone()
	if m.Enums != nil {
		cloned.Enums = make([]TestMultiKeyStruct_Enum, len(m.Enums))
		copy(cloned.Enums, m.Enums)
	}
	if m.IntSlice != nil {
		cloned.IntSlice = make([]int64, len(m.IntSlice))
		copy(cloned.IntSlice, m.IntSlice)
	}
	cloned.Embedded = m.Embedded.Clone()
	if m.Nested != nil {
		cloned.Nested = make([]*TestMultiKeyStruct_Nested, len(m.Nested))
		for idx, v := range m.Nested {
			cloned.Nested[idx] = v.Clone()
		}
	}
	if m.Oneof != nil {
		cloned.Oneof = m.Oneof.Clone()
	}
	return cloned
}

type TestMultiKeyStruct_Embedded struct {
	Embedded             string   `protobuf:"bytes,1,opt,name=embedded,proto3" json:"embedded,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestMultiKeyStruct_Embedded) Reset()         { *m = TestMultiKeyStruct_Embedded{} }
func (m *TestMultiKeyStruct_Embedded) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct_Embedded) ProtoMessage()    {}
func (*TestMultiKeyStruct_Embedded) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 1}
}
func (m *TestMultiKeyStruct_Embedded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct_Embedded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct_Embedded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct_Embedded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct_Embedded.Merge(m, src)
}
func (m *TestMultiKeyStruct_Embedded) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct_Embedded) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct_Embedded.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct_Embedded proto.InternalMessageInfo

func (m *TestMultiKeyStruct_Embedded) GetEmbedded() string {
	if m != nil {
		return m.Embedded
	}
	return ""
}

func (m *TestMultiKeyStruct_Embedded) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct_Embedded) Clone() *TestMultiKeyStruct_Embedded {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_Embedded)
	*cloned = *m

	return cloned
}

type TestMultiKeyStruct_Embedded_Embedded2 struct {
	Embedded             string   `protobuf:"bytes,2,opt,name=embedded,proto3" json:"embedded,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestMultiKeyStruct_Embedded_Embedded2) Reset()         { *m = TestMultiKeyStruct_Embedded_Embedded2{} }
func (m *TestMultiKeyStruct_Embedded_Embedded2) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct_Embedded_Embedded2) ProtoMessage()    {}
func (*TestMultiKeyStruct_Embedded_Embedded2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 1, 0}
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct_Embedded_Embedded2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct_Embedded_Embedded2.Merge(m, src)
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct_Embedded_Embedded2.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct_Embedded_Embedded2 proto.InternalMessageInfo

func (m *TestMultiKeyStruct_Embedded_Embedded2) GetEmbedded() string {
	if m != nil {
		return m.Embedded
	}
	return ""
}

func (m *TestMultiKeyStruct_Embedded_Embedded2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) Clone() *TestMultiKeyStruct_Embedded_Embedded2 {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_Embedded_Embedded2)
	*cloned = *m

	return cloned
}

type TestMultiKeyStruct_Nested struct {
	Nested               string                             `protobuf:"bytes,1,opt,name=nested,proto3" json:"nested,omitempty" search:"Test Nested String"`
	IsNested             bool                               `protobuf:"varint,3,opt,name=is_nested,json=isNested,proto3" json:"is_nested,omitempty" search:"Test Nested Bool"`
	Int64                int64                              `protobuf:"varint,4,opt,name=int64,proto3" json:"int64,omitempty" search:"Test Nested Int64"`
	Nested2              *TestMultiKeyStruct_Nested_Nested2 `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *TestMultiKeyStruct_Nested) Reset()         { *m = TestMultiKeyStruct_Nested{} }
func (m *TestMultiKeyStruct_Nested) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct_Nested) ProtoMessage()    {}
func (*TestMultiKeyStruct_Nested) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 2}
}
func (m *TestMultiKeyStruct_Nested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct_Nested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct_Nested.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct_Nested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct_Nested.Merge(m, src)
}
func (m *TestMultiKeyStruct_Nested) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct_Nested) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct_Nested.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct_Nested proto.InternalMessageInfo

func (m *TestMultiKeyStruct_Nested) GetNested() string {
	if m != nil {
		return m.Nested
	}
	return ""
}

func (m *TestMultiKeyStruct_Nested) GetIsNested() bool {
	if m != nil {
		return m.IsNested
	}
	return false
}

func (m *TestMultiKeyStruct_Nested) GetInt64() int64 {
	if m != nil {
		return m.Int64
	}
	return 0
}

func (m *TestMultiKeyStruct_Nested) GetNested2() *TestMultiKeyStruct_Nested_Nested2 {
	if m != nil {
		return m.Nested2
	}
	return nil
}

func (m *TestMultiKeyStruct_Nested) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct_Nested) Clone() *TestMultiKeyStruct_Nested {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_Nested)
	*cloned = *m

	cloned.Nested2 = m.Nested2.Clone()
	return cloned
}

type TestMultiKeyStruct_Nested_Nested2 struct {
	Nested2              string   `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty" search:"Test Nested String 2"`
	IsNested             bool     `protobuf:"varint,3,opt,name=is_nested,json=isNested,proto3" json:"is_nested,omitempty" search:"Test Nested Bool 2"`
	Int64                int64    `protobuf:"varint,4,opt,name=int64,proto3" json:"int64,omitempty" search:"Test Nested Int64 2"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestMultiKeyStruct_Nested_Nested2) Reset()         { *m = TestMultiKeyStruct_Nested_Nested2{} }
func (m *TestMultiKeyStruct_Nested_Nested2) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct_Nested_Nested2) ProtoMessage()    {}
func (*TestMultiKeyStruct_Nested_Nested2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 2, 0}
}
func (m *TestMultiKeyStruct_Nested_Nested2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct_Nested_Nested2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct_Nested_Nested2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct_Nested_Nested2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct_Nested_Nested2.Merge(m, src)
}
func (m *TestMultiKeyStruct_Nested_Nested2) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct_Nested_Nested2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct_Nested_Nested2.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct_Nested_Nested2 proto.InternalMessageInfo

func (m *TestMultiKeyStruct_Nested_Nested2) GetNested2() string {
	if m != nil {
		return m.Nested2
	}
	return ""
}

func (m *TestMultiKeyStruct_Nested_Nested2) GetIsNested() bool {
	if m != nil {
		return m.IsNested
	}
	return false
}

func (m *TestMultiKeyStruct_Nested_Nested2) GetInt64() int64 {
	if m != nil {
		return m.Int64
	}
	return 0
}

func (m *TestMultiKeyStruct_Nested_Nested2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct_Nested_Nested2) Clone() *TestMultiKeyStruct_Nested_Nested2 {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_Nested_Nested2)
	*cloned = *m

	return cloned
}

type TestMultiKeyStruct_OneOfNested struct {
	Nested               string   `protobuf:"bytes,1,opt,name=nested,proto3" json:"nested,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestMultiKeyStruct_OneOfNested) Reset()         { *m = TestMultiKeyStruct_OneOfNested{} }
func (m *TestMultiKeyStruct_OneOfNested) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct_OneOfNested) ProtoMessage()    {}
func (*TestMultiKeyStruct_OneOfNested) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 3}
}
func (m *TestMultiKeyStruct_OneOfNested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct_OneOfNested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct_OneOfNested.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct_OneOfNested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct_OneOfNested.Merge(m, src)
}
func (m *TestMultiKeyStruct_OneOfNested) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct_OneOfNested) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct_OneOfNested.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct_OneOfNested proto.InternalMessageInfo

func (m *TestMultiKeyStruct_OneOfNested) GetNested() string {
	if m != nil {
		return m.Nested
	}
	return ""
}

func (m *TestMultiKeyStruct_OneOfNested) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct_OneOfNested) Clone() *TestMultiKeyStruct_OneOfNested {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_OneOfNested)
	*cloned = *m

	return cloned
}

type TestMultiKeyStruct_OneOfNested_Nested2 struct {
	Nested2              string   `protobuf:"bytes,2,opt,name=nested2,proto3" json:"nested2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestMultiKeyStruct_OneOfNested_Nested2) Reset() {
	*m = TestMultiKeyStruct_OneOfNested_Nested2{}
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) String() string { return proto.CompactTextString(m) }
func (*TestMultiKeyStruct_OneOfNested_Nested2) ProtoMessage()    {}
func (*TestMultiKeyStruct_OneOfNested_Nested2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80f1f1db1167453, []int{1, 3, 0}
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMultiKeyStruct_OneOfNested_Nested2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMultiKeyStruct_OneOfNested_Nested2.Merge(m, src)
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) XXX_Size() int {
	return m.Size()
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMultiKeyStruct_OneOfNested_Nested2.DiscardUnknown(m)
}

var xxx_messageInfo_TestMultiKeyStruct_OneOfNested_Nested2 proto.InternalMessageInfo

func (m *TestMultiKeyStruct_OneOfNested_Nested2) GetNested2() string {
	if m != nil {
		return m.Nested2
	}
	return ""
}

func (m *TestMultiKeyStruct_OneOfNested_Nested2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) Clone() *TestMultiKeyStruct_OneOfNested_Nested2 {
	if m == nil {
		return nil
	}
	cloned := new(TestMultiKeyStruct_OneOfNested_Nested2)
	*cloned = *m

	return cloned
}

func init() {
	proto.RegisterEnum("storage.TestSingleKeyStruct_Enum", TestSingleKeyStruct_Enum_name, TestSingleKeyStruct_Enum_value)
	proto.RegisterEnum("storage.TestMultiKeyStruct_Enum", TestMultiKeyStruct_Enum_name, TestMultiKeyStruct_Enum_value)
	proto.RegisterType((*TestSingleKeyStruct)(nil), "storage.TestSingleKeyStruct")
	proto.RegisterMapType((map[string]string)(nil), "storage.TestSingleKeyStruct.LabelsEntry")
	proto.RegisterType((*TestSingleKeyStruct_Embedded)(nil), "storage.TestSingleKeyStruct.Embedded")
	proto.RegisterType((*TestSingleKeyStruct_Embedded_Embedded2)(nil), "storage.TestSingleKeyStruct.Embedded.Embedded2")
	proto.RegisterType((*TestSingleKeyStruct_Nested)(nil), "storage.TestSingleKeyStruct.Nested")
	proto.RegisterType((*TestSingleKeyStruct_Nested_Nested2)(nil), "storage.TestSingleKeyStruct.Nested.Nested2")
	proto.RegisterType((*TestSingleKeyStruct_OneOfNested)(nil), "storage.TestSingleKeyStruct.OneOfNested")
	proto.RegisterType((*TestSingleKeyStruct_OneOfNested_Nested2)(nil), "storage.TestSingleKeyStruct.OneOfNested.Nested2")
	proto.RegisterType((*TestMultiKeyStruct)(nil), "storage.TestMultiKeyStruct")
	proto.RegisterMapType((map[string]string)(nil), "storage.TestMultiKeyStruct.LabelsEntry")
	proto.RegisterType((*TestMultiKeyStruct_Embedded)(nil), "storage.TestMultiKeyStruct.Embedded")
	proto.RegisterType((*TestMultiKeyStruct_Embedded_Embedded2)(nil), "storage.TestMultiKeyStruct.Embedded.Embedded2")
	proto.RegisterType((*TestMultiKeyStruct_Nested)(nil), "storage.TestMultiKeyStruct.Nested")
	proto.RegisterType((*TestMultiKeyStruct_Nested_Nested2)(nil), "storage.TestMultiKeyStruct.Nested.Nested2")
	proto.RegisterType((*TestMultiKeyStruct_OneOfNested)(nil), "storage.TestMultiKeyStruct.OneOfNested")
	proto.RegisterType((*TestMultiKeyStruct_OneOfNested_Nested2)(nil), "storage.TestMultiKeyStruct.OneOfNested.Nested2")
}

func init() { proto.RegisterFile("storage/test.proto", fileDescriptor_f80f1f1db1167453) }

var fileDescriptor_f80f1f1db1167453 = []byte{
	// 1017 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x57, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xce, 0x78, 0xfd, 0x3b, 0x4e, 0x8b, 0x99, 0x46, 0xed, 0x76, 0xdb, 0x7a, 0xa7, 0x13, 0xaa,
	0x2c, 0x05, 0x9c, 0x74, 0xa9, 0x1a, 0x70, 0x40, 0xa2, 0x2b, 0x82, 0xa0, 0xf9, 0x93, 0x36, 0xc9,
	0x05, 0xbd, 0xa9, 0xd6, 0xf1, 0xc4, 0x59, 0x65, 0xbd, 0x9b, 0x7a, 0xc7, 0xa8, 0x7e, 0x07, 0xae,
	0x11, 0x8f, 0x82, 0x04, 0x0f, 0xc0, 0x25, 0x4f, 0xb0, 0x82, 0xf0, 0x06, 0x7b, 0xc5, 0x25, 0xda,
	0x99, 0x59, 0xdb, 0x6b, 0x3b, 0xae, 0x15, 0x09, 0x09, 0xc4, 0x95, 0x67, 0x67, 0xbe, 0xef, 0xdb,
	0xb3, 0xe7, 0x9c, 0xf9, 0x4e, 0x02, 0x51, 0xc8, 0x82, 0x9e, 0xd3, 0xa1, 0xeb, 0x8c, 0x86, 0xac,
	0x71, 0xd1, 0x0b, 0x58, 0x80, 0x4a, 0x72, 0x4f, 0xd3, 0x3b, 0x41, 0xd0, 0xf1, 0xe8, 0x3a, 0xdf,
	0x6e, 0xf5, 0x4f, 0xd7, 0x99, 0xdb, 0xa5, 0x21, 0x73, 0xba, 0x17, 0x02, 0xa9, 0xad, 0x74, 0x82,
	0x4e, 0xc0, 0x97, 0xeb, 0xc9, 0x4a, 0xec, 0x92, 0x9f, 0xab, 0xf0, 0xd6, 0x11, 0x0d, 0xd9, 0xa1,
	0xeb, 0x77, 0x3c, 0xba, 0x43, 0x07, 0x87, 0xac, 0xd7, 0x3f, 0x61, 0x68, 0x0b, 0x2a, 0xe7, 0x74,
	0xa0, 0x02, 0x0c, 0x8c, 0x8a, 0xf5, 0x7e, 0x1c, 0xe9, 0x8f, 0xc2, 0xd7, 0x5e, 0x93, 0x5c, 0x9c,
	0x7f, 0xe8, 0xfa, 0x6d, 0xfa, 0xe6, 0xf3, 0x33, 0x27, 0x3c, 0x23, 0x38, 0xa4, 0x4e, 0xef, 0xe4,
	0xac, 0x49, 0x12, 0x05, 0xbc, 0x43, 0x07, 0xc4, 0x4e, 0x58, 0x68, 0x13, 0xe6, 0x7d, 0xa7, 0x4b,
	0xd5, 0x1c, 0x67, 0xaf, 0xc6, 0x91, 0xae, 0x73, 0x76, 0xdf, 0x77, 0x5f, 0xf7, 0xe9, 0x04, 0x6d,
	0xdf, 0xe9, 0x52, 0x62, 0x73, 0x02, 0x7a, 0x0e, 0x97, 0x43, 0xd6, 0x73, 0xfd, 0xce, 0xab, 0xd0,
	0x73, 0x4f, 0xa8, 0xaa, 0x60, 0xc5, 0xa8, 0x58, 0xf5, 0x38, 0xd2, 0xb5, 0x0c, 0xe7, 0x90, 0x83,
	0xf0, 0x61, 0x02, 0x22, 0x76, 0x55, 0x70, 0xf8, 0x13, 0x7a, 0x0c, 0xf3, 0xad, 0x20, 0xf0, 0xd4,
	0x3c, 0x06, 0x46, 0xd9, 0xba, 0x1d, 0x47, 0x3a, 0xca, 0x50, 0xad, 0x20, 0xf0, 0x88, 0xcd, 0x31,
	0x68, 0x03, 0x16, 0xfb, 0xae, 0xcf, 0x9e, 0x3d, 0x55, 0x0b, 0x18, 0x18, 0x79, 0x4b, 0x8d, 0x23,
	0x7d, 0x25, 0x83, 0x3e, 0xe6, 0xc7, 0xc4, 0x96, 0x38, 0xf4, 0x11, 0x2c, 0x08, 0x42, 0x11, 0x03,
	0x43, 0xb1, 0xee, 0xc4, 0x91, 0x7e, 0x2b, 0x43, 0xf8, 0x46, 0xe0, 0x0b, 0x43, 0xf8, 0xa9, 0x17,
	0x38, 0x4c, 0x2d, 0x61, 0x60, 0xe4, 0x66, 0xc0, 0xbf, 0x4a, 0x4e, 0x89, 0x2d, 0x50, 0xe8, 0x25,
	0x2c, 0x7a, 0x4e, 0x8b, 0x7a, 0xa1, 0x5a, 0xc6, 0x8a, 0x51, 0x35, 0x8d, 0x86, 0xac, 0x6e, 0x63,
	0x46, 0x89, 0x1a, 0xbb, 0x1c, 0xba, 0xed, 0xb3, 0xde, 0x60, 0x46, 0xe4, 0xe2, 0x94, 0xd8, 0x52,
	0x11, 0x1d, 0xc3, 0xca, 0xb0, 0x23, 0xd4, 0x0a, 0x06, 0x46, 0xd5, 0xd4, 0x1a, 0xa2, 0x67, 0x1a,
	0x69, 0xcf, 0x34, 0x8e, 0x52, 0x84, 0x75, 0x2f, 0x8e, 0xf4, 0x3b, 0x19, 0xc1, 0xe1, 0x19, 0xb1,
	0x47, 0x4a, 0x68, 0x0f, 0xe6, 0xa9, 0xdf, 0xef, 0xaa, 0x10, 0x03, 0xe3, 0xa6, 0xf9, 0x70, 0x6e,
	0xc0, 0xdb, 0x7e, 0xbf, 0x3b, 0xa3, 0x22, 0xc9, 0x36, 0xb1, 0xb9, 0x0c, 0x3a, 0x86, 0x85, 0xe4,
	0x37, 0x54, 0xab, 0x58, 0x59, 0x4c, 0xef, 0x7e, 0x1c, 0xe9, 0xea, 0x94, 0x5e, 0xda, 0x1a, 0x42,
	0x0d, 0x3d, 0x87, 0x65, 0xda, 0x6d, 0xd1, 0x76, 0x9b, 0xb6, 0xd5, 0x65, 0xfe, 0xed, 0x8f, 0xe6,
	0x2b, 0x4b, 0xb0, 0x3d, 0xa4, 0xa1, 0x2d, 0x58, 0xf4, 0x69, 0xc8, 0x68, 0x5b, 0xbd, 0xc1, 0x6b,
	0xb3, 0x3a, 0x57, 0x60, 0x9f, 0x43, 0x6d, 0x49, 0x41, 0x04, 0x56, 0x03, 0x9f, 0x06, 0xa7, 0xa2,
	0x51, 0xd5, 0x9b, 0xc9, 0xbd, 0xf8, 0x7a, 0xc9, 0x1e, 0xdf, 0x44, 0xbb, 0x12, 0x23, 0xdf, 0xf2,
	0x0e, 0x0f, 0x73, 0x7e, 0x07, 0x1c, 0xf8, 0xf4, 0xe0, 0x54, 0xbc, 0x6a, 0xa8, 0x26, 0xe8, 0xda,
	0xa7, 0xb0, 0x3a, 0xd6, 0x1f, 0xa8, 0x36, 0x76, 0x9d, 0xc5, 0x1d, 0x5d, 0x81, 0x85, 0xef, 0x1c,
	0xaf, 0x2f, 0x2f, 0xa9, 0x2d, 0x1e, 0x9a, 0xb9, 0x4f, 0x80, 0x76, 0x00, 0xcb, 0xe9, 0xf7, 0x23,
	0x6d, 0x2c, 0x71, 0x82, 0x3c, 0x7c, 0xd6, 0xd6, 0x60, 0x25, 0xc5, 0x99, 0x19, 0x60, 0x6e, 0x02,
	0xf8, 0x3d, 0x80, 0x45, 0x11, 0x25, 0xba, 0x3d, 0xcc, 0xa2, 0x50, 0x4b, 0x13, 0xb4, 0x0d, 0x4b,
	0x62, 0x65, 0x72, 0x76, 0xd5, 0xfc, 0x60, 0x81, 0xf4, 0xca, 0x1f, 0xd3, 0x4e, 0xb9, 0xda, 0x2a,
	0x2c, 0xc9, 0x3d, 0xa4, 0x66, 0x15, 0x2b, 0x23, 0xd0, 0x0f, 0x00, 0x56, 0xc7, 0x32, 0x77, 0x65,
	0x4c, 0x2f, 0x26, 0x63, 0xda, 0x58, 0xb4, 0x18, 0xd7, 0x0b, 0x8c, 0xac, 0xc1, 0x7c, 0xd2, 0xbb,
	0xa8, 0x02, 0x0b, 0xdb, 0xfb, 0xc7, 0x7b, 0x1b, 0xb5, 0xa5, 0x74, 0xf9, 0xa4, 0x06, 0xd2, 0xa5,
	0x59, 0xcb, 0x59, 0x25, 0x58, 0xe0, 0xb5, 0x26, 0x7f, 0xdc, 0x80, 0x28, 0x89, 0x65, 0xaf, 0xef,
	0x31, 0x77, 0x64, 0xde, 0x26, 0xcc, 0x9f, 0xd3, 0xc1, 0x13, 0xe9, 0xde, 0xc2, 0x3e, 0x85, 0x7b,
	0xcf, 0xb2, 0x6c, 0x8e, 0x45, 0x98, 0x73, 0x64, 0x4c, 0xd6, 0x72, 0x1c, 0xe9, 0xe5, 0x94, 0xc3,
	0x11, 0xe6, 0xff, 0xdd, 0x9c, 0xbf, 0x9d, 0x30, 0xe7, 0xb5, 0x4c, 0x37, 0x64, 0x2b, 0xf0, 0xef,
	0xf0, 0xe6, 0xdd, 0x8c, 0x37, 0xe3, 0x79, 0xf1, 0x2e, 0x60, 0xcd, 0x47, 0x59, 0x6b, 0x7e, 0xbb,
	0xdc, 0x42, 0xce, 0xbc, 0x01, 0x8b, 0xd2, 0x14, 0x6b, 0xbc, 0xf1, 0xa6, 0x93, 0x25, 0xda, 0x89,
	0xd8, 0x12, 0x87, 0x9a, 0xb0, 0xe2, 0xfa, 0x4c, 0xf6, 0xe0, 0xbb, 0x58, 0x31, 0x14, 0xeb, 0x41,
	0x1c, 0xe9, 0x77, 0xa7, 0x2b, 0x9d, 0xbe, 0xaa, 0xec, 0xfa, 0x4c, 0xf4, 0xdf, 0x17, 0x53, 0x73,
	0xe0, 0xbd, 0xb9, 0x9f, 0x31, 0x3d, 0x06, 0x9a, 0x13, 0x63, 0x80, 0xcc, 0xe3, 0x5f, 0x63, 0x0a,
	0xec, 0xcc, 0x9a, 0x02, 0x73, 0x5b, 0xed, 0x3f, 0x32, 0x04, 0x7e, 0x52, 0x86, 0x43, 0x60, 0x33,
	0x6b, 0xb8, 0x96, 0x1e, 0x47, 0xfa, 0xbd, 0xec, 0xdf, 0x84, 0xfc, 0x78, 0x54, 0x7a, 0x99, 0xc0,
	0xa4, 0xf4, 0xe1, 0x2b, 0xc9, 0x55, 0xb8, 0x87, 0x4c, 0x97, 0x5e, 0x72, 0x85, 0x95, 0x94, 0xdd,
	0x50, 0xbe, 0xf4, 0x69, 0x6a, 0x0e, 0x79, 0x6e, 0x0e, 0xd3, 0xb6, 0x25, 0x79, 0x59, 0x8f, 0xf8,
	0x72, 0x72, 0x06, 0x3c, 0x7e, 0x7b, 0xbd, 0xa7, 0xdd, 0xff, 0x17, 0x30, 0xb2, 0xff, 0xad, 0x09,
	0xfb, 0xb7, 0x1e, 0xc6, 0x91, 0xfe, 0xe0, 0xea, 0xaf, 0xc7, 0x26, 0x19, 0x0a, 0xa1, 0xcf, 0xa6,
	0x13, 0x70, 0x65, 0xf2, 0x92, 0x04, 0x24, 0xe4, 0x51, 0x0a, 0x9e, 0x65, 0x53, 0x80, 0xe3, 0x48,
	0xbf, 0x7f, 0x65, 0x0a, 0x12, 0xaa, 0x80, 0x6b, 0x2f, 0x16, 0x9a, 0x97, 0xff, 0xd0, 0x8c, 0xb3,
	0x36, 0x7f, 0xbd, 0xac, 0x83, 0xdf, 0x2e, 0xeb, 0xe0, 0xf7, 0xcb, 0x3a, 0xf8, 0xf1, 0xcf, 0xfa,
	0x12, 0xbc, 0xeb, 0x06, 0x8d, 0x90, 0x39, 0x27, 0xe7, 0xbd, 0xe0, 0x8d, 0xf0, 0xc7, 0xb4, 0x28,
	0x2f, 0xd3, 0x7f, 0x87, 0xfe, 0x02, 0xa0, 0x55, 0xe4, 0x47, 0x1f, 0xff, 0x1d, 0x00, 0x00, 0xff,
	0xff, 0x7f, 0xef, 0x7f, 0x8b, 0x37, 0x0d, 0x00, 0x00,
}

func (m *TestSingleKeyStruct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Oneof != nil {
		{
			size := m.Oneof.Size()
			i -= size
			if _, err := m.Oneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Nested) > 0 {
		for iNdEx := len(m.Nested) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nested[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.Embedded != nil {
		{
			size, err := m.Embedded.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Enums) > 0 {
		dAtA3 := make([]byte, len(m.Enums)*10)
		var j2 int
		for _, num := range m.Enums {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintTest(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x5a
	}
	if m.Enum != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Enum))
		i--
		dAtA[i] = 0x50
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTest(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTest(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Float != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Float))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Int64 != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Int64))
		i--
		dAtA[i] = 0x30
	}
	if m.Uint64 != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Uint64))
		i--
		dAtA[i] = 0x28
	}
	if m.Bool {
		i--
		if m.Bool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.StringSlice) > 0 {
		for iNdEx := len(m.StringSlice) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StringSlice[iNdEx])
			copy(dAtA[i:], m.StringSlice[iNdEx])
			i = encodeVarintTest(dAtA, i, uint64(len(m.StringSlice[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestSingleKeyStruct_Oneofstring) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_Oneofstring) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Oneofstring)
	copy(dAtA[i:], m.Oneofstring)
	i = encodeVarintTest(dAtA, i, uint64(len(m.Oneofstring)))
	i--
	dAtA[i] = 0x72
	return len(dAtA) - i, nil
}
func (m *TestSingleKeyStruct_Oneofnested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_Oneofnested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Oneofnested != nil {
		{
			size, err := m.Oneofnested.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *TestSingleKeyStruct_Embedded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct_Embedded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_Embedded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Embedded) > 0 {
		i -= len(m.Embedded)
		copy(dAtA[i:], m.Embedded)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Embedded)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestSingleKeyStruct_Embedded_Embedded2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct_Embedded_Embedded2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_Embedded_Embedded2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Embedded) > 0 {
		i -= len(m.Embedded)
		copy(dAtA[i:], m.Embedded)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Embedded)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestSingleKeyStruct_Nested) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct_Nested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_Nested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Nested2 != nil {
		{
			size, err := m.Nested2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nested) > 0 {
		i -= len(m.Nested)
		copy(dAtA[i:], m.Nested)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestSingleKeyStruct_Nested_Nested2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct_Nested_Nested2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_Nested_Nested2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nested2) > 0 {
		i -= len(m.Nested2)
		copy(dAtA[i:], m.Nested2)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested2)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestSingleKeyStruct_OneOfNested) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct_OneOfNested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_OneOfNested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Nested2 != nil {
		{
			size, err := m.Nested2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nested) > 0 {
		i -= len(m.Nested)
		copy(dAtA[i:], m.Nested)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestSingleKeyStruct_OneOfNested_Nested2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSingleKeyStruct_OneOfNested_Nested2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSingleKeyStruct_OneOfNested_Nested2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nested2) > 0 {
		i -= len(m.Nested2)
		copy(dAtA[i:], m.Nested2)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested2)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IntSlice) > 0 {
		dAtA9 := make([]byte, len(m.IntSlice)*10)
		var j8 int
		for _, num1 := range m.IntSlice {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintTest(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.String_) > 0 {
		i -= len(m.String_)
		copy(dAtA[i:], m.String_)
		i = encodeVarintTest(dAtA, i, uint64(len(m.String_)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Oneof != nil {
		{
			size := m.Oneof.Size()
			i -= size
			if _, err := m.Oneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Nested) > 0 {
		for iNdEx := len(m.Nested) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nested[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.Embedded != nil {
		{
			size, err := m.Embedded.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Enums) > 0 {
		dAtA12 := make([]byte, len(m.Enums)*10)
		var j11 int
		for _, num := range m.Enums {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintTest(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x5a
	}
	if m.Enum != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Enum))
		i--
		dAtA[i] = 0x50
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTest(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTest(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Float != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Float))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Int64 != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Int64))
		i--
		dAtA[i] = 0x30
	}
	if m.Uint64 != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Uint64))
		i--
		dAtA[i] = 0x28
	}
	if m.Bool {
		i--
		if m.Bool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.StringSlice) > 0 {
		for iNdEx := len(m.StringSlice) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StringSlice[iNdEx])
			copy(dAtA[i:], m.StringSlice[iNdEx])
			i = encodeVarintTest(dAtA, i, uint64(len(m.StringSlice[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Key2) > 0 {
		i -= len(m.Key2)
		copy(dAtA[i:], m.Key2)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Key2)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key1) > 0 {
		i -= len(m.Key1)
		copy(dAtA[i:], m.Key1)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Key1)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct_Oneofstring) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_Oneofstring) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Oneofstring)
	copy(dAtA[i:], m.Oneofstring)
	i = encodeVarintTest(dAtA, i, uint64(len(m.Oneofstring)))
	i--
	dAtA[i] = 0x72
	return len(dAtA) - i, nil
}
func (m *TestMultiKeyStruct_Oneofnested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_Oneofnested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Oneofnested != nil {
		{
			size, err := m.Oneofnested.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *TestMultiKeyStruct_Embedded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct_Embedded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_Embedded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Embedded) > 0 {
		i -= len(m.Embedded)
		copy(dAtA[i:], m.Embedded)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Embedded)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct_Embedded_Embedded2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct_Embedded_Embedded2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_Embedded_Embedded2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Embedded) > 0 {
		i -= len(m.Embedded)
		copy(dAtA[i:], m.Embedded)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Embedded)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct_Nested) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct_Nested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_Nested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Int64 != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Int64))
		i--
		dAtA[i] = 0x20
	}
	if m.IsNested {
		i--
		if m.IsNested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Nested2 != nil {
		{
			size, err := m.Nested2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nested) > 0 {
		i -= len(m.Nested)
		copy(dAtA[i:], m.Nested)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct_Nested_Nested2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct_Nested_Nested2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_Nested_Nested2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Int64 != 0 {
		i = encodeVarintTest(dAtA, i, uint64(m.Int64))
		i--
		dAtA[i] = 0x20
	}
	if m.IsNested {
		i--
		if m.IsNested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Nested2) > 0 {
		i -= len(m.Nested2)
		copy(dAtA[i:], m.Nested2)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested2)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct_OneOfNested) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct_OneOfNested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_OneOfNested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nested) > 0 {
		i -= len(m.Nested)
		copy(dAtA[i:], m.Nested)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestMultiKeyStruct_OneOfNested_Nested2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMultiKeyStruct_OneOfNested_Nested2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMultiKeyStruct_OneOfNested_Nested2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nested2) > 0 {
		i -= len(m.Nested2)
		copy(dAtA[i:], m.Nested2)
		i = encodeVarintTest(dAtA, i, uint64(len(m.Nested2)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func encodeVarintTest(dAtA []byte, offset int, v uint64) int {
	offset -= sovTest(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TestSingleKeyStruct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.StringSlice) > 0 {
		for _, s := range m.StringSlice {
			l = len(s)
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if m.Bool {
		n += 2
	}
	if m.Uint64 != 0 {
		n += 1 + sovTest(uint64(m.Uint64))
	}
	if m.Int64 != 0 {
		n += 1 + sovTest(uint64(m.Int64))
	}
	if m.Float != 0 {
		n += 5
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + len(v) + sovTest(uint64(len(v)))
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if m.Enum != 0 {
		n += 1 + sovTest(uint64(m.Enum))
	}
	if len(m.Enums) > 0 {
		l = 0
		for _, e := range m.Enums {
			l += sovTest(uint64(e))
		}
		n += 1 + sovTest(uint64(l)) + l
	}
	if m.Embedded != nil {
		l = m.Embedded.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.Nested) > 0 {
		for _, e := range m.Nested {
			l = e.Size()
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if m.Oneof != nil {
		n += m.Oneof.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSingleKeyStruct_Oneofstring) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Oneofstring)
	n += 1 + l + sovTest(uint64(l))
	return n
}
func (m *TestSingleKeyStruct_Oneofnested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Oneofnested != nil {
		l = m.Oneofnested.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	return n
}
func (m *TestSingleKeyStruct_Embedded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Embedded)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSingleKeyStruct_Embedded_Embedded2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Embedded)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSingleKeyStruct_Nested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.Nested2 != nil {
		l = m.Nested2.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSingleKeyStruct_Nested_Nested2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested2)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSingleKeyStruct_OneOfNested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.Nested2 != nil {
		l = m.Nested2.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestSingleKeyStruct_OneOfNested_Nested2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested2)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key1)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Key2)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.StringSlice) > 0 {
		for _, s := range m.StringSlice {
			l = len(s)
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if m.Bool {
		n += 2
	}
	if m.Uint64 != 0 {
		n += 1 + sovTest(uint64(m.Uint64))
	}
	if m.Int64 != 0 {
		n += 1 + sovTest(uint64(m.Int64))
	}
	if m.Float != 0 {
		n += 5
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + len(v) + sovTest(uint64(len(v)))
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if m.Enum != 0 {
		n += 1 + sovTest(uint64(m.Enum))
	}
	if len(m.Enums) > 0 {
		l = 0
		for _, e := range m.Enums {
			l += sovTest(uint64(e))
		}
		n += 1 + sovTest(uint64(l)) + l
	}
	if m.Embedded != nil {
		l = m.Embedded.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.Nested) > 0 {
		for _, e := range m.Nested {
			l = e.Size()
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if m.Oneof != nil {
		n += m.Oneof.Size()
	}
	l = len(m.String_)
	if l > 0 {
		n += 2 + l + sovTest(uint64(l))
	}
	if len(m.IntSlice) > 0 {
		l = 0
		for _, e := range m.IntSlice {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct_Oneofstring) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Oneofstring)
	n += 1 + l + sovTest(uint64(l))
	return n
}
func (m *TestMultiKeyStruct_Oneofnested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Oneofnested != nil {
		l = m.Oneofnested.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	return n
}
func (m *TestMultiKeyStruct_Embedded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Embedded)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct_Embedded_Embedded2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Embedded)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct_Nested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.Nested2 != nil {
		l = m.Nested2.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if m.IsNested {
		n += 2
	}
	if m.Int64 != 0 {
		n += 1 + sovTest(uint64(m.Int64))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct_Nested_Nested2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested2)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.IsNested {
		n += 2
	}
	if m.Int64 != 0 {
		n += 1 + sovTest(uint64(m.Int64))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct_OneOfNested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMultiKeyStruct_OneOfNested_Nested2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nested2)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTest(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTest(x uint64) (n int) {
	return sovTest(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TestSingleKeyStruct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestSingleKeyStruct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestSingleKeyStruct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringSlice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringSlice = append(m.StringSlice, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bool = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64", wireType)
			}
			m.Uint64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uint64 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			m.Int64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Int64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Float = float32(math.Float32frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTest
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			m.Enum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Enum |= TestSingleKeyStruct_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v TestSingleKeyStruct_Enum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TestSingleKeyStruct_Enum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Enums = append(m.Enums, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTest
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Enums) == 0 {
					m.Enums = make([]TestSingleKeyStruct_Enum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TestSingleKeyStruct_Enum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TestSingleKeyStruct_Enum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Enums = append(m.Enums, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Enums", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Embedded == nil {
				m.Embedded = &TestSingleKeyStruct_Embedded{}
			}
			if err := m.Embedded.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested = append(m.Nested, &TestSingleKeyStruct_Nested{})
			if err := m.Nested[len(m.Nested)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oneofstring", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oneof = &TestSingleKeyStruct_Oneofstring{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oneofnested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestSingleKeyStruct_OneOfNested{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &TestSingleKeyStruct_Oneofnested{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSingleKeyStruct_Embedded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Embedded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Embedded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Embedded = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSingleKeyStruct_Embedded_Embedded2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Embedded2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Embedded2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Embedded = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSingleKeyStruct_Nested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nested2 == nil {
				m.Nested2 = &TestSingleKeyStruct_Nested_Nested2{}
			}
			if err := m.Nested2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSingleKeyStruct_Nested_Nested2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSingleKeyStruct_OneOfNested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OneOfNested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OneOfNested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nested2 == nil {
				m.Nested2 = &TestSingleKeyStruct_OneOfNested_Nested2{}
			}
			if err := m.Nested2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestSingleKeyStruct_OneOfNested_Nested2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestMultiKeyStruct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestMultiKeyStruct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringSlice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringSlice = append(m.StringSlice, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bool = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64", wireType)
			}
			m.Uint64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uint64 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			m.Int64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Int64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Float = float32(math.Float32frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTest
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			m.Enum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Enum |= TestMultiKeyStruct_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v TestMultiKeyStruct_Enum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TestMultiKeyStruct_Enum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Enums = append(m.Enums, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTest
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Enums) == 0 {
					m.Enums = make([]TestMultiKeyStruct_Enum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TestMultiKeyStruct_Enum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TestMultiKeyStruct_Enum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Enums = append(m.Enums, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Enums", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Embedded == nil {
				m.Embedded = &TestMultiKeyStruct_Embedded{}
			}
			if err := m.Embedded.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested = append(m.Nested, &TestMultiKeyStruct_Nested{})
			if err := m.Nested[len(m.Nested)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oneofstring", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oneof = &TestMultiKeyStruct_Oneofstring{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oneofnested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestMultiKeyStruct_OneOfNested{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Oneof = &TestMultiKeyStruct_Oneofnested{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.String_ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IntSlice = append(m.IntSlice, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTest
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IntSlice) == 0 {
					m.IntSlice = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IntSlice = append(m.IntSlice, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IntSlice", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct_Embedded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Embedded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Embedded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Embedded = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct_Embedded_Embedded2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Embedded2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Embedded2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedded", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Embedded = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct_Nested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nested2 == nil {
				m.Nested2 = &TestMultiKeyStruct_Nested_Nested2{}
			}
			if err := m.Nested2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNested = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			m.Int64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Int64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct_Nested_Nested2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNested = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			m.Int64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Int64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct_OneOfNested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OneOfNested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OneOfNested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMultiKeyStruct_OneOfNested_Nested2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nested2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTest(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTest
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTest
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTest
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTest
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTest        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTest          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTest = fmt.Errorf("proto: unexpected end of group")
)
