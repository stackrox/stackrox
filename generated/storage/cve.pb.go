// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/cve.proto

package storage

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.
type VulnerabilityState int32

const (
	VulnerabilityState_OBSERVED       VulnerabilityState = 0
	VulnerabilityState_DEFERRED       VulnerabilityState = 1
	VulnerabilityState_FALSE_POSITIVE VulnerabilityState = 2
)

var VulnerabilityState_name = map[int32]string{
	0: "OBSERVED",
	1: "DEFERRED",
	2: "FALSE_POSITIVE",
}

var VulnerabilityState_value = map[string]int32{
	"OBSERVED":       0,
	"DEFERRED":       1,
	"FALSE_POSITIVE": 2,
}

func (x VulnerabilityState) String() string {
	return proto.EnumName(VulnerabilityState_name, int32(x))
}

func (VulnerabilityState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{0}
}

type VulnerabilitySeverity int32

const (
	VulnerabilitySeverity_UNKNOWN_VULNERABILITY_SEVERITY   VulnerabilitySeverity = 0
	VulnerabilitySeverity_LOW_VULNERABILITY_SEVERITY       VulnerabilitySeverity = 1
	VulnerabilitySeverity_MODERATE_VULNERABILITY_SEVERITY  VulnerabilitySeverity = 2
	VulnerabilitySeverity_IMPORTANT_VULNERABILITY_SEVERITY VulnerabilitySeverity = 3
	VulnerabilitySeverity_CRITICAL_VULNERABILITY_SEVERITY  VulnerabilitySeverity = 4
)

var VulnerabilitySeverity_name = map[int32]string{
	0: "UNKNOWN_VULNERABILITY_SEVERITY",
	1: "LOW_VULNERABILITY_SEVERITY",
	2: "MODERATE_VULNERABILITY_SEVERITY",
	3: "IMPORTANT_VULNERABILITY_SEVERITY",
	4: "CRITICAL_VULNERABILITY_SEVERITY",
}

var VulnerabilitySeverity_value = map[string]int32{
	"UNKNOWN_VULNERABILITY_SEVERITY":   0,
	"LOW_VULNERABILITY_SEVERITY":       1,
	"MODERATE_VULNERABILITY_SEVERITY":  2,
	"IMPORTANT_VULNERABILITY_SEVERITY": 3,
	"CRITICAL_VULNERABILITY_SEVERITY":  4,
}

func (x VulnerabilitySeverity) String() string {
	return proto.EnumName(VulnerabilitySeverity_name, int32(x))
}

func (VulnerabilitySeverity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{1}
}

type CVE_CVEType int32

const (
	CVE_UNKNOWN_CVE   CVE_CVEType = 0
	CVE_IMAGE_CVE     CVE_CVEType = 1
	CVE_K8S_CVE       CVE_CVEType = 2
	CVE_ISTIO_CVE     CVE_CVEType = 3
	CVE_NODE_CVE      CVE_CVEType = 4
	CVE_OPENSHIFT_CVE CVE_CVEType = 5
)

var CVE_CVEType_name = map[int32]string{
	0: "UNKNOWN_CVE",
	1: "IMAGE_CVE",
	2: "K8S_CVE",
	3: "ISTIO_CVE",
	4: "NODE_CVE",
	5: "OPENSHIFT_CVE",
}

var CVE_CVEType_value = map[string]int32{
	"UNKNOWN_CVE":   0,
	"IMAGE_CVE":     1,
	"K8S_CVE":       2,
	"ISTIO_CVE":     3,
	"NODE_CVE":      4,
	"OPENSHIFT_CVE": 5,
}

func (x CVE_CVEType) String() string {
	return proto.EnumName(CVE_CVEType_name, int32(x))
}

func (CVE_CVEType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{0, 0}
}

type CVE_ScoreVersion int32

const (
	CVE_V2      CVE_ScoreVersion = 0
	CVE_V3      CVE_ScoreVersion = 1
	CVE_UNKNOWN CVE_ScoreVersion = 2
)

var CVE_ScoreVersion_name = map[int32]string{
	0: "V2",
	1: "V3",
	2: "UNKNOWN",
}

var CVE_ScoreVersion_value = map[string]int32{
	"V2":      0,
	"V3":      1,
	"UNKNOWN": 2,
}

func (x CVE_ScoreVersion) String() string {
	return proto.EnumName(CVE_ScoreVersion_name, int32(x))
}

func (CVE_ScoreVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{0, 1}
}

type CVSSV2_Impact int32

const (
	CVSSV2_IMPACT_NONE     CVSSV2_Impact = 0
	CVSSV2_IMPACT_PARTIAL  CVSSV2_Impact = 1
	CVSSV2_IMPACT_COMPLETE CVSSV2_Impact = 2
)

var CVSSV2_Impact_name = map[int32]string{
	0: "IMPACT_NONE",
	1: "IMPACT_PARTIAL",
	2: "IMPACT_COMPLETE",
}

var CVSSV2_Impact_value = map[string]int32{
	"IMPACT_NONE":     0,
	"IMPACT_PARTIAL":  1,
	"IMPACT_COMPLETE": 2,
}

func (x CVSSV2_Impact) String() string {
	return proto.EnumName(CVSSV2_Impact_name, int32(x))
}

func (CVSSV2_Impact) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{1, 0}
}

type CVSSV2_AttackVector int32

const (
	CVSSV2_ATTACK_LOCAL    CVSSV2_AttackVector = 0
	CVSSV2_ATTACK_ADJACENT CVSSV2_AttackVector = 1
	CVSSV2_ATTACK_NETWORK  CVSSV2_AttackVector = 2
)

var CVSSV2_AttackVector_name = map[int32]string{
	0: "ATTACK_LOCAL",
	1: "ATTACK_ADJACENT",
	2: "ATTACK_NETWORK",
}

var CVSSV2_AttackVector_value = map[string]int32{
	"ATTACK_LOCAL":    0,
	"ATTACK_ADJACENT": 1,
	"ATTACK_NETWORK":  2,
}

func (x CVSSV2_AttackVector) String() string {
	return proto.EnumName(CVSSV2_AttackVector_name, int32(x))
}

func (CVSSV2_AttackVector) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{1, 1}
}

type CVSSV2_AccessComplexity int32

const (
	CVSSV2_ACCESS_HIGH   CVSSV2_AccessComplexity = 0
	CVSSV2_ACCESS_MEDIUM CVSSV2_AccessComplexity = 1
	CVSSV2_ACCESS_LOW    CVSSV2_AccessComplexity = 2
)

var CVSSV2_AccessComplexity_name = map[int32]string{
	0: "ACCESS_HIGH",
	1: "ACCESS_MEDIUM",
	2: "ACCESS_LOW",
}

var CVSSV2_AccessComplexity_value = map[string]int32{
	"ACCESS_HIGH":   0,
	"ACCESS_MEDIUM": 1,
	"ACCESS_LOW":    2,
}

func (x CVSSV2_AccessComplexity) String() string {
	return proto.EnumName(CVSSV2_AccessComplexity_name, int32(x))
}

func (CVSSV2_AccessComplexity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{1, 2}
}

type CVSSV2_Authentication int32

const (
	CVSSV2_AUTH_MULTIPLE CVSSV2_Authentication = 0
	CVSSV2_AUTH_SINGLE   CVSSV2_Authentication = 1
	CVSSV2_AUTH_NONE     CVSSV2_Authentication = 2
)

var CVSSV2_Authentication_name = map[int32]string{
	0: "AUTH_MULTIPLE",
	1: "AUTH_SINGLE",
	2: "AUTH_NONE",
}

var CVSSV2_Authentication_value = map[string]int32{
	"AUTH_MULTIPLE": 0,
	"AUTH_SINGLE":   1,
	"AUTH_NONE":     2,
}

func (x CVSSV2_Authentication) String() string {
	return proto.EnumName(CVSSV2_Authentication_name, int32(x))
}

func (CVSSV2_Authentication) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{1, 3}
}

type CVSSV2_Severity int32

const (
	CVSSV2_UNKNOWN CVSSV2_Severity = 0
	CVSSV2_LOW     CVSSV2_Severity = 1
	CVSSV2_MEDIUM  CVSSV2_Severity = 2
	CVSSV2_HIGH    CVSSV2_Severity = 3
)

var CVSSV2_Severity_name = map[int32]string{
	0: "UNKNOWN",
	1: "LOW",
	2: "MEDIUM",
	3: "HIGH",
}

var CVSSV2_Severity_value = map[string]int32{
	"UNKNOWN": 0,
	"LOW":     1,
	"MEDIUM":  2,
	"HIGH":    3,
}

func (x CVSSV2_Severity) String() string {
	return proto.EnumName(CVSSV2_Severity_name, int32(x))
}

func (CVSSV2_Severity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{1, 4}
}

type CVSSV3_Impact int32

const (
	CVSSV3_IMPACT_NONE CVSSV3_Impact = 0
	CVSSV3_IMPACT_LOW  CVSSV3_Impact = 1
	CVSSV3_IMPACT_HIGH CVSSV3_Impact = 2
)

var CVSSV3_Impact_name = map[int32]string{
	0: "IMPACT_NONE",
	1: "IMPACT_LOW",
	2: "IMPACT_HIGH",
}

var CVSSV3_Impact_value = map[string]int32{
	"IMPACT_NONE": 0,
	"IMPACT_LOW":  1,
	"IMPACT_HIGH": 2,
}

func (x CVSSV3_Impact) String() string {
	return proto.EnumName(CVSSV3_Impact_name, int32(x))
}

func (CVSSV3_Impact) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{2, 0}
}

type CVSSV3_AttackVector int32

const (
	CVSSV3_ATTACK_LOCAL    CVSSV3_AttackVector = 0
	CVSSV3_ATTACK_ADJACENT CVSSV3_AttackVector = 1
	CVSSV3_ATTACK_NETWORK  CVSSV3_AttackVector = 2
	CVSSV3_ATTACK_PHYSICAL CVSSV3_AttackVector = 3
)

var CVSSV3_AttackVector_name = map[int32]string{
	0: "ATTACK_LOCAL",
	1: "ATTACK_ADJACENT",
	2: "ATTACK_NETWORK",
	3: "ATTACK_PHYSICAL",
}

var CVSSV3_AttackVector_value = map[string]int32{
	"ATTACK_LOCAL":    0,
	"ATTACK_ADJACENT": 1,
	"ATTACK_NETWORK":  2,
	"ATTACK_PHYSICAL": 3,
}

func (x CVSSV3_AttackVector) String() string {
	return proto.EnumName(CVSSV3_AttackVector_name, int32(x))
}

func (CVSSV3_AttackVector) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{2, 1}
}

type CVSSV3_Complexity int32

const (
	CVSSV3_COMPLEXITY_LOW  CVSSV3_Complexity = 0
	CVSSV3_COMPLEXITY_HIGH CVSSV3_Complexity = 1
)

var CVSSV3_Complexity_name = map[int32]string{
	0: "COMPLEXITY_LOW",
	1: "COMPLEXITY_HIGH",
}

var CVSSV3_Complexity_value = map[string]int32{
	"COMPLEXITY_LOW":  0,
	"COMPLEXITY_HIGH": 1,
}

func (x CVSSV3_Complexity) String() string {
	return proto.EnumName(CVSSV3_Complexity_name, int32(x))
}

func (CVSSV3_Complexity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{2, 2}
}

type CVSSV3_Privileges int32

const (
	CVSSV3_PRIVILEGE_NONE CVSSV3_Privileges = 0
	CVSSV3_PRIVILEGE_LOW  CVSSV3_Privileges = 1
	CVSSV3_PRIVILEGE_HIGH CVSSV3_Privileges = 2
)

var CVSSV3_Privileges_name = map[int32]string{
	0: "PRIVILEGE_NONE",
	1: "PRIVILEGE_LOW",
	2: "PRIVILEGE_HIGH",
}

var CVSSV3_Privileges_value = map[string]int32{
	"PRIVILEGE_NONE": 0,
	"PRIVILEGE_LOW":  1,
	"PRIVILEGE_HIGH": 2,
}

func (x CVSSV3_Privileges) String() string {
	return proto.EnumName(CVSSV3_Privileges_name, int32(x))
}

func (CVSSV3_Privileges) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{2, 3}
}

type CVSSV3_UserInteraction int32

const (
	CVSSV3_UI_NONE     CVSSV3_UserInteraction = 0
	CVSSV3_UI_REQUIRED CVSSV3_UserInteraction = 1
)

var CVSSV3_UserInteraction_name = map[int32]string{
	0: "UI_NONE",
	1: "UI_REQUIRED",
}

var CVSSV3_UserInteraction_value = map[string]int32{
	"UI_NONE":     0,
	"UI_REQUIRED": 1,
}

func (x CVSSV3_UserInteraction) String() string {
	return proto.EnumName(CVSSV3_UserInteraction_name, int32(x))
}

func (CVSSV3_UserInteraction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{2, 4}
}

type CVSSV3_Scope int32

const (
	CVSSV3_UNCHANGED CVSSV3_Scope = 0
	CVSSV3_CHANGED   CVSSV3_Scope = 1
)

var CVSSV3_Scope_name = map[int32]string{
	0: "UNCHANGED",
	1: "CHANGED",
}

var CVSSV3_Scope_value = map[string]int32{
	"UNCHANGED": 0,
	"CHANGED":   1,
}

func (x CVSSV3_Scope) String() string {
	return proto.EnumName(CVSSV3_Scope_name, int32(x))
}

func (CVSSV3_Scope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{2, 5}
}

type CVSSV3_Severity int32

const (
	CVSSV3_UNKNOWN  CVSSV3_Severity = 0
	CVSSV3_NONE     CVSSV3_Severity = 1
	CVSSV3_LOW      CVSSV3_Severity = 2
	CVSSV3_MEDIUM   CVSSV3_Severity = 3
	CVSSV3_HIGH     CVSSV3_Severity = 4
	CVSSV3_CRITICAL CVSSV3_Severity = 5
)

var CVSSV3_Severity_name = map[int32]string{
	0: "UNKNOWN",
	1: "NONE",
	2: "LOW",
	3: "MEDIUM",
	4: "HIGH",
	5: "CRITICAL",
}

var CVSSV3_Severity_value = map[string]int32{
	"UNKNOWN":  0,
	"NONE":     1,
	"LOW":      2,
	"MEDIUM":   3,
	"HIGH":     4,
	"CRITICAL": 5,
}

func (x CVSSV3_Severity) String() string {
	return proto.EnumName(CVSSV3_Severity_name, int32(x))
}

func (CVSSV3_Severity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{2, 6}
}

// Next Tag: 23
type CVE struct {
	Id              string        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" sql:"pk"`
	Cve             string        `protobuf:"bytes,22,opt,name=cve,proto3" json:"cve,omitempty" search:"CVE,store"`
	OperatingSystem string        `protobuf:"bytes,21,opt,name=operating_system,json=operatingSystem,proto3" json:"operating_system,omitempty" sql:"pk"`
	Cvss            float32       `protobuf:"fixed32,2,opt,name=cvss,proto3" json:"cvss,omitempty" search:"CVSS,store"`
	ImpactScore     float32       `protobuf:"fixed32,14,opt,name=impact_score,json=impactScore,proto3" json:"impact_score,omitempty" search:"Impact Score"`
	Type            CVE_CVEType   `protobuf:"varint,3,opt,name=type,proto3,enum=storage.CVE_CVEType" json:"type,omitempty" sql:"-"`
	Types           []CVE_CVEType `protobuf:"varint,18,rep,packed,name=types,proto3,enum=storage.CVE_CVEType" json:"types,omitempty" search:"CVE Type" sql:"-"`
	Summary         string        `protobuf:"bytes,4,opt,name=summary,proto3" json:"summary,omitempty"`
	Link            string        `protobuf:"bytes,5,opt,name=link,proto3" json:"link,omitempty"`
	// This indicates the timestamp when the cve was first published in the cve feeds.
	PublishedOn *types.Timestamp `protobuf:"bytes,6,opt,name=published_on,json=publishedOn,proto3" json:"published_on,omitempty" search:"CVE Published On"`
	// Time when the CVE was first seen in the system.
	CreatedAt            *types.Timestamp               `protobuf:"bytes,15,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty" search:"CVE Created Time"`
	LastModified         *types.Timestamp               `protobuf:"bytes,7,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
	References           []*CVE_Reference               `protobuf:"bytes,8,rep,name=references,proto3" json:"references,omitempty"`
	ScoreVersion         CVE_ScoreVersion               `protobuf:"varint,9,opt,name=score_version,json=scoreVersion,proto3,enum=storage.CVE_ScoreVersion" json:"score_version,omitempty"`
	CvssV2               *CVSSV2                        `protobuf:"bytes,10,opt,name=cvss_v2,json=cvssV2,proto3" json:"cvss_v2,omitempty"`
	CvssV3               *CVSSV3                        `protobuf:"bytes,11,opt,name=cvss_v3,json=cvssV3,proto3" json:"cvss_v3,omitempty"`
	Suppressed           bool                           `protobuf:"varint,12,opt,name=suppressed,proto3" json:"suppressed,omitempty" search:"CVE Snoozed"`
	SuppressActivation   *types.Timestamp               `protobuf:"bytes,16,opt,name=suppress_activation,json=suppressActivation,proto3" json:"suppress_activation,omitempty"`
	SuppressExpiry       *types.Timestamp               `protobuf:"bytes,17,opt,name=suppress_expiry,json=suppressExpiry,proto3" json:"suppress_expiry,omitempty" search:"CVE Snooze Expiry,hidden"`
	DistroSpecifics      map[string]*CVE_DistroSpecific `protobuf:"bytes,19,rep,name=distro_specifics,json=distroSpecifics,proto3" json:"distro_specifics,omitempty" sql:"-" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Severity             VulnerabilitySeverity          `protobuf:"varint,20,opt,name=severity,proto3,enum=storage.VulnerabilitySeverity" json:"severity,omitempty" search:"Severity"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *CVE) Reset()         { *m = CVE{} }
func (m *CVE) String() string { return proto.CompactTextString(m) }
func (*CVE) ProtoMessage()    {}
func (*CVE) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{0}
}
func (m *CVE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CVE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CVE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CVE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CVE.Merge(m, src)
}
func (m *CVE) XXX_Size() int {
	return m.Size()
}
func (m *CVE) XXX_DiscardUnknown() {
	xxx_messageInfo_CVE.DiscardUnknown(m)
}

var xxx_messageInfo_CVE proto.InternalMessageInfo

func (m *CVE) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CVE) GetCve() string {
	if m != nil {
		return m.Cve
	}
	return ""
}

func (m *CVE) GetOperatingSystem() string {
	if m != nil {
		return m.OperatingSystem
	}
	return ""
}

func (m *CVE) GetCvss() float32 {
	if m != nil {
		return m.Cvss
	}
	return 0
}

func (m *CVE) GetImpactScore() float32 {
	if m != nil {
		return m.ImpactScore
	}
	return 0
}

func (m *CVE) GetType() CVE_CVEType {
	if m != nil {
		return m.Type
	}
	return CVE_UNKNOWN_CVE
}

func (m *CVE) GetTypes() []CVE_CVEType {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *CVE) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

func (m *CVE) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *CVE) GetPublishedOn() *types.Timestamp {
	if m != nil {
		return m.PublishedOn
	}
	return nil
}

func (m *CVE) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *CVE) GetLastModified() *types.Timestamp {
	if m != nil {
		return m.LastModified
	}
	return nil
}

func (m *CVE) GetReferences() []*CVE_Reference {
	if m != nil {
		return m.References
	}
	return nil
}

func (m *CVE) GetScoreVersion() CVE_ScoreVersion {
	if m != nil {
		return m.ScoreVersion
	}
	return CVE_V2
}

func (m *CVE) GetCvssV2() *CVSSV2 {
	if m != nil {
		return m.CvssV2
	}
	return nil
}

func (m *CVE) GetCvssV3() *CVSSV3 {
	if m != nil {
		return m.CvssV3
	}
	return nil
}

func (m *CVE) GetSuppressed() bool {
	if m != nil {
		return m.Suppressed
	}
	return false
}

func (m *CVE) GetSuppressActivation() *types.Timestamp {
	if m != nil {
		return m.SuppressActivation
	}
	return nil
}

func (m *CVE) GetSuppressExpiry() *types.Timestamp {
	if m != nil {
		return m.SuppressExpiry
	}
	return nil
}

func (m *CVE) GetDistroSpecifics() map[string]*CVE_DistroSpecific {
	if m != nil {
		return m.DistroSpecifics
	}
	return nil
}

func (m *CVE) GetSeverity() VulnerabilitySeverity {
	if m != nil {
		return m.Severity
	}
	return VulnerabilitySeverity_UNKNOWN_VULNERABILITY_SEVERITY
}

func (m *CVE) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CVE) Clone() *CVE {
	if m == nil {
		return nil
	}
	cloned := new(CVE)
	*cloned = *m

	if m.Types != nil {
		cloned.Types = make([]CVE_CVEType, len(m.Types))
		copy(cloned.Types, m.Types)
	}
	cloned.PublishedOn = m.PublishedOn.Clone()
	cloned.CreatedAt = m.CreatedAt.Clone()
	cloned.LastModified = m.LastModified.Clone()
	if m.References != nil {
		cloned.References = make([]*CVE_Reference, len(m.References))
		for idx, v := range m.References {
			cloned.References[idx] = v.Clone()
		}
	}
	cloned.CvssV2 = m.CvssV2.Clone()
	cloned.CvssV3 = m.CvssV3.Clone()
	cloned.SuppressActivation = m.SuppressActivation.Clone()
	cloned.SuppressExpiry = m.SuppressExpiry.Clone()
	if m.DistroSpecifics != nil {
		cloned.DistroSpecifics = make(map[string]*CVE_DistroSpecific, len(m.DistroSpecifics))
		for k, v := range m.DistroSpecifics {
			cloned.DistroSpecifics[k] = v.Clone()
		}
	}
	return cloned
}

type CVE_DistroSpecific struct {
	Severity             VulnerabilitySeverity `protobuf:"varint,1,opt,name=severity,proto3,enum=storage.VulnerabilitySeverity" json:"severity,omitempty"`
	Cvss                 float32               `protobuf:"fixed32,2,opt,name=cvss,proto3" json:"cvss,omitempty"`
	ScoreVersion         CVE_ScoreVersion      `protobuf:"varint,3,opt,name=score_version,json=scoreVersion,proto3,enum=storage.CVE_ScoreVersion" json:"score_version,omitempty"`
	CvssV2               *CVSSV2               `protobuf:"bytes,4,opt,name=cvss_v2,json=cvssV2,proto3" json:"cvss_v2,omitempty"`
	CvssV3               *CVSSV3               `protobuf:"bytes,5,opt,name=cvss_v3,json=cvssV3,proto3" json:"cvss_v3,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *CVE_DistroSpecific) Reset()         { *m = CVE_DistroSpecific{} }
func (m *CVE_DistroSpecific) String() string { return proto.CompactTextString(m) }
func (*CVE_DistroSpecific) ProtoMessage()    {}
func (*CVE_DistroSpecific) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{0, 0}
}
func (m *CVE_DistroSpecific) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CVE_DistroSpecific) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CVE_DistroSpecific.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CVE_DistroSpecific) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CVE_DistroSpecific.Merge(m, src)
}
func (m *CVE_DistroSpecific) XXX_Size() int {
	return m.Size()
}
func (m *CVE_DistroSpecific) XXX_DiscardUnknown() {
	xxx_messageInfo_CVE_DistroSpecific.DiscardUnknown(m)
}

var xxx_messageInfo_CVE_DistroSpecific proto.InternalMessageInfo

func (m *CVE_DistroSpecific) GetSeverity() VulnerabilitySeverity {
	if m != nil {
		return m.Severity
	}
	return VulnerabilitySeverity_UNKNOWN_VULNERABILITY_SEVERITY
}

func (m *CVE_DistroSpecific) GetCvss() float32 {
	if m != nil {
		return m.Cvss
	}
	return 0
}

func (m *CVE_DistroSpecific) GetScoreVersion() CVE_ScoreVersion {
	if m != nil {
		return m.ScoreVersion
	}
	return CVE_V2
}

func (m *CVE_DistroSpecific) GetCvssV2() *CVSSV2 {
	if m != nil {
		return m.CvssV2
	}
	return nil
}

func (m *CVE_DistroSpecific) GetCvssV3() *CVSSV3 {
	if m != nil {
		return m.CvssV3
	}
	return nil
}

func (m *CVE_DistroSpecific) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CVE_DistroSpecific) Clone() *CVE_DistroSpecific {
	if m == nil {
		return nil
	}
	cloned := new(CVE_DistroSpecific)
	*cloned = *m

	cloned.CvssV2 = m.CvssV2.Clone()
	cloned.CvssV3 = m.CvssV3.Clone()
	return cloned
}

type CVE_Reference struct {
	URI                  string   `protobuf:"bytes,1,opt,name=URI,proto3" json:"URI,omitempty"`
	Tags                 []string `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CVE_Reference) Reset()         { *m = CVE_Reference{} }
func (m *CVE_Reference) String() string { return proto.CompactTextString(m) }
func (*CVE_Reference) ProtoMessage()    {}
func (*CVE_Reference) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{0, 1}
}
func (m *CVE_Reference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CVE_Reference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CVE_Reference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CVE_Reference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CVE_Reference.Merge(m, src)
}
func (m *CVE_Reference) XXX_Size() int {
	return m.Size()
}
func (m *CVE_Reference) XXX_DiscardUnknown() {
	xxx_messageInfo_CVE_Reference.DiscardUnknown(m)
}

var xxx_messageInfo_CVE_Reference proto.InternalMessageInfo

func (m *CVE_Reference) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *CVE_Reference) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *CVE_Reference) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CVE_Reference) Clone() *CVE_Reference {
	if m == nil {
		return nil
	}
	cloned := new(CVE_Reference)
	*cloned = *m

	if m.Tags != nil {
		cloned.Tags = make([]string, len(m.Tags))
		copy(cloned.Tags, m.Tags)
	}
	return cloned
}

type CVSSV2 struct {
	Vector               string                  `protobuf:"bytes,1,opt,name=vector,proto3" json:"vector,omitempty"`
	AttackVector         CVSSV2_AttackVector     `protobuf:"varint,2,opt,name=attack_vector,json=attackVector,proto3,enum=storage.CVSSV2_AttackVector" json:"attack_vector,omitempty"`
	AccessComplexity     CVSSV2_AccessComplexity `protobuf:"varint,3,opt,name=access_complexity,json=accessComplexity,proto3,enum=storage.CVSSV2_AccessComplexity" json:"access_complexity,omitempty"`
	Authentication       CVSSV2_Authentication   `protobuf:"varint,4,opt,name=authentication,proto3,enum=storage.CVSSV2_Authentication" json:"authentication,omitempty"`
	Confidentiality      CVSSV2_Impact           `protobuf:"varint,5,opt,name=confidentiality,proto3,enum=storage.CVSSV2_Impact" json:"confidentiality,omitempty"`
	Integrity            CVSSV2_Impact           `protobuf:"varint,6,opt,name=integrity,proto3,enum=storage.CVSSV2_Impact" json:"integrity,omitempty"`
	Availability         CVSSV2_Impact           `protobuf:"varint,7,opt,name=availability,proto3,enum=storage.CVSSV2_Impact" json:"availability,omitempty"`
	ExploitabilityScore  float32                 `protobuf:"fixed32,8,opt,name=exploitability_score,json=exploitabilityScore,proto3" json:"exploitability_score,omitempty"`
	ImpactScore          float32                 `protobuf:"fixed32,9,opt,name=impact_score,json=impactScore,proto3" json:"impact_score,omitempty"`
	Score                float32                 `protobuf:"fixed32,10,opt,name=score,proto3" json:"score,omitempty"`
	Severity             CVSSV2_Severity         `protobuf:"varint,11,opt,name=severity,proto3,enum=storage.CVSSV2_Severity" json:"severity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *CVSSV2) Reset()         { *m = CVSSV2{} }
func (m *CVSSV2) String() string { return proto.CompactTextString(m) }
func (*CVSSV2) ProtoMessage()    {}
func (*CVSSV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{1}
}
func (m *CVSSV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CVSSV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CVSSV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CVSSV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CVSSV2.Merge(m, src)
}
func (m *CVSSV2) XXX_Size() int {
	return m.Size()
}
func (m *CVSSV2) XXX_DiscardUnknown() {
	xxx_messageInfo_CVSSV2.DiscardUnknown(m)
}

var xxx_messageInfo_CVSSV2 proto.InternalMessageInfo

func (m *CVSSV2) GetVector() string {
	if m != nil {
		return m.Vector
	}
	return ""
}

func (m *CVSSV2) GetAttackVector() CVSSV2_AttackVector {
	if m != nil {
		return m.AttackVector
	}
	return CVSSV2_ATTACK_LOCAL
}

func (m *CVSSV2) GetAccessComplexity() CVSSV2_AccessComplexity {
	if m != nil {
		return m.AccessComplexity
	}
	return CVSSV2_ACCESS_HIGH
}

func (m *CVSSV2) GetAuthentication() CVSSV2_Authentication {
	if m != nil {
		return m.Authentication
	}
	return CVSSV2_AUTH_MULTIPLE
}

func (m *CVSSV2) GetConfidentiality() CVSSV2_Impact {
	if m != nil {
		return m.Confidentiality
	}
	return CVSSV2_IMPACT_NONE
}

func (m *CVSSV2) GetIntegrity() CVSSV2_Impact {
	if m != nil {
		return m.Integrity
	}
	return CVSSV2_IMPACT_NONE
}

func (m *CVSSV2) GetAvailability() CVSSV2_Impact {
	if m != nil {
		return m.Availability
	}
	return CVSSV2_IMPACT_NONE
}

func (m *CVSSV2) GetExploitabilityScore() float32 {
	if m != nil {
		return m.ExploitabilityScore
	}
	return 0
}

func (m *CVSSV2) GetImpactScore() float32 {
	if m != nil {
		return m.ImpactScore
	}
	return 0
}

func (m *CVSSV2) GetScore() float32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *CVSSV2) GetSeverity() CVSSV2_Severity {
	if m != nil {
		return m.Severity
	}
	return CVSSV2_UNKNOWN
}

func (m *CVSSV2) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CVSSV2) Clone() *CVSSV2 {
	if m == nil {
		return nil
	}
	cloned := new(CVSSV2)
	*cloned = *m

	return cloned
}

type CVSSV3 struct {
	Vector               string                 `protobuf:"bytes,1,opt,name=vector,proto3" json:"vector,omitempty"`
	ExploitabilityScore  float32                `protobuf:"fixed32,2,opt,name=exploitability_score,json=exploitabilityScore,proto3" json:"exploitability_score,omitempty"`
	ImpactScore          float32                `protobuf:"fixed32,3,opt,name=impact_score,json=impactScore,proto3" json:"impact_score,omitempty"`
	AttackVector         CVSSV3_AttackVector    `protobuf:"varint,4,opt,name=attack_vector,json=attackVector,proto3,enum=storage.CVSSV3_AttackVector" json:"attack_vector,omitempty"`
	AttackComplexity     CVSSV3_Complexity      `protobuf:"varint,5,opt,name=attack_complexity,json=attackComplexity,proto3,enum=storage.CVSSV3_Complexity" json:"attack_complexity,omitempty"`
	PrivilegesRequired   CVSSV3_Privileges      `protobuf:"varint,6,opt,name=privileges_required,json=privilegesRequired,proto3,enum=storage.CVSSV3_Privileges" json:"privileges_required,omitempty"`
	UserInteraction      CVSSV3_UserInteraction `protobuf:"varint,7,opt,name=user_interaction,json=userInteraction,proto3,enum=storage.CVSSV3_UserInteraction" json:"user_interaction,omitempty"`
	Scope                CVSSV3_Scope           `protobuf:"varint,8,opt,name=scope,proto3,enum=storage.CVSSV3_Scope" json:"scope,omitempty"`
	Confidentiality      CVSSV3_Impact          `protobuf:"varint,9,opt,name=confidentiality,proto3,enum=storage.CVSSV3_Impact" json:"confidentiality,omitempty"`
	Integrity            CVSSV3_Impact          `protobuf:"varint,10,opt,name=integrity,proto3,enum=storage.CVSSV3_Impact" json:"integrity,omitempty"`
	Availability         CVSSV3_Impact          `protobuf:"varint,11,opt,name=availability,proto3,enum=storage.CVSSV3_Impact" json:"availability,omitempty"`
	Score                float32                `protobuf:"fixed32,12,opt,name=score,proto3" json:"score,omitempty"`
	Severity             CVSSV3_Severity        `protobuf:"varint,13,opt,name=severity,proto3,enum=storage.CVSSV3_Severity" json:"severity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *CVSSV3) Reset()         { *m = CVSSV3{} }
func (m *CVSSV3) String() string { return proto.CompactTextString(m) }
func (*CVSSV3) ProtoMessage()    {}
func (*CVSSV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7bf0cfd04430357, []int{2}
}
func (m *CVSSV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CVSSV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CVSSV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CVSSV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CVSSV3.Merge(m, src)
}
func (m *CVSSV3) XXX_Size() int {
	return m.Size()
}
func (m *CVSSV3) XXX_DiscardUnknown() {
	xxx_messageInfo_CVSSV3.DiscardUnknown(m)
}

var xxx_messageInfo_CVSSV3 proto.InternalMessageInfo

func (m *CVSSV3) GetVector() string {
	if m != nil {
		return m.Vector
	}
	return ""
}

func (m *CVSSV3) GetExploitabilityScore() float32 {
	if m != nil {
		return m.ExploitabilityScore
	}
	return 0
}

func (m *CVSSV3) GetImpactScore() float32 {
	if m != nil {
		return m.ImpactScore
	}
	return 0
}

func (m *CVSSV3) GetAttackVector() CVSSV3_AttackVector {
	if m != nil {
		return m.AttackVector
	}
	return CVSSV3_ATTACK_LOCAL
}

func (m *CVSSV3) GetAttackComplexity() CVSSV3_Complexity {
	if m != nil {
		return m.AttackComplexity
	}
	return CVSSV3_COMPLEXITY_LOW
}

func (m *CVSSV3) GetPrivilegesRequired() CVSSV3_Privileges {
	if m != nil {
		return m.PrivilegesRequired
	}
	return CVSSV3_PRIVILEGE_NONE
}

func (m *CVSSV3) GetUserInteraction() CVSSV3_UserInteraction {
	if m != nil {
		return m.UserInteraction
	}
	return CVSSV3_UI_NONE
}

func (m *CVSSV3) GetScope() CVSSV3_Scope {
	if m != nil {
		return m.Scope
	}
	return CVSSV3_UNCHANGED
}

func (m *CVSSV3) GetConfidentiality() CVSSV3_Impact {
	if m != nil {
		return m.Confidentiality
	}
	return CVSSV3_IMPACT_NONE
}

func (m *CVSSV3) GetIntegrity() CVSSV3_Impact {
	if m != nil {
		return m.Integrity
	}
	return CVSSV3_IMPACT_NONE
}

func (m *CVSSV3) GetAvailability() CVSSV3_Impact {
	if m != nil {
		return m.Availability
	}
	return CVSSV3_IMPACT_NONE
}

func (m *CVSSV3) GetScore() float32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *CVSSV3) GetSeverity() CVSSV3_Severity {
	if m != nil {
		return m.Severity
	}
	return CVSSV3_UNKNOWN
}

func (m *CVSSV3) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CVSSV3) Clone() *CVSSV3 {
	if m == nil {
		return nil
	}
	cloned := new(CVSSV3)
	*cloned = *m

	return cloned
}

func init() {
	proto.RegisterEnum("storage.VulnerabilityState", VulnerabilityState_name, VulnerabilityState_value)
	proto.RegisterEnum("storage.VulnerabilitySeverity", VulnerabilitySeverity_name, VulnerabilitySeverity_value)
	proto.RegisterEnum("storage.CVE_CVEType", CVE_CVEType_name, CVE_CVEType_value)
	proto.RegisterEnum("storage.CVE_ScoreVersion", CVE_ScoreVersion_name, CVE_ScoreVersion_value)
	proto.RegisterEnum("storage.CVSSV2_Impact", CVSSV2_Impact_name, CVSSV2_Impact_value)
	proto.RegisterEnum("storage.CVSSV2_AttackVector", CVSSV2_AttackVector_name, CVSSV2_AttackVector_value)
	proto.RegisterEnum("storage.CVSSV2_AccessComplexity", CVSSV2_AccessComplexity_name, CVSSV2_AccessComplexity_value)
	proto.RegisterEnum("storage.CVSSV2_Authentication", CVSSV2_Authentication_name, CVSSV2_Authentication_value)
	proto.RegisterEnum("storage.CVSSV2_Severity", CVSSV2_Severity_name, CVSSV2_Severity_value)
	proto.RegisterEnum("storage.CVSSV3_Impact", CVSSV3_Impact_name, CVSSV3_Impact_value)
	proto.RegisterEnum("storage.CVSSV3_AttackVector", CVSSV3_AttackVector_name, CVSSV3_AttackVector_value)
	proto.RegisterEnum("storage.CVSSV3_Complexity", CVSSV3_Complexity_name, CVSSV3_Complexity_value)
	proto.RegisterEnum("storage.CVSSV3_Privileges", CVSSV3_Privileges_name, CVSSV3_Privileges_value)
	proto.RegisterEnum("storage.CVSSV3_UserInteraction", CVSSV3_UserInteraction_name, CVSSV3_UserInteraction_value)
	proto.RegisterEnum("storage.CVSSV3_Scope", CVSSV3_Scope_name, CVSSV3_Scope_value)
	proto.RegisterEnum("storage.CVSSV3_Severity", CVSSV3_Severity_name, CVSSV3_Severity_value)
	proto.RegisterType((*CVE)(nil), "storage.CVE")
	proto.RegisterMapType((map[string]*CVE_DistroSpecific)(nil), "storage.CVE.DistroSpecificsEntry")
	proto.RegisterType((*CVE_DistroSpecific)(nil), "storage.CVE.DistroSpecific")
	proto.RegisterType((*CVE_Reference)(nil), "storage.CVE.Reference")
	proto.RegisterType((*CVSSV2)(nil), "storage.CVSSV2")
	proto.RegisterType((*CVSSV3)(nil), "storage.CVSSV3")
}

func init() { proto.RegisterFile("storage/cve.proto", fileDescriptor_d7bf0cfd04430357) }

var fileDescriptor_d7bf0cfd04430357 = []byte{
	// 1772 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x7f, 0x6e, 0xdb, 0xc8,
	0x15, 0x36, 0x29, 0xd9, 0x96, 0x9e, 0x64, 0x89, 0x1e, 0xdb, 0x29, 0xe3, 0x6e, 0x2d, 0x85, 0xdb,
	0x02, 0xc6, 0x66, 0x6b, 0x23, 0x76, 0x76, 0x1b, 0x18, 0x45, 0x5b, 0x4a, 0xa2, 0x6d, 0xae, 0xf5,
	0x6b, 0x87, 0x94, 0xb2, 0x29, 0x8a, 0x12, 0x0c, 0x35, 0x56, 0x58, 0xcb, 0xa2, 0x42, 0x52, 0x42,
	0xd4, 0x23, 0xf4, 0x04, 0x3d, 0x40, 0x81, 0x5e, 0xa5, 0x40, 0xff, 0xe9, 0x09, 0x84, 0x22, 0xbd,
	0x81, 0xd0, 0x03, 0x14, 0x33, 0x24, 0x25, 0x4a, 0x96, 0x9c, 0xb4, 0xe8, 0x1f, 0x81, 0x38, 0x6f,
	0xbe, 0xef, 0xe3, 0x9b, 0x99, 0xf7, 0x3d, 0x4e, 0x0c, 0xbb, 0x9e, 0xef, 0xb8, 0x66, 0x97, 0x9c,
	0x5a, 0x23, 0x72, 0x32, 0x70, 0x1d, 0xdf, 0x41, 0xdb, 0x61, 0xe8, 0xb0, 0xd0, 0x75, 0x9c, 0x6e,
	0x8f, 0x9c, 0xb2, 0xf0, 0xdb, 0xe1, 0xed, 0xa9, 0x6f, 0xdf, 0x13, 0xcf, 0x37, 0xef, 0x07, 0x01,
	0xf2, 0x70, 0xbf, 0xeb, 0x74, 0x1d, 0xf6, 0x78, 0x4a, 0x9f, 0x82, 0xa8, 0xf4, 0xd7, 0x1c, 0x24,
	0xca, 0x6d, 0x05, 0x7d, 0x01, 0xbc, 0xdd, 0x11, 0xb9, 0x22, 0x77, 0x9c, 0x2e, 0x65, 0xa7, 0x93,
	0x42, 0xca, 0x7b, 0xdf, 0xbb, 0x90, 0x06, 0x77, 0x12, 0xe6, 0xed, 0x0e, 0x3a, 0x86, 0x84, 0x35,
	0x22, 0xe2, 0x13, 0x36, 0xfd, 0x64, 0x3a, 0x29, 0x20, 0x8f, 0x98, 0xae, 0xf5, 0xee, 0x42, 0x2a,
	0xb7, 0x95, 0xaf, 0x69, 0x0a, 0x44, 0xc2, 0x14, 0x82, 0x7e, 0x01, 0x82, 0x33, 0x20, 0xae, 0xe9,
	0xdb, 0xfd, 0xae, 0xe1, 0x8d, 0x3d, 0x9f, 0xdc, 0x8b, 0x07, 0x2b, 0x54, 0xf3, 0x33, 0x94, 0xc6,
	0x40, 0xe8, 0x39, 0x24, 0xad, 0x91, 0xe7, 0x89, 0x7c, 0x91, 0x3b, 0xe6, 0x4b, 0x3f, 0x9a, 0x4e,
	0x0a, 0x7b, 0xf3, 0x77, 0x68, 0x5a, 0xf4, 0x12, 0x06, 0x42, 0xbf, 0x84, 0xac, 0x7d, 0x3f, 0x30,
	0x2d, 0xdf, 0xf0, 0x2c, 0xc7, 0x25, 0x62, 0x8e, 0x91, 0x9e, 0x4e, 0x27, 0x85, 0x83, 0x88, 0xa4,
	0xb2, 0xf9, 0xa2, 0x66, 0x31, 0x5a, 0x26, 0x80, 0xb3, 0x11, 0xfa, 0x06, 0x92, 0xfe, 0x78, 0x40,
	0xc4, 0x44, 0x91, 0x3b, 0xce, 0x9d, 0xed, 0x9f, 0x84, 0x5b, 0x78, 0x52, 0x6e, 0x2b, 0xf4, 0x9f,
	0x3e, 0x1e, 0x90, 0x52, 0x66, 0x3a, 0x29, 0x6c, 0xb3, 0x6c, 0x7f, 0x2e, 0x61, 0x06, 0x47, 0x2a,
	0x6c, 0xd2, 0x5f, 0x4f, 0x44, 0xc5, 0xc4, 0x5a, 0xde, 0x4f, 0xa6, 0x93, 0xc2, 0xd3, 0xd8, 0xe6,
	0x14, 0x69, 0x54, 0x2a, 0x46, 0x4a, 0x81, 0x02, 0x12, 0x61, 0xdb, 0x1b, 0xde, 0xdf, 0x9b, 0xee,
	0x58, 0x4c, 0xd2, 0xcd, 0xc1, 0xd1, 0x10, 0x21, 0x48, 0xf6, 0xec, 0xfe, 0x9d, 0xb8, 0xc9, 0xc2,
	0xec, 0x19, 0xfd, 0x0e, 0xb2, 0x83, 0xe1, 0xdb, 0x9e, 0xed, 0xbd, 0x23, 0x1d, 0xc3, 0xe9, 0x8b,
	0x5b, 0x45, 0xee, 0x38, 0x73, 0x76, 0x78, 0x12, 0x9c, 0xf8, 0x49, 0x74, 0xe2, 0x27, 0x7a, 0x74,
	0xe2, 0x0f, 0xb3, 0x68, 0x46, 0xfc, 0x62, 0xa3, 0x2f, 0xe1, 0xcc, 0x4c, 0xae, 0xd1, 0x47, 0x3f,
	0x00, 0x58, 0x2e, 0x31, 0x7d, 0xd2, 0x31, 0x4c, 0x5f, 0xcc, 0xff, 0xf7, 0xda, 0xe5, 0x80, 0x5d,
	0xa4, 0x10, 0x09, 0xa7, 0x43, 0x31, 0xd9, 0x47, 0xbf, 0x86, 0x9d, 0x9e, 0xe9, 0xf9, 0xc6, 0xbd,
	0xd3, 0xb1, 0x6f, 0x6d, 0xd2, 0x11, 0xb7, 0x3f, 0x25, 0x8e, 0xb3, 0x94, 0x50, 0x0b, 0xf1, 0xe8,
	0x5b, 0x00, 0x97, 0xdc, 0x12, 0x97, 0xf4, 0x2d, 0xe2, 0x89, 0xa9, 0x62, 0xe2, 0x38, 0x73, 0xf6,
	0x64, 0x61, 0xdb, 0x71, 0x34, 0x8d, 0x63, 0x48, 0xf4, 0x2b, 0xd8, 0x61, 0x75, 0x61, 0x8c, 0x88,
	0xeb, 0xd9, 0x4e, 0x5f, 0x4c, 0xb3, 0x93, 0x7e, 0xba, 0x40, 0x65, 0xb5, 0xd0, 0x0e, 0x00, 0x38,
	0xeb, 0xc5, 0x46, 0xe8, 0x18, 0xb6, 0x69, 0x99, 0x19, 0xa3, 0x33, 0x11, 0x58, 0xca, 0xf9, 0x18,
	0x53, 0xd3, 0xda, 0x67, 0x78, 0x8b, 0xce, 0xb7, 0xcf, 0xe6, 0xc8, 0x73, 0x31, 0xb3, 0x0a, 0x79,
	0x1e, 0x22, 0xcf, 0xd1, 0x2b, 0x00, 0x6f, 0x38, 0x18, 0xb8, 0xc4, 0xf3, 0x48, 0x47, 0xcc, 0x16,
	0xb9, 0xe3, 0x54, 0x49, 0x9c, 0x4e, 0x0a, 0xfb, 0xf1, 0xad, 0xd4, 0xfa, 0x8e, 0xf3, 0x47, 0xd2,
	0x91, 0x70, 0x0c, 0x8b, 0x6e, 0x60, 0x2f, 0x1a, 0x19, 0xa6, 0xe5, 0xdb, 0x23, 0xd3, 0xa7, 0x6b,
	0x12, 0x3e, 0xb9, 0x99, 0x28, 0xa2, 0xc9, 0x33, 0x16, 0xfa, 0x03, 0xe4, 0x67, 0x62, 0xe4, 0xc3,
	0xc0, 0x76, 0xc7, 0xe2, 0xee, 0x27, 0x8f, 0xfc, 0x67, 0xd3, 0x49, 0xe1, 0xd9, 0xc3, 0x3c, 0x8b,
	0x0a, 0x13, 0xf8, 0xfa, 0x9d, 0xdd, 0xe9, 0x90, 0xbe, 0x84, 0x73, 0x91, 0x72, 0x10, 0x47, 0x6f,
	0x40, 0xe8, 0xd8, 0x9e, 0xef, 0x3a, 0x86, 0x37, 0x20, 0x96, 0x7d, 0x6b, 0x5b, 0x9e, 0xb8, 0xc7,
	0x0e, 0xf1, 0xd9, 0xc2, 0x49, 0x54, 0x18, 0x48, 0x8b, 0x30, 0x4a, 0xdf, 0x77, 0xc7, 0x8b, 0x06,
	0xcc, 0x77, 0x16, 0x21, 0xe8, 0x7b, 0x48, 0x79, 0x64, 0x44, 0x5c, 0xdb, 0x1f, 0x8b, 0xfb, 0xec,
	0x70, 0x8f, 0x66, 0x92, 0xed, 0x61, 0xaf, 0x4f, 0x5c, 0xf3, 0xad, 0xdd, 0xb3, 0xfd, 0xb1, 0x16,
	0xa2, 0x4a, 0x07, 0xd3, 0x49, 0x61, 0x37, 0x5a, 0x43, 0x14, 0x95, 0xf0, 0x4c, 0xe6, 0xf0, 0xdf,
	0x1c, 0xe4, 0x16, 0x33, 0x41, 0x17, 0xb1, 0xb7, 0x70, 0x9f, 0xf3, 0x96, 0xb9, 0x1c, 0x35, 0xf2,
	0xbc, 0x9f, 0x85, 0x6d, 0xeb, 0x41, 0x5d, 0x26, 0xfe, 0xe7, 0xba, 0x4c, 0x7e, 0x76, 0x5d, 0x6e,
	0x3e, 0x5a, 0x97, 0x87, 0x2f, 0x20, 0x3d, 0x33, 0x11, 0x12, 0x20, 0xd1, 0xc2, 0x6a, 0xf0, 0x19,
	0xc0, 0xf4, 0x91, 0x2e, 0xc3, 0x37, 0xbb, 0x74, 0x19, 0x09, 0xda, 0x8f, 0xe8, 0xf3, 0xa1, 0x01,
	0xfb, 0xab, 0x8e, 0x8c, 0xb2, 0xef, 0xc8, 0x38, 0x62, 0xdf, 0x91, 0x31, 0x7a, 0x01, 0x9b, 0x23,
	0xb3, 0x37, 0x24, 0x6c, 0x17, 0x32, 0x67, 0x3f, 0x7e, 0xe4, 0xd8, 0x71, 0x80, 0xbc, 0xe0, 0x5f,
	0x71, 0xd2, 0x2d, 0x6c, 0x87, 0xfd, 0x14, 0xe5, 0x21, 0xd3, 0xaa, 0xdf, 0xd4, 0x1b, 0xaf, 0xeb,
	0x46, 0xb9, 0xad, 0x08, 0x1b, 0x68, 0x07, 0xd2, 0x6a, 0x4d, 0xbe, 0x52, 0xd8, 0x90, 0x43, 0x19,
	0xd8, 0xbe, 0x79, 0xa5, 0xb1, 0x01, 0xcf, 0xe6, 0x34, 0x5d, 0x6d, 0xb0, 0x61, 0x02, 0x65, 0x21,
	0x55, 0x6f, 0x54, 0x02, 0x64, 0x12, 0xed, 0xc2, 0x4e, 0xa3, 0xa9, 0xd4, 0xb5, 0x6b, 0xf5, 0x52,
	0x67, 0xa1, 0x4d, 0xe9, 0x39, 0x64, 0xe3, 0xbb, 0x8d, 0xb6, 0x80, 0x6f, 0x9f, 0x09, 0x1b, 0xec,
	0xf7, 0x3c, 0x10, 0x0f, 0x5f, 0x2e, 0xf0, 0xd2, 0x5f, 0xb6, 0x61, 0x2b, 0xd8, 0x65, 0xf4, 0x04,
	0xb6, 0x46, 0xc4, 0xf2, 0x1d, 0x37, 0x5c, 0x6b, 0x38, 0x42, 0x32, 0xec, 0x98, 0xbe, 0x6f, 0x5a,
	0x77, 0x46, 0x38, 0xcd, 0xb3, 0xf3, 0xfd, 0x62, 0xe9, 0x94, 0x4e, 0x64, 0x06, 0x6a, 0x33, 0x0c,
	0xce, 0x9a, 0xb1, 0x11, 0xaa, 0xc1, 0xae, 0x69, 0x59, 0xd4, 0x9d, 0x96, 0x73, 0x3f, 0xe8, 0x91,
	0x0f, 0xb4, 0xf6, 0x82, 0x32, 0x29, 0x3e, 0x90, 0x61, 0xc0, 0xf2, 0x0c, 0x87, 0x05, 0x73, 0x29,
	0x82, 0x2e, 0x21, 0x67, 0x0e, 0xfd, 0x77, 0xa4, 0xef, 0xdb, 0x56, 0xd0, 0x36, 0x92, 0x4b, 0x75,
	0x1c, 0x69, 0x2d, 0xa0, 0xf0, 0x12, 0x0b, 0xfd, 0x06, 0xf2, 0x96, 0xd3, 0xbf, 0xb5, 0x3b, 0x34,
	0x66, 0xd2, 0x92, 0x67, 0x75, 0x95, 0x5b, 0x68, 0xc7, 0x4c, 0x28, 0xf8, 0xee, 0xe2, 0x65, 0x38,
	0x7a, 0x09, 0x69, 0xbb, 0xef, 0x93, 0x2e, 0x33, 0xd3, 0xd6, 0xa3, 0xdc, 0x39, 0x10, 0x5d, 0x40,
	0xd6, 0x1c, 0x99, 0x76, 0x2f, 0xf4, 0x19, 0xfb, 0x82, 0xac, 0x27, 0x2e, 0x60, 0xd1, 0x0b, 0xd8,
	0x27, 0x1f, 0x06, 0x3d, 0xc7, 0xf6, 0xc3, 0x48, 0x78, 0x59, 0x48, 0x31, 0x47, 0xee, 0x2d, 0xce,
	0x05, 0x37, 0x83, 0x67, 0x4b, 0xf7, 0x8a, 0x34, 0x83, 0x2e, 0x5c, 0x1e, 0xf6, 0x61, 0x33, 0x98,
	0x03, 0x36, 0x17, 0x0c, 0xd0, 0xcb, 0x58, 0xa7, 0xc8, 0xb0, 0x1c, 0xc5, 0xe5, 0x1c, 0x1f, 0xf6,
	0x08, 0xa9, 0x04, 0x5b, 0x41, 0xe6, 0xb4, 0xcc, 0xd5, 0x5a, 0x53, 0x2e, 0xeb, 0x46, 0xbd, 0x51,
	0xa7, 0x65, 0x8e, 0x20, 0x17, 0x06, 0x9a, 0x32, 0xd6, 0x55, 0xb9, 0x2a, 0x70, 0x68, 0x0f, 0xf2,
	0x61, 0xac, 0xdc, 0xa8, 0x35, 0xab, 0x8a, 0xae, 0x08, 0xbc, 0xa4, 0x42, 0x36, 0x5e, 0x4e, 0x48,
	0x80, 0xac, 0xac, 0xeb, 0x72, 0xf9, 0xc6, 0xa8, 0x36, 0xca, 0x72, 0x55, 0xd8, 0xa0, 0xb4, 0x30,
	0x22, 0x57, 0xbe, 0x93, 0xcb, 0x4a, 0x5d, 0x17, 0x38, 0xaa, 0x1f, 0x06, 0xeb, 0x8a, 0xfe, 0xba,
	0x81, 0x6f, 0x04, 0x5e, 0xba, 0x04, 0x61, 0xb9, 0xa4, 0x68, 0x62, 0x72, 0xb9, 0xac, 0x68, 0x9a,
	0x71, 0xad, 0x5e, 0x5d, 0x0b, 0x1b, 0xd4, 0x46, 0x61, 0xa0, 0xa6, 0x54, 0xd4, 0x56, 0x4d, 0xe0,
	0x50, 0x0e, 0x20, 0x0c, 0x55, 0x1b, 0xaf, 0x05, 0x5e, 0x2a, 0x43, 0x6e, 0xb1, 0x9c, 0x18, 0xa9,
	0xa5, 0x5f, 0x1b, 0xb5, 0x56, 0x55, 0x57, 0x9b, 0x55, 0xba, 0x40, 0x2a, 0x4c, 0x43, 0x9a, 0x5a,
	0xbf, 0xaa, 0x52, 0x27, 0xef, 0x40, 0x9a, 0x05, 0xd8, 0x06, 0xf0, 0xd2, 0xb7, 0x90, 0x8a, 0x76,
	0x2c, 0xee, 0xc3, 0x0d, 0xb4, 0x0d, 0x09, 0xfa, 0x1a, 0x0e, 0x01, 0x6c, 0x85, 0x29, 0xf0, 0x28,
	0x05, 0x49, 0x96, 0x5f, 0x42, 0xfa, 0x53, 0x3a, 0xb4, 0xe9, 0xf9, 0x5a, 0x9b, 0xae, 0x2b, 0x0c,
	0xfe, 0xf3, 0x0b, 0x23, 0xf1, 0xb0, 0x30, 0x1e, 0x98, 0x3f, 0xb9, 0xca, 0xfc, 0xe7, 0x8f, 0x99,
	0xff, 0x0a, 0x76, 0x43, 0x89, 0x98, 0xf9, 0x03, 0x9f, 0x1d, 0x2e, 0xcb, 0x2c, 0xd8, 0x9e, 0x91,
	0x62, 0xa7, 0x76, 0x03, 0x7b, 0x03, 0xd7, 0x1e, 0xd9, 0x3d, 0xd2, 0x25, 0x9e, 0xe1, 0x92, 0xf7,
	0x43, 0xdb, 0x25, 0x9d, 0xd0, 0x76, 0x0f, 0xa4, 0x9a, 0x33, 0x28, 0x46, 0x73, 0x1a, 0x0e, 0x59,
	0xe8, 0x3b, 0x10, 0x86, 0x1e, 0x71, 0x0d, 0xea, 0x4a, 0x97, 0x5e, 0x40, 0x9c, 0x7e, 0xe8, 0xc3,
	0xc2, 0xb2, 0x52, 0xcb, 0x23, 0xae, 0x3a, 0x87, 0xe1, 0xfc, 0x70, 0x31, 0x80, 0x9e, 0x33, 0xf7,
	0x0c, 0x02, 0x13, 0xe6, 0xce, 0x0e, 0x96, 0x05, 0x34, 0x3a, 0x89, 0x03, 0xcc, 0xaa, 0xa6, 0x93,
	0x5e, 0xe5, 0xff, 0xf3, 0xcf, 0x6b, 0x3a, 0xf0, 0x28, 0xf7, 0x91, 0xa6, 0x93, 0x79, 0x94, 0xb8,
	0xd8, 0x74, 0x66, 0xed, 0x21, 0xbb, 0xae, 0x3d, 0xec, 0xac, 0x6a, 0x0f, 0xe7, 0xab, 0xda, 0xc3,
	0xc5, 0xfa, 0xf6, 0x90, 0x03, 0x08, 0x03, 0x81, 0x17, 0xe6, 0x00, 0x66, 0x03, 0x5e, 0xfa, 0xfd,
	0xff, 0xad, 0x2d, 0xc4, 0x80, 0xcd, 0xeb, 0x37, 0x9a, 0x4a, 0xd9, 0x09, 0xe9, 0x1b, 0x80, 0x58,
	0xbd, 0x21, 0xc8, 0x05, 0x2d, 0xe9, 0x07, 0x55, 0x7f, 0xc3, 0x52, 0x62, 0xfa, 0xb1, 0x18, 0x4b,
	0x8b, 0x93, 0xae, 0x00, 0xe6, 0xd5, 0x46, 0x69, 0x4d, 0xac, 0xb6, 0xd5, 0xaa, 0x72, 0xa5, 0x44,
	0x2b, 0xdb, 0x85, 0x9d, 0x79, 0x2c, 0x58, 0xdc, 0x02, 0x2c, 0x5c, 0xdf, 0x29, 0xe4, 0x97, 0x8a,
	0x8d, 0x75, 0x09, 0x35, 0x92, 0xa1, 0xf7, 0x06, 0xd5, 0xc0, 0xca, 0xf7, 0x2d, 0x15, 0x2b, 0x15,
	0x81, 0x93, 0xbe, 0x84, 0x4d, 0x56, 0x5c, 0xb4, 0xcf, 0xb4, 0xea, 0xe5, 0x6b, 0xb9, 0x7e, 0xa5,
	0x54, 0x84, 0x0d, 0xca, 0x8a, 0x06, 0x9c, 0x54, 0x5f, 0xd7, 0x74, 0x52, 0x90, 0x64, 0xc2, 0x5c,
	0xd4, 0x7e, 0xf8, 0x58, 0xfb, 0x49, 0xcc, 0xda, 0x4f, 0x92, 0xde, 0x39, 0xca, 0x58, 0xd5, 0xd9,
	0x2e, 0x6d, 0x7e, 0x55, 0x01, 0xb4, 0x78, 0x4f, 0xf4, 0x4d, 0x9f, 0x50, 0x4c, 0xa3, 0xa4, 0x29,
	0xb8, 0xcd, 0x12, 0xc8, 0x42, 0xaa, 0xa2, 0x5c, 0x2a, 0x98, 0xa5, 0x49, 0xd7, 0x7a, 0x29, 0x57,
	0x35, 0xc5, 0x68, 0x36, 0x34, 0x55, 0x57, 0xe9, 0xb5, 0xe6, 0xab, 0xbf, 0x73, 0x70, 0xb0, 0xf2,
	0xba, 0x89, 0x24, 0x38, 0x8a, 0x6e, 0x47, 0xed, 0x56, 0xb5, 0xae, 0x60, 0xb9, 0xa4, 0x56, 0xe9,
	0x76, 0x6b, 0x4a, 0x5b, 0xc1, 0xaa, 0xfe, 0x46, 0xd8, 0x40, 0x47, 0x70, 0x58, 0x6d, 0xbc, 0x5e,
	0x37, 0xcf, 0xa1, 0x2f, 0xa1, 0x50, 0x6b, 0x54, 0x14, 0x2c, 0xeb, 0xca, 0x3a, 0x10, 0x8f, 0x7e,
	0x0a, 0x45, 0xb5, 0xd6, 0x6c, 0x60, 0x5d, 0xae, 0xeb, 0xeb, 0x50, 0x09, 0x2a, 0x15, 0x2d, 0x7e,
	0x1d, 0x28, 0x59, 0x7a, 0xf9, 0xb7, 0x8f, 0x47, 0xdc, 0x3f, 0x3e, 0x1e, 0x71, 0xff, 0xfc, 0x78,
	0xc4, 0xfd, 0xf9, 0x5f, 0x47, 0x1b, 0xf0, 0xd4, 0x76, 0x4e, 0x3c, 0x5a, 0xab, 0xae, 0xf3, 0x21,
	0xf8, 0xef, 0x47, 0x64, 0x8e, 0xdf, 0x46, 0x7f, 0xde, 0x78, 0xbb, 0xc5, 0xe2, 0xe7, 0xff, 0x09,
	0x00, 0x00, 0xff, 0xff, 0xb5, 0x5b, 0x9a, 0x1d, 0x03, 0x11, 0x00, 0x00,
}

func (m *CVE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CVE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CVE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cve) > 0 {
		i -= len(m.Cve)
		copy(dAtA[i:], m.Cve)
		i = encodeVarintCve(dAtA, i, uint64(len(m.Cve)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.OperatingSystem) > 0 {
		i -= len(m.OperatingSystem)
		copy(dAtA[i:], m.OperatingSystem)
		i = encodeVarintCve(dAtA, i, uint64(len(m.OperatingSystem)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Severity != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.DistroSpecifics) > 0 {
		for k := range m.DistroSpecifics {
			v := m.DistroSpecifics[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCve(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCve(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCve(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.Types) > 0 {
		dAtA3 := make([]byte, len(m.Types)*10)
		var j2 int
		for _, num := range m.Types {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintCve(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.SuppressExpiry != nil {
		{
			size, err := m.SuppressExpiry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCve(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.SuppressActivation != nil {
		{
			size, err := m.SuppressActivation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCve(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCve(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ImpactScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ImpactScore))))
		i--
		dAtA[i] = 0x75
	}
	if m.Suppressed {
		i--
		if m.Suppressed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.CvssV3 != nil {
		{
			size, err := m.CvssV3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCve(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.CvssV2 != nil {
		{
			size, err := m.CvssV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCve(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ScoreVersion != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.ScoreVersion))
		i--
		dAtA[i] = 0x48
	}
	if len(m.References) > 0 {
		for iNdEx := len(m.References) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.References[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCve(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.LastModified != nil {
		{
			size, err := m.LastModified.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCve(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PublishedOn != nil {
		{
			size, err := m.PublishedOn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCve(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Link) > 0 {
		i -= len(m.Link)
		copy(dAtA[i:], m.Link)
		i = encodeVarintCve(dAtA, i, uint64(len(m.Link)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Summary) > 0 {
		i -= len(m.Summary)
		copy(dAtA[i:], m.Summary)
		i = encodeVarintCve(dAtA, i, uint64(len(m.Summary)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Cvss != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Cvss))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCve(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CVE_DistroSpecific) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CVE_DistroSpecific) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CVE_DistroSpecific) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CvssV3 != nil {
		{
			size, err := m.CvssV3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCve(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CvssV2 != nil {
		{
			size, err := m.CvssV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCve(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ScoreVersion != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.ScoreVersion))
		i--
		dAtA[i] = 0x18
	}
	if m.Cvss != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Cvss))))
		i--
		dAtA[i] = 0x15
	}
	if m.Severity != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CVE_Reference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CVE_Reference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CVE_Reference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintCve(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintCve(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CVSSV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CVSSV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CVSSV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Severity != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x58
	}
	if m.Score != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Score))))
		i--
		dAtA[i] = 0x55
	}
	if m.ImpactScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ImpactScore))))
		i--
		dAtA[i] = 0x4d
	}
	if m.ExploitabilityScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ExploitabilityScore))))
		i--
		dAtA[i] = 0x45
	}
	if m.Availability != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.Availability))
		i--
		dAtA[i] = 0x38
	}
	if m.Integrity != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.Integrity))
		i--
		dAtA[i] = 0x30
	}
	if m.Confidentiality != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.Confidentiality))
		i--
		dAtA[i] = 0x28
	}
	if m.Authentication != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.Authentication))
		i--
		dAtA[i] = 0x20
	}
	if m.AccessComplexity != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.AccessComplexity))
		i--
		dAtA[i] = 0x18
	}
	if m.AttackVector != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.AttackVector))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Vector) > 0 {
		i -= len(m.Vector)
		copy(dAtA[i:], m.Vector)
		i = encodeVarintCve(dAtA, i, uint64(len(m.Vector)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CVSSV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CVSSV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CVSSV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Severity != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x68
	}
	if m.Score != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Score))))
		i--
		dAtA[i] = 0x65
	}
	if m.Availability != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.Availability))
		i--
		dAtA[i] = 0x58
	}
	if m.Integrity != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.Integrity))
		i--
		dAtA[i] = 0x50
	}
	if m.Confidentiality != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.Confidentiality))
		i--
		dAtA[i] = 0x48
	}
	if m.Scope != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.Scope))
		i--
		dAtA[i] = 0x40
	}
	if m.UserInteraction != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.UserInteraction))
		i--
		dAtA[i] = 0x38
	}
	if m.PrivilegesRequired != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.PrivilegesRequired))
		i--
		dAtA[i] = 0x30
	}
	if m.AttackComplexity != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.AttackComplexity))
		i--
		dAtA[i] = 0x28
	}
	if m.AttackVector != 0 {
		i = encodeVarintCve(dAtA, i, uint64(m.AttackVector))
		i--
		dAtA[i] = 0x20
	}
	if m.ImpactScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ImpactScore))))
		i--
		dAtA[i] = 0x1d
	}
	if m.ExploitabilityScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ExploitabilityScore))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.Vector) > 0 {
		i -= len(m.Vector)
		copy(dAtA[i:], m.Vector)
		i = encodeVarintCve(dAtA, i, uint64(len(m.Vector)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCve(dAtA []byte, offset int, v uint64) int {
	offset -= sovCve(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CVE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCve(uint64(l))
	}
	if m.Cvss != 0 {
		n += 5
	}
	if m.Type != 0 {
		n += 1 + sovCve(uint64(m.Type))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovCve(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovCve(uint64(l))
	}
	if m.PublishedOn != nil {
		l = m.PublishedOn.Size()
		n += 1 + l + sovCve(uint64(l))
	}
	if m.LastModified != nil {
		l = m.LastModified.Size()
		n += 1 + l + sovCve(uint64(l))
	}
	if len(m.References) > 0 {
		for _, e := range m.References {
			l = e.Size()
			n += 1 + l + sovCve(uint64(l))
		}
	}
	if m.ScoreVersion != 0 {
		n += 1 + sovCve(uint64(m.ScoreVersion))
	}
	if m.CvssV2 != nil {
		l = m.CvssV2.Size()
		n += 1 + l + sovCve(uint64(l))
	}
	if m.CvssV3 != nil {
		l = m.CvssV3.Size()
		n += 1 + l + sovCve(uint64(l))
	}
	if m.Suppressed {
		n += 2
	}
	if m.ImpactScore != 0 {
		n += 5
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovCve(uint64(l))
	}
	if m.SuppressActivation != nil {
		l = m.SuppressActivation.Size()
		n += 2 + l + sovCve(uint64(l))
	}
	if m.SuppressExpiry != nil {
		l = m.SuppressExpiry.Size()
		n += 2 + l + sovCve(uint64(l))
	}
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovCve(uint64(e))
		}
		n += 2 + sovCve(uint64(l)) + l
	}
	if len(m.DistroSpecifics) > 0 {
		for k, v := range m.DistroSpecifics {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCve(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCve(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCve(uint64(mapEntrySize))
		}
	}
	if m.Severity != 0 {
		n += 2 + sovCve(uint64(m.Severity))
	}
	l = len(m.OperatingSystem)
	if l > 0 {
		n += 2 + l + sovCve(uint64(l))
	}
	l = len(m.Cve)
	if l > 0 {
		n += 2 + l + sovCve(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CVE_DistroSpecific) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Severity != 0 {
		n += 1 + sovCve(uint64(m.Severity))
	}
	if m.Cvss != 0 {
		n += 5
	}
	if m.ScoreVersion != 0 {
		n += 1 + sovCve(uint64(m.ScoreVersion))
	}
	if m.CvssV2 != nil {
		l = m.CvssV2.Size()
		n += 1 + l + sovCve(uint64(l))
	}
	if m.CvssV3 != nil {
		l = m.CvssV3.Size()
		n += 1 + l + sovCve(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CVE_Reference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovCve(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovCve(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CVSSV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Vector)
	if l > 0 {
		n += 1 + l + sovCve(uint64(l))
	}
	if m.AttackVector != 0 {
		n += 1 + sovCve(uint64(m.AttackVector))
	}
	if m.AccessComplexity != 0 {
		n += 1 + sovCve(uint64(m.AccessComplexity))
	}
	if m.Authentication != 0 {
		n += 1 + sovCve(uint64(m.Authentication))
	}
	if m.Confidentiality != 0 {
		n += 1 + sovCve(uint64(m.Confidentiality))
	}
	if m.Integrity != 0 {
		n += 1 + sovCve(uint64(m.Integrity))
	}
	if m.Availability != 0 {
		n += 1 + sovCve(uint64(m.Availability))
	}
	if m.ExploitabilityScore != 0 {
		n += 5
	}
	if m.ImpactScore != 0 {
		n += 5
	}
	if m.Score != 0 {
		n += 5
	}
	if m.Severity != 0 {
		n += 1 + sovCve(uint64(m.Severity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CVSSV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Vector)
	if l > 0 {
		n += 1 + l + sovCve(uint64(l))
	}
	if m.ExploitabilityScore != 0 {
		n += 5
	}
	if m.ImpactScore != 0 {
		n += 5
	}
	if m.AttackVector != 0 {
		n += 1 + sovCve(uint64(m.AttackVector))
	}
	if m.AttackComplexity != 0 {
		n += 1 + sovCve(uint64(m.AttackComplexity))
	}
	if m.PrivilegesRequired != 0 {
		n += 1 + sovCve(uint64(m.PrivilegesRequired))
	}
	if m.UserInteraction != 0 {
		n += 1 + sovCve(uint64(m.UserInteraction))
	}
	if m.Scope != 0 {
		n += 1 + sovCve(uint64(m.Scope))
	}
	if m.Confidentiality != 0 {
		n += 1 + sovCve(uint64(m.Confidentiality))
	}
	if m.Integrity != 0 {
		n += 1 + sovCve(uint64(m.Integrity))
	}
	if m.Availability != 0 {
		n += 1 + sovCve(uint64(m.Availability))
	}
	if m.Score != 0 {
		n += 5
	}
	if m.Severity != 0 {
		n += 1 + sovCve(uint64(m.Severity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCve(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCve(x uint64) (n int) {
	return sovCve(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CVE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCve
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CVE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CVE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cvss", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Cvss = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CVE_CVEType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishedOn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishedOn == nil {
				m.PublishedOn = &types.Timestamp{}
			}
			if err := m.PublishedOn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModified == nil {
				m.LastModified = &types.Timestamp{}
			}
			if err := m.LastModified.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = append(m.References, &CVE_Reference{})
			if err := m.References[len(m.References)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreVersion", wireType)
			}
			m.ScoreVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoreVersion |= CVE_ScoreVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvssV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CvssV2 == nil {
				m.CvssV2 = &CVSSV2{}
			}
			if err := m.CvssV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvssV3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CvssV3 == nil {
				m.CvssV3 = &CVSSV3{}
			}
			if err := m.CvssV3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suppressed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Suppressed = bool(v != 0)
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImpactScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ImpactScore = float32(math.Float32frombits(v))
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuppressActivation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SuppressActivation == nil {
				m.SuppressActivation = &types.Timestamp{}
			}
			if err := m.SuppressActivation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuppressExpiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SuppressExpiry == nil {
				m.SuppressExpiry = &types.Timestamp{}
			}
			if err := m.SuppressExpiry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType == 0 {
				var v CVE_CVEType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCve
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= CVE_CVEType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCve
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCve
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCve
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Types) == 0 {
					m.Types = make([]CVE_CVEType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v CVE_CVEType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCve
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= CVE_CVEType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistroSpecifics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DistroSpecifics == nil {
				m.DistroSpecifics = make(map[string]*CVE_DistroSpecific)
			}
			var mapkey string
			var mapvalue *CVE_DistroSpecific
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCve
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCve
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCve
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCve
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCve
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCve
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCve
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CVE_DistroSpecific{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCve(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCve
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DistroSpecifics[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= VulnerabilitySeverity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cve", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cve = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCve(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCve
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CVE_DistroSpecific) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCve
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistroSpecific: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistroSpecific: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= VulnerabilitySeverity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cvss", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Cvss = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreVersion", wireType)
			}
			m.ScoreVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoreVersion |= CVE_ScoreVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvssV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CvssV2 == nil {
				m.CvssV2 = &CVSSV2{}
			}
			if err := m.CvssV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvssV3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CvssV3 == nil {
				m.CvssV3 = &CVSSV3{}
			}
			if err := m.CvssV3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCve(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCve
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CVE_Reference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCve
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCve(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCve
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CVSSV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCve
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CVSSV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CVSSV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vector = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackVector", wireType)
			}
			m.AttackVector = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackVector |= CVSSV2_AttackVector(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessComplexity", wireType)
			}
			m.AccessComplexity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessComplexity |= CVSSV2_AccessComplexity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			m.Authentication = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Authentication |= CVSSV2_Authentication(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confidentiality", wireType)
			}
			m.Confidentiality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Confidentiality |= CVSSV2_Impact(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integrity", wireType)
			}
			m.Integrity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Integrity |= CVSSV2_Impact(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Availability", wireType)
			}
			m.Availability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Availability |= CVSSV2_Impact(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExploitabilityScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ExploitabilityScore = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImpactScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ImpactScore = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Score = float32(math.Float32frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= CVSSV2_Severity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCve(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCve
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CVSSV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCve
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CVSSV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CVSSV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCve
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCve
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vector = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExploitabilityScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ExploitabilityScore = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImpactScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ImpactScore = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackVector", wireType)
			}
			m.AttackVector = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackVector |= CVSSV3_AttackVector(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackComplexity", wireType)
			}
			m.AttackComplexity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackComplexity |= CVSSV3_Complexity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivilegesRequired", wireType)
			}
			m.PrivilegesRequired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivilegesRequired |= CVSSV3_Privileges(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInteraction", wireType)
			}
			m.UserInteraction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserInteraction |= CVSSV3_UserInteraction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scope |= CVSSV3_Scope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confidentiality", wireType)
			}
			m.Confidentiality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Confidentiality |= CVSSV3_Impact(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integrity", wireType)
			}
			m.Integrity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Integrity |= CVSSV3_Impact(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Availability", wireType)
			}
			m.Availability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Availability |= CVSSV3_Impact(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Score = float32(math.Float32frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCve
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= CVSSV3_Severity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCve(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCve
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCve(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCve
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCve
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCve
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCve
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCve
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCve
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCve        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCve          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCve = fmt.Errorf("proto: unexpected end of group")
)
