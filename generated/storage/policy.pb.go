// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/policy.proto

package storage

import (
	fmt "fmt"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type EventSource int32

const (
	EventSource_NOT_APPLICABLE   EventSource = 0
	EventSource_DEPLOYMENT_EVENT EventSource = 1
	EventSource_AUDIT_LOG_EVENT  EventSource = 2
)

var EventSource_name = map[int32]string{
	0: "NOT_APPLICABLE",
	1: "DEPLOYMENT_EVENT",
	2: "AUDIT_LOG_EVENT",
}

var EventSource_value = map[string]int32{
	"NOT_APPLICABLE":   0,
	"DEPLOYMENT_EVENT": 1,
	"AUDIT_LOG_EVENT":  2,
}

func (x EventSource) String() string {
	return proto.EnumName(EventSource_name, int32(x))
}

func (EventSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{0}
}

type BooleanOperator int32

const (
	BooleanOperator_OR  BooleanOperator = 0
	BooleanOperator_AND BooleanOperator = 1
)

var BooleanOperator_name = map[int32]string{
	0: "OR",
	1: "AND",
}

var BooleanOperator_value = map[string]int32{
	"OR":  0,
	"AND": 1,
}

func (x BooleanOperator) String() string {
	return proto.EnumName(BooleanOperator_name, int32(x))
}

func (BooleanOperator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{1}
}

type EnforcementAction int32

const (
	EnforcementAction_UNSET_ENFORCEMENT                         EnforcementAction = 0
	EnforcementAction_SCALE_TO_ZERO_ENFORCEMENT                 EnforcementAction = 1
	EnforcementAction_UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT EnforcementAction = 2
	EnforcementAction_KILL_POD_ENFORCEMENT                      EnforcementAction = 3
	EnforcementAction_FAIL_BUILD_ENFORCEMENT                    EnforcementAction = 4
	// FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.
	EnforcementAction_FAIL_KUBE_REQUEST_ENFORCEMENT EnforcementAction = 5
	// FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.
	EnforcementAction_FAIL_DEPLOYMENT_CREATE_ENFORCEMENT EnforcementAction = 6
	// FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.
	EnforcementAction_FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT EnforcementAction = 7
)

var EnforcementAction_name = map[int32]string{
	0: "UNSET_ENFORCEMENT",
	1: "SCALE_TO_ZERO_ENFORCEMENT",
	2: "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
	3: "KILL_POD_ENFORCEMENT",
	4: "FAIL_BUILD_ENFORCEMENT",
	5: "FAIL_KUBE_REQUEST_ENFORCEMENT",
	6: "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
	7: "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT",
}

var EnforcementAction_value = map[string]int32{
	"UNSET_ENFORCEMENT":                         0,
	"SCALE_TO_ZERO_ENFORCEMENT":                 1,
	"UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT": 2,
	"KILL_POD_ENFORCEMENT":                      3,
	"FAIL_BUILD_ENFORCEMENT":                    4,
	"FAIL_KUBE_REQUEST_ENFORCEMENT":             5,
	"FAIL_DEPLOYMENT_CREATE_ENFORCEMENT":        6,
	"FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT":        7,
}

func (x EnforcementAction) String() string {
	return proto.EnumName(EnforcementAction_name, int32(x))
}

func (EnforcementAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{2}
}

type Severity int32

const (
	Severity_UNSET_SEVERITY    Severity = 0
	Severity_LOW_SEVERITY      Severity = 1
	Severity_MEDIUM_SEVERITY   Severity = 2
	Severity_HIGH_SEVERITY     Severity = 3
	Severity_CRITICAL_SEVERITY Severity = 4
)

var Severity_name = map[int32]string{
	0: "UNSET_SEVERITY",
	1: "LOW_SEVERITY",
	2: "MEDIUM_SEVERITY",
	3: "HIGH_SEVERITY",
	4: "CRITICAL_SEVERITY",
}

var Severity_value = map[string]int32{
	"UNSET_SEVERITY":    0,
	"LOW_SEVERITY":      1,
	"MEDIUM_SEVERITY":   2,
	"HIGH_SEVERITY":     3,
	"CRITICAL_SEVERITY": 4,
}

func (x Severity) String() string {
	return proto.EnumName(Severity_name, int32(x))
}

func (Severity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{3}
}

type LifecycleStage int32

const (
	LifecycleStage_DEPLOY  LifecycleStage = 0
	LifecycleStage_BUILD   LifecycleStage = 1
	LifecycleStage_RUNTIME LifecycleStage = 2
)

var LifecycleStage_name = map[int32]string{
	0: "DEPLOY",
	1: "BUILD",
	2: "RUNTIME",
}

var LifecycleStage_value = map[string]int32{
	"DEPLOY":  0,
	"BUILD":   1,
	"RUNTIME": 2,
}

func (x LifecycleStage) String() string {
	return proto.EnumName(LifecycleStage_name, int32(x))
}

func (LifecycleStage) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{4}
}

type Comparator int32

const (
	Comparator_LESS_THAN              Comparator = 0
	Comparator_LESS_THAN_OR_EQUALS    Comparator = 1
	Comparator_EQUALS                 Comparator = 2
	Comparator_GREATER_THAN_OR_EQUALS Comparator = 3
	Comparator_GREATER_THAN           Comparator = 4
)

var Comparator_name = map[int32]string{
	0: "LESS_THAN",
	1: "LESS_THAN_OR_EQUALS",
	2: "EQUALS",
	3: "GREATER_THAN_OR_EQUALS",
	4: "GREATER_THAN",
}

var Comparator_value = map[string]int32{
	"LESS_THAN":              0,
	"LESS_THAN_OR_EQUALS":    1,
	"EQUALS":                 2,
	"GREATER_THAN_OR_EQUALS": 3,
	"GREATER_THAN":           4,
}

func (x Comparator) String() string {
	return proto.EnumName(Comparator_name, int32(x))
}

func (Comparator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{5}
}

type Policy struct {
	Id              string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Policy ID,store,hidden" sql:"pk"`                   // @gotags: search:"Policy ID,store,hidden" sql:"pk"
	Name            string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" search:"Policy,store" sql:"unique"`               // @gotags: search:"Policy,store" sql:"unique"
	Description     string           `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty" search:"Description"` // @gotags: search:"Description"
	Rationale       string           `protobuf:"bytes,4,opt,name=rationale,proto3" json:"rationale,omitempty"`
	Remediation     string           `protobuf:"bytes,5,opt,name=remediation,proto3" json:"remediation,omitempty"`
	Disabled        bool             `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty" search:"Disabled"`                                                                         // @gotags: search:"Disabled"
	Categories      []string         `protobuf:"bytes,7,rep,name=categories,proto3" json:"categories,omitempty" search:"Category,store"`                                                                      // @gotags: search:"Category,store"
	LifecycleStages []LifecycleStage `protobuf:"varint,9,rep,packed,name=lifecycle_stages,json=lifecycleStages,proto3,enum=storage.LifecycleStage" json:"lifecycle_stages,omitempty" search:"Lifecycle Stage,store"` // @gotags: search:"Lifecycle Stage,store"
	EventSource     EventSource      `protobuf:"varint,22,opt,name=event_source,json=eventSource,proto3,enum=storage.EventSource" json:"event_source,omitempty"`
	Exclusions      []*Exclusion     `protobuf:"bytes,21,rep,name=exclusions,proto3" json:"exclusions,omitempty"`
	Scope           []*Scope         `protobuf:"bytes,11,rep,name=scope,proto3" json:"scope,omitempty"`
	Severity        Severity         `protobuf:"varint,12,opt,name=severity,proto3,enum=storage.Severity" json:"severity,omitempty" search:"Severity,store"` // @gotags: search:"Severity,store"
	// FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates/updates.
	// FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.
	// FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.
	EnforcementActions []EnforcementAction `protobuf:"varint,13,rep,packed,name=enforcement_actions,json=enforcementActions,proto3,enum=storage.EnforcementAction" json:"enforcement_actions,omitempty" search:"Enforcement"` // @gotags: search:"Enforcement"
	Notifiers          []string            `protobuf:"bytes,14,rep,name=notifiers,proto3" json:"notifiers,omitempty"`
	LastUpdated        *types.Timestamp    `protobuf:"bytes,15,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty" search:"Policy Last Updated"` // @gotags: search:"Policy Last Updated"
	// For internal use only.
	SORTName string `protobuf:"bytes,16,opt,name=SORT_name,json=SORTName,proto3" json:"SORT_name,omitempty" search:"SORT_Policy,hidden,analyzer=keyword"` // @gotags: search:"SORT_Policy,hidden,analyzer=keyword"
	// For internal use only.
	SORTLifecycleStage string `protobuf:"bytes,17,opt,name=SORT_lifecycleStage,json=SORTLifecycleStage,proto3" json:"SORT_lifecycleStage,omitempty" search:"SORT_Lifecycle Stage,hidden"` // @gotags: search:"SORT_Lifecycle Stage,hidden"
	// For internal use only.
	SORTEnforcement    bool                         `protobuf:"varint,18,opt,name=SORT_enforcement,json=SORTEnforcement,proto3" json:"SORT_enforcement,omitempty" search:"SORT_Enforcement,hidden"` // @gotags: search:"SORT_Enforcement,hidden"
	PolicyVersion      string                       `protobuf:"bytes,19,opt,name=policy_version,json=policyVersion,proto3" json:"policy_version,omitempty"`
	PolicySections     []*PolicySection             `protobuf:"bytes,20,rep,name=policy_sections,json=policySections,proto3" json:"policy_sections,omitempty"`
	MitreAttackVectors []*Policy_MitreAttackVectors `protobuf:"bytes,23,rep,name=mitre_attack_vectors,json=mitreAttackVectors,proto3" json:"mitre_attack_vectors,omitempty"`
	// Read-only field. If true, the policy's criteria fields are rendered read-only.
	CriteriaLocked bool `protobuf:"varint,24,opt,name=criteria_locked,json=criteriaLocked,proto3" json:"criteria_locked,omitempty"`
	// Read-only field. If true, the policy's MITRE ATT&CK fields are rendered read-only.
	MitreVectorsLocked bool `protobuf:"varint,25,opt,name=mitre_vectors_locked,json=mitreVectorsLocked,proto3" json:"mitre_vectors_locked,omitempty"`
	// Read-only field. Indicates the policy is a default policy if true and a custom policy if false.
	IsDefault            bool     `protobuf:"varint,26,opt,name=is_default,json=isDefault,proto3" json:"is_default,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Policy) Reset()         { *m = Policy{} }
func (m *Policy) String() string { return proto.CompactTextString(m) }
func (*Policy) ProtoMessage()    {}
func (*Policy) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{0}
}
func (m *Policy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Policy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Policy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Policy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Policy.Merge(m, src)
}
func (m *Policy) XXX_Size() int {
	return m.Size()
}
func (m *Policy) XXX_DiscardUnknown() {
	xxx_messageInfo_Policy.DiscardUnknown(m)
}

var xxx_messageInfo_Policy proto.InternalMessageInfo

func (m *Policy) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Policy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Policy) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Policy) GetRationale() string {
	if m != nil {
		return m.Rationale
	}
	return ""
}

func (m *Policy) GetRemediation() string {
	if m != nil {
		return m.Remediation
	}
	return ""
}

func (m *Policy) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *Policy) GetCategories() []string {
	if m != nil {
		return m.Categories
	}
	return nil
}

func (m *Policy) GetLifecycleStages() []LifecycleStage {
	if m != nil {
		return m.LifecycleStages
	}
	return nil
}

func (m *Policy) GetEventSource() EventSource {
	if m != nil {
		return m.EventSource
	}
	return EventSource_NOT_APPLICABLE
}

func (m *Policy) GetExclusions() []*Exclusion {
	if m != nil {
		return m.Exclusions
	}
	return nil
}

func (m *Policy) GetScope() []*Scope {
	if m != nil {
		return m.Scope
	}
	return nil
}

func (m *Policy) GetSeverity() Severity {
	if m != nil {
		return m.Severity
	}
	return Severity_UNSET_SEVERITY
}

func (m *Policy) GetEnforcementActions() []EnforcementAction {
	if m != nil {
		return m.EnforcementActions
	}
	return nil
}

func (m *Policy) GetNotifiers() []string {
	if m != nil {
		return m.Notifiers
	}
	return nil
}

func (m *Policy) GetLastUpdated() *types.Timestamp {
	if m != nil {
		return m.LastUpdated
	}
	return nil
}

func (m *Policy) GetSORTName() string {
	if m != nil {
		return m.SORTName
	}
	return ""
}

func (m *Policy) GetSORTLifecycleStage() string {
	if m != nil {
		return m.SORTLifecycleStage
	}
	return ""
}

func (m *Policy) GetSORTEnforcement() bool {
	if m != nil {
		return m.SORTEnforcement
	}
	return false
}

func (m *Policy) GetPolicyVersion() string {
	if m != nil {
		return m.PolicyVersion
	}
	return ""
}

func (m *Policy) GetPolicySections() []*PolicySection {
	if m != nil {
		return m.PolicySections
	}
	return nil
}

func (m *Policy) GetMitreAttackVectors() []*Policy_MitreAttackVectors {
	if m != nil {
		return m.MitreAttackVectors
	}
	return nil
}

func (m *Policy) GetCriteriaLocked() bool {
	if m != nil {
		return m.CriteriaLocked
	}
	return false
}

func (m *Policy) GetMitreVectorsLocked() bool {
	if m != nil {
		return m.MitreVectorsLocked
	}
	return false
}

func (m *Policy) GetIsDefault() bool {
	if m != nil {
		return m.IsDefault
	}
	return false
}

func (m *Policy) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Policy) Clone() *Policy {
	if m == nil {
		return nil
	}
	cloned := new(Policy)
	*cloned = *m

	if m.Categories != nil {
		cloned.Categories = make([]string, len(m.Categories))
		copy(cloned.Categories, m.Categories)
	}
	if m.LifecycleStages != nil {
		cloned.LifecycleStages = make([]LifecycleStage, len(m.LifecycleStages))
		copy(cloned.LifecycleStages, m.LifecycleStages)
	}
	if m.Exclusions != nil {
		cloned.Exclusions = make([]*Exclusion, len(m.Exclusions))
		for idx, v := range m.Exclusions {
			cloned.Exclusions[idx] = v.Clone()
		}
	}
	if m.Scope != nil {
		cloned.Scope = make([]*Scope, len(m.Scope))
		for idx, v := range m.Scope {
			cloned.Scope[idx] = v.Clone()
		}
	}
	if m.EnforcementActions != nil {
		cloned.EnforcementActions = make([]EnforcementAction, len(m.EnforcementActions))
		copy(cloned.EnforcementActions, m.EnforcementActions)
	}
	if m.Notifiers != nil {
		cloned.Notifiers = make([]string, len(m.Notifiers))
		copy(cloned.Notifiers, m.Notifiers)
	}
	cloned.LastUpdated = m.LastUpdated.Clone()
	if m.PolicySections != nil {
		cloned.PolicySections = make([]*PolicySection, len(m.PolicySections))
		for idx, v := range m.PolicySections {
			cloned.PolicySections[idx] = v.Clone()
		}
	}
	if m.MitreAttackVectors != nil {
		cloned.MitreAttackVectors = make([]*Policy_MitreAttackVectors, len(m.MitreAttackVectors))
		for idx, v := range m.MitreAttackVectors {
			cloned.MitreAttackVectors[idx] = v.Clone()
		}
	}
	return cloned
}

type Policy_MitreAttackVectors struct {
	Tactic               string   `protobuf:"bytes,1,opt,name=tactic,proto3" json:"tactic,omitempty"`
	Techniques           []string `protobuf:"bytes,2,rep,name=techniques,proto3" json:"techniques,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Policy_MitreAttackVectors) Reset()         { *m = Policy_MitreAttackVectors{} }
func (m *Policy_MitreAttackVectors) String() string { return proto.CompactTextString(m) }
func (*Policy_MitreAttackVectors) ProtoMessage()    {}
func (*Policy_MitreAttackVectors) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{0, 0}
}
func (m *Policy_MitreAttackVectors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Policy_MitreAttackVectors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Policy_MitreAttackVectors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Policy_MitreAttackVectors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Policy_MitreAttackVectors.Merge(m, src)
}
func (m *Policy_MitreAttackVectors) XXX_Size() int {
	return m.Size()
}
func (m *Policy_MitreAttackVectors) XXX_DiscardUnknown() {
	xxx_messageInfo_Policy_MitreAttackVectors.DiscardUnknown(m)
}

var xxx_messageInfo_Policy_MitreAttackVectors proto.InternalMessageInfo

func (m *Policy_MitreAttackVectors) GetTactic() string {
	if m != nil {
		return m.Tactic
	}
	return ""
}

func (m *Policy_MitreAttackVectors) GetTechniques() []string {
	if m != nil {
		return m.Techniques
	}
	return nil
}

func (m *Policy_MitreAttackVectors) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Policy_MitreAttackVectors) Clone() *Policy_MitreAttackVectors {
	if m == nil {
		return nil
	}
	cloned := new(Policy_MitreAttackVectors)
	*cloned = *m

	if m.Techniques != nil {
		cloned.Techniques = make([]string, len(m.Techniques))
		copy(cloned.Techniques, m.Techniques)
	}
	return cloned
}

type PolicySection struct {
	SectionName          string         `protobuf:"bytes,1,opt,name=section_name,json=sectionName,proto3" json:"section_name,omitempty"`
	PolicyGroups         []*PolicyGroup `protobuf:"bytes,3,rep,name=policy_groups,json=policyGroups,proto3" json:"policy_groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *PolicySection) Reset()         { *m = PolicySection{} }
func (m *PolicySection) String() string { return proto.CompactTextString(m) }
func (*PolicySection) ProtoMessage()    {}
func (*PolicySection) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{1}
}
func (m *PolicySection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicySection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicySection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicySection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicySection.Merge(m, src)
}
func (m *PolicySection) XXX_Size() int {
	return m.Size()
}
func (m *PolicySection) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicySection.DiscardUnknown(m)
}

var xxx_messageInfo_PolicySection proto.InternalMessageInfo

func (m *PolicySection) GetSectionName() string {
	if m != nil {
		return m.SectionName
	}
	return ""
}

func (m *PolicySection) GetPolicyGroups() []*PolicyGroup {
	if m != nil {
		return m.PolicyGroups
	}
	return nil
}

func (m *PolicySection) MessageClone() proto.Message {
	return m.Clone()
}
func (m *PolicySection) Clone() *PolicySection {
	if m == nil {
		return nil
	}
	cloned := new(PolicySection)
	*cloned = *m

	if m.PolicyGroups != nil {
		cloned.PolicyGroups = make([]*PolicyGroup, len(m.PolicyGroups))
		for idx, v := range m.PolicyGroups {
			cloned.PolicyGroups[idx] = v.Clone()
		}
	}
	return cloned
}

type PolicyGroup struct {
	FieldName            string          `protobuf:"bytes,1,opt,name=field_name,json=fieldName,proto3" json:"field_name,omitempty"`
	BooleanOperator      BooleanOperator `protobuf:"varint,2,opt,name=boolean_operator,json=booleanOperator,proto3,enum=storage.BooleanOperator" json:"boolean_operator,omitempty"`
	Negate               bool            `protobuf:"varint,3,opt,name=negate,proto3" json:"negate,omitempty"`
	Values               []*PolicyValue  `protobuf:"bytes,4,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PolicyGroup) Reset()         { *m = PolicyGroup{} }
func (m *PolicyGroup) String() string { return proto.CompactTextString(m) }
func (*PolicyGroup) ProtoMessage()    {}
func (*PolicyGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{2}
}
func (m *PolicyGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyGroup.Merge(m, src)
}
func (m *PolicyGroup) XXX_Size() int {
	return m.Size()
}
func (m *PolicyGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyGroup.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyGroup proto.InternalMessageInfo

func (m *PolicyGroup) GetFieldName() string {
	if m != nil {
		return m.FieldName
	}
	return ""
}

func (m *PolicyGroup) GetBooleanOperator() BooleanOperator {
	if m != nil {
		return m.BooleanOperator
	}
	return BooleanOperator_OR
}

func (m *PolicyGroup) GetNegate() bool {
	if m != nil {
		return m.Negate
	}
	return false
}

func (m *PolicyGroup) GetValues() []*PolicyValue {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *PolicyGroup) MessageClone() proto.Message {
	return m.Clone()
}
func (m *PolicyGroup) Clone() *PolicyGroup {
	if m == nil {
		return nil
	}
	cloned := new(PolicyGroup)
	*cloned = *m

	if m.Values != nil {
		cloned.Values = make([]*PolicyValue, len(m.Values))
		for idx, v := range m.Values {
			cloned.Values[idx] = v.Clone()
		}
	}
	return cloned
}

type PolicyValue struct {
	Value                string   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PolicyValue) Reset()         { *m = PolicyValue{} }
func (m *PolicyValue) String() string { return proto.CompactTextString(m) }
func (*PolicyValue) ProtoMessage()    {}
func (*PolicyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{3}
}
func (m *PolicyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyValue.Merge(m, src)
}
func (m *PolicyValue) XXX_Size() int {
	return m.Size()
}
func (m *PolicyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyValue.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyValue proto.InternalMessageInfo

func (m *PolicyValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *PolicyValue) MessageClone() proto.Message {
	return m.Clone()
}
func (m *PolicyValue) Clone() *PolicyValue {
	if m == nil {
		return nil
	}
	cloned := new(PolicyValue)
	*cloned = *m

	return cloned
}

type PolicyList struct {
	Policies             []*Policy `protobuf:"bytes,1,rep,name=policies,proto3" json:"policies,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *PolicyList) Reset()         { *m = PolicyList{} }
func (m *PolicyList) String() string { return proto.CompactTextString(m) }
func (*PolicyList) ProtoMessage()    {}
func (*PolicyList) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{4}
}
func (m *PolicyList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyList.Merge(m, src)
}
func (m *PolicyList) XXX_Size() int {
	return m.Size()
}
func (m *PolicyList) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyList.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyList proto.InternalMessageInfo

func (m *PolicyList) GetPolicies() []*Policy {
	if m != nil {
		return m.Policies
	}
	return nil
}

func (m *PolicyList) MessageClone() proto.Message {
	return m.Clone()
}
func (m *PolicyList) Clone() *PolicyList {
	if m == nil {
		return nil
	}
	cloned := new(PolicyList)
	*cloned = *m

	if m.Policies != nil {
		cloned.Policies = make([]*Policy, len(m.Policies))
		for idx, v := range m.Policies {
			cloned.Policies[idx] = v.Clone()
		}
	}
	return cloned
}

type ListPolicy struct {
	Id                   string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description          string           `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Severity             Severity         `protobuf:"varint,4,opt,name=severity,proto3,enum=storage.Severity" json:"severity,omitempty"`
	Disabled             bool             `protobuf:"varint,5,opt,name=disabled,proto3" json:"disabled,omitempty"`
	LifecycleStages      []LifecycleStage `protobuf:"varint,6,rep,packed,name=lifecycle_stages,json=lifecycleStages,proto3,enum=storage.LifecycleStage" json:"lifecycle_stages,omitempty"`
	Notifiers            []string         `protobuf:"bytes,7,rep,name=notifiers,proto3" json:"notifiers,omitempty"`
	LastUpdated          *types.Timestamp `protobuf:"bytes,8,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty"`
	EventSource          EventSource      `protobuf:"varint,9,opt,name=event_source,json=eventSource,proto3,enum=storage.EventSource" json:"event_source,omitempty"`
	IsDefault            bool             `protobuf:"varint,10,opt,name=is_default,json=isDefault,proto3" json:"is_default,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ListPolicy) Reset()         { *m = ListPolicy{} }
func (m *ListPolicy) String() string { return proto.CompactTextString(m) }
func (*ListPolicy) ProtoMessage()    {}
func (*ListPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{5}
}
func (m *ListPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPolicy.Merge(m, src)
}
func (m *ListPolicy) XXX_Size() int {
	return m.Size()
}
func (m *ListPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ListPolicy proto.InternalMessageInfo

func (m *ListPolicy) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ListPolicy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListPolicy) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ListPolicy) GetSeverity() Severity {
	if m != nil {
		return m.Severity
	}
	return Severity_UNSET_SEVERITY
}

func (m *ListPolicy) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *ListPolicy) GetLifecycleStages() []LifecycleStage {
	if m != nil {
		return m.LifecycleStages
	}
	return nil
}

func (m *ListPolicy) GetNotifiers() []string {
	if m != nil {
		return m.Notifiers
	}
	return nil
}

func (m *ListPolicy) GetLastUpdated() *types.Timestamp {
	if m != nil {
		return m.LastUpdated
	}
	return nil
}

func (m *ListPolicy) GetEventSource() EventSource {
	if m != nil {
		return m.EventSource
	}
	return EventSource_NOT_APPLICABLE
}

func (m *ListPolicy) GetIsDefault() bool {
	if m != nil {
		return m.IsDefault
	}
	return false
}

func (m *ListPolicy) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ListPolicy) Clone() *ListPolicy {
	if m == nil {
		return nil
	}
	cloned := new(ListPolicy)
	*cloned = *m

	if m.LifecycleStages != nil {
		cloned.LifecycleStages = make([]LifecycleStage, len(m.LifecycleStages))
		copy(cloned.LifecycleStages, m.LifecycleStages)
	}
	if m.Notifiers != nil {
		cloned.Notifiers = make([]string, len(m.Notifiers))
		copy(cloned.Notifiers, m.Notifiers)
	}
	cloned.LastUpdated = m.LastUpdated.Clone()
	return cloned
}

type Exclusion struct {
	Name                 string                `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Deployment           *Exclusion_Deployment `protobuf:"bytes,5,opt,name=deployment,proto3" json:"deployment,omitempty"`
	Image                *Exclusion_Image      `protobuf:"bytes,7,opt,name=image,proto3" json:"image,omitempty"`
	Expiration           *types.Timestamp      `protobuf:"bytes,6,opt,name=expiration,proto3" json:"expiration,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Exclusion) Reset()         { *m = Exclusion{} }
func (m *Exclusion) String() string { return proto.CompactTextString(m) }
func (*Exclusion) ProtoMessage()    {}
func (*Exclusion) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{6}
}
func (m *Exclusion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Exclusion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Exclusion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Exclusion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Exclusion.Merge(m, src)
}
func (m *Exclusion) XXX_Size() int {
	return m.Size()
}
func (m *Exclusion) XXX_DiscardUnknown() {
	xxx_messageInfo_Exclusion.DiscardUnknown(m)
}

var xxx_messageInfo_Exclusion proto.InternalMessageInfo

func (m *Exclusion) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Exclusion) GetDeployment() *Exclusion_Deployment {
	if m != nil {
		return m.Deployment
	}
	return nil
}

func (m *Exclusion) GetImage() *Exclusion_Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *Exclusion) GetExpiration() *types.Timestamp {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *Exclusion) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Exclusion) Clone() *Exclusion {
	if m == nil {
		return nil
	}
	cloned := new(Exclusion)
	*cloned = *m

	cloned.Deployment = m.Deployment.Clone()
	cloned.Image = m.Image.Clone()
	cloned.Expiration = m.Expiration.Clone()
	return cloned
}

type Exclusion_Container struct {
	ImageName            *ImageName `protobuf:"bytes,3,opt,name=image_name,json=imageName,proto3" json:"image_name,omitempty" search:"-"` // @gotags: search:"-"
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Exclusion_Container) Reset()         { *m = Exclusion_Container{} }
func (m *Exclusion_Container) String() string { return proto.CompactTextString(m) }
func (*Exclusion_Container) ProtoMessage()    {}
func (*Exclusion_Container) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{6, 0}
}
func (m *Exclusion_Container) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Exclusion_Container) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Exclusion_Container.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Exclusion_Container) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Exclusion_Container.Merge(m, src)
}
func (m *Exclusion_Container) XXX_Size() int {
	return m.Size()
}
func (m *Exclusion_Container) XXX_DiscardUnknown() {
	xxx_messageInfo_Exclusion_Container.DiscardUnknown(m)
}

var xxx_messageInfo_Exclusion_Container proto.InternalMessageInfo

func (m *Exclusion_Container) GetImageName() *ImageName {
	if m != nil {
		return m.ImageName
	}
	return nil
}

func (m *Exclusion_Container) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Exclusion_Container) Clone() *Exclusion_Container {
	if m == nil {
		return nil
	}
	cloned := new(Exclusion_Container)
	*cloned = *m

	cloned.ImageName = m.ImageName.Clone()
	return cloned
}

type Exclusion_Deployment struct {
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Scope                *Scope   `protobuf:"bytes,4,opt,name=scope,proto3" json:"scope,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Exclusion_Deployment) Reset()         { *m = Exclusion_Deployment{} }
func (m *Exclusion_Deployment) String() string { return proto.CompactTextString(m) }
func (*Exclusion_Deployment) ProtoMessage()    {}
func (*Exclusion_Deployment) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{6, 1}
}
func (m *Exclusion_Deployment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Exclusion_Deployment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Exclusion_Deployment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Exclusion_Deployment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Exclusion_Deployment.Merge(m, src)
}
func (m *Exclusion_Deployment) XXX_Size() int {
	return m.Size()
}
func (m *Exclusion_Deployment) XXX_DiscardUnknown() {
	xxx_messageInfo_Exclusion_Deployment.DiscardUnknown(m)
}

var xxx_messageInfo_Exclusion_Deployment proto.InternalMessageInfo

func (m *Exclusion_Deployment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Exclusion_Deployment) GetScope() *Scope {
	if m != nil {
		return m.Scope
	}
	return nil
}

func (m *Exclusion_Deployment) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Exclusion_Deployment) Clone() *Exclusion_Deployment {
	if m == nil {
		return nil
	}
	cloned := new(Exclusion_Deployment)
	*cloned = *m

	cloned.Scope = m.Scope.Clone()
	return cloned
}

type Exclusion_Image struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Exclusion_Image) Reset()         { *m = Exclusion_Image{} }
func (m *Exclusion_Image) String() string { return proto.CompactTextString(m) }
func (*Exclusion_Image) ProtoMessage()    {}
func (*Exclusion_Image) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{6, 2}
}
func (m *Exclusion_Image) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Exclusion_Image) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Exclusion_Image.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Exclusion_Image) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Exclusion_Image.Merge(m, src)
}
func (m *Exclusion_Image) XXX_Size() int {
	return m.Size()
}
func (m *Exclusion_Image) XXX_DiscardUnknown() {
	xxx_messageInfo_Exclusion_Image.DiscardUnknown(m)
}

var xxx_messageInfo_Exclusion_Image proto.InternalMessageInfo

func (m *Exclusion_Image) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Exclusion_Image) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Exclusion_Image) Clone() *Exclusion_Image {
	if m == nil {
		return nil
	}
	cloned := new(Exclusion_Image)
	*cloned = *m

	return cloned
}

// ExportPoliciesResponse is used by the API but it is defined in storage because we expect customers to store them.
// We do backwards-compatibility checks on objects in the storge folder and those checks should be applied to this object
type ExportPoliciesResponse struct {
	Policies             []*Policy `protobuf:"bytes,1,rep,name=policies,proto3" json:"policies,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ExportPoliciesResponse) Reset()         { *m = ExportPoliciesResponse{} }
func (m *ExportPoliciesResponse) String() string { return proto.CompactTextString(m) }
func (*ExportPoliciesResponse) ProtoMessage()    {}
func (*ExportPoliciesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e41152b9b8342fa, []int{7}
}
func (m *ExportPoliciesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportPoliciesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportPoliciesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportPoliciesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportPoliciesResponse.Merge(m, src)
}
func (m *ExportPoliciesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExportPoliciesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportPoliciesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExportPoliciesResponse proto.InternalMessageInfo

func (m *ExportPoliciesResponse) GetPolicies() []*Policy {
	if m != nil {
		return m.Policies
	}
	return nil
}

func (m *ExportPoliciesResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ExportPoliciesResponse) Clone() *ExportPoliciesResponse {
	if m == nil {
		return nil
	}
	cloned := new(ExportPoliciesResponse)
	*cloned = *m

	if m.Policies != nil {
		cloned.Policies = make([]*Policy, len(m.Policies))
		for idx, v := range m.Policies {
			cloned.Policies[idx] = v.Clone()
		}
	}
	return cloned
}

func init() {
	proto.RegisterEnum("storage.EventSource", EventSource_name, EventSource_value)
	proto.RegisterEnum("storage.BooleanOperator", BooleanOperator_name, BooleanOperator_value)
	proto.RegisterEnum("storage.EnforcementAction", EnforcementAction_name, EnforcementAction_value)
	proto.RegisterEnum("storage.Severity", Severity_name, Severity_value)
	proto.RegisterEnum("storage.LifecycleStage", LifecycleStage_name, LifecycleStage_value)
	proto.RegisterEnum("storage.Comparator", Comparator_name, Comparator_value)
	proto.RegisterType((*Policy)(nil), "storage.Policy")
	proto.RegisterType((*Policy_MitreAttackVectors)(nil), "storage.Policy.MitreAttackVectors")
	proto.RegisterType((*PolicySection)(nil), "storage.PolicySection")
	proto.RegisterType((*PolicyGroup)(nil), "storage.PolicyGroup")
	proto.RegisterType((*PolicyValue)(nil), "storage.PolicyValue")
	proto.RegisterType((*PolicyList)(nil), "storage.PolicyList")
	proto.RegisterType((*ListPolicy)(nil), "storage.ListPolicy")
	proto.RegisterType((*Exclusion)(nil), "storage.Exclusion")
	proto.RegisterType((*Exclusion_Container)(nil), "storage.Exclusion.Container")
	proto.RegisterType((*Exclusion_Deployment)(nil), "storage.Exclusion.Deployment")
	proto.RegisterType((*Exclusion_Image)(nil), "storage.Exclusion.Image")
	proto.RegisterType((*ExportPoliciesResponse)(nil), "storage.ExportPoliciesResponse")
}

func init() { proto.RegisterFile("storage/policy.proto", fileDescriptor_6e41152b9b8342fa) }

var fileDescriptor_6e41152b9b8342fa = []byte{
	// 1437 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xdb, 0x72, 0xdb, 0x44,
	0x18, 0x8e, 0x7c, 0x8a, 0xf5, 0x3b, 0xb1, 0x95, 0x8d, 0x9b, 0xaa, 0x2e, 0x09, 0xae, 0x39, 0xa5,
	0x81, 0x3a, 0x10, 0x98, 0x61, 0x0a, 0xd3, 0x32, 0x8e, 0xad, 0xa4, 0x6a, 0x15, 0x3b, 0x5d, 0xc9,
	0x61, 0xda, 0x1b, 0x8d, 0x22, 0x6f, 0x8c, 0xa6, 0xb2, 0xd7, 0x68, 0xe5, 0x4c, 0xf3, 0x00, 0xbc,
	0x02, 0xc3, 0x2d, 0x4f, 0xc1, 0x2b, 0x70, 0xc9, 0x23, 0x30, 0xe5, 0x19, 0xb8, 0x67, 0x76, 0x25,
	0x5b, 0xb2, 0x93, 0xa1, 0x74, 0x86, 0x2b, 0x6b, 0xbf, 0xef, 0xdb, 0x7f, 0x77, 0xff, 0xa3, 0xa1,
	0xca, 0x42, 0x1a, 0x38, 0x43, 0xb2, 0x3f, 0xa1, 0xbe, 0xe7, 0x5e, 0x35, 0x27, 0x01, 0x0d, 0x29,
	0x5a, 0x8d, 0xd1, 0xda, 0xfb, 0x43, 0x4a, 0x87, 0x3e, 0xd9, 0x17, 0xf0, 0xf9, 0xf4, 0x62, 0x3f,
	0xf4, 0x46, 0x84, 0x85, 0xce, 0x68, 0x12, 0x29, 0x6b, 0x9b, 0xb3, 0xfd, 0xde, 0xc8, 0x19, 0x92,
	0x65, 0x90, 0xb9, 0x74, 0x12, 0x83, 0x8d, 0x9f, 0x64, 0x28, 0x9c, 0x8a, 0x43, 0x50, 0x19, 0x32,
	0xde, 0x40, 0x95, 0xea, 0xd2, 0xae, 0x8c, 0x33, 0xde, 0x00, 0x21, 0xc8, 0x8d, 0x9d, 0x11, 0x51,
	0x33, 0x02, 0x11, 0xdf, 0xa8, 0x0e, 0xa5, 0x01, 0x61, 0x6e, 0xe0, 0x4d, 0x42, 0x8f, 0x8e, 0xd5,
	0xac, 0xa0, 0xd2, 0x10, 0x7a, 0x0f, 0xe4, 0xc0, 0xe1, 0x5f, 0x8e, 0x4f, 0xd4, 0x9c, 0xe0, 0x13,
	0x80, 0xef, 0x0f, 0xc8, 0x88, 0x0c, 0x3c, 0x81, 0xa8, 0xf9, 0x68, 0x7f, 0x0a, 0x42, 0x35, 0x28,
	0x0e, 0x3c, 0xe6, 0x9c, 0xfb, 0x64, 0xa0, 0x16, 0xea, 0xd2, 0x6e, 0x11, 0xcf, 0xd7, 0x68, 0x07,
	0xc0, 0x75, 0x42, 0x32, 0xa4, 0x81, 0x47, 0x98, 0xba, 0x5a, 0xcf, 0xee, 0xca, 0x38, 0x85, 0xa0,
	0x43, 0x50, 0x7c, 0xef, 0x82, 0xb8, 0x57, 0xae, 0x4f, 0x6c, 0x16, 0x3a, 0x43, 0xc2, 0x54, 0xb9,
	0x9e, 0xdd, 0x2d, 0x1f, 0xdc, 0x6e, 0xc6, 0x8f, 0x6f, 0x1a, 0x33, 0x81, 0xc9, 0x79, 0x5c, 0xf1,
	0x17, 0xd6, 0x0c, 0x7d, 0x0d, 0x6b, 0xe4, 0x92, 0x8c, 0x43, 0x9b, 0xd1, 0x69, 0xe0, 0x12, 0x75,
	0xab, 0x2e, 0xed, 0x96, 0x0f, 0xaa, 0xf3, 0xfd, 0x1a, 0x27, 0x4d, 0xc1, 0xe1, 0x12, 0x49, 0x16,
	0xe8, 0x00, 0x80, 0xbc, 0x76, 0xfd, 0x29, 0xf3, 0xe8, 0x98, 0xa9, 0xb7, 0xea, 0xd9, 0xdd, 0xd2,
	0x01, 0x4a, 0xb6, 0xcd, 0x28, 0x9c, 0x52, 0xa1, 0x0f, 0x21, 0x2f, 0x82, 0xa1, 0x96, 0x84, 0xbc,
	0x3c, 0x97, 0x9b, 0x1c, 0xc5, 0x11, 0x89, 0x1e, 0x40, 0x91, 0x91, 0x4b, 0x12, 0x78, 0xe1, 0x95,
	0xba, 0x26, 0xae, 0xb3, 0x91, 0x08, 0x63, 0x02, 0xcf, 0x25, 0xe8, 0x19, 0x6c, 0x92, 0xf1, 0x05,
	0x0d, 0x5c, 0x32, 0xe2, 0xef, 0x70, 0xdc, 0x50, 0xdc, 0x68, 0x5d, 0x38, 0xa2, 0x96, 0xdc, 0x28,
	0xd1, 0xb4, 0x84, 0x04, 0x23, 0xb2, 0x0c, 0x31, 0x1e, 0xce, 0x31, 0x0d, 0xbd, 0x0b, 0x8f, 0x04,
	0x4c, 0x2d, 0x0b, 0x8f, 0x27, 0x00, 0x7a, 0x04, 0x6b, 0xbe, 0xc3, 0x42, 0x7b, 0x3a, 0x19, 0x38,
	0x21, 0x19, 0xa8, 0x95, 0xba, 0xb4, 0x5b, 0x3a, 0xa8, 0x35, 0xa3, 0xfc, 0x6c, 0xce, 0xf2, 0xb3,
	0x69, 0xcd, 0xf2, 0x13, 0x97, 0xb8, 0xbe, 0x1f, 0xc9, 0xd1, 0x5d, 0x90, 0xcd, 0x1e, 0xb6, 0x6c,
	0x91, 0x66, 0x8a, 0xc8, 0x85, 0x22, 0x07, 0xba, 0x3c, 0xd5, 0xf6, 0x61, 0x53, 0x90, 0x8b, 0x01,
	0x52, 0x37, 0x84, 0x0c, 0x71, 0x6a, 0x31, 0x94, 0xe8, 0x3e, 0x28, 0x62, 0x43, 0xea, 0x15, 0x2a,
	0x12, 0x19, 0x54, 0xe1, 0x78, 0xea, 0xbd, 0xe8, 0x23, 0x28, 0x47, 0x95, 0x65, 0x5f, 0x92, 0x80,
	0x87, 0x42, 0xdd, 0x14, 0x66, 0xd7, 0x23, 0xf4, 0x2c, 0x02, 0xd1, 0x77, 0x50, 0x89, 0x65, 0x8c,
	0xc4, 0x5e, 0xac, 0x8a, 0x40, 0x6d, 0xcd, 0xbd, 0x18, 0xd5, 0x8e, 0x19, 0xd1, 0x38, 0xb6, 0x1a,
	0x2f, 0x19, 0xb2, 0xa0, 0x3a, 0xf2, 0xc2, 0x80, 0xd8, 0x4e, 0x18, 0x3a, 0xee, 0x2b, 0xfb, 0x92,
	0xb8, 0x21, 0x0d, 0x98, 0x7a, 0x5b, 0x58, 0x69, 0x2c, 0x59, 0x69, 0x9e, 0x70, 0x6d, 0x4b, 0x48,
	0xcf, 0x22, 0x25, 0x46, 0xa3, 0x6b, 0x18, 0xfa, 0x04, 0x2a, 0x6e, 0xe0, 0x85, 0x24, 0xf0, 0x1c,
	0xdb, 0xa7, 0xee, 0x2b, 0x32, 0x50, 0x55, 0xf1, 0xce, 0xf2, 0x0c, 0x36, 0x04, 0x8a, 0x3e, 0x9f,
	0x1d, 0x1f, 0x9f, 0x3b, 0x53, 0xdf, 0x11, 0xea, 0xc8, 0x74, 0x6c, 0x34, 0xde, 0xb1, 0x0d, 0xe0,
	0x31, 0x7b, 0x40, 0x2e, 0x9c, 0xa9, 0x1f, 0xaa, 0x35, 0xa1, 0x93, 0x3d, 0xd6, 0x89, 0x80, 0x9a,
	0x01, 0xe8, 0xfa, 0x1d, 0xd1, 0x16, 0x14, 0x42, 0x9e, 0x65, 0x6e, 0xdc, 0x3c, 0xe2, 0x15, 0x2f,
	0xd7, 0x90, 0xb8, 0x3f, 0x8c, 0xbd, 0x1f, 0xa7, 0x84, 0xa9, 0x99, 0xa8, 0x5c, 0x13, 0xe4, 0x69,
	0xae, 0x58, 0x54, 0xe4, 0xa7, 0xb9, 0x22, 0x28, 0xa5, 0xc6, 0x08, 0xd6, 0x17, 0x5c, 0x89, 0xee,
	0xc1, 0x5a, 0xec, 0xf4, 0x28, 0x3d, 0x22, 0xd3, 0xa5, 0x18, 0x13, 0x19, 0xf2, 0x10, 0xe2, 0x78,
	0xd9, 0xc3, 0x80, 0x4e, 0x27, 0x4c, 0xcd, 0x0a, 0xb7, 0x56, 0x97, 0xdc, 0x7a, 0xcc, 0x49, 0xbc,
	0x36, 0x49, 0x16, 0xac, 0xf1, 0x9b, 0x04, 0xa5, 0x14, 0xcb, 0xdf, 0x7d, 0xe1, 0x11, 0x7f, 0x90,
	0x3e, 0x4b, 0x16, 0x88, 0x38, 0xa9, 0x0d, 0xca, 0x39, 0xa5, 0x3e, 0x71, 0xc6, 0x36, 0x9d, 0x90,
	0xc0, 0x09, 0x69, 0x20, 0xda, 0x62, 0xf9, 0x40, 0x9d, 0x1f, 0x76, 0x18, 0x09, 0x7a, 0x31, 0x8f,
	0x2b, 0xe7, 0x8b, 0x00, 0x77, 0xd3, 0x98, 0x0c, 0x9d, 0x90, 0x88, 0xb6, 0x59, 0xc4, 0xf1, 0x0a,
	0x7d, 0x06, 0x85, 0x4b, 0xc7, 0xe7, 0x2e, 0xca, 0xdd, 0x78, 0xff, 0x33, 0x4e, 0xe2, 0x58, 0xd3,
	0xf8, 0x60, 0x76, 0x71, 0x01, 0xa3, 0x2a, 0xe4, 0x05, 0x11, 0xdf, 0x39, 0x5a, 0x34, 0x1e, 0x02,
	0x44, 0x22, 0xc3, 0x63, 0x21, 0xfa, 0x14, 0x8a, 0xe2, 0xf1, 0xbc, 0x69, 0x4a, 0xe2, 0x88, 0xca,
	0xd2, 0x11, 0x78, 0x2e, 0x68, 0xfc, 0x9c, 0x05, 0xe0, 0xbb, 0xfe, 0xd7, 0xa1, 0x90, 0xee, 0x60,
	0xb9, 0xb7, 0x77, 0xb0, 0xf4, 0x0c, 0xc8, 0x2f, 0xcd, 0x80, 0x9b, 0x7a, 0x7c, 0xe1, 0x1d, 0x7b,
	0xfc, 0x42, 0x53, 0x5b, 0x7d, 0x5b, 0x53, 0x2b, 0xbe, 0x5b, 0x53, 0x5b, 0x1e, 0x20, 0xf2, 0x7f,
	0x1d, 0x20, 0x8b, 0xb5, 0x07, 0x4b, 0xb5, 0xd7, 0xf8, 0x3b, 0x03, 0xf2, 0x7c, 0x8a, 0xcc, 0xe3,
	0x20, 0xa5, 0xe2, 0xf0, 0x08, 0x60, 0x40, 0x26, 0x3e, 0xbd, 0x12, 0xad, 0x2f, 0x2f, 0xae, 0xbd,
	0x7d, 0x7d, 0x02, 0x35, 0x3b, 0x73, 0x11, 0x4e, 0x6d, 0x40, 0x4d, 0xc8, 0x8b, 0xbf, 0x0b, 0xea,
	0xaa, 0xd8, 0xa9, 0xde, 0xb0, 0x53, 0xe7, 0x3c, 0x8e, 0x64, 0xe8, 0x1b, 0x3e, 0xf0, 0x26, 0x5e,
	0x34, 0xdc, 0xc5, 0xac, 0xfe, 0x77, 0x2f, 0xa5, 0xd4, 0xb5, 0xc7, 0x20, 0xb7, 0xe9, 0x38, 0x74,
	0xbc, 0x31, 0x09, 0xd0, 0x17, 0x00, 0xc2, 0x62, 0x54, 0x7c, 0x59, 0x61, 0x28, 0x99, 0x9c, 0xe2,
	0x4c, 0x5e, 0x85, 0x58, 0xf6, 0x66, 0x9f, 0xb5, 0x23, 0x80, 0xe4, 0x15, 0x73, 0x67, 0x64, 0x53,
	0xce, 0x98, 0x8f, 0xd6, 0x9c, 0xb0, 0x77, 0xf3, 0x68, 0xad, 0xdd, 0x85, 0xbc, 0xb0, 0x7f, 0x93,
	0x3f, 0x9f, 0xe6, 0x8a, 0x19, 0x25, 0xdb, 0xd0, 0x60, 0x4b, 0x7b, 0x3d, 0xa1, 0x41, 0x54, 0x11,
	0x1e, 0x61, 0x98, 0xb0, 0x09, 0x1d, 0x33, 0xf2, 0x4e, 0x75, 0xb5, 0x67, 0x40, 0x29, 0x15, 0x79,
	0x84, 0xa0, 0xdc, 0xed, 0x59, 0x76, 0xeb, 0xf4, 0xd4, 0xd0, 0xdb, 0xad, 0x43, 0x43, 0x53, 0x56,
	0x50, 0x15, 0x94, 0x8e, 0x76, 0x6a, 0xf4, 0x5e, 0x9c, 0x68, 0x5d, 0xcb, 0xd6, 0xce, 0xb4, 0xae,
	0xa5, 0x48, 0x68, 0x13, 0x2a, 0xad, 0x7e, 0x47, 0xb7, 0x6c, 0xa3, 0x77, 0x1c, 0x83, 0x99, 0xbd,
	0x06, 0x54, 0x96, 0xfa, 0x0d, 0x2a, 0x40, 0xa6, 0x87, 0x95, 0x15, 0xb4, 0x0a, 0xd9, 0x56, 0xb7,
	0xa3, 0x48, 0x7b, 0xbf, 0x66, 0x60, 0xe3, 0xda, 0x90, 0x47, 0xb7, 0x60, 0xa3, 0xdf, 0x35, 0x35,
	0xcb, 0xd6, 0xba, 0x47, 0x3d, 0xdc, 0xd6, 0xf8, 0x59, 0xca, 0x0a, 0xda, 0x86, 0x3b, 0x66, 0xbb,
	0x65, 0x68, 0xb6, 0xd5, 0xb3, 0x5f, 0x6a, 0xb8, 0xb7, 0x40, 0x4b, 0xe8, 0x01, 0xdc, 0xef, 0x77,
	0xcd, 0x96, 0xa5, 0x9b, 0x47, 0x3a, 0xbf, 0xad, 0xdd, 0xed, 0x75, 0x34, 0xbb, 0xdd, 0xeb, 0x9a,
	0x16, 0x6e, 0xe9, 0xdd, 0x45, 0x6b, 0x19, 0xa4, 0x42, 0xf5, 0x99, 0x6e, 0x18, 0xf6, 0x69, 0xaf,
	0xb3, 0xc0, 0x64, 0x51, 0x0d, 0xb6, 0x8e, 0x5a, 0xba, 0x61, 0x1f, 0xf6, 0x75, 0x63, 0x91, 0xcb,
	0xa1, 0x7b, 0xb0, 0x2d, 0xb8, 0x67, 0xfd, 0x43, 0xcd, 0xc6, 0xda, 0xf3, 0xbe, 0x66, 0x2e, 0x1a,
	0xce, 0xa3, 0x8f, 0xa1, 0x21, 0x24, 0x29, 0x3f, 0xb5, 0xb1, 0xd6, 0xb2, 0xb4, 0x05, 0x5d, 0xe1,
	0x26, 0x5d, 0xff, 0xb4, 0xb3, 0xac, 0x5b, 0xdd, 0xa3, 0x50, 0x9c, 0xf5, 0x1f, 0x1e, 0x92, 0xc8,
	0x33, 0xa6, 0x76, 0xa6, 0x61, 0xdd, 0x7a, 0xa1, 0xac, 0x20, 0x05, 0xd6, 0x8c, 0xde, 0xf7, 0x09,
	0x22, 0xc2, 0x71, 0xa2, 0x75, 0xf4, 0xfe, 0x49, 0x02, 0x66, 0xd0, 0x06, 0xac, 0x3f, 0xd1, 0x8f,
	0x9f, 0x24, 0x50, 0x96, 0xfb, 0xb9, 0x8d, 0x75, 0x4b, 0x6f, 0xb7, 0x8c, 0x04, 0xce, 0xed, 0x7d,
	0x05, 0xe5, 0xa5, 0xbf, 0x2d, 0x00, 0x85, 0xe8, 0x96, 0xca, 0x0a, 0x92, 0x21, 0x2f, 0x1c, 0xa3,
	0x48, 0xa8, 0x04, 0xab, 0xb8, 0xdf, 0xb5, 0xf4, 0x13, 0x4d, 0xc9, 0xec, 0x8d, 0x01, 0xda, 0x74,
	0x34, 0x71, 0xa2, 0x48, 0xaf, 0x83, 0x6c, 0x68, 0xa6, 0x69, 0x5b, 0x4f, 0x5a, 0x5d, 0x65, 0x05,
	0xdd, 0x86, 0xcd, 0xf9, 0xd2, 0xee, 0x61, 0x5b, 0x7b, 0xde, 0x6f, 0x19, 0xa6, 0x22, 0x71, 0xcb,
	0xf1, 0x77, 0x86, 0xfb, 0xfd, 0x58, 0x38, 0x0a, 0x2f, 0xeb, 0xb2, 0xfc, 0x91, 0x69, 0x4e, 0xc9,
	0x1d, 0x3e, 0xfe, 0xfd, 0xcd, 0x8e, 0xf4, 0xc7, 0x9b, 0x1d, 0xe9, 0xcf, 0x37, 0x3b, 0xd2, 0x2f,
	0x7f, 0xed, 0xac, 0xc0, 0x1d, 0x8f, 0x36, 0x19, 0x1f, 0xfa, 0x01, 0x7d, 0x1d, 0x15, 0xf7, 0x2c,
	0xd5, 0x5f, 0x6e, 0x34, 0xf7, 0xe3, 0xcf, 0x6f, 0xe3, 0xdf, 0xf3, 0x82, 0x50, 0x7c, 0xf9, 0x4f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x8b, 0xe3, 0xfb, 0x5f, 0xc8, 0x0c, 0x00, 0x00,
}

func (m *Policy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Policy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Policy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsDefault {
		i--
		if m.IsDefault {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.MitreVectorsLocked {
		i--
		if m.MitreVectorsLocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.CriteriaLocked {
		i--
		if m.CriteriaLocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if len(m.MitreAttackVectors) > 0 {
		for iNdEx := len(m.MitreAttackVectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MitreAttackVectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.EventSource != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.EventSource))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.Exclusions) > 0 {
		for iNdEx := len(m.Exclusions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Exclusions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.PolicySections) > 0 {
		for iNdEx := len(m.PolicySections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PolicySections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.PolicyVersion) > 0 {
		i -= len(m.PolicyVersion)
		copy(dAtA[i:], m.PolicyVersion)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.PolicyVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.SORTEnforcement {
		i--
		if m.SORTEnforcement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.SORTLifecycleStage) > 0 {
		i -= len(m.SORTLifecycleStage)
		copy(dAtA[i:], m.SORTLifecycleStage)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.SORTLifecycleStage)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.SORTName) > 0 {
		i -= len(m.SORTName)
		copy(dAtA[i:], m.SORTName)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.SORTName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.LastUpdated != nil {
		{
			size, err := m.LastUpdated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Notifiers) > 0 {
		for iNdEx := len(m.Notifiers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Notifiers[iNdEx])
			copy(dAtA[i:], m.Notifiers[iNdEx])
			i = encodeVarintPolicy(dAtA, i, uint64(len(m.Notifiers[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.EnforcementActions) > 0 {
		dAtA3 := make([]byte, len(m.EnforcementActions)*10)
		var j2 int
		for _, num := range m.EnforcementActions {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintPolicy(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x6a
	}
	if m.Severity != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Scope) > 0 {
		for iNdEx := len(m.Scope) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Scope[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.LifecycleStages) > 0 {
		dAtA5 := make([]byte, len(m.LifecycleStages)*10)
		var j4 int
		for _, num := range m.LifecycleStages {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintPolicy(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Categories) > 0 {
		for iNdEx := len(m.Categories) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Categories[iNdEx])
			copy(dAtA[i:], m.Categories[iNdEx])
			i = encodeVarintPolicy(dAtA, i, uint64(len(m.Categories[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Remediation) > 0 {
		i -= len(m.Remediation)
		copy(dAtA[i:], m.Remediation)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Remediation)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Rationale) > 0 {
		i -= len(m.Rationale)
		copy(dAtA[i:], m.Rationale)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Rationale)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Policy_MitreAttackVectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Policy_MitreAttackVectors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Policy_MitreAttackVectors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Techniques) > 0 {
		for iNdEx := len(m.Techniques) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Techniques[iNdEx])
			copy(dAtA[i:], m.Techniques[iNdEx])
			i = encodeVarintPolicy(dAtA, i, uint64(len(m.Techniques[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Tactic) > 0 {
		i -= len(m.Tactic)
		copy(dAtA[i:], m.Tactic)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Tactic)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicySection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicySection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicySection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PolicyGroups) > 0 {
		for iNdEx := len(m.PolicyGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PolicyGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SectionName) > 0 {
		i -= len(m.SectionName)
		copy(dAtA[i:], m.SectionName)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.SectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicyGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Negate {
		i--
		if m.Negate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.BooleanOperator != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.BooleanOperator))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FieldName) > 0 {
		i -= len(m.FieldName)
		copy(dAtA[i:], m.FieldName)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.FieldName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Policies) > 0 {
		for iNdEx := len(m.Policies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Policies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsDefault {
		i--
		if m.IsDefault {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.EventSource != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.EventSource))
		i--
		dAtA[i] = 0x48
	}
	if m.LastUpdated != nil {
		{
			size, err := m.LastUpdated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Notifiers) > 0 {
		for iNdEx := len(m.Notifiers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Notifiers[iNdEx])
			copy(dAtA[i:], m.Notifiers[iNdEx])
			i = encodeVarintPolicy(dAtA, i, uint64(len(m.Notifiers[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.LifecycleStages) > 0 {
		dAtA8 := make([]byte, len(m.LifecycleStages)*10)
		var j7 int
		for _, num := range m.LifecycleStages {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintPolicy(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x32
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Severity != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Exclusion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Exclusion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Exclusion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Expiration != nil {
		{
			size, err := m.Expiration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Deployment != nil {
		{
			size, err := m.Deployment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Exclusion_Container) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Exclusion_Container) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Exclusion_Container) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ImageName != nil {
		{
			size, err := m.ImageName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *Exclusion_Deployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Exclusion_Deployment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Exclusion_Deployment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Scope != nil {
		{
			size, err := m.Scope.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *Exclusion_Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Exclusion_Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Exclusion_Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExportPoliciesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportPoliciesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportPoliciesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Policies) > 0 {
		for iNdEx := len(m.Policies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Policies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintPolicy(dAtA []byte, offset int, v uint64) int {
	offset -= sovPolicy(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Policy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	l = len(m.Rationale)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	l = len(m.Remediation)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	if len(m.Categories) > 0 {
		for _, s := range m.Categories {
			l = len(s)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if len(m.LifecycleStages) > 0 {
		l = 0
		for _, e := range m.LifecycleStages {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	if len(m.Scope) > 0 {
		for _, e := range m.Scope {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.Severity != 0 {
		n += 1 + sovPolicy(uint64(m.Severity))
	}
	if len(m.EnforcementActions) > 0 {
		l = 0
		for _, e := range m.EnforcementActions {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	if len(m.Notifiers) > 0 {
		for _, s := range m.Notifiers {
			l = len(s)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.LastUpdated != nil {
		l = m.LastUpdated.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	l = len(m.SORTName)
	if l > 0 {
		n += 2 + l + sovPolicy(uint64(l))
	}
	l = len(m.SORTLifecycleStage)
	if l > 0 {
		n += 2 + l + sovPolicy(uint64(l))
	}
	if m.SORTEnforcement {
		n += 3
	}
	l = len(m.PolicyVersion)
	if l > 0 {
		n += 2 + l + sovPolicy(uint64(l))
	}
	if len(m.PolicySections) > 0 {
		for _, e := range m.PolicySections {
			l = e.Size()
			n += 2 + l + sovPolicy(uint64(l))
		}
	}
	if len(m.Exclusions) > 0 {
		for _, e := range m.Exclusions {
			l = e.Size()
			n += 2 + l + sovPolicy(uint64(l))
		}
	}
	if m.EventSource != 0 {
		n += 2 + sovPolicy(uint64(m.EventSource))
	}
	if len(m.MitreAttackVectors) > 0 {
		for _, e := range m.MitreAttackVectors {
			l = e.Size()
			n += 2 + l + sovPolicy(uint64(l))
		}
	}
	if m.CriteriaLocked {
		n += 3
	}
	if m.MitreVectorsLocked {
		n += 3
	}
	if m.IsDefault {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Policy_MitreAttackVectors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tactic)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Techniques) > 0 {
		for _, s := range m.Techniques {
			l = len(s)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicySection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SectionName)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.PolicyGroups) > 0 {
		for _, e := range m.PolicyGroups {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FieldName)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.BooleanOperator != 0 {
		n += 1 + sovPolicy(uint64(m.BooleanOperator))
	}
	if m.Negate {
		n += 2
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Policies) > 0 {
		for _, e := range m.Policies {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Severity != 0 {
		n += 1 + sovPolicy(uint64(m.Severity))
	}
	if m.Disabled {
		n += 2
	}
	if len(m.LifecycleStages) > 0 {
		l = 0
		for _, e := range m.LifecycleStages {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	if len(m.Notifiers) > 0 {
		for _, s := range m.Notifiers {
			l = len(s)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.LastUpdated != nil {
		l = m.LastUpdated.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.EventSource != 0 {
		n += 1 + sovPolicy(uint64(m.EventSource))
	}
	if m.IsDefault {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Exclusion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Deployment != nil {
		l = m.Deployment.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Expiration != nil {
		l = m.Expiration.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Exclusion_Container) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageName != nil {
		l = m.ImageName.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Exclusion_Deployment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Scope != nil {
		l = m.Scope.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Exclusion_Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExportPoliciesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Policies) > 0 {
		for _, e := range m.Policies {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPolicy(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPolicy(x uint64) (n int) {
	return sovPolicy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Policy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Policy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Policy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rationale", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rationale = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remediation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remediation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Categories = append(m.Categories, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v LifecycleStage
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= LifecycleStage(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LifecycleStages = append(m.LifecycleStages, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPolicy
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.LifecycleStages) == 0 {
					m.LifecycleStages = make([]LifecycleStage, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v LifecycleStage
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= LifecycleStage(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LifecycleStages = append(m.LifecycleStages, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LifecycleStages", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = append(m.Scope, &Scope{})
			if err := m.Scope[len(m.Scope)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= Severity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType == 0 {
				var v EnforcementAction
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= EnforcementAction(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EnforcementActions = append(m.EnforcementActions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPolicy
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.EnforcementActions) == 0 {
					m.EnforcementActions = make([]EnforcementAction, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v EnforcementAction
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= EnforcementAction(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EnforcementActions = append(m.EnforcementActions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EnforcementActions", wireType)
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notifiers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notifiers = append(m.Notifiers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdated == nil {
				m.LastUpdated = &types.Timestamp{}
			}
			if err := m.LastUpdated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SORTName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SORTName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SORTLifecycleStage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SORTLifecycleStage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SORTEnforcement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SORTEnforcement = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicySections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicySections = append(m.PolicySections, &PolicySection{})
			if err := m.PolicySections[len(m.PolicySections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclusions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exclusions = append(m.Exclusions, &Exclusion{})
			if err := m.Exclusions[len(m.Exclusions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventSource", wireType)
			}
			m.EventSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventSource |= EventSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MitreAttackVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MitreAttackVectors = append(m.MitreAttackVectors, &Policy_MitreAttackVectors{})
			if err := m.MitreAttackVectors[len(m.MitreAttackVectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CriteriaLocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CriteriaLocked = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MitreVectorsLocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MitreVectorsLocked = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDefault = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Policy_MitreAttackVectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MitreAttackVectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MitreAttackVectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tactic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tactic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Techniques", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Techniques = append(m.Techniques, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicySection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicySection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicySection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyGroups = append(m.PolicyGroups, &PolicyGroup{})
			if err := m.PolicyGroups[len(m.PolicyGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BooleanOperator", wireType)
			}
			m.BooleanOperator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BooleanOperator |= BooleanOperator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Negate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Negate = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &PolicyValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policies = append(m.Policies, &Policy{})
			if err := m.Policies[len(m.Policies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= Severity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 6:
			if wireType == 0 {
				var v LifecycleStage
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= LifecycleStage(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LifecycleStages = append(m.LifecycleStages, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPolicy
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.LifecycleStages) == 0 {
					m.LifecycleStages = make([]LifecycleStage, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v LifecycleStage
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= LifecycleStage(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LifecycleStages = append(m.LifecycleStages, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LifecycleStages", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notifiers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notifiers = append(m.Notifiers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdated == nil {
				m.LastUpdated = &types.Timestamp{}
			}
			if err := m.LastUpdated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventSource", wireType)
			}
			m.EventSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventSource |= EventSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDefault = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Exclusion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Exclusion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Exclusion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deployment == nil {
				m.Deployment = &Exclusion_Deployment{}
			}
			if err := m.Deployment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = &types.Timestamp{}
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &Exclusion_Image{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Exclusion_Container) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageName == nil {
				m.ImageName = &ImageName{}
			}
			if err := m.ImageName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Exclusion_Deployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scope == nil {
				m.Scope = &Scope{}
			}
			if err := m.Scope.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Exclusion_Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportPoliciesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportPoliciesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportPoliciesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policies = append(m.Policies, &Policy{})
			if err := m.Policies[len(m.Policies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPolicy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPolicy
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPolicy
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPolicy
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPolicy        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPolicy          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPolicy = fmt.Errorf("proto: unexpected end of group")
)
