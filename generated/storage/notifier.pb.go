// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/notifier.proto

package storage

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Email_AuthMethod int32

const (
	Email_DISABLED Email_AuthMethod = 0
	Email_PLAIN    Email_AuthMethod = 1
	Email_LOGIN    Email_AuthMethod = 2
)

var Email_AuthMethod_name = map[int32]string{
	0: "DISABLED",
	1: "PLAIN",
	2: "LOGIN",
}

var Email_AuthMethod_value = map[string]int32{
	"DISABLED": 0,
	"PLAIN":    1,
	"LOGIN":    2,
}

func (x Email_AuthMethod) String() string {
	return proto.EnumName(Email_AuthMethod_name, int32(x))
}

func (Email_AuthMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{4, 0}
}

type Syslog_LocalFacility int32

const (
	Syslog_LOCAL0 Syslog_LocalFacility = 0
	Syslog_LOCAL1 Syslog_LocalFacility = 1
	Syslog_LOCAL2 Syslog_LocalFacility = 2
	Syslog_LOCAL3 Syslog_LocalFacility = 3
	Syslog_LOCAL4 Syslog_LocalFacility = 4
	Syslog_LOCAL5 Syslog_LocalFacility = 5
	Syslog_LOCAL6 Syslog_LocalFacility = 6
	Syslog_LOCAL7 Syslog_LocalFacility = 7
)

var Syslog_LocalFacility_name = map[int32]string{
	0: "LOCAL0",
	1: "LOCAL1",
	2: "LOCAL2",
	3: "LOCAL3",
	4: "LOCAL4",
	5: "LOCAL5",
	6: "LOCAL6",
	7: "LOCAL7",
}

var Syslog_LocalFacility_value = map[string]int32{
	"LOCAL0": 0,
	"LOCAL1": 1,
	"LOCAL2": 2,
	"LOCAL3": 3,
	"LOCAL4": 4,
	"LOCAL5": 5,
	"LOCAL6": 6,
	"LOCAL7": 7,
}

func (x Syslog_LocalFacility) String() string {
	return proto.EnumName(Syslog_LocalFacility_name, int32(x))
}

func (Syslog_LocalFacility) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{9, 0}
}

type Syslog_MessageFormat int32

const (
	Syslog_LEGACY Syslog_MessageFormat = 0
	Syslog_CEF    Syslog_MessageFormat = 1
)

var Syslog_MessageFormat_name = map[int32]string{
	0: "LEGACY",
	1: "CEF",
}

var Syslog_MessageFormat_value = map[string]int32{
	"LEGACY": 0,
	"CEF":    1,
}

func (x Syslog_MessageFormat) String() string {
	return proto.EnumName(Syslog_MessageFormat_name, int32(x))
}

func (Syslog_MessageFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{9, 1}
}

// Next Tag: 19
type Notifier struct {
	Id           string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" sql:"pk"`
	Name         string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" sql:"unique"`
	Type         string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	UiEndpoint   string `protobuf:"bytes,4,opt,name=ui_endpoint,json=uiEndpoint,proto3" json:"ui_endpoint,omitempty"`
	LabelKey     string `protobuf:"bytes,8,opt,name=label_key,json=labelKey,proto3" json:"label_key,omitempty"`
	LabelDefault string `protobuf:"bytes,9,opt,name=label_default,json=labelDefault,proto3" json:"label_default,omitempty"`
	// Types that are valid to be assigned to Config:
	//	*Notifier_Jira
	//	*Notifier_Email
	//	*Notifier_Cscc
	//	*Notifier_Splunk
	//	*Notifier_Pagerduty
	//	*Notifier_Generic
	//	*Notifier_Sumologic
	//	*Notifier_AwsSecurityHub
	//	*Notifier_Syslog
	Config               isNotifier_Config `protobuf_oneof:"config"`
	Traits               *Traits           `protobuf:"bytes,50,opt,name=traits,proto3" json:"traits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Notifier) Reset()         { *m = Notifier{} }
func (m *Notifier) String() string { return proto.CompactTextString(m) }
func (*Notifier) ProtoMessage()    {}
func (*Notifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{0}
}
func (m *Notifier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Notifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Notifier.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Notifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notifier.Merge(m, src)
}
func (m *Notifier) XXX_Size() int {
	return m.Size()
}
func (m *Notifier) XXX_DiscardUnknown() {
	xxx_messageInfo_Notifier.DiscardUnknown(m)
}

var xxx_messageInfo_Notifier proto.InternalMessageInfo

type isNotifier_Config interface {
	isNotifier_Config()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isNotifier_Config
}

type Notifier_Jira struct {
	Jira *Jira `protobuf:"bytes,10,opt,name=jira,proto3,oneof" json:"jira,omitempty"`
}
type Notifier_Email struct {
	Email *Email `protobuf:"bytes,11,opt,name=email,proto3,oneof" json:"email,omitempty"`
}
type Notifier_Cscc struct {
	Cscc *CSCC `protobuf:"bytes,12,opt,name=cscc,proto3,oneof" json:"cscc,omitempty"`
}
type Notifier_Splunk struct {
	Splunk *Splunk `protobuf:"bytes,13,opt,name=splunk,proto3,oneof" json:"splunk,omitempty"`
}
type Notifier_Pagerduty struct {
	Pagerduty *PagerDuty `protobuf:"bytes,14,opt,name=pagerduty,proto3,oneof" json:"pagerduty,omitempty"`
}
type Notifier_Generic struct {
	Generic *Generic `protobuf:"bytes,15,opt,name=generic,proto3,oneof" json:"generic,omitempty"`
}
type Notifier_Sumologic struct {
	Sumologic *SumoLogic `protobuf:"bytes,16,opt,name=sumologic,proto3,oneof" json:"sumologic,omitempty"`
}
type Notifier_AwsSecurityHub struct {
	AwsSecurityHub *AWSSecurityHub `protobuf:"bytes,17,opt,name=aws_security_hub,json=awsSecurityHub,proto3,oneof" json:"aws_security_hub,omitempty"`
}
type Notifier_Syslog struct {
	Syslog *Syslog `protobuf:"bytes,18,opt,name=syslog,proto3,oneof" json:"syslog,omitempty"`
}

func (*Notifier_Jira) isNotifier_Config() {}
func (m *Notifier_Jira) Clone() isNotifier_Config {
	if m == nil {
		return nil
	}
	cloned := new(Notifier_Jira)
	*cloned = *m

	cloned.Jira = m.Jira.Clone()
	return cloned
}
func (*Notifier_Email) isNotifier_Config() {}
func (m *Notifier_Email) Clone() isNotifier_Config {
	if m == nil {
		return nil
	}
	cloned := new(Notifier_Email)
	*cloned = *m

	cloned.Email = m.Email.Clone()
	return cloned
}
func (*Notifier_Cscc) isNotifier_Config() {}
func (m *Notifier_Cscc) Clone() isNotifier_Config {
	if m == nil {
		return nil
	}
	cloned := new(Notifier_Cscc)
	*cloned = *m

	cloned.Cscc = m.Cscc.Clone()
	return cloned
}
func (*Notifier_Splunk) isNotifier_Config() {}
func (m *Notifier_Splunk) Clone() isNotifier_Config {
	if m == nil {
		return nil
	}
	cloned := new(Notifier_Splunk)
	*cloned = *m

	cloned.Splunk = m.Splunk.Clone()
	return cloned
}
func (*Notifier_Pagerduty) isNotifier_Config() {}
func (m *Notifier_Pagerduty) Clone() isNotifier_Config {
	if m == nil {
		return nil
	}
	cloned := new(Notifier_Pagerduty)
	*cloned = *m

	cloned.Pagerduty = m.Pagerduty.Clone()
	return cloned
}
func (*Notifier_Generic) isNotifier_Config() {}
func (m *Notifier_Generic) Clone() isNotifier_Config {
	if m == nil {
		return nil
	}
	cloned := new(Notifier_Generic)
	*cloned = *m

	cloned.Generic = m.Generic.Clone()
	return cloned
}
func (*Notifier_Sumologic) isNotifier_Config() {}
func (m *Notifier_Sumologic) Clone() isNotifier_Config {
	if m == nil {
		return nil
	}
	cloned := new(Notifier_Sumologic)
	*cloned = *m

	cloned.Sumologic = m.Sumologic.Clone()
	return cloned
}
func (*Notifier_AwsSecurityHub) isNotifier_Config() {}
func (m *Notifier_AwsSecurityHub) Clone() isNotifier_Config {
	if m == nil {
		return nil
	}
	cloned := new(Notifier_AwsSecurityHub)
	*cloned = *m

	cloned.AwsSecurityHub = m.AwsSecurityHub.Clone()
	return cloned
}
func (*Notifier_Syslog) isNotifier_Config() {}
func (m *Notifier_Syslog) Clone() isNotifier_Config {
	if m == nil {
		return nil
	}
	cloned := new(Notifier_Syslog)
	*cloned = *m

	cloned.Syslog = m.Syslog.Clone()
	return cloned
}

func (m *Notifier) GetConfig() isNotifier_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Notifier) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Notifier) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Notifier) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Notifier) GetUiEndpoint() string {
	if m != nil {
		return m.UiEndpoint
	}
	return ""
}

func (m *Notifier) GetLabelKey() string {
	if m != nil {
		return m.LabelKey
	}
	return ""
}

func (m *Notifier) GetLabelDefault() string {
	if m != nil {
		return m.LabelDefault
	}
	return ""
}

func (m *Notifier) GetJira() *Jira {
	if x, ok := m.GetConfig().(*Notifier_Jira); ok {
		return x.Jira
	}
	return nil
}

func (m *Notifier) GetEmail() *Email {
	if x, ok := m.GetConfig().(*Notifier_Email); ok {
		return x.Email
	}
	return nil
}

func (m *Notifier) GetCscc() *CSCC {
	if x, ok := m.GetConfig().(*Notifier_Cscc); ok {
		return x.Cscc
	}
	return nil
}

func (m *Notifier) GetSplunk() *Splunk {
	if x, ok := m.GetConfig().(*Notifier_Splunk); ok {
		return x.Splunk
	}
	return nil
}

func (m *Notifier) GetPagerduty() *PagerDuty {
	if x, ok := m.GetConfig().(*Notifier_Pagerduty); ok {
		return x.Pagerduty
	}
	return nil
}

func (m *Notifier) GetGeneric() *Generic {
	if x, ok := m.GetConfig().(*Notifier_Generic); ok {
		return x.Generic
	}
	return nil
}

func (m *Notifier) GetSumologic() *SumoLogic {
	if x, ok := m.GetConfig().(*Notifier_Sumologic); ok {
		return x.Sumologic
	}
	return nil
}

func (m *Notifier) GetAwsSecurityHub() *AWSSecurityHub {
	if x, ok := m.GetConfig().(*Notifier_AwsSecurityHub); ok {
		return x.AwsSecurityHub
	}
	return nil
}

func (m *Notifier) GetSyslog() *Syslog {
	if x, ok := m.GetConfig().(*Notifier_Syslog); ok {
		return x.Syslog
	}
	return nil
}

func (m *Notifier) GetTraits() *Traits {
	if m != nil {
		return m.Traits
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Notifier) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Notifier_Jira)(nil),
		(*Notifier_Email)(nil),
		(*Notifier_Cscc)(nil),
		(*Notifier_Splunk)(nil),
		(*Notifier_Pagerduty)(nil),
		(*Notifier_Generic)(nil),
		(*Notifier_Sumologic)(nil),
		(*Notifier_AwsSecurityHub)(nil),
		(*Notifier_Syslog)(nil),
	}
}

func (m *Notifier) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Notifier) Clone() *Notifier {
	if m == nil {
		return nil
	}
	cloned := new(Notifier)
	*cloned = *m

	if m.Config != nil {
		cloned.Config = m.Config.Clone()
	}
	cloned.Traits = m.Traits.Clone()
	return cloned
}

type AWSSecurityHub struct {
	Region               string                      `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	Credentials          *AWSSecurityHub_Credentials `protobuf:"bytes,2,opt,name=credentials,proto3" json:"credentials,omitempty"`
	AccountId            string                      `protobuf:"bytes,3,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *AWSSecurityHub) Reset()         { *m = AWSSecurityHub{} }
func (m *AWSSecurityHub) String() string { return proto.CompactTextString(m) }
func (*AWSSecurityHub) ProtoMessage()    {}
func (*AWSSecurityHub) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{1}
}
func (m *AWSSecurityHub) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSSecurityHub) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AWSSecurityHub.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AWSSecurityHub) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSSecurityHub.Merge(m, src)
}
func (m *AWSSecurityHub) XXX_Size() int {
	return m.Size()
}
func (m *AWSSecurityHub) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSSecurityHub.DiscardUnknown(m)
}

var xxx_messageInfo_AWSSecurityHub proto.InternalMessageInfo

func (m *AWSSecurityHub) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *AWSSecurityHub) GetCredentials() *AWSSecurityHub_Credentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *AWSSecurityHub) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *AWSSecurityHub) MessageClone() proto.Message {
	return m.Clone()
}
func (m *AWSSecurityHub) Clone() *AWSSecurityHub {
	if m == nil {
		return nil
	}
	cloned := new(AWSSecurityHub)
	*cloned = *m

	cloned.Credentials = m.Credentials.Clone()
	return cloned
}

type AWSSecurityHub_Credentials struct {
	AccessKeyId          string   `protobuf:"bytes,1,opt,name=access_key_id,json=accessKeyId,proto3" json:"access_key_id,omitempty" scrub:"always"`
	SecretAccessKey      string   `protobuf:"bytes,2,opt,name=secret_access_key,json=secretAccessKey,proto3" json:"secret_access_key,omitempty" scrub:"always"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AWSSecurityHub_Credentials) Reset()         { *m = AWSSecurityHub_Credentials{} }
func (m *AWSSecurityHub_Credentials) String() string { return proto.CompactTextString(m) }
func (*AWSSecurityHub_Credentials) ProtoMessage()    {}
func (*AWSSecurityHub_Credentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{1, 0}
}
func (m *AWSSecurityHub_Credentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSSecurityHub_Credentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AWSSecurityHub_Credentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AWSSecurityHub_Credentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSSecurityHub_Credentials.Merge(m, src)
}
func (m *AWSSecurityHub_Credentials) XXX_Size() int {
	return m.Size()
}
func (m *AWSSecurityHub_Credentials) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSSecurityHub_Credentials.DiscardUnknown(m)
}

var xxx_messageInfo_AWSSecurityHub_Credentials proto.InternalMessageInfo

func (m *AWSSecurityHub_Credentials) GetAccessKeyId() string {
	if m != nil {
		return m.AccessKeyId
	}
	return ""
}

func (m *AWSSecurityHub_Credentials) GetSecretAccessKey() string {
	if m != nil {
		return m.SecretAccessKey
	}
	return ""
}

func (m *AWSSecurityHub_Credentials) MessageClone() proto.Message {
	return m.Clone()
}
func (m *AWSSecurityHub_Credentials) Clone() *AWSSecurityHub_Credentials {
	if m == nil {
		return nil
	}
	cloned := new(AWSSecurityHub_Credentials)
	*cloned = *m

	return cloned
}

type CSCC struct {
	// The service account for the integration. The server will mask the value of this credential in responses and logs.
	ServiceAccount       string   `protobuf:"bytes,1,opt,name=service_account,json=serviceAccount,proto3" json:"service_account,omitempty" scrub:"always"`
	SourceId             string   `protobuf:"bytes,4,opt,name=source_id,json=sourceId,proto3" json:"source_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSCC) Reset()         { *m = CSCC{} }
func (m *CSCC) String() string { return proto.CompactTextString(m) }
func (*CSCC) ProtoMessage()    {}
func (*CSCC) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{2}
}
func (m *CSCC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSCC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSCC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSCC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSCC.Merge(m, src)
}
func (m *CSCC) XXX_Size() int {
	return m.Size()
}
func (m *CSCC) XXX_DiscardUnknown() {
	xxx_messageInfo_CSCC.DiscardUnknown(m)
}

var xxx_messageInfo_CSCC proto.InternalMessageInfo

func (m *CSCC) GetServiceAccount() string {
	if m != nil {
		return m.ServiceAccount
	}
	return ""
}

func (m *CSCC) GetSourceId() string {
	if m != nil {
		return m.SourceId
	}
	return ""
}

func (m *CSCC) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CSCC) Clone() *CSCC {
	if m == nil {
		return nil
	}
	cloned := new(CSCC)
	*cloned = *m

	return cloned
}

type Jira struct {
	Url      string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty" scrub:"dependent" validate:"nolocalendpoint"`
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty" scrub:"dependent"`
	// The password for the integration. The server will mask the value of this credential in responses and logs.
	Password             string                  `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty" scrub:"always"`
	IssueType            string                  `protobuf:"bytes,4,opt,name=issue_type,json=issueType,proto3" json:"issue_type,omitempty"`
	PriorityMappings     []*Jira_PriorityMapping `protobuf:"bytes,5,rep,name=priority_mappings,json=priorityMappings,proto3" json:"priority_mappings,omitempty"`
	DefaultFieldsJson    string                  `protobuf:"bytes,6,opt,name=default_fields_json,json=defaultFieldsJson,proto3" json:"default_fields_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Jira) Reset()         { *m = Jira{} }
func (m *Jira) String() string { return proto.CompactTextString(m) }
func (*Jira) ProtoMessage()    {}
func (*Jira) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{3}
}
func (m *Jira) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Jira) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Jira.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Jira) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Jira.Merge(m, src)
}
func (m *Jira) XXX_Size() int {
	return m.Size()
}
func (m *Jira) XXX_DiscardUnknown() {
	xxx_messageInfo_Jira.DiscardUnknown(m)
}

var xxx_messageInfo_Jira proto.InternalMessageInfo

func (m *Jira) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Jira) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Jira) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Jira) GetIssueType() string {
	if m != nil {
		return m.IssueType
	}
	return ""
}

func (m *Jira) GetPriorityMappings() []*Jira_PriorityMapping {
	if m != nil {
		return m.PriorityMappings
	}
	return nil
}

func (m *Jira) GetDefaultFieldsJson() string {
	if m != nil {
		return m.DefaultFieldsJson
	}
	return ""
}

func (m *Jira) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Jira) Clone() *Jira {
	if m == nil {
		return nil
	}
	cloned := new(Jira)
	*cloned = *m

	if m.PriorityMappings != nil {
		cloned.PriorityMappings = make([]*Jira_PriorityMapping, len(m.PriorityMappings))
		for idx, v := range m.PriorityMappings {
			cloned.PriorityMappings[idx] = v.Clone()
		}
	}
	return cloned
}

type Jira_PriorityMapping struct {
	Severity             Severity `protobuf:"varint,1,opt,name=severity,proto3,enum=storage.Severity" json:"severity,omitempty"`
	PriorityName         string   `protobuf:"bytes,2,opt,name=priority_name,json=priorityName,proto3" json:"priority_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Jira_PriorityMapping) Reset()         { *m = Jira_PriorityMapping{} }
func (m *Jira_PriorityMapping) String() string { return proto.CompactTextString(m) }
func (*Jira_PriorityMapping) ProtoMessage()    {}
func (*Jira_PriorityMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{3, 0}
}
func (m *Jira_PriorityMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Jira_PriorityMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Jira_PriorityMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Jira_PriorityMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Jira_PriorityMapping.Merge(m, src)
}
func (m *Jira_PriorityMapping) XXX_Size() int {
	return m.Size()
}
func (m *Jira_PriorityMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_Jira_PriorityMapping.DiscardUnknown(m)
}

var xxx_messageInfo_Jira_PriorityMapping proto.InternalMessageInfo

func (m *Jira_PriorityMapping) GetSeverity() Severity {
	if m != nil {
		return m.Severity
	}
	return Severity_UNSET_SEVERITY
}

func (m *Jira_PriorityMapping) GetPriorityName() string {
	if m != nil {
		return m.PriorityName
	}
	return ""
}

func (m *Jira_PriorityMapping) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Jira_PriorityMapping) Clone() *Jira_PriorityMapping {
	if m == nil {
		return nil
	}
	cloned := new(Jira_PriorityMapping)
	*cloned = *m

	return cloned
}

type Email struct {
	Server   string `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty" scrub:"dependent"`
	Sender   string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty" scrub:"dependent"`
	// The password for the integration. The server will mask the value of this credential in responses and logs.
	Password              string           `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty" scrub:"always"`
	DisableTLS            bool             `protobuf:"varint,5,opt,name=disableTLS,proto3" json:"disableTLS,omitempty"`
	DEPRECATEDUseStartTLS bool             `protobuf:"varint,6,opt,name=DEPRECATED_useStartTLS,json=DEPRECATEDUseStartTLS,proto3" json:"DEPRECATED_useStartTLS,omitempty"`
	From                  string           `protobuf:"bytes,7,opt,name=from,proto3" json:"from,omitempty"`
	StartTLSAuthMethod    Email_AuthMethod `protobuf:"varint,8,opt,name=startTLSAuthMethod,proto3,enum=storage.Email_AuthMethod" json:"startTLSAuthMethod,omitempty"`
	// Set to true to allow unauthenticated SMTP
	AllowUnauthenticatedSmtp bool     `protobuf:"varint,9,opt,name=allow_unauthenticated_smtp,json=allowUnauthenticatedSmtp,proto3" json:"allow_unauthenticated_smtp,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *Email) Reset()         { *m = Email{} }
func (m *Email) String() string { return proto.CompactTextString(m) }
func (*Email) ProtoMessage()    {}
func (*Email) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{4}
}
func (m *Email) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Email) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Email.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Email) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Email.Merge(m, src)
}
func (m *Email) XXX_Size() int {
	return m.Size()
}
func (m *Email) XXX_DiscardUnknown() {
	xxx_messageInfo_Email.DiscardUnknown(m)
}

var xxx_messageInfo_Email proto.InternalMessageInfo

func (m *Email) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *Email) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *Email) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Email) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Email) GetDisableTLS() bool {
	if m != nil {
		return m.DisableTLS
	}
	return false
}

func (m *Email) GetDEPRECATEDUseStartTLS() bool {
	if m != nil {
		return m.DEPRECATEDUseStartTLS
	}
	return false
}

func (m *Email) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Email) GetStartTLSAuthMethod() Email_AuthMethod {
	if m != nil {
		return m.StartTLSAuthMethod
	}
	return Email_DISABLED
}

func (m *Email) GetAllowUnauthenticatedSmtp() bool {
	if m != nil {
		return m.AllowUnauthenticatedSmtp
	}
	return false
}

func (m *Email) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Email) Clone() *Email {
	if m == nil {
		return nil
	}
	cloned := new(Email)
	*cloned = *m

	return cloned
}

type Splunk struct {
	// The HTTP token for the integration. The server will mask the value of this credential in responses and logs.
	HttpToken           string `protobuf:"bytes,1,opt,name=http_token,json=httpToken,proto3" json:"http_token,omitempty" scrub:"always"`
	HttpEndpoint        string `protobuf:"bytes,2,opt,name=http_endpoint,json=httpEndpoint,proto3" json:"http_endpoint,omitempty" scrub:"dependent" validate:"nolocalendpoint"`
	Insecure            bool   `protobuf:"varint,3,opt,name=insecure,proto3" json:"insecure,omitempty"`
	Truncate            int64  `protobuf:"varint,4,opt,name=truncate,proto3" json:"truncate,omitempty"`
	AuditLoggingEnabled bool   `protobuf:"varint,5,opt,name=audit_logging_enabled,json=auditLoggingEnabled,proto3" json:"audit_logging_enabled,omitempty"`
	// Types that are valid to be assigned to DerivedSourceTypeDeprecated:
	//	*Splunk_DerivedSourceType
	DerivedSourceTypeDeprecated isSplunk_DerivedSourceTypeDeprecated `protobuf_oneof:"derived_source_type_deprecated"`
	SourceTypes                 map[string]string                    `protobuf:"bytes,7,rep,name=source_types,json=sourceTypes,proto3" json:"source_types,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral        struct{}                             `json:"-"`
	XXX_unrecognized            []byte                               `json:"-"`
	XXX_sizecache               int32                                `json:"-"`
}

func (m *Splunk) Reset()         { *m = Splunk{} }
func (m *Splunk) String() string { return proto.CompactTextString(m) }
func (*Splunk) ProtoMessage()    {}
func (*Splunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{5}
}
func (m *Splunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Splunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Splunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Splunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Splunk.Merge(m, src)
}
func (m *Splunk) XXX_Size() int {
	return m.Size()
}
func (m *Splunk) XXX_DiscardUnknown() {
	xxx_messageInfo_Splunk.DiscardUnknown(m)
}

var xxx_messageInfo_Splunk proto.InternalMessageInfo

type isSplunk_DerivedSourceTypeDeprecated interface {
	isSplunk_DerivedSourceTypeDeprecated()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isSplunk_DerivedSourceTypeDeprecated
}

type Splunk_DerivedSourceType struct {
	DerivedSourceType bool `protobuf:"varint,6,opt,name=derived_source_type,json=derivedSourceType,proto3,oneof" json:"derived_source_type,omitempty"`
}

func (*Splunk_DerivedSourceType) isSplunk_DerivedSourceTypeDeprecated() {}
func (m *Splunk_DerivedSourceType) Clone() isSplunk_DerivedSourceTypeDeprecated {
	if m == nil {
		return nil
	}
	cloned := new(Splunk_DerivedSourceType)
	*cloned = *m

	return cloned
}

func (m *Splunk) GetDerivedSourceTypeDeprecated() isSplunk_DerivedSourceTypeDeprecated {
	if m != nil {
		return m.DerivedSourceTypeDeprecated
	}
	return nil
}

func (m *Splunk) GetHttpToken() string {
	if m != nil {
		return m.HttpToken
	}
	return ""
}

func (m *Splunk) GetHttpEndpoint() string {
	if m != nil {
		return m.HttpEndpoint
	}
	return ""
}

func (m *Splunk) GetInsecure() bool {
	if m != nil {
		return m.Insecure
	}
	return false
}

func (m *Splunk) GetTruncate() int64 {
	if m != nil {
		return m.Truncate
	}
	return 0
}

func (m *Splunk) GetAuditLoggingEnabled() bool {
	if m != nil {
		return m.AuditLoggingEnabled
	}
	return false
}

// Deprecated: Do not use.
func (m *Splunk) GetDerivedSourceType() bool {
	if x, ok := m.GetDerivedSourceTypeDeprecated().(*Splunk_DerivedSourceType); ok {
		return x.DerivedSourceType
	}
	return false
}

func (m *Splunk) GetSourceTypes() map[string]string {
	if m != nil {
		return m.SourceTypes
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Splunk) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Splunk_DerivedSourceType)(nil),
	}
}

func (m *Splunk) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Splunk) Clone() *Splunk {
	if m == nil {
		return nil
	}
	cloned := new(Splunk)
	*cloned = *m

	if m.DerivedSourceTypeDeprecated != nil {
		cloned.DerivedSourceTypeDeprecated = m.DerivedSourceTypeDeprecated.Clone()
	}
	if m.SourceTypes != nil {
		cloned.SourceTypes = make(map[string]string, len(m.SourceTypes))
		for k, v := range m.SourceTypes {
			cloned.SourceTypes[k] = v
		}
	}
	return cloned
}

type PagerDuty struct {
	// The API key for the integration. The server will mask the value of this credential in responses and logs.
	ApiKey               string   `protobuf:"bytes,1,opt,name=api_key,json=apiKey,proto3" json:"api_key,omitempty" scrub:"always"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PagerDuty) Reset()         { *m = PagerDuty{} }
func (m *PagerDuty) String() string { return proto.CompactTextString(m) }
func (*PagerDuty) ProtoMessage()    {}
func (*PagerDuty) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{6}
}
func (m *PagerDuty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PagerDuty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PagerDuty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PagerDuty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PagerDuty.Merge(m, src)
}
func (m *PagerDuty) XXX_Size() int {
	return m.Size()
}
func (m *PagerDuty) XXX_DiscardUnknown() {
	xxx_messageInfo_PagerDuty.DiscardUnknown(m)
}

var xxx_messageInfo_PagerDuty proto.InternalMessageInfo

func (m *PagerDuty) GetApiKey() string {
	if m != nil {
		return m.ApiKey
	}
	return ""
}

func (m *PagerDuty) MessageClone() proto.Message {
	return m.Clone()
}
func (m *PagerDuty) Clone() *PagerDuty {
	if m == nil {
		return nil
	}
	cloned := new(PagerDuty)
	*cloned = *m

	return cloned
}

type Generic struct {
	Endpoint      string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty" scrub:"dependent" validate:"nolocalendpoint"`
	SkipTLSVerify bool   `protobuf:"varint,2,opt,name=skipTLSVerify,proto3" json:"skipTLSVerify,omitempty"`
	CaCert        string `protobuf:"bytes,3,opt,name=ca_cert,json=caCert,proto3" json:"ca_cert,omitempty"`
	Username      string `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty" scrub:"dependent"`
	// The password for the integration. The server will mask the value of this credential in responses and logs.
	Password             string          `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty" scrub:"always"`
	Headers              []*KeyValuePair `protobuf:"bytes,6,rep,name=headers,proto3" json:"headers,omitempty"`
	ExtraFields          []*KeyValuePair `protobuf:"bytes,7,rep,name=extra_fields,json=extraFields,proto3" json:"extra_fields,omitempty"`
	AuditLoggingEnabled  bool            `protobuf:"varint,8,opt,name=audit_logging_enabled,json=auditLoggingEnabled,proto3" json:"audit_logging_enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Generic) Reset()         { *m = Generic{} }
func (m *Generic) String() string { return proto.CompactTextString(m) }
func (*Generic) ProtoMessage()    {}
func (*Generic) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{7}
}
func (m *Generic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Generic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Generic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Generic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Generic.Merge(m, src)
}
func (m *Generic) XXX_Size() int {
	return m.Size()
}
func (m *Generic) XXX_DiscardUnknown() {
	xxx_messageInfo_Generic.DiscardUnknown(m)
}

var xxx_messageInfo_Generic proto.InternalMessageInfo

func (m *Generic) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *Generic) GetSkipTLSVerify() bool {
	if m != nil {
		return m.SkipTLSVerify
	}
	return false
}

func (m *Generic) GetCaCert() string {
	if m != nil {
		return m.CaCert
	}
	return ""
}

func (m *Generic) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Generic) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Generic) GetHeaders() []*KeyValuePair {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *Generic) GetExtraFields() []*KeyValuePair {
	if m != nil {
		return m.ExtraFields
	}
	return nil
}

func (m *Generic) GetAuditLoggingEnabled() bool {
	if m != nil {
		return m.AuditLoggingEnabled
	}
	return false
}

func (m *Generic) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Generic) Clone() *Generic {
	if m == nil {
		return nil
	}
	cloned := new(Generic)
	*cloned = *m

	if m.Headers != nil {
		cloned.Headers = make([]*KeyValuePair, len(m.Headers))
		for idx, v := range m.Headers {
			cloned.Headers[idx] = v.Clone()
		}
	}
	if m.ExtraFields != nil {
		cloned.ExtraFields = make([]*KeyValuePair, len(m.ExtraFields))
		for idx, v := range m.ExtraFields {
			cloned.ExtraFields[idx] = v.Clone()
		}
	}
	return cloned
}

type SumoLogic struct {
	HttpSourceAddress    string   `protobuf:"bytes,1,opt,name=http_source_address,json=httpSourceAddress,proto3" json:"http_source_address,omitempty" validate:"nolocalendpoint"`
	SkipTLSVerify        bool     `protobuf:"varint,2,opt,name=skipTLSVerify,proto3" json:"skipTLSVerify,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SumoLogic) Reset()         { *m = SumoLogic{} }
func (m *SumoLogic) String() string { return proto.CompactTextString(m) }
func (*SumoLogic) ProtoMessage()    {}
func (*SumoLogic) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{8}
}
func (m *SumoLogic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SumoLogic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SumoLogic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SumoLogic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SumoLogic.Merge(m, src)
}
func (m *SumoLogic) XXX_Size() int {
	return m.Size()
}
func (m *SumoLogic) XXX_DiscardUnknown() {
	xxx_messageInfo_SumoLogic.DiscardUnknown(m)
}

var xxx_messageInfo_SumoLogic proto.InternalMessageInfo

func (m *SumoLogic) GetHttpSourceAddress() string {
	if m != nil {
		return m.HttpSourceAddress
	}
	return ""
}

func (m *SumoLogic) GetSkipTLSVerify() bool {
	if m != nil {
		return m.SkipTLSVerify
	}
	return false
}

func (m *SumoLogic) MessageClone() proto.Message {
	return m.Clone()
}
func (m *SumoLogic) Clone() *SumoLogic {
	if m == nil {
		return nil
	}
	cloned := new(SumoLogic)
	*cloned = *m

	return cloned
}

type Syslog struct {
	LocalFacility Syslog_LocalFacility `protobuf:"varint,1,opt,name=local_facility,json=localFacility,proto3,enum=storage.Syslog_LocalFacility" json:"local_facility,omitempty"`
	// Eventually this will support TCP, UDP, and local endpoints
	//
	// Types that are valid to be assigned to Endpoint:
	//
	//	*Syslog_TcpConfig
	Endpoint             isSyslog_Endpoint    `protobuf_oneof:"endpoint"`
	ExtraFields          []*KeyValuePair      `protobuf:"bytes,3,rep,name=extra_fields,json=extraFields,proto3" json:"extra_fields,omitempty"`
	MessageFormat        Syslog_MessageFormat `protobuf:"varint,4,opt,name=message_format,json=messageFormat,proto3,enum=storage.Syslog_MessageFormat" json:"message_format,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Syslog) Reset()         { *m = Syslog{} }
func (m *Syslog) String() string { return proto.CompactTextString(m) }
func (*Syslog) ProtoMessage()    {}
func (*Syslog) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{9}
}
func (m *Syslog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Syslog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Syslog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Syslog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Syslog.Merge(m, src)
}
func (m *Syslog) XXX_Size() int {
	return m.Size()
}
func (m *Syslog) XXX_DiscardUnknown() {
	xxx_messageInfo_Syslog.DiscardUnknown(m)
}

var xxx_messageInfo_Syslog proto.InternalMessageInfo

type isSyslog_Endpoint interface {
	isSyslog_Endpoint()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isSyslog_Endpoint
}

type Syslog_TcpConfig struct {
	TcpConfig *Syslog_TCPConfig `protobuf:"bytes,2,opt,name=tcp_config,json=tcpConfig,proto3,oneof" json:"tcp_config,omitempty"`
}

func (*Syslog_TcpConfig) isSyslog_Endpoint() {}
func (m *Syslog_TcpConfig) Clone() isSyslog_Endpoint {
	if m == nil {
		return nil
	}
	cloned := new(Syslog_TcpConfig)
	*cloned = *m

	cloned.TcpConfig = m.TcpConfig.Clone()
	return cloned
}

func (m *Syslog) GetEndpoint() isSyslog_Endpoint {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

func (m *Syslog) GetLocalFacility() Syslog_LocalFacility {
	if m != nil {
		return m.LocalFacility
	}
	return Syslog_LOCAL0
}

func (m *Syslog) GetTcpConfig() *Syslog_TCPConfig {
	if x, ok := m.GetEndpoint().(*Syslog_TcpConfig); ok {
		return x.TcpConfig
	}
	return nil
}

func (m *Syslog) GetExtraFields() []*KeyValuePair {
	if m != nil {
		return m.ExtraFields
	}
	return nil
}

func (m *Syslog) GetMessageFormat() Syslog_MessageFormat {
	if m != nil {
		return m.MessageFormat
	}
	return Syslog_LEGACY
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Syslog) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Syslog_TcpConfig)(nil),
	}
}

func (m *Syslog) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Syslog) Clone() *Syslog {
	if m == nil {
		return nil
	}
	cloned := new(Syslog)
	*cloned = *m

	if m.Endpoint != nil {
		cloned.Endpoint = m.Endpoint.Clone()
	}
	if m.ExtraFields != nil {
		cloned.ExtraFields = make([]*KeyValuePair, len(m.ExtraFields))
		for idx, v := range m.ExtraFields {
			cloned.ExtraFields[idx] = v.Clone()
		}
	}
	return cloned
}

type Syslog_TCPConfig struct {
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty" scrub:"dependent"`
	Port                 int32    `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	SkipTlsVerify        bool     `protobuf:"varint,3,opt,name=skip_tls_verify,json=skipTlsVerify,proto3" json:"skip_tls_verify,omitempty"`
	UseTls               bool     `protobuf:"varint,4,opt,name=use_tls,json=useTls,proto3" json:"use_tls,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Syslog_TCPConfig) Reset()         { *m = Syslog_TCPConfig{} }
func (m *Syslog_TCPConfig) String() string { return proto.CompactTextString(m) }
func (*Syslog_TCPConfig) ProtoMessage()    {}
func (*Syslog_TCPConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e3e7b397b1162ec, []int{9, 0}
}
func (m *Syslog_TCPConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Syslog_TCPConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Syslog_TCPConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Syslog_TCPConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Syslog_TCPConfig.Merge(m, src)
}
func (m *Syslog_TCPConfig) XXX_Size() int {
	return m.Size()
}
func (m *Syslog_TCPConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Syslog_TCPConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Syslog_TCPConfig proto.InternalMessageInfo

func (m *Syslog_TCPConfig) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Syslog_TCPConfig) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Syslog_TCPConfig) GetSkipTlsVerify() bool {
	if m != nil {
		return m.SkipTlsVerify
	}
	return false
}

func (m *Syslog_TCPConfig) GetUseTls() bool {
	if m != nil {
		return m.UseTls
	}
	return false
}

func (m *Syslog_TCPConfig) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Syslog_TCPConfig) Clone() *Syslog_TCPConfig {
	if m == nil {
		return nil
	}
	cloned := new(Syslog_TCPConfig)
	*cloned = *m

	return cloned
}

func init() {
	proto.RegisterEnum("storage.Email_AuthMethod", Email_AuthMethod_name, Email_AuthMethod_value)
	proto.RegisterEnum("storage.Syslog_LocalFacility", Syslog_LocalFacility_name, Syslog_LocalFacility_value)
	proto.RegisterEnum("storage.Syslog_MessageFormat", Syslog_MessageFormat_name, Syslog_MessageFormat_value)
	proto.RegisterType((*Notifier)(nil), "storage.Notifier")
	proto.RegisterType((*AWSSecurityHub)(nil), "storage.AWSSecurityHub")
	proto.RegisterType((*AWSSecurityHub_Credentials)(nil), "storage.AWSSecurityHub.Credentials")
	proto.RegisterType((*CSCC)(nil), "storage.CSCC")
	proto.RegisterType((*Jira)(nil), "storage.Jira")
	proto.RegisterType((*Jira_PriorityMapping)(nil), "storage.Jira.PriorityMapping")
	proto.RegisterType((*Email)(nil), "storage.Email")
	proto.RegisterType((*Splunk)(nil), "storage.Splunk")
	proto.RegisterMapType((map[string]string)(nil), "storage.Splunk.SourceTypesEntry")
	proto.RegisterType((*PagerDuty)(nil), "storage.PagerDuty")
	proto.RegisterType((*Generic)(nil), "storage.Generic")
	proto.RegisterType((*SumoLogic)(nil), "storage.SumoLogic")
	proto.RegisterType((*Syslog)(nil), "storage.Syslog")
	proto.RegisterType((*Syslog_TCPConfig)(nil), "storage.Syslog.TCPConfig")
}

func init() { proto.RegisterFile("storage/notifier.proto", fileDescriptor_2e3e7b397b1162ec) }

var fileDescriptor_2e3e7b397b1162ec = []byte{
	// 1690 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xdb, 0x6e, 0x1b, 0xc7,
	0x19, 0xe6, 0x99, 0xcb, 0x9f, 0x07, 0xad, 0xc6, 0x87, 0xac, 0xd9, 0x5a, 0x12, 0xd6, 0x46, 0xea,
	0xa2, 0x09, 0x6d, 0x33, 0x4e, 0x6a, 0xb8, 0x45, 0x00, 0x8a, 0xa2, 0x2d, 0xc9, 0xb4, 0x22, 0x2c,
	0xe5, 0x14, 0xed, 0xcd, 0x62, 0xb4, 0x3b, 0xa2, 0x26, 0x5a, 0xee, 0x6e, 0x66, 0x66, 0xa5, 0xf0,
	0xb2, 0x17, 0x7d, 0x82, 0x02, 0x45, 0x9e, 0xa1, 0x37, 0x7d, 0x88, 0xde, 0xf4, 0xb2, 0x77, 0xbd,
	0x28, 0x20, 0x14, 0xee, 0x1b, 0xe8, 0x09, 0x82, 0x99, 0x1d, 0x2e, 0x0f, 0x91, 0x0c, 0x27, 0x77,
	0xff, 0xfc, 0xdf, 0xf7, 0xcf, 0xcc, 0xfe, 0xc7, 0x59, 0xb8, 0xcb, 0x45, 0xc4, 0xf0, 0x98, 0x3c,
	0x0e, 0x23, 0x41, 0x4f, 0x28, 0x61, 0x9d, 0x98, 0x45, 0x22, 0x42, 0x55, 0xad, 0x6f, 0xdf, 0x1e,
	0x47, 0xe3, 0x48, 0xe9, 0x1e, 0x4b, 0x29, 0x85, 0xdb, 0xb7, 0x67, 0x66, 0x5e, 0x34, 0x99, 0x44,
	0xe1, 0xaa, 0x36, 0x8e, 0x02, 0xea, 0x4d, 0x57, 0xb5, 0x82, 0x61, 0x2a, 0x78, 0xaa, 0xb5, 0xff,
	0x5e, 0x06, 0xe3, 0x40, 0x9f, 0x89, 0x7e, 0x09, 0x05, 0xea, 0x5b, 0xf9, 0xad, 0xfc, 0xa3, 0xda,
	0x76, 0xe3, 0xea, 0x72, 0xd3, 0xe0, 0xdf, 0x06, 0x2f, 0xec, 0xf8, 0xcc, 0x76, 0x0a, 0xd4, 0x47,
	0x0f, 0xa1, 0x14, 0xe2, 0x09, 0xb1, 0x0a, 0x0a, 0x37, 0xaf, 0x2e, 0x37, 0x1b, 0x0a, 0x4f, 0x42,
	0xfa, 0x6d, 0x42, 0x6c, 0x47, 0xa1, 0x08, 0x41, 0x49, 0x4c, 0x63, 0x62, 0x15, 0x25, 0xcb, 0x51,
	0x32, 0xda, 0x84, 0x7a, 0x42, 0x5d, 0x12, 0xfa, 0x71, 0x44, 0x43, 0x61, 0x95, 0x14, 0x04, 0x09,
	0x1d, 0x68, 0x0d, 0xfa, 0x05, 0xd4, 0x02, 0x7c, 0x4c, 0x02, 0xf7, 0x8c, 0x4c, 0x2d, 0x43, 0xc1,
	0x86, 0x52, 0xbc, 0x26, 0x53, 0xf4, 0x00, 0x9a, 0x29, 0xe8, 0x93, 0x13, 0x9c, 0x04, 0xc2, 0xaa,
	0x29, 0x42, 0x43, 0x29, 0x77, 0x52, 0x1d, 0x7a, 0x00, 0xa5, 0x6f, 0x28, 0xc3, 0x16, 0x6c, 0xe5,
	0x1f, 0xd5, 0xbb, 0xcd, 0x8e, 0xfe, 0xd8, 0xce, 0x3e, 0x65, 0x78, 0x37, 0xe7, 0x28, 0x10, 0x7d,
	0x0c, 0x65, 0x32, 0xc1, 0x34, 0xb0, 0xea, 0x8a, 0xd5, 0xca, 0x58, 0x03, 0xa9, 0xdd, 0xcd, 0x39,
	0x29, 0x2c, 0x37, 0xf3, 0xb8, 0xe7, 0x59, 0x8d, 0x95, 0xcd, 0xfa, 0xa3, 0x7e, 0x5f, 0x6e, 0x26,
	0x41, 0xf4, 0x6b, 0xa8, 0xf0, 0x38, 0x48, 0xc2, 0x33, 0xab, 0xa9, 0x68, 0x6b, 0x19, 0x6d, 0xa4,
	0xd4, 0xbb, 0x39, 0x47, 0x13, 0x50, 0x17, 0x6a, 0x31, 0x1e, 0x13, 0xe6, 0x27, 0x62, 0x6a, 0xb5,
	0x14, 0x1b, 0x65, 0xec, 0x43, 0x89, 0xec, 0x24, 0x62, 0xba, 0x9b, 0x73, 0xe6, 0x34, 0xf4, 0x09,
	0x54, 0xc7, 0x24, 0x24, 0x8c, 0x7a, 0xd6, 0x9a, 0xb2, 0x30, 0x33, 0x8b, 0x57, 0xa9, 0x7e, 0x37,
	0xe7, 0xcc, 0x28, 0xf2, 0x04, 0x9e, 0x4c, 0xa2, 0x20, 0x1a, 0x53, 0xcf, 0x32, 0x57, 0x4e, 0x18,
	0x25, 0x93, 0x68, 0x28, 0x11, 0x79, 0x42, 0x46, 0x43, 0x7d, 0x30, 0xf1, 0x05, 0x77, 0x39, 0xf1,
	0x12, 0x46, 0xc5, 0xd4, 0x3d, 0x4d, 0x8e, 0xad, 0x75, 0x65, 0xfa, 0x51, 0x66, 0xda, 0xfb, 0xc3,
	0x68, 0xa4, 0xf1, 0xdd, 0xe4, 0x78, 0x37, 0xe7, 0xb4, 0xf0, 0x05, 0x5f, 0xd0, 0x28, 0x2f, 0x4c,
	0x79, 0x10, 0x8d, 0x2d, 0xb4, 0xea, 0x05, 0xa5, 0x56, 0x5e, 0x50, 0x12, 0xfa, 0x15, 0x54, 0xd2,
	0xd4, 0xb3, 0xba, 0x2b, 0xd4, 0x23, 0xa5, 0x76, 0x34, 0xbc, 0x6d, 0x40, 0xc5, 0x8b, 0xc2, 0x13,
	0x3a, 0xde, 0x2f, 0x19, 0x65, 0xb3, 0xe2, 0x54, 0x49, 0x88, 0x8f, 0x03, 0xe2, 0xdb, 0x7f, 0x2b,
	0x40, 0x6b, 0xf9, 0x46, 0xe8, 0x2e, 0x54, 0x18, 0x19, 0xd3, 0x28, 0x4c, 0xd3, 0xd6, 0xd1, 0x2b,
	0x34, 0x80, 0xba, 0xc7, 0x88, 0x4f, 0x42, 0x41, 0x71, 0xc0, 0x55, 0xce, 0xd6, 0xbb, 0x0f, 0x6e,
	0xf8, 0xae, 0x4e, 0x7f, 0x4e, 0x75, 0x16, 0xed, 0xd0, 0x7d, 0x00, 0xec, 0x79, 0x51, 0x12, 0x0a,
	0x97, 0xfa, 0x3a, 0xa7, 0x6b, 0x5a, 0xb3, 0xe7, 0xb7, 0xff, 0x92, 0x87, 0xfa, 0x82, 0x2d, 0xfa,
	0x02, 0x9a, 0xd8, 0xf3, 0x08, 0xe7, 0x32, 0x91, 0xdd, 0xac, 0x96, 0xd0, 0xd5, 0xe5, 0x66, 0x8b,
	0x7b, 0x2c, 0x39, 0x7e, 0x61, 0xe3, 0xe0, 0x02, 0x4f, 0xb9, 0xed, 0xd4, 0x53, 0xe2, 0x6b, 0x32,
	0xdd, 0xf3, 0xd1, 0x97, 0xb0, 0xce, 0x89, 0xc7, 0x88, 0x70, 0xe7, 0xe6, 0xba, 0xce, 0xae, 0xb3,
	0x5d, 0x4b, 0xc9, 0xbd, 0xd9, 0x0e, 0x76, 0x00, 0x25, 0x99, 0x9b, 0xe8, 0x77, 0xb0, 0xc6, 0x09,
	0x3b, 0xa7, 0x1e, 0x71, 0xf5, 0x25, 0xdf, 0x73, 0x83, 0x96, 0xa6, 0xf6, 0x52, 0xa6, 0x2c, 0x42,
	0x1e, 0x25, 0xcc, 0x23, 0xf2, 0xe2, 0x69, 0x8d, 0x1a, 0xa9, 0x62, 0xcf, 0xdf, 0x2f, 0x19, 0x05,
	0xb3, 0xb8, 0x5f, 0x32, 0x8a, 0x66, 0xc9, 0xfe, 0x47, 0x11, 0x4a, 0xb2, 0xae, 0xd0, 0x36, 0x14,
	0x13, 0x16, 0xe8, 0x23, 0x9e, 0x5c, 0x5d, 0x6e, 0x7e, 0xa2, 0x8f, 0xf0, 0x49, 0x4c, 0x42, 0xe9,
	0x15, 0x7b, 0xeb, 0x1c, 0x07, 0xd4, 0xc7, 0x82, 0xbc, 0xb0, 0xc3, 0x28, 0x88, 0x3c, 0x1c, 0xcc,
	0xda, 0x80, 0xed, 0x48, 0x63, 0xf4, 0x14, 0x8c, 0x84, 0x13, 0xb6, 0xd0, 0x59, 0xee, 0x5c, 0x5d,
	0x6e, 0xae, 0xff, 0x68, 0x23, 0x27, 0xa3, 0xa1, 0x0e, 0x18, 0x31, 0xe6, 0xfc, 0x22, 0x62, 0x3a,
	0x24, 0xd7, 0x7e, 0x5e, 0xc6, 0x91, 0x41, 0xa4, 0x9c, 0x27, 0xc4, 0x55, 0x8d, 0x29, 0xfd, 0xb2,
	0x9a, 0xd2, 0x1c, 0xc9, 0xee, 0xb4, 0x0f, 0xeb, 0x31, 0xa3, 0x91, 0xaa, 0x81, 0x09, 0x8e, 0x63,
	0x1a, 0x8e, 0xb9, 0x55, 0xde, 0x2a, 0x3e, 0xaa, 0x77, 0xef, 0x2f, 0xf5, 0x91, 0xce, 0xa1, 0xa6,
	0xbd, 0x49, 0x59, 0x8e, 0x19, 0x2f, 0x2b, 0x38, 0xea, 0xc0, 0x2d, 0xdd, 0xa5, 0xdc, 0x13, 0x4a,
	0x02, 0x9f, 0xbb, 0xdf, 0xf0, 0x28, 0xb4, 0x2a, 0xea, 0xcc, 0x75, 0x0d, 0xbd, 0x54, 0xc8, 0x3e,
	0x8f, 0xc2, 0x36, 0x81, 0xb5, 0x95, 0x4d, 0xd1, 0xa7, 0x60, 0x70, 0x72, 0x4e, 0xa4, 0x4a, 0x79,
	0xb6, 0xd5, 0x5d, 0x9f, 0xd7, 0x94, 0x06, 0x9c, 0x8c, 0x22, 0xbb, 0x63, 0x76, 0xfb, 0xb9, 0x13,
	0x9d, 0xc6, 0x4c, 0x79, 0x80, 0x27, 0xc4, 0xfe, 0x4f, 0x11, 0xca, 0xaa, 0xc7, 0xa1, 0x4f, 0xa1,
	0x22, 0xc3, 0x4e, 0x98, 0x8e, 0xda, 0x0d, 0xce, 0xd6, 0x24, 0x59, 0x5e, 0x5c, 0xea, 0x98, 0xde,
	0x56, 0xaf, 0x96, 0xa2, 0x56, 0xfc, 0xe9, 0x51, 0x2b, 0x7d, 0x40, 0xd4, 0x36, 0x00, 0x7c, 0xca,
	0x65, 0xe1, 0x1f, 0x0d, 0x47, 0x56, 0x79, 0x2b, 0xff, 0xc8, 0x70, 0x16, 0x34, 0xe8, 0x73, 0xb8,
	0xbb, 0x33, 0x38, 0x74, 0x06, 0xfd, 0xde, 0xd1, 0x60, 0xc7, 0x4d, 0x38, 0x19, 0x09, 0xcc, 0x84,
	0xe4, 0x56, 0x14, 0xf7, 0xce, 0x1c, 0x7d, 0x3b, 0x07, 0xe5, 0x7c, 0x3a, 0x61, 0xd1, 0xc4, 0xaa,
	0xa6, 0xf3, 0x49, 0xca, 0x68, 0x0f, 0x10, 0xd7, 0x78, 0x2f, 0x11, 0xa7, 0x6f, 0x88, 0x38, 0x8d,
	0x7c, 0x35, 0x87, 0x5a, 0xdd, 0x7b, 0xcb, 0x43, 0xa2, 0x33, 0x27, 0x38, 0xd7, 0x18, 0xa1, 0xdf,
	0x43, 0x1b, 0x07, 0x41, 0x74, 0xe1, 0x26, 0x21, 0x4e, 0xc4, 0xa9, 0x6c, 0x0c, 0x1e, 0x16, 0xc4,
	0x77, 0xf9, 0x44, 0xc4, 0x6a, 0x72, 0x19, 0x8e, 0xa5, 0x18, 0x6f, 0x97, 0x09, 0xa3, 0x89, 0x88,
	0xed, 0x27, 0x00, 0x0b, 0x7b, 0x35, 0xc0, 0xd8, 0xd9, 0x1b, 0xf5, 0xb6, 0x87, 0x83, 0x1d, 0x33,
	0x87, 0x6a, 0x50, 0x3e, 0x1c, 0xf6, 0xf6, 0x0e, 0xcc, 0xbc, 0x14, 0x87, 0x5f, 0xbd, 0xda, 0x3b,
	0x30, 0x0b, 0xf6, 0x7f, 0x8b, 0x50, 0x49, 0xe7, 0x0d, 0x7a, 0x0a, 0x70, 0x2a, 0x44, 0xec, 0x8a,
	0xe8, 0x8c, 0x84, 0xef, 0xa9, 0xfb, 0x9a, 0x64, 0x1d, 0x49, 0x12, 0x7a, 0x0b, 0x4d, 0x65, 0x92,
	0x8d, 0xe6, 0xc2, 0xcf, 0x2c, 0xe5, 0x86, 0xdc, 0x26, 0x1b, 0xe7, 0x6d, 0x30, 0x68, 0xa8, 0xe6,
	0x4a, 0x9a, 0x1d, 0x86, 0x93, 0xad, 0x25, 0x26, 0x58, 0x12, 0xca, 0x6f, 0x56, 0x69, 0x50, 0x74,
	0xb2, 0x35, 0xea, 0xc2, 0x1d, 0x9c, 0xf8, 0x54, 0xb8, 0x41, 0x34, 0x1e, 0xd3, 0x70, 0xec, 0xea,
	0xc6, 0xaf, 0xa3, 0x7f, 0x4b, 0x81, 0xc3, 0x14, 0x1b, 0xa4, 0x10, 0x7a, 0x26, 0x2b, 0x8e, 0xd1,
	0x73, 0xe9, 0xe2, 0xb4, 0x7b, 0xa9, 0x2a, 0x57, 0x39, 0xb0, 0x5d, 0xb0, 0xf2, 0xbb, 0x39, 0x59,
	0x77, 0x8a, 0x30, 0x52, 0xb8, 0xaa, 0xf9, 0x3e, 0x34, 0x16, 0xd8, 0xdc, 0xaa, 0xaa, 0x72, 0xdf,
	0x5a, 0x19, 0xe1, 0x9d, 0xb9, 0x05, 0x1f, 0x84, 0x82, 0x4d, 0x9d, 0x3a, 0x9f, 0x6b, 0xda, 0x5f,
	0x82, 0xb9, 0x4a, 0x40, 0x26, 0x14, 0x65, 0xef, 0x4e, 0x87, 0x91, 0x14, 0xd1, 0x6d, 0x28, 0x9f,
	0xe3, 0x20, 0x99, 0x15, 0x66, 0xba, 0x78, 0x51, 0x78, 0x9e, 0xdf, 0xde, 0x82, 0x8d, 0x6b, 0xae,
	0xee, 0xfa, 0x24, 0x66, 0x44, 0xe5, 0x84, 0xfd, 0x1c, 0x6a, 0xd9, 0xf3, 0x00, 0xfd, 0x06, 0xaa,
	0x38, 0xa6, 0x6e, 0xb6, 0xfd, 0xb5, 0xc1, 0xad, 0xe0, 0x98, 0xca, 0x89, 0xf0, 0x7d, 0x11, 0xaa,
	0xfa, 0x9d, 0x80, 0x86, 0x60, 0x64, 0x01, 0xfe, 0xb9, 0xbd, 0x3a, 0xdb, 0x01, 0x3d, 0x84, 0x26,
	0x3f, 0xa3, 0xf1, 0xd1, 0x70, 0xf4, 0x35, 0x61, 0xf4, 0x24, 0x9d, 0x53, 0x86, 0xb3, 0xac, 0x44,
	0x1f, 0x41, 0xd5, 0xc3, 0xae, 0x47, 0x98, 0xd0, 0x53, 0xb3, 0xe2, 0xe1, 0x3e, 0x61, 0x62, 0xa9,
	0x73, 0x94, 0x7e, 0x7a, 0xe7, 0x28, 0x7f, 0x40, 0xe7, 0x78, 0x0c, 0xd5, 0x53, 0x82, 0x7d, 0xc2,
	0xb8, 0x55, 0x51, 0x71, 0xbd, 0x93, 0xc5, 0xf5, 0x35, 0x99, 0x7e, 0x2d, 0xfd, 0x7f, 0x88, 0x29,
	0x73, 0x66, 0x2c, 0xf4, 0x1c, 0x1a, 0xe4, 0x3b, 0xc1, 0xb0, 0xee, 0xd9, 0x3a, 0x1b, 0x6e, 0xb0,
	0xaa, 0x2b, 0x6a, 0xda, 0xc3, 0x6f, 0xce, 0x58, 0xe3, 0xc6, 0x8c, 0xb5, 0xff, 0x9c, 0x87, 0x5a,
	0xf6, 0x24, 0x43, 0x07, 0x70, 0x4b, 0x95, 0xa0, 0xce, 0x00, 0xec, 0xfb, 0x8c, 0x70, 0xae, 0xe3,
	0xb4, 0x71, 0x75, 0xb9, 0xd9, 0x7e, 0x4f, 0x54, 0xd6, 0xa5, 0x69, 0x9a, 0x83, 0xbd, 0xd4, 0xf0,
	0xc3, 0xc2, 0x63, 0xff, 0xb3, 0x04, 0x95, 0xf4, 0x81, 0x86, 0x76, 0xa0, 0xa5, 0x76, 0x75, 0x4f,
	0xb0, 0x47, 0x83, 0xf9, 0xd4, 0xb9, 0xbf, 0xf2, 0x92, 0xeb, 0x0c, 0x25, 0xeb, 0xa5, 0x26, 0x39,
	0xcd, 0x60, 0x71, 0x89, 0x5e, 0x00, 0x08, 0x2f, 0x76, 0xd3, 0x77, 0x9b, 0x7e, 0x6e, 0xdd, 0x5b,
	0xdd, 0xe1, 0xa8, 0x7f, 0xd8, 0x57, 0x04, 0xf9, 0x10, 0x15, 0x5e, 0x9c, 0x2e, 0x7e, 0xe4, 0xfe,
	0xe2, 0x07, 0xbb, 0x7f, 0x07, 0x5a, 0x13, 0xc2, 0x39, 0x1e, 0x13, 0xf7, 0x24, 0x62, 0x13, 0x9c,
	0xfe, 0x5b, 0x5c, 0x73, 0xf7, 0x37, 0x29, 0xeb, 0xa5, 0x22, 0x39, 0xcd, 0xc9, 0xe2, 0xb2, 0xfd,
	0xd7, 0x3c, 0xd4, 0xb2, 0xab, 0xc9, 0x04, 0x3d, 0x8d, 0xb8, 0x50, 0x09, 0xfa, 0xde, 0x19, 0x99,
	0xd1, 0xe4, 0x4c, 0x89, 0x23, 0x96, 0x76, 0xcf, 0xb2, 0xa3, 0x64, 0xf4, 0x31, 0xac, 0x49, 0x97,
	0xbb, 0x22, 0xe0, 0xee, 0x79, 0x1a, 0x89, 0xe2, 0x42, 0x24, 0x02, 0x3e, 0x2f, 0x94, 0x84, 0x13,
	0x49, 0x53, 0x77, 0x37, 0x9c, 0x4a, 0xc2, 0xc9, 0x51, 0xc0, 0xed, 0x08, 0x9a, 0x4b, 0x1e, 0x47,
	0x00, 0x95, 0xe1, 0x57, 0xfd, 0xde, 0xf0, 0x89, 0x99, 0xcb, 0xe4, 0xa7, 0x66, 0x3e, 0x93, 0xbb,
	0x66, 0x21, 0x93, 0x3f, 0x33, 0x8b, 0x99, 0xfc, 0xcc, 0x2c, 0x65, 0xf2, 0xe7, 0x66, 0x39, 0x93,
	0xbf, 0x30, 0x2b, 0x99, 0xfc, 0x5b, 0xb3, 0x6a, 0x3f, 0x84, 0xe6, 0x92, 0x9b, 0x14, 0x38, 0x78,
	0xd5, 0xeb, 0xff, 0xd1, 0xcc, 0xa1, 0x2a, 0x14, 0xfb, 0x83, 0x97, 0x66, 0x7e, 0x1b, 0xe6, 0xcd,
	0x64, 0xfb, 0xd9, 0xbf, 0xde, 0x6d, 0xe4, 0xff, 0xfd, 0x6e, 0x23, 0xff, 0xbf, 0x77, 0x1b, 0xf9,
	0xef, 0xff, 0xbf, 0x91, 0x83, 0x7b, 0x34, 0xea, 0x70, 0x81, 0xbd, 0x33, 0x16, 0x7d, 0x97, 0xfe,
	0x61, 0xce, 0x22, 0xf1, 0xa7, 0xd9, 0xaf, 0xec, 0x71, 0x45, 0xe9, 0x3f, 0xfb, 0x21, 0x00, 0x00,
	0xff, 0xff, 0x43, 0xa6, 0xc2, 0x2e, 0xf4, 0x0e, 0x00, 0x00,
}

func (m *Notifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notifier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notifier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Traits != nil {
		{
			size, err := m.Traits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotifier(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.Config != nil {
		{
			size := m.Config.Size()
			i -= size
			if _, err := m.Config.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.LabelDefault) > 0 {
		i -= len(m.LabelDefault)
		copy(dAtA[i:], m.LabelDefault)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.LabelDefault)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.LabelKey) > 0 {
		i -= len(m.LabelKey)
		copy(dAtA[i:], m.LabelKey)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.LabelKey)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.UiEndpoint) > 0 {
		i -= len(m.UiEndpoint)
		copy(dAtA[i:], m.UiEndpoint)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.UiEndpoint)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Notifier_Jira) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notifier_Jira) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Jira != nil {
		{
			size, err := m.Jira.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotifier(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Notifier_Email) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notifier_Email) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Email != nil {
		{
			size, err := m.Email.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotifier(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Notifier_Cscc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notifier_Cscc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cscc != nil {
		{
			size, err := m.Cscc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotifier(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Notifier_Splunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notifier_Splunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Splunk != nil {
		{
			size, err := m.Splunk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotifier(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Notifier_Pagerduty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notifier_Pagerduty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Pagerduty != nil {
		{
			size, err := m.Pagerduty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotifier(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *Notifier_Generic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notifier_Generic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Generic != nil {
		{
			size, err := m.Generic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotifier(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *Notifier_Sumologic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notifier_Sumologic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sumologic != nil {
		{
			size, err := m.Sumologic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotifier(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Notifier_AwsSecurityHub) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notifier_AwsSecurityHub) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsSecurityHub != nil {
		{
			size, err := m.AwsSecurityHub.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotifier(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Notifier_Syslog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notifier_Syslog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Syslog != nil {
		{
			size, err := m.Syslog.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotifier(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *AWSSecurityHub) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSSecurityHub) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSSecurityHub) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Credentials != nil {
		{
			size, err := m.Credentials.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotifier(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSSecurityHub_Credentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSSecurityHub_Credentials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSSecurityHub_Credentials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SecretAccessKey) > 0 {
		i -= len(m.SecretAccessKey)
		copy(dAtA[i:], m.SecretAccessKey)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.SecretAccessKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccessKeyId) > 0 {
		i -= len(m.AccessKeyId)
		copy(dAtA[i:], m.AccessKeyId)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.AccessKeyId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CSCC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSCC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSCC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SourceId) > 0 {
		i -= len(m.SourceId)
		copy(dAtA[i:], m.SourceId)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.SourceId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServiceAccount) > 0 {
		i -= len(m.ServiceAccount)
		copy(dAtA[i:], m.ServiceAccount)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.ServiceAccount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Jira) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Jira) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Jira) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DefaultFieldsJson) > 0 {
		i -= len(m.DefaultFieldsJson)
		copy(dAtA[i:], m.DefaultFieldsJson)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.DefaultFieldsJson)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PriorityMappings) > 0 {
		for iNdEx := len(m.PriorityMappings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PriorityMappings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNotifier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.IssueType) > 0 {
		i -= len(m.IssueType)
		copy(dAtA[i:], m.IssueType)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.IssueType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Jira_PriorityMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Jira_PriorityMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Jira_PriorityMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PriorityName) > 0 {
		i -= len(m.PriorityName)
		copy(dAtA[i:], m.PriorityName)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.PriorityName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Severity != 0 {
		i = encodeVarintNotifier(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Email) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Email) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Email) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllowUnauthenticatedSmtp {
		i--
		if m.AllowUnauthenticatedSmtp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.StartTLSAuthMethod != 0 {
		i = encodeVarintNotifier(dAtA, i, uint64(m.StartTLSAuthMethod))
		i--
		dAtA[i] = 0x40
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DEPRECATEDUseStartTLS {
		i--
		if m.DEPRECATEDUseStartTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.DisableTLS {
		i--
		if m.DisableTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Server) > 0 {
		i -= len(m.Server)
		copy(dAtA[i:], m.Server)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Server)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Splunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Splunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Splunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SourceTypes) > 0 {
		for k := range m.SourceTypes {
			v := m.SourceTypes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintNotifier(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintNotifier(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintNotifier(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.DerivedSourceTypeDeprecated != nil {
		{
			size := m.DerivedSourceTypeDeprecated.Size()
			i -= size
			if _, err := m.DerivedSourceTypeDeprecated.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AuditLoggingEnabled {
		i--
		if m.AuditLoggingEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Truncate != 0 {
		i = encodeVarintNotifier(dAtA, i, uint64(m.Truncate))
		i--
		dAtA[i] = 0x20
	}
	if m.Insecure {
		i--
		if m.Insecure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.HttpEndpoint) > 0 {
		i -= len(m.HttpEndpoint)
		copy(dAtA[i:], m.HttpEndpoint)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.HttpEndpoint)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HttpToken) > 0 {
		i -= len(m.HttpToken)
		copy(dAtA[i:], m.HttpToken)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.HttpToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Splunk_DerivedSourceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Splunk_DerivedSourceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.DerivedSourceType {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *PagerDuty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PagerDuty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PagerDuty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiKey) > 0 {
		i -= len(m.ApiKey)
		copy(dAtA[i:], m.ApiKey)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.ApiKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Generic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Generic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Generic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuditLoggingEnabled {
		i--
		if m.AuditLoggingEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.ExtraFields) > 0 {
		for iNdEx := len(m.ExtraFields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExtraFields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNotifier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNotifier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CaCert) > 0 {
		i -= len(m.CaCert)
		copy(dAtA[i:], m.CaCert)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.CaCert)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SkipTLSVerify {
		i--
		if m.SkipTLSVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SumoLogic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SumoLogic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SumoLogic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SkipTLSVerify {
		i--
		if m.SkipTLSVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.HttpSourceAddress) > 0 {
		i -= len(m.HttpSourceAddress)
		copy(dAtA[i:], m.HttpSourceAddress)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.HttpSourceAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Syslog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Syslog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Syslog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MessageFormat != 0 {
		i = encodeVarintNotifier(dAtA, i, uint64(m.MessageFormat))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ExtraFields) > 0 {
		for iNdEx := len(m.ExtraFields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExtraFields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNotifier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Endpoint != nil {
		{
			size := m.Endpoint.Size()
			i -= size
			if _, err := m.Endpoint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LocalFacility != 0 {
		i = encodeVarintNotifier(dAtA, i, uint64(m.LocalFacility))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Syslog_TcpConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Syslog_TcpConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TcpConfig != nil {
		{
			size, err := m.TcpConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotifier(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Syslog_TCPConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Syslog_TCPConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Syslog_TCPConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseTls {
		i--
		if m.UseTls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.SkipTlsVerify {
		i--
		if m.SkipTlsVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Port != 0 {
		i = encodeVarintNotifier(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintNotifier(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintNotifier(dAtA []byte, offset int, v uint64) int {
	offset -= sovNotifier(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Notifier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.UiEndpoint)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.LabelKey)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.LabelDefault)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.Config != nil {
		n += m.Config.Size()
	}
	if m.Traits != nil {
		l = m.Traits.Size()
		n += 2 + l + sovNotifier(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Notifier_Jira) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Jira != nil {
		l = m.Jira.Size()
		n += 1 + l + sovNotifier(uint64(l))
	}
	return n
}
func (m *Notifier_Email) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Email != nil {
		l = m.Email.Size()
		n += 1 + l + sovNotifier(uint64(l))
	}
	return n
}
func (m *Notifier_Cscc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cscc != nil {
		l = m.Cscc.Size()
		n += 1 + l + sovNotifier(uint64(l))
	}
	return n
}
func (m *Notifier_Splunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Splunk != nil {
		l = m.Splunk.Size()
		n += 1 + l + sovNotifier(uint64(l))
	}
	return n
}
func (m *Notifier_Pagerduty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagerduty != nil {
		l = m.Pagerduty.Size()
		n += 1 + l + sovNotifier(uint64(l))
	}
	return n
}
func (m *Notifier_Generic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Generic != nil {
		l = m.Generic.Size()
		n += 1 + l + sovNotifier(uint64(l))
	}
	return n
}
func (m *Notifier_Sumologic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sumologic != nil {
		l = m.Sumologic.Size()
		n += 2 + l + sovNotifier(uint64(l))
	}
	return n
}
func (m *Notifier_AwsSecurityHub) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsSecurityHub != nil {
		l = m.AwsSecurityHub.Size()
		n += 2 + l + sovNotifier(uint64(l))
	}
	return n
}
func (m *Notifier_Syslog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Syslog != nil {
		l = m.Syslog.Size()
		n += 2 + l + sovNotifier(uint64(l))
	}
	return n
}
func (m *AWSSecurityHub) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.Credentials != nil {
		l = m.Credentials.Size()
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AWSSecurityHub_Credentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessKeyId)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.SecretAccessKey)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSCC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceAccount)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.SourceId)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Jira) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.IssueType)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if len(m.PriorityMappings) > 0 {
		for _, e := range m.PriorityMappings {
			l = e.Size()
			n += 1 + l + sovNotifier(uint64(l))
		}
	}
	l = len(m.DefaultFieldsJson)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Jira_PriorityMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Severity != 0 {
		n += 1 + sovNotifier(uint64(m.Severity))
	}
	l = len(m.PriorityName)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Email) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Server)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.DisableTLS {
		n += 2
	}
	if m.DEPRECATEDUseStartTLS {
		n += 2
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.StartTLSAuthMethod != 0 {
		n += 1 + sovNotifier(uint64(m.StartTLSAuthMethod))
	}
	if m.AllowUnauthenticatedSmtp {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Splunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HttpToken)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.HttpEndpoint)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.Insecure {
		n += 2
	}
	if m.Truncate != 0 {
		n += 1 + sovNotifier(uint64(m.Truncate))
	}
	if m.AuditLoggingEnabled {
		n += 2
	}
	if m.DerivedSourceTypeDeprecated != nil {
		n += m.DerivedSourceTypeDeprecated.Size()
	}
	if len(m.SourceTypes) > 0 {
		for k, v := range m.SourceTypes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovNotifier(uint64(len(k))) + 1 + len(v) + sovNotifier(uint64(len(v)))
			n += mapEntrySize + 1 + sovNotifier(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Splunk_DerivedSourceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *PagerDuty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiKey)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Generic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.SkipTLSVerify {
		n += 2
	}
	l = len(m.CaCert)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovNotifier(uint64(l))
		}
	}
	if len(m.ExtraFields) > 0 {
		for _, e := range m.ExtraFields {
			l = e.Size()
			n += 1 + l + sovNotifier(uint64(l))
		}
	}
	if m.AuditLoggingEnabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SumoLogic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HttpSourceAddress)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.SkipTLSVerify {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Syslog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LocalFacility != 0 {
		n += 1 + sovNotifier(uint64(m.LocalFacility))
	}
	if m.Endpoint != nil {
		n += m.Endpoint.Size()
	}
	if len(m.ExtraFields) > 0 {
		for _, e := range m.ExtraFields {
			l = e.Size()
			n += 1 + l + sovNotifier(uint64(l))
		}
	}
	if m.MessageFormat != 0 {
		n += 1 + sovNotifier(uint64(m.MessageFormat))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Syslog_TcpConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TcpConfig != nil {
		l = m.TcpConfig.Size()
		n += 1 + l + sovNotifier(uint64(l))
	}
	return n
}
func (m *Syslog_TCPConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovNotifier(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovNotifier(uint64(m.Port))
	}
	if m.SkipTlsVerify {
		n += 2
	}
	if m.UseTls {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNotifier(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNotifier(x uint64) (n int) {
	return sovNotifier(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Notifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UiEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UiEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelDefault", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelDefault = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jira", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Jira{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &Notifier_Jira{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Email{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &Notifier_Email{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cscc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CSCC{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &Notifier_Cscc{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Splunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Splunk{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &Notifier_Splunk{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagerduty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PagerDuty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &Notifier_Pagerduty{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Generic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Generic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &Notifier_Generic{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sumologic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SumoLogic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &Notifier_Sumologic{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsSecurityHub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSSecurityHub{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &Notifier_AwsSecurityHub{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Syslog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Syslog{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &Notifier_Syslog{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Traits == nil {
				m.Traits = &Traits{}
			}
			if err := m.Traits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotifier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotifier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSSecurityHub) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSSecurityHub: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSSecurityHub: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credentials == nil {
				m.Credentials = &AWSSecurityHub_Credentials{}
			}
			if err := m.Credentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotifier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotifier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSSecurityHub_Credentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Credentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Credentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessKeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretAccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretAccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotifier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotifier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSCC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSCC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSCC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotifier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotifier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Jira) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Jira: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Jira: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssueType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IssueType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityMappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityMappings = append(m.PriorityMappings, &Jira_PriorityMapping{})
			if err := m.PriorityMappings[len(m.PriorityMappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFieldsJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultFieldsJson = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotifier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotifier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Jira_PriorityMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriorityMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriorityMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= Severity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotifier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotifier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Email) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Email: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Email: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Server = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableTLS = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEPRECATEDUseStartTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DEPRECATEDUseStartTLS = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTLSAuthMethod", wireType)
			}
			m.StartTLSAuthMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTLSAuthMethod |= Email_AuthMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowUnauthenticatedSmtp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowUnauthenticatedSmtp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNotifier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotifier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Splunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Splunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Splunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Insecure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Insecure = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Truncate", wireType)
			}
			m.Truncate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Truncate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditLoggingEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AuditLoggingEnabled = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivedSourceType", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DerivedSourceTypeDeprecated = &Splunk_DerivedSourceType{b}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceTypes == nil {
				m.SourceTypes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNotifier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNotifier
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthNotifier
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthNotifier
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNotifier
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthNotifier
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthNotifier
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNotifier(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthNotifier
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SourceTypes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotifier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotifier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagerDuty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PagerDuty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PagerDuty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotifier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotifier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Generic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Generic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Generic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipTLSVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipTLSVerify = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaCert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &KeyValuePair{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraFields = append(m.ExtraFields, &KeyValuePair{})
			if err := m.ExtraFields[len(m.ExtraFields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditLoggingEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AuditLoggingEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNotifier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotifier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SumoLogic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SumoLogic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SumoLogic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpSourceAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpSourceAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipTLSVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipTLSVerify = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNotifier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotifier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Syslog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Syslog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Syslog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFacility", wireType)
			}
			m.LocalFacility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalFacility |= Syslog_LocalFacility(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Syslog_TCPConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Endpoint = &Syslog_TcpConfig{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraFields = append(m.ExtraFields, &KeyValuePair{})
			if err := m.ExtraFields[len(m.ExtraFields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageFormat", wireType)
			}
			m.MessageFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageFormat |= Syslog_MessageFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNotifier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotifier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Syslog_TCPConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotifier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotifier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipTlsVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipTlsVerify = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseTls = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNotifier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotifier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNotifier(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNotifier
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNotifier
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNotifier
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNotifier
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNotifier
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNotifier        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNotifier          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNotifier = fmt.Errorf("proto: unexpected end of group")
)
