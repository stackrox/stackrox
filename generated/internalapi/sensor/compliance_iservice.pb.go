// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: internalapi/sensor/compliance_iservice.proto

package sensor

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	compliance "github.com/stackrox/rox/generated/internalapi/compliance"
	storage "github.com/stackrox/rox/generated/storage"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GetScrapeConfigRequest struct {
	NodeName             string   `protobuf:"bytes,1,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	ScrapeId             string   `protobuf:"bytes,2,opt,name=scrape_id,json=scrapeId,proto3" json:"scrape_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetScrapeConfigRequest) Reset()         { *m = GetScrapeConfigRequest{} }
func (m *GetScrapeConfigRequest) String() string { return proto.CompactTextString(m) }
func (*GetScrapeConfigRequest) ProtoMessage()    {}
func (*GetScrapeConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b20c44efbf676a9, []int{0}
}
func (m *GetScrapeConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetScrapeConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetScrapeConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetScrapeConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetScrapeConfigRequest.Merge(m, src)
}
func (m *GetScrapeConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetScrapeConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetScrapeConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetScrapeConfigRequest proto.InternalMessageInfo

func (m *GetScrapeConfigRequest) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *GetScrapeConfigRequest) GetScrapeId() string {
	if m != nil {
		return m.ScrapeId
	}
	return ""
}

func (m *GetScrapeConfigRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetScrapeConfigRequest) Clone() *GetScrapeConfigRequest {
	if m == nil {
		return nil
	}
	cloned := new(GetScrapeConfigRequest)
	*cloned = *m

	return cloned
}

type AuditEvents struct {
	// events are ordered with the most recent being the last element
	Events               []*storage.KubernetesEvent `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *AuditEvents) Reset()         { *m = AuditEvents{} }
func (m *AuditEvents) String() string { return proto.CompactTextString(m) }
func (*AuditEvents) ProtoMessage()    {}
func (*AuditEvents) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b20c44efbf676a9, []int{1}
}
func (m *AuditEvents) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuditEvents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuditEvents.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuditEvents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuditEvents.Merge(m, src)
}
func (m *AuditEvents) XXX_Size() int {
	return m.Size()
}
func (m *AuditEvents) XXX_DiscardUnknown() {
	xxx_messageInfo_AuditEvents.DiscardUnknown(m)
}

var xxx_messageInfo_AuditEvents proto.InternalMessageInfo

func (m *AuditEvents) GetEvents() []*storage.KubernetesEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *AuditEvents) MessageClone() proto.Message {
	return m.Clone()
}
func (m *AuditEvents) Clone() *AuditEvents {
	if m == nil {
		return nil
	}
	cloned := new(AuditEvents)
	*cloned = *m

	if m.Events != nil {
		cloned.Events = make([]*storage.KubernetesEvent, len(m.Events))
		for idx, v := range m.Events {
			cloned.Events[idx] = v.Clone()
		}
	}
	return cloned
}

type MsgFromCompliance struct {
	Node string `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	// Types that are valid to be assigned to Msg:
	//	*MsgFromCompliance_Return
	//	*MsgFromCompliance_AuditEvents
	//	*MsgFromCompliance_NodeInventory
	Msg                  isMsgFromCompliance_Msg `protobuf_oneof:"msg"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *MsgFromCompliance) Reset()         { *m = MsgFromCompliance{} }
func (m *MsgFromCompliance) String() string { return proto.CompactTextString(m) }
func (*MsgFromCompliance) ProtoMessage()    {}
func (*MsgFromCompliance) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b20c44efbf676a9, []int{2}
}
func (m *MsgFromCompliance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFromCompliance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFromCompliance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFromCompliance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFromCompliance.Merge(m, src)
}
func (m *MsgFromCompliance) XXX_Size() int {
	return m.Size()
}
func (m *MsgFromCompliance) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFromCompliance.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFromCompliance proto.InternalMessageInfo

type isMsgFromCompliance_Msg interface {
	isMsgFromCompliance_Msg()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isMsgFromCompliance_Msg
}

type MsgFromCompliance_Return struct {
	Return *compliance.ComplianceReturn `protobuf:"bytes,2,opt,name=return,proto3,oneof" json:"return,omitempty"`
}
type MsgFromCompliance_AuditEvents struct {
	AuditEvents *AuditEvents `protobuf:"bytes,3,opt,name=audit_events,json=auditEvents,proto3,oneof" json:"audit_events,omitempty"`
}
type MsgFromCompliance_NodeInventory struct {
	NodeInventory *storage.NodeInventory `protobuf:"bytes,4,opt,name=node_inventory,json=nodeInventory,proto3,oneof" json:"node_inventory,omitempty"`
}

func (*MsgFromCompliance_Return) isMsgFromCompliance_Msg() {}
func (m *MsgFromCompliance_Return) Clone() isMsgFromCompliance_Msg {
	if m == nil {
		return nil
	}
	cloned := new(MsgFromCompliance_Return)
	*cloned = *m

	cloned.Return = m.Return.Clone()
	return cloned
}
func (*MsgFromCompliance_AuditEvents) isMsgFromCompliance_Msg() {}
func (m *MsgFromCompliance_AuditEvents) Clone() isMsgFromCompliance_Msg {
	if m == nil {
		return nil
	}
	cloned := new(MsgFromCompliance_AuditEvents)
	*cloned = *m

	cloned.AuditEvents = m.AuditEvents.Clone()
	return cloned
}
func (*MsgFromCompliance_NodeInventory) isMsgFromCompliance_Msg() {}
func (m *MsgFromCompliance_NodeInventory) Clone() isMsgFromCompliance_Msg {
	if m == nil {
		return nil
	}
	cloned := new(MsgFromCompliance_NodeInventory)
	*cloned = *m

	cloned.NodeInventory = m.NodeInventory.Clone()
	return cloned
}

func (m *MsgFromCompliance) GetMsg() isMsgFromCompliance_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *MsgFromCompliance) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *MsgFromCompliance) GetReturn() *compliance.ComplianceReturn {
	if x, ok := m.GetMsg().(*MsgFromCompliance_Return); ok {
		return x.Return
	}
	return nil
}

func (m *MsgFromCompliance) GetAuditEvents() *AuditEvents {
	if x, ok := m.GetMsg().(*MsgFromCompliance_AuditEvents); ok {
		return x.AuditEvents
	}
	return nil
}

func (m *MsgFromCompliance) GetNodeInventory() *storage.NodeInventory {
	if x, ok := m.GetMsg().(*MsgFromCompliance_NodeInventory); ok {
		return x.NodeInventory
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MsgFromCompliance) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MsgFromCompliance_Return)(nil),
		(*MsgFromCompliance_AuditEvents)(nil),
		(*MsgFromCompliance_NodeInventory)(nil),
	}
}

func (m *MsgFromCompliance) MessageClone() proto.Message {
	return m.Clone()
}
func (m *MsgFromCompliance) Clone() *MsgFromCompliance {
	if m == nil {
		return nil
	}
	cloned := new(MsgFromCompliance)
	*cloned = *m

	if m.Msg != nil {
		cloned.Msg = m.Msg.Clone()
	}
	return cloned
}

type MsgToCompliance struct {
	// Types that are valid to be assigned to Msg:
	//	*MsgToCompliance_Config
	//	*MsgToCompliance_Trigger
	//	*MsgToCompliance_AuditLogCollectionRequest_
	Msg                  isMsgToCompliance_Msg `protobuf_oneof:"msg"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MsgToCompliance) Reset()         { *m = MsgToCompliance{} }
func (m *MsgToCompliance) String() string { return proto.CompactTextString(m) }
func (*MsgToCompliance) ProtoMessage()    {}
func (*MsgToCompliance) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b20c44efbf676a9, []int{3}
}
func (m *MsgToCompliance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgToCompliance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgToCompliance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgToCompliance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgToCompliance.Merge(m, src)
}
func (m *MsgToCompliance) XXX_Size() int {
	return m.Size()
}
func (m *MsgToCompliance) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgToCompliance.DiscardUnknown(m)
}

var xxx_messageInfo_MsgToCompliance proto.InternalMessageInfo

type isMsgToCompliance_Msg interface {
	isMsgToCompliance_Msg()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isMsgToCompliance_Msg
}

type MsgToCompliance_Config struct {
	Config *MsgToCompliance_ScrapeConfig `protobuf:"bytes,1,opt,name=config,proto3,oneof" json:"config,omitempty"`
}
type MsgToCompliance_Trigger struct {
	Trigger *MsgToCompliance_TriggerRun `protobuf:"bytes,2,opt,name=trigger,proto3,oneof" json:"trigger,omitempty"`
}
type MsgToCompliance_AuditLogCollectionRequest_ struct {
	AuditLogCollectionRequest *MsgToCompliance_AuditLogCollectionRequest `protobuf:"bytes,3,opt,name=audit_log_collection_request,json=auditLogCollectionRequest,proto3,oneof" json:"audit_log_collection_request,omitempty"`
}

func (*MsgToCompliance_Config) isMsgToCompliance_Msg() {}
func (m *MsgToCompliance_Config) Clone() isMsgToCompliance_Msg {
	if m == nil {
		return nil
	}
	cloned := new(MsgToCompliance_Config)
	*cloned = *m

	cloned.Config = m.Config.Clone()
	return cloned
}
func (*MsgToCompliance_Trigger) isMsgToCompliance_Msg() {}
func (m *MsgToCompliance_Trigger) Clone() isMsgToCompliance_Msg {
	if m == nil {
		return nil
	}
	cloned := new(MsgToCompliance_Trigger)
	*cloned = *m

	cloned.Trigger = m.Trigger.Clone()
	return cloned
}
func (*MsgToCompliance_AuditLogCollectionRequest_) isMsgToCompliance_Msg() {}
func (m *MsgToCompliance_AuditLogCollectionRequest_) Clone() isMsgToCompliance_Msg {
	if m == nil {
		return nil
	}
	cloned := new(MsgToCompliance_AuditLogCollectionRequest_)
	*cloned = *m

	cloned.AuditLogCollectionRequest = m.AuditLogCollectionRequest.Clone()
	return cloned
}

func (m *MsgToCompliance) GetMsg() isMsgToCompliance_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *MsgToCompliance) GetConfig() *MsgToCompliance_ScrapeConfig {
	if x, ok := m.GetMsg().(*MsgToCompliance_Config); ok {
		return x.Config
	}
	return nil
}

func (m *MsgToCompliance) GetTrigger() *MsgToCompliance_TriggerRun {
	if x, ok := m.GetMsg().(*MsgToCompliance_Trigger); ok {
		return x.Trigger
	}
	return nil
}

func (m *MsgToCompliance) GetAuditLogCollectionRequest() *MsgToCompliance_AuditLogCollectionRequest {
	if x, ok := m.GetMsg().(*MsgToCompliance_AuditLogCollectionRequest_); ok {
		return x.AuditLogCollectionRequest
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MsgToCompliance) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MsgToCompliance_Config)(nil),
		(*MsgToCompliance_Trigger)(nil),
		(*MsgToCompliance_AuditLogCollectionRequest_)(nil),
	}
}

func (m *MsgToCompliance) MessageClone() proto.Message {
	return m.Clone()
}
func (m *MsgToCompliance) Clone() *MsgToCompliance {
	if m == nil {
		return nil
	}
	cloned := new(MsgToCompliance)
	*cloned = *m

	if m.Msg != nil {
		cloned.Msg = m.Msg.Clone()
	}
	return cloned
}

type MsgToCompliance_ScrapeConfig struct {
	ContainerRuntime     storage.ContainerRuntime `protobuf:"varint,1,opt,name=container_runtime,json=containerRuntime,proto3,enum=storage.ContainerRuntime" json:"container_runtime,omitempty"`
	IsMasterNode         bool                     `protobuf:"varint,2,opt,name=is_master_node,json=isMasterNode,proto3" json:"is_master_node,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *MsgToCompliance_ScrapeConfig) Reset()         { *m = MsgToCompliance_ScrapeConfig{} }
func (m *MsgToCompliance_ScrapeConfig) String() string { return proto.CompactTextString(m) }
func (*MsgToCompliance_ScrapeConfig) ProtoMessage()    {}
func (*MsgToCompliance_ScrapeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b20c44efbf676a9, []int{3, 0}
}
func (m *MsgToCompliance_ScrapeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgToCompliance_ScrapeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgToCompliance_ScrapeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgToCompliance_ScrapeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgToCompliance_ScrapeConfig.Merge(m, src)
}
func (m *MsgToCompliance_ScrapeConfig) XXX_Size() int {
	return m.Size()
}
func (m *MsgToCompliance_ScrapeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgToCompliance_ScrapeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MsgToCompliance_ScrapeConfig proto.InternalMessageInfo

func (m *MsgToCompliance_ScrapeConfig) GetContainerRuntime() storage.ContainerRuntime {
	if m != nil {
		return m.ContainerRuntime
	}
	return storage.ContainerRuntime_UNKNOWN_CONTAINER_RUNTIME
}

func (m *MsgToCompliance_ScrapeConfig) GetIsMasterNode() bool {
	if m != nil {
		return m.IsMasterNode
	}
	return false
}

func (m *MsgToCompliance_ScrapeConfig) MessageClone() proto.Message {
	return m.Clone()
}
func (m *MsgToCompliance_ScrapeConfig) Clone() *MsgToCompliance_ScrapeConfig {
	if m == nil {
		return nil
	}
	cloned := new(MsgToCompliance_ScrapeConfig)
	*cloned = *m

	return cloned
}

type MsgToCompliance_TriggerRun struct {
	ScrapeId             string   `protobuf:"bytes,1,opt,name=scrape_id,json=scrapeId,proto3" json:"scrape_id,omitempty"`
	StandardIds          []string `protobuf:"bytes,2,rep,name=standard_ids,json=standardIds,proto3" json:"standard_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgToCompliance_TriggerRun) Reset()         { *m = MsgToCompliance_TriggerRun{} }
func (m *MsgToCompliance_TriggerRun) String() string { return proto.CompactTextString(m) }
func (*MsgToCompliance_TriggerRun) ProtoMessage()    {}
func (*MsgToCompliance_TriggerRun) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b20c44efbf676a9, []int{3, 1}
}
func (m *MsgToCompliance_TriggerRun) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgToCompliance_TriggerRun) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgToCompliance_TriggerRun.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgToCompliance_TriggerRun) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgToCompliance_TriggerRun.Merge(m, src)
}
func (m *MsgToCompliance_TriggerRun) XXX_Size() int {
	return m.Size()
}
func (m *MsgToCompliance_TriggerRun) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgToCompliance_TriggerRun.DiscardUnknown(m)
}

var xxx_messageInfo_MsgToCompliance_TriggerRun proto.InternalMessageInfo

func (m *MsgToCompliance_TriggerRun) GetScrapeId() string {
	if m != nil {
		return m.ScrapeId
	}
	return ""
}

func (m *MsgToCompliance_TriggerRun) GetStandardIds() []string {
	if m != nil {
		return m.StandardIds
	}
	return nil
}

func (m *MsgToCompliance_TriggerRun) MessageClone() proto.Message {
	return m.Clone()
}
func (m *MsgToCompliance_TriggerRun) Clone() *MsgToCompliance_TriggerRun {
	if m == nil {
		return nil
	}
	cloned := new(MsgToCompliance_TriggerRun)
	*cloned = *m

	if m.StandardIds != nil {
		cloned.StandardIds = make([]string, len(m.StandardIds))
		copy(cloned.StandardIds, m.StandardIds)
	}
	return cloned
}

type MsgToCompliance_AuditLogCollectionRequest struct {
	// Types that are valid to be assigned to Req:
	//	*MsgToCompliance_AuditLogCollectionRequest_StartReq
	//	*MsgToCompliance_AuditLogCollectionRequest_StopReq
	Req                  isMsgToCompliance_AuditLogCollectionRequest_Req `protobuf_oneof:"req"`
	XXX_NoUnkeyedLiteral struct{}                                        `json:"-"`
	XXX_unrecognized     []byte                                          `json:"-"`
	XXX_sizecache        int32                                           `json:"-"`
}

func (m *MsgToCompliance_AuditLogCollectionRequest) Reset() {
	*m = MsgToCompliance_AuditLogCollectionRequest{}
}
func (m *MsgToCompliance_AuditLogCollectionRequest) String() string {
	return proto.CompactTextString(m)
}
func (*MsgToCompliance_AuditLogCollectionRequest) ProtoMessage() {}
func (*MsgToCompliance_AuditLogCollectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b20c44efbf676a9, []int{3, 2}
}
func (m *MsgToCompliance_AuditLogCollectionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgToCompliance_AuditLogCollectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgToCompliance_AuditLogCollectionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgToCompliance_AuditLogCollectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgToCompliance_AuditLogCollectionRequest.Merge(m, src)
}
func (m *MsgToCompliance_AuditLogCollectionRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgToCompliance_AuditLogCollectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgToCompliance_AuditLogCollectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgToCompliance_AuditLogCollectionRequest proto.InternalMessageInfo

type isMsgToCompliance_AuditLogCollectionRequest_Req interface {
	isMsgToCompliance_AuditLogCollectionRequest_Req()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isMsgToCompliance_AuditLogCollectionRequest_Req
}

type MsgToCompliance_AuditLogCollectionRequest_StartReq struct {
	StartReq *MsgToCompliance_AuditLogCollectionRequest_StartRequest `protobuf:"bytes,1,opt,name=start_req,json=startReq,proto3,oneof" json:"start_req,omitempty"`
}
type MsgToCompliance_AuditLogCollectionRequest_StopReq struct {
	StopReq *MsgToCompliance_AuditLogCollectionRequest_StopRequest `protobuf:"bytes,2,opt,name=stop_req,json=stopReq,proto3,oneof" json:"stop_req,omitempty"`
}

func (*MsgToCompliance_AuditLogCollectionRequest_StartReq) isMsgToCompliance_AuditLogCollectionRequest_Req() {
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StartReq) Clone() isMsgToCompliance_AuditLogCollectionRequest_Req {
	if m == nil {
		return nil
	}
	cloned := new(MsgToCompliance_AuditLogCollectionRequest_StartReq)
	*cloned = *m

	cloned.StartReq = m.StartReq.Clone()
	return cloned
}
func (*MsgToCompliance_AuditLogCollectionRequest_StopReq) isMsgToCompliance_AuditLogCollectionRequest_Req() {
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StopReq) Clone() isMsgToCompliance_AuditLogCollectionRequest_Req {
	if m == nil {
		return nil
	}
	cloned := new(MsgToCompliance_AuditLogCollectionRequest_StopReq)
	*cloned = *m

	cloned.StopReq = m.StopReq.Clone()
	return cloned
}

func (m *MsgToCompliance_AuditLogCollectionRequest) GetReq() isMsgToCompliance_AuditLogCollectionRequest_Req {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *MsgToCompliance_AuditLogCollectionRequest) GetStartReq() *MsgToCompliance_AuditLogCollectionRequest_StartRequest {
	if x, ok := m.GetReq().(*MsgToCompliance_AuditLogCollectionRequest_StartReq); ok {
		return x.StartReq
	}
	return nil
}

func (m *MsgToCompliance_AuditLogCollectionRequest) GetStopReq() *MsgToCompliance_AuditLogCollectionRequest_StopRequest {
	if x, ok := m.GetReq().(*MsgToCompliance_AuditLogCollectionRequest_StopReq); ok {
		return x.StopReq
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MsgToCompliance_AuditLogCollectionRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MsgToCompliance_AuditLogCollectionRequest_StartReq)(nil),
		(*MsgToCompliance_AuditLogCollectionRequest_StopReq)(nil),
	}
}

func (m *MsgToCompliance_AuditLogCollectionRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *MsgToCompliance_AuditLogCollectionRequest) Clone() *MsgToCompliance_AuditLogCollectionRequest {
	if m == nil {
		return nil
	}
	cloned := new(MsgToCompliance_AuditLogCollectionRequest)
	*cloned = *m

	if m.Req != nil {
		cloned.Req = m.Req.Clone()
	}
	return cloned
}

type MsgToCompliance_AuditLogCollectionRequest_StartRequest struct {
	ClusterId            string                     `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	CollectStartState    *storage.AuditLogFileState `protobuf:"bytes,2,opt,name=collect_start_state,json=collectStartState,proto3" json:"collect_start_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) Reset() {
	*m = MsgToCompliance_AuditLogCollectionRequest_StartRequest{}
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) String() string {
	return proto.CompactTextString(m)
}
func (*MsgToCompliance_AuditLogCollectionRequest_StartRequest) ProtoMessage() {}
func (*MsgToCompliance_AuditLogCollectionRequest_StartRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b20c44efbf676a9, []int{3, 2, 0}
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgToCompliance_AuditLogCollectionRequest_StartRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgToCompliance_AuditLogCollectionRequest_StartRequest.Merge(m, src)
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgToCompliance_AuditLogCollectionRequest_StartRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgToCompliance_AuditLogCollectionRequest_StartRequest proto.InternalMessageInfo

func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) GetCollectStartState() *storage.AuditLogFileState {
	if m != nil {
		return m.CollectStartState
	}
	return nil
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) Clone() *MsgToCompliance_AuditLogCollectionRequest_StartRequest {
	if m == nil {
		return nil
	}
	cloned := new(MsgToCompliance_AuditLogCollectionRequest_StartRequest)
	*cloned = *m

	cloned.CollectStartState = m.CollectStartState.Clone()
	return cloned
}

type MsgToCompliance_AuditLogCollectionRequest_StopRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) Reset() {
	*m = MsgToCompliance_AuditLogCollectionRequest_StopRequest{}
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) String() string {
	return proto.CompactTextString(m)
}
func (*MsgToCompliance_AuditLogCollectionRequest_StopRequest) ProtoMessage() {}
func (*MsgToCompliance_AuditLogCollectionRequest_StopRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b20c44efbf676a9, []int{3, 2, 1}
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgToCompliance_AuditLogCollectionRequest_StopRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgToCompliance_AuditLogCollectionRequest_StopRequest.Merge(m, src)
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgToCompliance_AuditLogCollectionRequest_StopRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgToCompliance_AuditLogCollectionRequest_StopRequest proto.InternalMessageInfo

func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) Clone() *MsgToCompliance_AuditLogCollectionRequest_StopRequest {
	if m == nil {
		return nil
	}
	cloned := new(MsgToCompliance_AuditLogCollectionRequest_StopRequest)
	*cloned = *m

	return cloned
}

func init() {
	proto.RegisterType((*GetScrapeConfigRequest)(nil), "sensor.GetScrapeConfigRequest")
	proto.RegisterType((*AuditEvents)(nil), "sensor.AuditEvents")
	proto.RegisterType((*MsgFromCompliance)(nil), "sensor.MsgFromCompliance")
	proto.RegisterType((*MsgToCompliance)(nil), "sensor.MsgToCompliance")
	proto.RegisterType((*MsgToCompliance_ScrapeConfig)(nil), "sensor.MsgToCompliance.ScrapeConfig")
	proto.RegisterType((*MsgToCompliance_TriggerRun)(nil), "sensor.MsgToCompliance.TriggerRun")
	proto.RegisterType((*MsgToCompliance_AuditLogCollectionRequest)(nil), "sensor.MsgToCompliance.AuditLogCollectionRequest")
	proto.RegisterType((*MsgToCompliance_AuditLogCollectionRequest_StartRequest)(nil), "sensor.MsgToCompliance.AuditLogCollectionRequest.StartRequest")
	proto.RegisterType((*MsgToCompliance_AuditLogCollectionRequest_StopRequest)(nil), "sensor.MsgToCompliance.AuditLogCollectionRequest.StopRequest")
}

func init() {
	proto.RegisterFile("internalapi/sensor/compliance_iservice.proto", fileDescriptor_9b20c44efbf676a9)
}

var fileDescriptor_9b20c44efbf676a9 = []byte{
	// 723 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xc1, 0x6e, 0xeb, 0x44,
	0x14, 0x8d, 0x9b, 0x92, 0x26, 0xd7, 0x69, 0x21, 0x53, 0x51, 0x1c, 0x53, 0x42, 0x89, 0xba, 0xc8,
	0x02, 0xb9, 0x25, 0x48, 0x88, 0x0d, 0xad, 0x68, 0xd4, 0x92, 0x40, 0xdb, 0x85, 0xd3, 0x55, 0x25,
	0x64, 0x4d, 0xed, 0xc1, 0x1a, 0x11, 0xcf, 0xa4, 0x33, 0xe3, 0x4a, 0x95, 0xf8, 0x10, 0x3e, 0x88,
	0x05, 0x4b, 0x3e, 0x01, 0xca, 0xe2, 0xfd, 0xc6, 0xd3, 0x8c, 0xc7, 0xb1, 0xd3, 0xa7, 0x2c, 0xde,
	0xdb, 0xd9, 0xf7, 0x9e, 0x73, 0xe7, 0xdc, 0x73, 0xef, 0x0c, 0x7c, 0x4d, 0x99, 0x22, 0x82, 0xe1,
	0x05, 0x5e, 0xd2, 0x13, 0x49, 0x98, 0xe4, 0xe2, 0x24, 0xe6, 0xd9, 0x72, 0x41, 0x31, 0x8b, 0x49,
	0x44, 0x25, 0x11, 0x4f, 0x34, 0x26, 0xc1, 0x52, 0x70, 0xc5, 0x51, 0xab, 0x40, 0xf8, 0x6b, 0xac,
	0x0a, 0x5e, 0x67, 0x26, 0x58, 0xe1, 0x82, 0xe5, 0x7f, 0x2a, 0x15, 0x17, 0x38, 0x25, 0x27, 0xf1,
	0x22, 0x97, 0x8a, 0x08, 0x1b, 0xfe, 0x72, 0x15, 0xe6, 0x4c, 0x61, 0xca, 0x88, 0x88, 0x44, 0xce,
	0x14, 0xcd, 0xec, 0x69, 0xbe, 0x57, 0x02, 0x7e, 0xcf, 0x1f, 0x48, 0x44, 0x9e, 0x08, 0x53, 0x36,
	0x83, 0xca, 0x0c, 0xe3, 0x89, 0x45, 0x0f, 0x43, 0x38, 0xf8, 0x89, 0xa8, 0x79, 0x2c, 0xf0, 0x92,
	0x4c, 0x38, 0xfb, 0x8d, 0xa6, 0x21, 0x79, 0xcc, 0x89, 0x54, 0xe8, 0x73, 0xe8, 0x68, 0x5c, 0xc4,
	0x70, 0x46, 0x3c, 0xe7, 0xc8, 0x19, 0x75, 0xc2, 0xb6, 0x0e, 0xdc, 0xe2, 0x8c, 0xe8, 0xa4, 0x34,
	0x9c, 0x88, 0x26, 0xde, 0x56, 0x91, 0x2c, 0x02, 0xb3, 0x64, 0x78, 0x0e, 0xee, 0x8f, 0x79, 0x42,
	0xd5, 0xa5, 0x3e, 0x5b, 0xa2, 0x53, 0x68, 0x19, 0x15, 0xd2, 0x73, 0x8e, 0x9a, 0x23, 0x77, 0xec,
	0x05, 0x56, 0x47, 0xf0, 0x4b, 0xfe, 0x40, 0x04, 0x23, 0x8a, 0x48, 0x03, 0x0d, 0x2d, 0x6e, 0xf8,
	0x9f, 0x03, 0xbd, 0x1b, 0x99, 0x5e, 0x09, 0x9e, 0x4d, 0x56, 0xde, 0x20, 0x04, 0xdb, 0xfa, 0x7c,
	0xab, 0xc5, 0x7c, 0xa3, 0xef, 0xa0, 0x25, 0x88, 0xca, 0x05, 0x33, 0x22, 0xdc, 0xf1, 0x61, 0x50,
	0x99, 0x19, 0x54, 0xdc, 0xd0, 0x60, 0xa6, 0x8d, 0xd0, 0xa2, 0xd1, 0xf7, 0xd0, 0xc5, 0x5a, 0x62,
	0x64, 0x95, 0x35, 0x0d, 0x7b, 0x3f, 0x28, 0x26, 0x15, 0xd4, 0xe4, 0x4f, 0x1b, 0xa1, 0x8b, 0x6b,
	0xdd, 0x9c, 0xc3, 0x9e, 0xb1, 0x85, 0x32, 0xfd, 0xcf, 0xc5, 0xb3, 0xb7, 0x6d, 0xb8, 0x07, 0xab,
	0xae, 0x6e, 0x79, 0x42, 0x66, 0x65, 0x76, 0xda, 0x08, 0x77, 0x59, 0x3d, 0x70, 0xf1, 0x11, 0x34,
	0x33, 0x99, 0x0e, 0xff, 0x6a, 0xc1, 0xc7, 0x37, 0x32, 0xbd, 0xe3, 0xb5, 0x0e, 0xcf, 0xa0, 0x15,
	0x9b, 0x19, 0x98, 0x1e, 0xdd, 0xf1, 0x71, 0xa9, 0xe7, 0x15, 0x30, 0xa8, 0xcf, 0x4b, 0x77, 0x55,
	0xb0, 0xd0, 0x19, 0xec, 0x28, 0x41, 0xd3, 0x94, 0x08, 0x6b, 0xc7, 0x70, 0x53, 0x81, 0xbb, 0x02,
	0x16, 0xe6, 0xda, 0x94, 0x92, 0x84, 0x14, 0x1c, 0x16, 0xae, 0x2c, 0x78, 0x1a, 0xc5, 0x7c, 0xb1,
	0x20, 0xb1, 0xa2, 0x9c, 0x45, 0xa2, 0x58, 0x09, 0xeb, 0xd2, 0x37, 0x9b, 0x8a, 0x1a, 0xd7, 0xae,
	0x79, 0x3a, 0x59, 0x31, 0xed, 0x2e, 0x4d, 0x1b, 0x61, 0x1f, 0x6f, 0x4a, 0xfa, 0x7f, 0x40, 0xb7,
	0xde, 0x0f, 0xba, 0x82, 0xde, 0x3b, 0xbb, 0x6d, 0x0c, 0xd9, 0x1b, 0xf7, 0x57, 0x26, 0x4f, 0x4a,
	0x44, 0x58, 0x00, 0xc2, 0x4f, 0xe2, 0x57, 0x11, 0x74, 0x0c, 0x7b, 0x54, 0x46, 0x19, 0xd6, 0x97,
	0x27, 0x32, 0x9b, 0xa3, 0x4d, 0x69, 0x87, 0x5d, 0x2a, 0x6f, 0x4c, 0x50, 0x0f, 0xca, 0xbf, 0x06,
	0xa8, 0xcc, 0x58, 0xdf, 0x6b, 0x67, 0x7d, 0xaf, 0xd1, 0x57, 0xd0, 0x95, 0x0a, 0xb3, 0x04, 0x8b,
	0x24, 0xa2, 0x89, 0xf4, 0xb6, 0x8e, 0x9a, 0xa3, 0x4e, 0xe8, 0x96, 0xb1, 0x59, 0x22, 0xfd, 0x37,
	0x5b, 0xd0, 0xdf, 0x68, 0x03, 0xfa, 0x15, 0x3a, 0x52, 0x61, 0xa1, 0xb4, 0xa1, 0x76, 0xc4, 0x67,
	0xef, 0x6d, 0x66, 0x30, 0xd7, 0x25, 0x2a, 0x67, 0xdb, 0xd2, 0xfe, 0xa3, 0x7b, 0x68, 0x4b, 0xc5,
	0x97, 0xa6, 0x7a, 0x31, 0xff, 0x1f, 0x3e, 0xa4, 0x3a, 0x5f, 0x56, 0xc5, 0x77, 0x64, 0xf1, 0xeb,
	0x3f, 0x43, 0xb7, 0x7e, 0x2e, 0xfa, 0x02, 0xc0, 0xbe, 0x4b, 0x95, 0x53, 0x1d, 0x1b, 0x99, 0x25,
	0xe8, 0x67, 0xd8, 0xb7, 0xfb, 0x13, 0x15, 0x1d, 0x4b, 0x85, 0x15, 0xb1, 0xaa, 0xfc, 0xd5, 0x14,
	0x4b, 0x19, 0x57, 0x74, 0x41, 0xe6, 0x1a, 0x11, 0xf6, 0x2c, 0xcd, 0x1c, 0x66, 0x42, 0xfe, 0x2e,
	0xb8, 0x35, 0x51, 0xfa, 0xfe, 0x08, 0xf2, 0x68, 0xaf, 0xd1, 0xf8, 0x1e, 0x7a, 0x55, 0x5b, 0xf3,
	0xe2, 0xd9, 0x45, 0x97, 0xe0, 0x4e, 0x78, 0x96, 0xe5, 0x8c, 0xc6, 0x58, 0x11, 0xd4, 0xaf, 0xb9,
	0xb0, 0xfe, 0xa6, 0xf8, 0x9f, 0x6d, 0x30, 0x68, 0xe4, 0x9c, 0x3a, 0x17, 0xde, 0xdf, 0x2f, 0x03,
	0xe7, 0x9f, 0x97, 0x81, 0xf3, 0xef, 0xcb, 0xc0, 0xf9, 0xf3, 0xff, 0x41, 0xe3, 0xde, 0xbe, 0xe4,
	0x0f, 0x2d, 0xf3, 0x78, 0x7e, 0xfb, 0x36, 0x00, 0x00, 0xff, 0xff, 0xb8, 0x68, 0xc0, 0xe9, 0x08,
	0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ComplianceServiceClient is the client API for ComplianceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConnInterface.NewStream.
type ComplianceServiceClient interface {
	Communicate(ctx context.Context, opts ...grpc.CallOption) (ComplianceService_CommunicateClient, error)
}

type complianceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewComplianceServiceClient(cc grpc.ClientConnInterface) ComplianceServiceClient {
	return &complianceServiceClient{cc}
}

func (c *complianceServiceClient) Communicate(ctx context.Context, opts ...grpc.CallOption) (ComplianceService_CommunicateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ComplianceService_serviceDesc.Streams[0], "/sensor.ComplianceService/Communicate", opts...)
	if err != nil {
		return nil, err
	}
	x := &complianceServiceCommunicateClient{stream}
	return x, nil
}

type ComplianceService_CommunicateClient interface {
	Send(*MsgFromCompliance) error
	Recv() (*MsgToCompliance, error)
	grpc.ClientStream
}

type complianceServiceCommunicateClient struct {
	grpc.ClientStream
}

func (x *complianceServiceCommunicateClient) Send(m *MsgFromCompliance) error {
	return x.ClientStream.SendMsg(m)
}

func (x *complianceServiceCommunicateClient) Recv() (*MsgToCompliance, error) {
	m := new(MsgToCompliance)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ComplianceServiceServer is the server API for ComplianceService service.
type ComplianceServiceServer interface {
	Communicate(ComplianceService_CommunicateServer) error
}

// UnimplementedComplianceServiceServer can be embedded to have forward compatible implementations.
type UnimplementedComplianceServiceServer struct {
}

func (*UnimplementedComplianceServiceServer) Communicate(srv ComplianceService_CommunicateServer) error {
	return status.Errorf(codes.Unimplemented, "method Communicate not implemented")
}

func RegisterComplianceServiceServer(s *grpc.Server, srv ComplianceServiceServer) {
	s.RegisterService(&_ComplianceService_serviceDesc, srv)
}

func _ComplianceService_Communicate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ComplianceServiceServer).Communicate(&complianceServiceCommunicateServer{stream})
}

type ComplianceService_CommunicateServer interface {
	Send(*MsgToCompliance) error
	Recv() (*MsgFromCompliance, error)
	grpc.ServerStream
}

type complianceServiceCommunicateServer struct {
	grpc.ServerStream
}

func (x *complianceServiceCommunicateServer) Send(m *MsgToCompliance) error {
	return x.ServerStream.SendMsg(m)
}

func (x *complianceServiceCommunicateServer) Recv() (*MsgFromCompliance, error) {
	m := new(MsgFromCompliance)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ComplianceService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sensor.ComplianceService",
	HandlerType: (*ComplianceServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Communicate",
			Handler:       _ComplianceService_Communicate_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "internalapi/sensor/compliance_iservice.proto",
}

func (m *GetScrapeConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetScrapeConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetScrapeConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ScrapeId) > 0 {
		i -= len(m.ScrapeId)
		copy(dAtA[i:], m.ScrapeId)
		i = encodeVarintComplianceIservice(dAtA, i, uint64(len(m.ScrapeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintComplianceIservice(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuditEvents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditEvents) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditEvents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComplianceIservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgFromCompliance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFromCompliance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFromCompliance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Msg != nil {
		{
			size := m.Msg.Size()
			i -= size
			if _, err := m.Msg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Node) > 0 {
		i -= len(m.Node)
		copy(dAtA[i:], m.Node)
		i = encodeVarintComplianceIservice(dAtA, i, uint64(len(m.Node)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFromCompliance_Return) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFromCompliance_Return) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Return != nil {
		{
			size, err := m.Return.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceIservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MsgFromCompliance_AuditEvents) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFromCompliance_AuditEvents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AuditEvents != nil {
		{
			size, err := m.AuditEvents.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceIservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MsgFromCompliance_NodeInventory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFromCompliance_NodeInventory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NodeInventory != nil {
		{
			size, err := m.NodeInventory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceIservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MsgToCompliance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgToCompliance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgToCompliance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Msg != nil {
		{
			size := m.Msg.Size()
			i -= size
			if _, err := m.Msg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgToCompliance_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgToCompliance_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceIservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *MsgToCompliance_Trigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgToCompliance_Trigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Trigger != nil {
		{
			size, err := m.Trigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceIservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MsgToCompliance_AuditLogCollectionRequest_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgToCompliance_AuditLogCollectionRequest_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AuditLogCollectionRequest != nil {
		{
			size, err := m.AuditLogCollectionRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceIservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MsgToCompliance_ScrapeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgToCompliance_ScrapeConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgToCompliance_ScrapeConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsMasterNode {
		i--
		if m.IsMasterNode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ContainerRuntime != 0 {
		i = encodeVarintComplianceIservice(dAtA, i, uint64(m.ContainerRuntime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgToCompliance_TriggerRun) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgToCompliance_TriggerRun) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgToCompliance_TriggerRun) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StandardIds) > 0 {
		for iNdEx := len(m.StandardIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StandardIds[iNdEx])
			copy(dAtA[i:], m.StandardIds[iNdEx])
			i = encodeVarintComplianceIservice(dAtA, i, uint64(len(m.StandardIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ScrapeId) > 0 {
		i -= len(m.ScrapeId)
		copy(dAtA[i:], m.ScrapeId)
		i = encodeVarintComplianceIservice(dAtA, i, uint64(len(m.ScrapeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgToCompliance_AuditLogCollectionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgToCompliance_AuditLogCollectionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgToCompliance_AuditLogCollectionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Req != nil {
		{
			size := m.Req.Size()
			i -= size
			if _, err := m.Req.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StartReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StartReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StartReq != nil {
		{
			size, err := m.StartReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceIservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StopReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StopReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StopReq != nil {
		{
			size, err := m.StopReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceIservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CollectStartState != nil {
		{
			size, err := m.CollectStartState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceIservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintComplianceIservice(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintComplianceIservice(dAtA []byte, offset int, v uint64) int {
	offset -= sovComplianceIservice(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetScrapeConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	l = len(m.ScrapeId)
	if l > 0 {
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuditEvents) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovComplianceIservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgFromCompliance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgFromCompliance_Return) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Return != nil {
		l = m.Return.Size()
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	return n
}
func (m *MsgFromCompliance_AuditEvents) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuditEvents != nil {
		l = m.AuditEvents.Size()
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	return n
}
func (m *MsgFromCompliance_NodeInventory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeInventory != nil {
		l = m.NodeInventory.Size()
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	return n
}
func (m *MsgToCompliance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgToCompliance_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	return n
}
func (m *MsgToCompliance_Trigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Trigger != nil {
		l = m.Trigger.Size()
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	return n
}
func (m *MsgToCompliance_AuditLogCollectionRequest_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuditLogCollectionRequest != nil {
		l = m.AuditLogCollectionRequest.Size()
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	return n
}
func (m *MsgToCompliance_ScrapeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerRuntime != 0 {
		n += 1 + sovComplianceIservice(uint64(m.ContainerRuntime))
	}
	if m.IsMasterNode {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgToCompliance_TriggerRun) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScrapeId)
	if l > 0 {
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	if len(m.StandardIds) > 0 {
		for _, s := range m.StandardIds {
			l = len(s)
			n += 1 + l + sovComplianceIservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgToCompliance_AuditLogCollectionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Req != nil {
		n += m.Req.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StartReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartReq != nil {
		l = m.StartReq.Size()
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	return n
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StopReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StopReq != nil {
		l = m.StopReq.Size()
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	return n
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	if m.CollectStartState != nil {
		l = m.CollectStartState.Size()
		n += 1 + l + sovComplianceIservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovComplianceIservice(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozComplianceIservice(x uint64) (n int) {
	return sovComplianceIservice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetScrapeConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceIservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetScrapeConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetScrapeConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScrapeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScrapeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceIservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditEvents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceIservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditEvents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditEvents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &storage.KubernetesEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceIservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFromCompliance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceIservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFromCompliance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFromCompliance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Return", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &compliance.ComplianceReturn{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &MsgFromCompliance_Return{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuditEvents{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &MsgFromCompliance_AuditEvents{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &storage.NodeInventory{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &MsgFromCompliance_NodeInventory{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceIservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgToCompliance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceIservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgToCompliance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgToCompliance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgToCompliance_ScrapeConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &MsgToCompliance_Config{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgToCompliance_TriggerRun{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &MsgToCompliance_Trigger{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditLogCollectionRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgToCompliance_AuditLogCollectionRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &MsgToCompliance_AuditLogCollectionRequest_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceIservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgToCompliance_ScrapeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceIservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScrapeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScrapeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRuntime", wireType)
			}
			m.ContainerRuntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerRuntime |= storage.ContainerRuntime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMasterNode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMasterNode = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceIservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgToCompliance_TriggerRun) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceIservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerRun: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerRun: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScrapeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScrapeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardIds = append(m.StandardIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceIservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgToCompliance_AuditLogCollectionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceIservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditLogCollectionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditLogCollectionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgToCompliance_AuditLogCollectionRequest_StartRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Req = &MsgToCompliance_AuditLogCollectionRequest_StartReq{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgToCompliance_AuditLogCollectionRequest_StopRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Req = &MsgToCompliance_AuditLogCollectionRequest_StopReq{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceIservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StartRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceIservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectStartState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectStartState == nil {
				m.CollectStartState = &storage.AuditLogFileState{}
			}
			if err := m.CollectStartState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceIservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgToCompliance_AuditLogCollectionRequest_StopRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceIservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceIservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceIservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipComplianceIservice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowComplianceIservice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowComplianceIservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthComplianceIservice
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupComplianceIservice
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthComplianceIservice
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthComplianceIservice        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowComplianceIservice          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupComplianceIservice = fmt.Errorf("proto: unexpected end of group")
)
