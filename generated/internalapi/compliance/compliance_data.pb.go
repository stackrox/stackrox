// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: internalapi/compliance/compliance_data.proto

package compliance

import (
	fmt "fmt"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	storage "github.com/stackrox/rox/generated/storage"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Next Available Tag: 2
type GZIPDataChunk struct {
	Gzip                 []byte   `protobuf:"bytes,1,opt,name=gzip,proto3" json:"gzip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GZIPDataChunk) Reset()         { *m = GZIPDataChunk{} }
func (m *GZIPDataChunk) String() string { return proto.CompactTextString(m) }
func (*GZIPDataChunk) ProtoMessage()    {}
func (*GZIPDataChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_0141493472fe6290, []int{0}
}
func (m *GZIPDataChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GZIPDataChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GZIPDataChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GZIPDataChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GZIPDataChunk.Merge(m, src)
}
func (m *GZIPDataChunk) XXX_Size() int {
	return m.Size()
}
func (m *GZIPDataChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_GZIPDataChunk.DiscardUnknown(m)
}

var xxx_messageInfo_GZIPDataChunk proto.InternalMessageInfo

func (m *GZIPDataChunk) GetGzip() []byte {
	if m != nil {
		return m.Gzip
	}
	return nil
}

func (m *GZIPDataChunk) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GZIPDataChunk) Clone() *GZIPDataChunk {
	if m == nil {
		return nil
	}
	cloned := new(GZIPDataChunk)
	*cloned = *m

	if m.Gzip != nil {
		cloned.Gzip = make([]byte, len(m.Gzip))
		copy(cloned.Gzip, m.Gzip)
	}
	return cloned
}

// Next Available Tag: 8
type File struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	User                 uint32   `protobuf:"varint,2,opt,name=user,proto3" json:"user,omitempty"`
	UserName             string   `protobuf:"bytes,3,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	Group                uint32   `protobuf:"varint,4,opt,name=group,proto3" json:"group,omitempty"`
	GroupName            string   `protobuf:"bytes,5,opt,name=group_name,json=groupName,proto3" json:"group_name,omitempty"`
	Permissions          uint32   `protobuf:"varint,6,opt,name=permissions,proto3" json:"permissions,omitempty"`
	Content              []byte   `protobuf:"bytes,7,opt,name=content,proto3" json:"content,omitempty"`
	IsDir                bool     `protobuf:"varint,8,opt,name=is_dir,json=isDir,proto3" json:"is_dir,omitempty"`
	Children             []*File  `protobuf:"bytes,9,rep,name=children,proto3" json:"children,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_0141493472fe6290, []int{1}
}
func (m *File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_File.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(m, src)
}
func (m *File) XXX_Size() int {
	return m.Size()
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

func (m *File) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *File) GetUser() uint32 {
	if m != nil {
		return m.User
	}
	return 0
}

func (m *File) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *File) GetGroup() uint32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *File) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

func (m *File) GetPermissions() uint32 {
	if m != nil {
		return m.Permissions
	}
	return 0
}

func (m *File) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *File) GetIsDir() bool {
	if m != nil {
		return m.IsDir
	}
	return false
}

func (m *File) GetChildren() []*File {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *File) MessageClone() proto.Message {
	return m.Clone()
}
func (m *File) Clone() *File {
	if m == nil {
		return nil
	}
	cloned := new(File)
	*cloned = *m

	if m.Content != nil {
		cloned.Content = make([]byte, len(m.Content))
		copy(cloned.Content, m.Content)
	}
	if m.Children != nil {
		cloned.Children = make([]*File, len(m.Children))
		for idx, v := range m.Children {
			cloned.Children[idx] = v.Clone()
		}
	}
	return cloned
}

// Next Available Tag: 3
type CommandLine struct {
	Process              string              `protobuf:"bytes,1,opt,name=process,proto3" json:"process,omitempty"`
	Args                 []*CommandLine_Args `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CommandLine) Reset()         { *m = CommandLine{} }
func (m *CommandLine) String() string { return proto.CompactTextString(m) }
func (*CommandLine) ProtoMessage()    {}
func (*CommandLine) Descriptor() ([]byte, []int) {
	return fileDescriptor_0141493472fe6290, []int{2}
}
func (m *CommandLine) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandLine) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandLine.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandLine) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandLine.Merge(m, src)
}
func (m *CommandLine) XXX_Size() int {
	return m.Size()
}
func (m *CommandLine) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandLine.DiscardUnknown(m)
}

var xxx_messageInfo_CommandLine proto.InternalMessageInfo

func (m *CommandLine) GetProcess() string {
	if m != nil {
		return m.Process
	}
	return ""
}

func (m *CommandLine) GetArgs() []*CommandLine_Args {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *CommandLine) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CommandLine) Clone() *CommandLine {
	if m == nil {
		return nil
	}
	cloned := new(CommandLine)
	*cloned = *m

	if m.Args != nil {
		cloned.Args = make([]*CommandLine_Args, len(m.Args))
		for idx, v := range m.Args {
			cloned.Args[idx] = v.Clone()
		}
	}
	return cloned
}

type CommandLine_Args struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Values               []string `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	File                 *File    `protobuf:"bytes,3,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandLine_Args) Reset()         { *m = CommandLine_Args{} }
func (m *CommandLine_Args) String() string { return proto.CompactTextString(m) }
func (*CommandLine_Args) ProtoMessage()    {}
func (*CommandLine_Args) Descriptor() ([]byte, []int) {
	return fileDescriptor_0141493472fe6290, []int{2, 0}
}
func (m *CommandLine_Args) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandLine_Args) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandLine_Args.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandLine_Args) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandLine_Args.Merge(m, src)
}
func (m *CommandLine_Args) XXX_Size() int {
	return m.Size()
}
func (m *CommandLine_Args) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandLine_Args.DiscardUnknown(m)
}

var xxx_messageInfo_CommandLine_Args proto.InternalMessageInfo

func (m *CommandLine_Args) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *CommandLine_Args) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *CommandLine_Args) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *CommandLine_Args) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CommandLine_Args) Clone() *CommandLine_Args {
	if m == nil {
		return nil
	}
	cloned := new(CommandLine_Args)
	*cloned = *m

	if m.Values != nil {
		cloned.Values = make([]string, len(m.Values))
		copy(cloned.Values, m.Values)
	}
	cloned.File = m.File.Clone()
	return cloned
}

type InsecureRegistriesConfig struct {
	InsecureRegistries   []string `protobuf:"bytes,1,rep,name=insecure_registries,json=insecureRegistries,proto3" json:"insecure_registries,omitempty"`
	InsecureCidrs        []string `protobuf:"bytes,2,rep,name=insecure_cidrs,json=insecureCidrs,proto3" json:"insecure_cidrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InsecureRegistriesConfig) Reset()         { *m = InsecureRegistriesConfig{} }
func (m *InsecureRegistriesConfig) String() string { return proto.CompactTextString(m) }
func (*InsecureRegistriesConfig) ProtoMessage()    {}
func (*InsecureRegistriesConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0141493472fe6290, []int{3}
}
func (m *InsecureRegistriesConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsecureRegistriesConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsecureRegistriesConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsecureRegistriesConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsecureRegistriesConfig.Merge(m, src)
}
func (m *InsecureRegistriesConfig) XXX_Size() int {
	return m.Size()
}
func (m *InsecureRegistriesConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_InsecureRegistriesConfig.DiscardUnknown(m)
}

var xxx_messageInfo_InsecureRegistriesConfig proto.InternalMessageInfo

func (m *InsecureRegistriesConfig) GetInsecureRegistries() []string {
	if m != nil {
		return m.InsecureRegistries
	}
	return nil
}

func (m *InsecureRegistriesConfig) GetInsecureCidrs() []string {
	if m != nil {
		return m.InsecureCidrs
	}
	return nil
}

func (m *InsecureRegistriesConfig) MessageClone() proto.Message {
	return m.Clone()
}
func (m *InsecureRegistriesConfig) Clone() *InsecureRegistriesConfig {
	if m == nil {
		return nil
	}
	cloned := new(InsecureRegistriesConfig)
	*cloned = *m

	if m.InsecureRegistries != nil {
		cloned.InsecureRegistries = make([]string, len(m.InsecureRegistries))
		copy(cloned.InsecureRegistries, m.InsecureRegistries)
	}
	if m.InsecureCidrs != nil {
		cloned.InsecureCidrs = make([]string, len(m.InsecureCidrs))
		copy(cloned.InsecureCidrs, m.InsecureCidrs)
	}
	return cloned
}

type ContainerRuntimeInfo struct {
	InsecureRegistries   *InsecureRegistriesConfig `protobuf:"bytes,1,opt,name=insecure_registries,json=insecureRegistries,proto3" json:"insecure_registries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ContainerRuntimeInfo) Reset()         { *m = ContainerRuntimeInfo{} }
func (m *ContainerRuntimeInfo) String() string { return proto.CompactTextString(m) }
func (*ContainerRuntimeInfo) ProtoMessage()    {}
func (*ContainerRuntimeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0141493472fe6290, []int{4}
}
func (m *ContainerRuntimeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerRuntimeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerRuntimeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerRuntimeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerRuntimeInfo.Merge(m, src)
}
func (m *ContainerRuntimeInfo) XXX_Size() int {
	return m.Size()
}
func (m *ContainerRuntimeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerRuntimeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerRuntimeInfo proto.InternalMessageInfo

func (m *ContainerRuntimeInfo) GetInsecureRegistries() *InsecureRegistriesConfig {
	if m != nil {
		return m.InsecureRegistries
	}
	return nil
}

func (m *ContainerRuntimeInfo) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ContainerRuntimeInfo) Clone() *ContainerRuntimeInfo {
	if m == nil {
		return nil
	}
	cloned := new(ContainerRuntimeInfo)
	*cloned = *m

	cloned.InsecureRegistries = m.InsecureRegistries.Clone()
	return cloned
}

type ComplianceStandardResult struct {
	NodeCheckResults     map[string]*storage.ComplianceResultValue `protobuf:"bytes,1,rep,name=node_check_results,json=nodeCheckResults,proto3" json:"node_check_results,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ClusterCheckResults  map[string]*storage.ComplianceResultValue `protobuf:"bytes,2,rep,name=cluster_check_results,json=clusterCheckResults,proto3" json:"cluster_check_results,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                  `json:"-"`
	XXX_unrecognized     []byte                                    `json:"-"`
	XXX_sizecache        int32                                     `json:"-"`
}

func (m *ComplianceStandardResult) Reset()         { *m = ComplianceStandardResult{} }
func (m *ComplianceStandardResult) String() string { return proto.CompactTextString(m) }
func (*ComplianceStandardResult) ProtoMessage()    {}
func (*ComplianceStandardResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0141493472fe6290, []int{5}
}
func (m *ComplianceStandardResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceStandardResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceStandardResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceStandardResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceStandardResult.Merge(m, src)
}
func (m *ComplianceStandardResult) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceStandardResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceStandardResult.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceStandardResult proto.InternalMessageInfo

func (m *ComplianceStandardResult) GetNodeCheckResults() map[string]*storage.ComplianceResultValue {
	if m != nil {
		return m.NodeCheckResults
	}
	return nil
}

func (m *ComplianceStandardResult) GetClusterCheckResults() map[string]*storage.ComplianceResultValue {
	if m != nil {
		return m.ClusterCheckResults
	}
	return nil
}

func (m *ComplianceStandardResult) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceStandardResult) Clone() *ComplianceStandardResult {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceStandardResult)
	*cloned = *m

	if m.NodeCheckResults != nil {
		cloned.NodeCheckResults = make(map[string]*storage.ComplianceResultValue, len(m.NodeCheckResults))
		for k, v := range m.NodeCheckResults {
			cloned.NodeCheckResults[k] = v.Clone()
		}
	}
	if m.ClusterCheckResults != nil {
		cloned.ClusterCheckResults = make(map[string]*storage.ComplianceResultValue, len(m.ClusterCheckResults))
		for k, v := range m.ClusterCheckResults {
			cloned.ClusterCheckResults[k] = v.Clone()
		}
	}
	return cloned
}

// Next Available Tag: 11
type ComplianceReturn struct {
	NodeName             string                  `protobuf:"bytes,1,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	ScrapeId             string                  `protobuf:"bytes,2,opt,name=scrape_id,json=scrapeId,proto3" json:"scrape_id,omitempty"`
	DockerData           *GZIPDataChunk          `protobuf:"bytes,3,opt,name=docker_data,json=dockerData,proto3" json:"docker_data,omitempty"`
	CommandLines         map[string]*CommandLine `protobuf:"bytes,4,rep,name=command_lines,json=commandLines,proto3" json:"command_lines,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Files                map[string]*File        `protobuf:"bytes,5,rep,name=files,proto3" json:"files,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	SystemdFiles         map[string]*File        `protobuf:"bytes,6,rep,name=systemd_files,json=systemdFiles,proto3" json:"systemd_files,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ContainerRuntimeInfo *ContainerRuntimeInfo   `protobuf:"bytes,9,opt,name=container_runtime_info,json=containerRuntimeInfo,proto3" json:"container_runtime_info,omitempty"`
	Time                 *types.Timestamp        `protobuf:"bytes,7,opt,name=time,proto3" json:"time,omitempty"`
	Evidence             *GZIPDataChunk          `protobuf:"bytes,10,opt,name=evidence,proto3" json:"evidence,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ComplianceReturn) Reset()         { *m = ComplianceReturn{} }
func (m *ComplianceReturn) String() string { return proto.CompactTextString(m) }
func (*ComplianceReturn) ProtoMessage()    {}
func (*ComplianceReturn) Descriptor() ([]byte, []int) {
	return fileDescriptor_0141493472fe6290, []int{6}
}
func (m *ComplianceReturn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceReturn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceReturn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceReturn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceReturn.Merge(m, src)
}
func (m *ComplianceReturn) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceReturn) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceReturn.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceReturn proto.InternalMessageInfo

func (m *ComplianceReturn) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *ComplianceReturn) GetScrapeId() string {
	if m != nil {
		return m.ScrapeId
	}
	return ""
}

func (m *ComplianceReturn) GetDockerData() *GZIPDataChunk {
	if m != nil {
		return m.DockerData
	}
	return nil
}

func (m *ComplianceReturn) GetCommandLines() map[string]*CommandLine {
	if m != nil {
		return m.CommandLines
	}
	return nil
}

func (m *ComplianceReturn) GetFiles() map[string]*File {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *ComplianceReturn) GetSystemdFiles() map[string]*File {
	if m != nil {
		return m.SystemdFiles
	}
	return nil
}

func (m *ComplianceReturn) GetContainerRuntimeInfo() *ContainerRuntimeInfo {
	if m != nil {
		return m.ContainerRuntimeInfo
	}
	return nil
}

func (m *ComplianceReturn) GetTime() *types.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *ComplianceReturn) GetEvidence() *GZIPDataChunk {
	if m != nil {
		return m.Evidence
	}
	return nil
}

func (m *ComplianceReturn) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceReturn) Clone() *ComplianceReturn {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceReturn)
	*cloned = *m

	cloned.DockerData = m.DockerData.Clone()
	if m.CommandLines != nil {
		cloned.CommandLines = make(map[string]*CommandLine, len(m.CommandLines))
		for k, v := range m.CommandLines {
			cloned.CommandLines[k] = v.Clone()
		}
	}
	if m.Files != nil {
		cloned.Files = make(map[string]*File, len(m.Files))
		for k, v := range m.Files {
			cloned.Files[k] = v.Clone()
		}
	}
	if m.SystemdFiles != nil {
		cloned.SystemdFiles = make(map[string]*File, len(m.SystemdFiles))
		for k, v := range m.SystemdFiles {
			cloned.SystemdFiles[k] = v.Clone()
		}
	}
	cloned.ContainerRuntimeInfo = m.ContainerRuntimeInfo.Clone()
	cloned.Time = m.Time.Clone()
	cloned.Evidence = m.Evidence.Clone()
	return cloned
}

func init() {
	proto.RegisterType((*GZIPDataChunk)(nil), "compliance.GZIPDataChunk")
	proto.RegisterType((*File)(nil), "compliance.File")
	proto.RegisterType((*CommandLine)(nil), "compliance.CommandLine")
	proto.RegisterType((*CommandLine_Args)(nil), "compliance.CommandLine.Args")
	proto.RegisterType((*InsecureRegistriesConfig)(nil), "compliance.InsecureRegistriesConfig")
	proto.RegisterType((*ContainerRuntimeInfo)(nil), "compliance.ContainerRuntimeInfo")
	proto.RegisterType((*ComplianceStandardResult)(nil), "compliance.ComplianceStandardResult")
	proto.RegisterMapType((map[string]*storage.ComplianceResultValue)(nil), "compliance.ComplianceStandardResult.ClusterCheckResultsEntry")
	proto.RegisterMapType((map[string]*storage.ComplianceResultValue)(nil), "compliance.ComplianceStandardResult.NodeCheckResultsEntry")
	proto.RegisterType((*ComplianceReturn)(nil), "compliance.ComplianceReturn")
	proto.RegisterMapType((map[string]*CommandLine)(nil), "compliance.ComplianceReturn.CommandLinesEntry")
	proto.RegisterMapType((map[string]*File)(nil), "compliance.ComplianceReturn.FilesEntry")
	proto.RegisterMapType((map[string]*File)(nil), "compliance.ComplianceReturn.SystemdFilesEntry")
}

func init() {
	proto.RegisterFile("internalapi/compliance/compliance_data.proto", fileDescriptor_0141493472fe6290)
}

var fileDescriptor_0141493472fe6290 = []byte{
	// 880 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4f, 0x6f, 0x23, 0x35,
	0x14, 0x67, 0xda, 0x24, 0x9b, 0xbc, 0xb4, 0xa8, 0xeb, 0x6d, 0x17, 0x93, 0x5d, 0x42, 0x14, 0x16,
	0xe8, 0x61, 0x99, 0xa2, 0x02, 0x12, 0xaa, 0xb4, 0x07, 0xc8, 0x02, 0x2a, 0x42, 0x2b, 0x98, 0x42,
	0x85, 0xf6, 0x32, 0xf2, 0x7a, 0x9c, 0x89, 0x95, 0x19, 0x7b, 0xb0, 0x3d, 0x2b, 0xca, 0x8d, 0x6f,
	0xc1, 0x57, 0xe0, 0xc8, 0x77, 0xe0, 0xc0, 0x91, 0x8f, 0x80, 0xca, 0x17, 0x41, 0xb6, 0x93, 0xac,
	0xdb, 0x4c, 0xa0, 0x12, 0x7b, 0x8a, 0xfd, 0x7b, 0xef, 0xfd, 0xde, 0xf3, 0xfb, 0x37, 0x81, 0x87,
	0x5c, 0x18, 0xa6, 0x04, 0x29, 0x48, 0xc5, 0x8f, 0xa8, 0x2c, 0xab, 0x82, 0x13, 0x41, 0x59, 0x70,
	0x4c, 0x33, 0x62, 0x48, 0x5c, 0x29, 0x69, 0x24, 0x82, 0x17, 0xf0, 0xe0, 0xcd, 0x5c, 0xca, 0xbc,
	0x60, 0x47, 0x4e, 0xf2, 0xac, 0x9e, 0x1e, 0x19, 0x5e, 0x32, 0x6d, 0x48, 0x59, 0x79, 0xe5, 0x01,
	0xd6, 0x46, 0x2a, 0x92, 0x87, 0x5c, 0x5e, 0x32, 0x7e, 0x0b, 0x76, 0xbf, 0x78, 0x7a, 0xfa, 0xf5,
	0x63, 0x62, 0xc8, 0x64, 0x56, 0x8b, 0x39, 0x42, 0xd0, 0xca, 0x7f, 0xe2, 0x15, 0x8e, 0x46, 0xd1,
	0xe1, 0x4e, 0xe2, 0xce, 0xe3, 0x9f, 0xb7, 0xa0, 0xf5, 0x39, 0x2f, 0x98, 0x15, 0x56, 0xc4, 0xcc,
	0x9c, 0xb0, 0x97, 0xb8, 0xb3, 0xc5, 0x6a, 0xcd, 0x14, 0xde, 0x1a, 0x45, 0x87, 0xbb, 0x89, 0x3b,
	0xa3, 0x7b, 0xd0, 0xb3, 0xbf, 0xa9, 0x20, 0x25, 0xc3, 0xdb, 0x4e, 0xb9, 0x6b, 0x81, 0x27, 0xa4,
	0x64, 0x68, 0x1f, 0xda, 0xb9, 0x92, 0x75, 0x85, 0x5b, 0xce, 0xc2, 0x5f, 0xd0, 0x1b, 0x00, 0xee,
	0xe0, 0x6d, 0xda, 0xce, 0xa6, 0xe7, 0x10, 0x67, 0x34, 0x82, 0x7e, 0xc5, 0x54, 0xc9, 0xb5, 0xe6,
	0x52, 0x68, 0xdc, 0x71, 0xa6, 0x21, 0x84, 0x30, 0xdc, 0xa2, 0x52, 0x18, 0x26, 0x0c, 0xbe, 0xe5,
	0x62, 0x5f, 0x5e, 0xd1, 0x01, 0x74, 0xb8, 0x4e, 0x33, 0xae, 0x70, 0x77, 0x14, 0x1d, 0x76, 0x93,
	0x36, 0xd7, 0x8f, 0xb9, 0x42, 0x0f, 0xa1, 0x4b, 0x67, 0xbc, 0xc8, 0x14, 0x13, 0xb8, 0x37, 0xda,
	0x3e, 0xec, 0x1f, 0xef, 0xc5, 0x41, 0x7e, 0xec, 0x83, 0x93, 0x95, 0xc6, 0xf8, 0xb7, 0x08, 0xfa,
	0x13, 0x59, 0x96, 0x44, 0x64, 0x5f, 0x71, 0xc1, 0xac, 0xbb, 0x4a, 0x49, 0xca, 0xb4, 0x5e, 0x64,
	0x63, 0x79, 0x45, 0xef, 0x43, 0x8b, 0xa8, 0x5c, 0xe3, 0x2d, 0xc7, 0x79, 0x3f, 0xe4, 0x0c, 0x08,
	0xe2, 0x4f, 0x54, 0xae, 0x13, 0xa7, 0x39, 0x38, 0x87, 0x96, 0xbd, 0xa1, 0x3d, 0xd8, 0x9e, 0xb3,
	0x8b, 0x05, 0x9f, 0x3d, 0xa2, 0xbb, 0xd0, 0x79, 0x4e, 0x8a, 0x9a, 0x79, 0xb6, 0x5e, 0xb2, 0xb8,
	0xa1, 0x07, 0xd0, 0x9a, 0xf2, 0xc2, 0xe7, 0xb6, 0x29, 0x6e, 0x27, 0x1d, 0x2b, 0xc0, 0xa7, 0x42,
	0x33, 0x5a, 0x2b, 0x96, 0xb0, 0x9c, 0x6b, 0xa3, 0x38, 0xd3, 0x13, 0x29, 0xa6, 0x3c, 0x47, 0x47,
	0x70, 0x87, 0x2f, 0x64, 0xa9, 0x5a, 0x09, 0x71, 0xe4, 0xdc, 0x20, 0xbe, 0x66, 0x86, 0xde, 0x86,
	0x57, 0x57, 0x06, 0x94, 0x67, 0x6a, 0x19, 0xd2, 0xee, 0x12, 0x9d, 0x58, 0x70, 0x5c, 0xc2, 0xfe,
	0x44, 0x0a, 0x43, 0xb8, 0x60, 0x2a, 0xa9, 0x85, 0xed, 0xc4, 0x53, 0x31, 0x95, 0xe8, 0xbb, 0x4d,
	0xfe, 0xec, 0x03, 0x1e, 0x84, 0x0f, 0xd8, 0x14, 0x72, 0x53, 0x54, 0xe3, 0xdf, 0xb7, 0x01, 0x4f,
	0x56, 0xb6, 0x67, 0x86, 0x88, 0x8c, 0xa8, 0x2c, 0x61, 0xba, 0x2e, 0x0c, 0x9a, 0x01, 0x12, 0x32,
	0x63, 0x29, 0x9d, 0x31, 0x3a, 0x4f, 0x95, 0x03, 0xfd, 0x13, 0xfb, 0xc7, 0x27, 0xd7, 0xea, 0xd2,
	0xc8, 0x10, 0x3f, 0x91, 0x19, 0x9b, 0x58, 0x6b, 0x7f, 0xd7, 0x9f, 0x09, 0xa3, 0x2e, 0x92, 0x3d,
	0x71, 0x0d, 0x46, 0x3f, 0xc0, 0x01, 0x2d, 0x6a, 0x6d, 0x98, 0xba, 0xe6, 0xcc, 0x37, 0xc1, 0xa3,
	0x1b, 0x39, 0x9b, 0x78, 0x86, 0x75, 0x7f, 0x77, 0xe8, 0xba, 0x64, 0x40, 0xe1, 0xa0, 0x31, 0xba,
	0x86, 0x2e, 0xfa, 0x10, 0xda, 0xae, 0x6f, 0xdc, 0x8c, 0xf6, 0x8f, 0x87, 0xf1, 0x62, 0x1d, 0x04,
	0xa1, 0x78, 0x86, 0x73, 0xab, 0x95, 0x78, 0xe5, 0x93, 0xad, 0x8f, 0xa3, 0xc1, 0x14, 0xf0, 0xa6,
	0xa8, 0x5e, 0xa6, 0x9f, 0xf1, 0xaf, 0x1d, 0xd8, 0x0b, 0x95, 0x4c, 0xad, 0x84, 0xdd, 0x22, 0xae,
	0x7c, 0x6e, 0x23, 0x78, 0x37, 0x5d, 0x0b, 0xb8, 0x85, 0x70, 0x0f, 0x7a, 0x9a, 0x2a, 0x52, 0xb1,
	0x94, 0x67, 0xce, 0x5f, 0x2f, 0xe9, 0x7a, 0xe0, 0x34, 0x43, 0x27, 0xd0, 0xcf, 0x24, 0x9d, 0x33,
	0xe5, 0x36, 0xe6, 0x62, 0x4a, 0x5e, 0x0f, 0x8b, 0x70, 0x65, 0xe9, 0x25, 0xe0, 0xb5, 0x2d, 0x80,
	0xce, 0x60, 0x97, 0xfa, 0x31, 0x4d, 0x0b, 0x2e, 0x98, 0xc6, 0x2d, 0x57, 0xc2, 0xb8, 0xb9, 0x84,
	0x3e, 0xd4, 0x70, 0xb0, 0x17, 0x35, 0xdb, 0xa1, 0x01, 0x84, 0x1e, 0x41, 0xdb, 0x4e, 0xa4, 0xc6,
	0x6d, 0x47, 0xf6, 0xee, 0xbf, 0x92, 0xd9, 0x09, 0x5e, 0xb0, 0x78, 0x2b, 0x1b, 0x93, 0xbe, 0xd0,
	0x86, 0x95, 0x59, 0xea, 0x69, 0x3a, 0x37, 0x88, 0xe9, 0xcc, 0x5b, 0x04, 0x6c, 0x3b, 0x3a, 0x80,
	0xd0, 0x39, 0xdc, 0xa5, 0xcb, 0x49, 0x4d, 0x95, 0x1f, 0xd5, 0x94, 0x8b, 0xa9, 0xc4, 0x3d, 0x97,
	0xaf, 0xd1, 0x55, 0xf6, 0xf5, 0x99, 0x4e, 0xf6, 0x69, 0xd3, 0xa4, 0xc7, 0xd0, 0xb2, 0x67, 0xb7,
	0x85, 0xfb, 0xc7, 0x83, 0xd8, 0x7f, 0x9c, 0xe2, 0xe5, 0xc7, 0x29, 0xfe, 0x76, 0xf9, 0x71, 0x4a,
	0x9c, 0x1e, 0xfa, 0x08, 0xba, 0xec, 0x39, 0xcf, 0x98, 0xa0, 0x0c, 0xc3, 0x7f, 0x55, 0x6a, 0xa5,
	0x3a, 0xf8, 0x1e, 0x6e, 0xaf, 0x65, 0xbd, 0xa1, 0x27, 0xdf, 0xbb, 0xda, 0x93, 0xaf, 0x6d, 0x58,
	0xc7, 0x61, 0xd3, 0x7f, 0x09, 0xf0, 0x22, 0x69, 0x0d, 0x94, 0xef, 0x5c, 0xa5, 0x5c, 0xdf, 0xbe,
	0x01, 0xd7, 0x37, 0x70, 0x7b, 0xad, 0x0e, 0xff, 0x8f, 0xf2, 0xd3, 0x93, 0x3f, 0x2e, 0x87, 0xd1,
	0x9f, 0x97, 0xc3, 0xe8, 0xaf, 0xcb, 0x61, 0xf4, 0xcb, 0xdf, 0xc3, 0x57, 0xe0, 0x3e, 0x97, 0xb1,
	0x36, 0x84, 0xce, 0x95, 0xfc, 0xd1, 0xe7, 0x39, 0xb0, 0x7f, 0x1a, 0xfc, 0x53, 0x78, 0xd6, 0x71,
	0xd2, 0x0f, 0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0x06, 0x64, 0xc3, 0xee, 0x6c, 0x08, 0x00, 0x00,
}

func (m *GZIPDataChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GZIPDataChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GZIPDataChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Gzip) > 0 {
		i -= len(m.Gzip)
		copy(dAtA[i:], m.Gzip)
		i = encodeVarintComplianceData(dAtA, i, uint64(len(m.Gzip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComplianceData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.IsDir {
		i--
		if m.IsDir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintComplianceData(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Permissions != 0 {
		i = encodeVarintComplianceData(dAtA, i, uint64(m.Permissions))
		i--
		dAtA[i] = 0x30
	}
	if len(m.GroupName) > 0 {
		i -= len(m.GroupName)
		copy(dAtA[i:], m.GroupName)
		i = encodeVarintComplianceData(dAtA, i, uint64(len(m.GroupName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Group != 0 {
		i = encodeVarintComplianceData(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x20
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintComplianceData(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.User != 0 {
		i = encodeVarintComplianceData(dAtA, i, uint64(m.User))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintComplianceData(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandLine) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandLine) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandLine) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComplianceData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Process) > 0 {
		i -= len(m.Process)
		copy(dAtA[i:], m.Process)
		i = encodeVarintComplianceData(dAtA, i, uint64(len(m.Process)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandLine_Args) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandLine_Args) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandLine_Args) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintComplianceData(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintComplianceData(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InsecureRegistriesConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsecureRegistriesConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsecureRegistriesConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InsecureCidrs) > 0 {
		for iNdEx := len(m.InsecureCidrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InsecureCidrs[iNdEx])
			copy(dAtA[i:], m.InsecureCidrs[iNdEx])
			i = encodeVarintComplianceData(dAtA, i, uint64(len(m.InsecureCidrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.InsecureRegistries) > 0 {
		for iNdEx := len(m.InsecureRegistries) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InsecureRegistries[iNdEx])
			copy(dAtA[i:], m.InsecureRegistries[iNdEx])
			i = encodeVarintComplianceData(dAtA, i, uint64(len(m.InsecureRegistries[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContainerRuntimeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerRuntimeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerRuntimeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InsecureRegistries != nil {
		{
			size, err := m.InsecureRegistries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceStandardResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceStandardResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceStandardResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClusterCheckResults) > 0 {
		for k := range m.ClusterCheckResults {
			v := m.ClusterCheckResults[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintComplianceData(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintComplianceData(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintComplianceData(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NodeCheckResults) > 0 {
		for k := range m.NodeCheckResults {
			v := m.NodeCheckResults[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintComplianceData(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintComplianceData(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintComplianceData(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceReturn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceReturn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceReturn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Evidence != nil {
		{
			size, err := m.Evidence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ContainerRuntimeInfo != nil {
		{
			size, err := m.ContainerRuntimeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Time != nil {
		{
			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SystemdFiles) > 0 {
		for k := range m.SystemdFiles {
			v := m.SystemdFiles[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintComplianceData(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintComplianceData(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintComplianceData(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Files) > 0 {
		for k := range m.Files {
			v := m.Files[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintComplianceData(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintComplianceData(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintComplianceData(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CommandLines) > 0 {
		for k := range m.CommandLines {
			v := m.CommandLines[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintComplianceData(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintComplianceData(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintComplianceData(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.DockerData != nil {
		{
			size, err := m.DockerData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ScrapeId) > 0 {
		i -= len(m.ScrapeId)
		copy(dAtA[i:], m.ScrapeId)
		i = encodeVarintComplianceData(dAtA, i, uint64(len(m.ScrapeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintComplianceData(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintComplianceData(dAtA []byte, offset int, v uint64) int {
	offset -= sovComplianceData(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GZIPDataChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Gzip)
	if l > 0 {
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if m.User != 0 {
		n += 1 + sovComplianceData(uint64(m.User))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovComplianceData(uint64(m.Group))
	}
	l = len(m.GroupName)
	if l > 0 {
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if m.Permissions != 0 {
		n += 1 + sovComplianceData(uint64(m.Permissions))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if m.IsDir {
		n += 2
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovComplianceData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandLine) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Process)
	if l > 0 {
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.Size()
			n += 1 + l + sovComplianceData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandLine_Args) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovComplianceData(uint64(l))
		}
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InsecureRegistriesConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InsecureRegistries) > 0 {
		for _, s := range m.InsecureRegistries {
			l = len(s)
			n += 1 + l + sovComplianceData(uint64(l))
		}
	}
	if len(m.InsecureCidrs) > 0 {
		for _, s := range m.InsecureCidrs {
			l = len(s)
			n += 1 + l + sovComplianceData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerRuntimeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InsecureRegistries != nil {
		l = m.InsecureRegistries.Size()
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceStandardResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeCheckResults) > 0 {
		for k, v := range m.NodeCheckResults {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovComplianceData(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovComplianceData(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovComplianceData(uint64(mapEntrySize))
		}
	}
	if len(m.ClusterCheckResults) > 0 {
		for k, v := range m.ClusterCheckResults {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovComplianceData(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovComplianceData(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovComplianceData(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceReturn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovComplianceData(uint64(l))
	}
	l = len(m.ScrapeId)
	if l > 0 {
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if m.DockerData != nil {
		l = m.DockerData.Size()
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if len(m.CommandLines) > 0 {
		for k, v := range m.CommandLines {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovComplianceData(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovComplianceData(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovComplianceData(uint64(mapEntrySize))
		}
	}
	if len(m.Files) > 0 {
		for k, v := range m.Files {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovComplianceData(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovComplianceData(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovComplianceData(uint64(mapEntrySize))
		}
	}
	if len(m.SystemdFiles) > 0 {
		for k, v := range m.SystemdFiles {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovComplianceData(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovComplianceData(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovComplianceData(uint64(mapEntrySize))
		}
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if m.ContainerRuntimeInfo != nil {
		l = m.ContainerRuntimeInfo.Size()
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if m.Evidence != nil {
		l = m.Evidence.Size()
		n += 1 + l + sovComplianceData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovComplianceData(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozComplianceData(x uint64) (n int) {
	return sovComplianceData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GZIPDataChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GZIPDataChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GZIPDataChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gzip", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gzip = append(m.Gzip[:0], dAtA[iNdEx:postIndex]...)
			if m.Gzip == nil {
				m.Gzip = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			m.User = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.User |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			m.Permissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permissions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDir = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &File{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandLine) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandLine: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandLine: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Process = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &CommandLine_Args{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandLine_Args) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Args: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Args: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsecureRegistriesConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsecureRegistriesConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsecureRegistriesConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsecureRegistries", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsecureRegistries = append(m.InsecureRegistries, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsecureCidrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsecureCidrs = append(m.InsecureCidrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerRuntimeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerRuntimeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerRuntimeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsecureRegistries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsecureRegistries == nil {
				m.InsecureRegistries = &InsecureRegistriesConfig{}
			}
			if err := m.InsecureRegistries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceStandardResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceStandardResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceStandardResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCheckResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeCheckResults == nil {
				m.NodeCheckResults = make(map[string]*storage.ComplianceResultValue)
			}
			var mapkey string
			var mapvalue *storage.ComplianceResultValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthComplianceData
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthComplianceData
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthComplianceData
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthComplianceData
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &storage.ComplianceResultValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipComplianceData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthComplianceData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeCheckResults[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterCheckResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterCheckResults == nil {
				m.ClusterCheckResults = make(map[string]*storage.ComplianceResultValue)
			}
			var mapkey string
			var mapvalue *storage.ComplianceResultValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthComplianceData
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthComplianceData
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthComplianceData
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthComplianceData
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &storage.ComplianceResultValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipComplianceData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthComplianceData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ClusterCheckResults[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceReturn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceReturn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceReturn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScrapeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScrapeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DockerData == nil {
				m.DockerData = &GZIPDataChunk{}
			}
			if err := m.DockerData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandLines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommandLines == nil {
				m.CommandLines = make(map[string]*CommandLine)
			}
			var mapkey string
			var mapvalue *CommandLine
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthComplianceData
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthComplianceData
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthComplianceData
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthComplianceData
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CommandLine{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipComplianceData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthComplianceData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CommandLines[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Files == nil {
				m.Files = make(map[string]*File)
			}
			var mapkey string
			var mapvalue *File
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthComplianceData
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthComplianceData
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthComplianceData
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthComplianceData
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &File{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipComplianceData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthComplianceData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Files[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemdFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SystemdFiles == nil {
				m.SystemdFiles = make(map[string]*File)
			}
			var mapkey string
			var mapvalue *File
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthComplianceData
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthComplianceData
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthComplianceData
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthComplianceData
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &File{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipComplianceData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthComplianceData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SystemdFiles[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &types.Timestamp{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRuntimeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerRuntimeInfo == nil {
				m.ContainerRuntimeInfo = &ContainerRuntimeInfo{}
			}
			if err := m.ContainerRuntimeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Evidence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Evidence == nil {
				m.Evidence = &GZIPDataChunk{}
			}
			if err := m.Evidence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipComplianceData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowComplianceData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowComplianceData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthComplianceData
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupComplianceData
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthComplianceData
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthComplianceData        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowComplianceData          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupComplianceData = fmt.Errorf("proto: unexpected end of group")
)
